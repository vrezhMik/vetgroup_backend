'use strict';

var globalAgent = require('global-agent');
var path = require('path');
var _ = require('lodash');
var fp = require('lodash/fp');
var logger$1 = require('@strapi/logger');
var database = require('@strapi/database');
var tsUtils = require('@strapi/typescript-utils');
var os = require('os');
var dotenv = require('dotenv');
var strapiUtils = require('@strapi/utils');
var fs = require('fs');
var async_hooks = require('async_hooks');
var open = require('open');
var crypto = require('crypto');
var packageJson = require('package-json');
var Configstore = require('configstore');
var semver = require('semver');
var boxen = require('boxen');
var chalk = require('chalk');
var undici = require('undici');
var CLITable = require('cli-table3');
var cuid2 = require('@paralleldrive/cuid2');
var assert = require('node:assert');
var path$1 = require('node:path');
var fse = require('fs-extra');
var Router = require('@koa/router');
var http = require('http');
var compose = require('koa-compose');
var Koa = require('koa');
var createError = require('http-errors');
var delegate = require('delegates');
var statuses = require('statuses');
var nodeSchedule = require('node-schedule');
var compress = require('koa-compress');
var koaCors = require('@koa/cors');
var koaFavicon = require('koa-favicon');
var koaIp = require('koa-ip');
var koaBody = require('koa-body');
var mime = require('mime-types');
var qs = require('qs');
var helmet = require('koa-helmet');
var koaSession = require('koa-session');
var koaStatic = require('koa-static');
var glob = require('glob');
var resolve = require('resolve.exports');
var bcrypt = require('bcryptjs');
var isDocker = require('is-docker');
var ciEnv = require('ci-info');
var createDebugger = require('debug');
var assert$1 = require('assert/strict');
var permissions = require('@strapi/permissions');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var globalAgent__namespace = /*#__PURE__*/_interopNamespaceDefault(globalAgent);
var resolve__namespace = /*#__PURE__*/_interopNamespaceDefault(resolve);

const getConfigUrls = (config, forAdminBuild = false)=>{
    const serverConfig = config.server;
    const adminConfig = config.admin;
    // Defines serverUrl value
    let serverUrl = _.get(serverConfig, 'url', '');
    serverUrl = _.trim(serverUrl, '/ ');
    if (typeof serverUrl !== 'string') {
        throw new Error('Invalid server url config. Make sure the url is a string.');
    }
    if (serverUrl.startsWith('http')) {
        try {
            serverUrl = _.trim(new URL(serverConfig.url).toString(), '/');
        } catch (e) {
            throw new Error('Invalid server url config. Make sure the url defined in server.js is valid.');
        }
    } else if (serverUrl !== '') {
        serverUrl = `/${serverUrl}`;
    }
    // Defines adminUrl value
    let adminUrl = _.get(adminConfig, 'url', '/admin');
    adminUrl = _.trim(adminUrl, '/ ');
    if (typeof adminUrl !== 'string') {
        throw new Error('Invalid admin url config. Make sure the url is a non-empty string.');
    }
    if (adminUrl.startsWith('http')) {
        try {
            adminUrl = _.trim(new URL(adminUrl).toString(), '/');
        } catch (e) {
            throw new Error('Invalid admin url config. Make sure the url defined in server.js is valid.');
        }
    } else {
        adminUrl = `${serverUrl}/${adminUrl}`;
    }
    // Defines adminPath value
    let adminPath = adminUrl;
    if (serverUrl.startsWith('http') && adminUrl.startsWith('http') && new URL(adminUrl).origin === new URL(serverUrl).origin && !forAdminBuild) {
        adminPath = adminUrl.replace(strapiUtils.strings.getCommonPath(serverUrl, adminUrl), '');
        adminPath = `/${_.trim(adminPath, '/')}`;
    } else if (adminUrl.startsWith('http')) {
        adminPath = new URL(adminUrl).pathname;
    }
    return {
        serverUrl,
        adminUrl,
        adminPath
    };
};
const getAbsoluteUrl = (adminOrServer)=>(config, forAdminBuild = false)=>{
        const { serverUrl, adminUrl } = getConfigUrls(config, forAdminBuild);
        const url = adminOrServer === 'server' ? serverUrl : adminUrl;
        if (url.startsWith('http')) {
            return url;
        }
        const serverConfig = config.server;
        const hostname = config.environment === 'development' && [
            '127.0.0.1',
            '0.0.0.0'
        ].includes(serverConfig.host) ? 'localhost' : serverConfig.host;
        return `http://${hostname}:${serverConfig.port}${url}`;
    };
const getAbsoluteAdminUrl = getAbsoluteUrl('admin');
const getAbsoluteServerUrl = getAbsoluteUrl('server');

const loadJsFile = (file)=>{
    try {
        const jsModule = strapiUtils.importDefault(file);
        // call if function
        if (typeof jsModule === 'function') {
            return jsModule({
                env: strapiUtils.env
            });
        }
        return jsModule;
    } catch (error) {
        if (error instanceof Error) {
            throw new Error(`Could not load js config file ${file}: ${error.message}`);
        }
        throw new Error('Unknown error');
    }
};
const loadJSONFile = (file)=>{
    try {
        return JSON.parse(fs.readFileSync(file).toString());
    } catch (error) {
        if (error instanceof Error) {
            throw new Error(`Could not load json config file ${file}: ${error.message}`);
        }
        throw new Error('Unknown error');
    }
};
const loadConfigFile = (file)=>{
    const ext = path.extname(file);
    switch(ext){
        case '.js':
            return loadJsFile(file);
        case '.json':
            return loadJSONFile(file);
        default:
            return {};
    }
};

const VALID_EXTENSIONS = [
    '.js',
    '.json'
];
// These filenames are restricted, but will also emit a warning that the filename is probably a mistake
const MISTAKEN_FILENAMES = {
    middleware: 'middlewares',
    plugin: 'plugins'
};
// the following are restricted to prevent conflicts with existing STRAPI_* env vars or root level config options
// must all be lowercase to match validator
const RESTRICTED_FILENAMES = [
    // existing env vars
    'uuid',
    'hosting',
    'license',
    'enforce',
    'disable',
    'enable',
    'telemetry',
    // reserved for future internal use
    'strapi',
    'internal',
    // root level config options
    // TODO: it would be better to move these out of the root config and allow them to be loaded
    'launchedAt',
    'serveAdminPanel',
    'autoReload',
    'environment',
    'packageJsonStrapi',
    'info',
    'autoReload',
    'dirs',
    // probably mistaken/typo filenames
    ...Object.keys(MISTAKEN_FILENAMES)
];
// Existing Strapi configuration files
const STRAPI_CONFIG_FILENAMES = [
    'admin',
    'server',
    'api',
    'database',
    'middlewares',
    'plugins',
    'features'
];
// Note: we don't have access to strapi logger at this point so we can't use it
const logWarning = (message)=>{
    console.warn(message);
};
var loadConfigDir = ((dir)=>{
    if (!fs.existsSync(dir)) return {};
    const allFiles = fs.readdirSync(dir, {
        withFileTypes: true
    });
    const seenFilenames = new Set();
    const configFiles = allFiles.reduce((acc, file)=>{
        const baseName = path.basename(file.name, path.extname(file.name));
        const baseNameLower = baseName.toLowerCase();
        const extension = path.extname(file.name);
        const extensionLower = extension.toLowerCase();
        if (!file.isFile()) {
            return acc;
        }
        if (!VALID_EXTENSIONS.includes(extensionLower)) {
            logWarning(`Config file not loaded, extension must be one of ${VALID_EXTENSIONS.join(',')}): ${file.name}`);
            return acc;
        }
        if (RESTRICTED_FILENAMES.includes(baseNameLower)) {
            logWarning(`Config file not loaded, restricted filename: ${file.name}`);
            // suggest the filename they probably meant
            if (baseNameLower in MISTAKEN_FILENAMES) {
                console.log(`Did you mean ${MISTAKEN_FILENAMES[baseNameLower]}]} ?`);
            }
            return acc;
        }
        // restricted names and Strapi configs are also restricted from being prefixes
        const restrictedPrefix = [
            ...RESTRICTED_FILENAMES,
            ...STRAPI_CONFIG_FILENAMES
        ].find((restrictedName)=>restrictedName.startsWith(baseNameLower) && restrictedName !== baseNameLower);
        if (restrictedPrefix) {
            logWarning(`Config file not loaded, filename cannot start with ${restrictedPrefix}: ${file.name}`);
        }
        /**
     *  Note: If user config files contain non-alpha-numeric characters, we won't be able to auto-load env
     * into them.
     *
     * For the initial feature, we will only load our internal configs, but later when we provide a method
     * to define the shape of custom configs, we will need to warn that those filenames can't be loaded
     * for technical limitations on env variable names
     *  */ // if (!/^[A-Za-z0-9]+$/.test(baseName)) {
        //   logWarning("Using a non-alphanumeric config file name prevents Strapi from auto-loading it from environment variables.")
        // }
        // filter filenames without case-insensitive uniqueness
        if (seenFilenames.has(baseNameLower)) {
            logWarning(`Config file not loaded, case-insensitive name matches other config file: ${file.name}`);
            return acc;
        }
        seenFilenames.add(baseNameLower);
        // If file passes all filters, add it to the accumulator
        acc.push(file);
        return acc;
    }, []);
    return configFiles.reduce((acc, file)=>{
        const key = path.basename(file.name, path.extname(file.name));
        acc[key] = loadConfigFile(path.resolve(dir, file.name));
        return acc;
    }, {});
});

const getDirs = ({ appDir, distDir }, config)=>({
        dist: {
            root: distDir,
            src: path.join(distDir, 'src'),
            api: path.join(distDir, 'src', 'api'),
            components: path.join(distDir, 'src', 'components'),
            extensions: path.join(distDir, 'src', 'extensions'),
            policies: path.join(distDir, 'src', 'policies'),
            middlewares: path.join(distDir, 'src', 'middlewares'),
            config: path.join(distDir, 'config')
        },
        app: {
            root: appDir,
            src: path.join(appDir, 'src'),
            api: path.join(appDir, 'src', 'api'),
            components: path.join(appDir, 'src', 'components'),
            extensions: path.join(appDir, 'src', 'extensions'),
            policies: path.join(appDir, 'src', 'policies'),
            middlewares: path.join(appDir, 'src', 'middlewares'),
            config: path.join(appDir, 'config')
        },
        static: {
            public: path.resolve(appDir, fp.get('server.dirs.public', config))
        }
    });

var name = "@strapi/core";
var version = "5.11.2";
var description = "Core of Strapi";
var homepage = "https://strapi.io";
var bugs = {
    url: "https://github.com/strapi/strapi/issues"
};
var repository = {
    type: "git",
    url: "git://github.com/strapi/strapi.git"
};
var license = "SEE LICENSE IN LICENSE";
var author = {
    name: "Strapi Solutions SAS",
    email: "hi@strapi.io",
    url: "https://strapi.io"
};
var maintainers = [
    {
        name: "Strapi Solutions SAS",
        email: "hi@strapi.io",
        url: "https://strapi.io"
    }
];
var main = "./dist/index.js";
var module$1 = "./dist/index.mjs";
var source = "./src/index.ts";
var types = "./dist/index.d.ts";
var exports$1 = {
    ".": {
        types: "./dist/index.d.ts",
        source: "./src/index.ts",
        "import": "./dist/index.mjs",
        require: "./dist/index.js",
        "default": "./dist/index.js"
    },
    "./package.json": "./package.json"
};
var files = [
    "dist/",
    "resources/"
];
var scripts = {
    build: "run -T npm-run-all clean --parallel build:code build:types",
    "build:code": "run -T  rollup -c",
    "build:types": "run -T tsc -p tsconfig.build.json --emitDeclarationOnly",
    watch: "run -T rollup -c -w",
    clean: "run -T rimraf ./dist",
    lint: "run -T eslint .",
    prepublishOnly: "yarn clean && yarn build",
    "test:unit": "run -T jest",
    "test:unit:watch": "run -T jest --watch"
};
var dependencies = {
    "@koa/cors": "5.0.0",
    "@koa/router": "12.0.2",
    "@paralleldrive/cuid2": "2.2.2",
    "@strapi/admin": "5.11.2",
    "@strapi/database": "5.11.2",
    "@strapi/generators": "5.11.2",
    "@strapi/logger": "5.11.2",
    "@strapi/permissions": "5.11.2",
    "@strapi/types": "5.11.2",
    "@strapi/typescript-utils": "5.11.2",
    "@strapi/utils": "5.11.2",
    bcryptjs: "2.4.3",
    boxen: "5.1.2",
    chalk: "4.1.2",
    "ci-info": "4.0.0",
    "cli-table3": "0.6.2",
    commander: "8.3.0",
    configstore: "5.0.1",
    copyfiles: "2.4.1",
    debug: "4.3.4",
    delegates: "1.0.0",
    dotenv: "16.4.5",
    execa: "5.1.1",
    "fs-extra": "11.2.0",
    glob: "10.3.10",
    "global-agent": "3.0.0",
    "http-errors": "2.0.0",
    inquirer: "8.2.5",
    "is-docker": "2.2.1",
    koa: "2.15.4",
    "koa-body": "6.0.1",
    "koa-compose": "4.1.0",
    "koa-compress": "5.1.1",
    "koa-favicon": "2.1.0",
    "koa-helmet": "7.0.2",
    "koa-ip": "^2.1.3",
    "koa-session": "6.4.0",
    "koa-static": "5.0.0",
    lodash: "4.17.21",
    "mime-types": "2.1.35",
    "node-schedule": "2.1.1",
    open: "8.4.0",
    ora: "5.4.1",
    "package-json": "7.0.0",
    "pkg-up": "3.1.0",
    qs: "6.11.1",
    "resolve.exports": "2.0.2",
    semver: "7.5.4",
    statuses: "2.0.1",
    typescript: "5.4.4",
    undici: "6.21.1",
    yup: "0.32.9"
};
var devDependencies = {
    "@strapi/ts-zen": "^0.2.0",
    "@swc/core": "1.9.3",
    "@types/bcryptjs": "2.4.3",
    "@types/configstore": "5.0.1",
    "@types/delegates": "1.0.0",
    "@types/fs-extra": "11.0.4",
    "@types/global-agent": "2.1.3",
    "@types/http-errors": "2.0.4",
    "@types/jest": "29.5.2",
    "@types/koa": "2.13.4",
    "@types/koa-compress": "4.0.3",
    "@types/koa-session": "6.4.1",
    "@types/koa-static": "4.0.2",
    "@types/koa__router": "12.0.0",
    "@types/lodash": "^4.14.191",
    "@types/mime-types": "2.1.1",
    "@types/node": "18.19.24",
    "@types/node-schedule": "2.1.7",
    "@types/statuses": "2.0.1",
    "eslint-config-custom": "5.11.2",
    supertest: "6.3.3",
    tsconfig: "5.11.2"
};
var engines = {
    node: ">=18.0.0 <=22.x.x",
    npm: ">=6.0.0"
};
var pkg = {
    name: name,
    version: version,
    description: description,
    homepage: homepage,
    bugs: bugs,
    repository: repository,
    license: license,
    author: author,
    maintainers: maintainers,
    main: main,
    module: module$1,
    source: source,
    types: types,
    exports: exports$1,
    files: files,
    scripts: scripts,
    dependencies: dependencies,
    devDependencies: devDependencies,
    engines: engines
};

dotenv.config({
    path: process.env.ENV_PATH
});
process.env.NODE_ENV = process.env.NODE_ENV || 'development';
const defaultConfig$2 = {
    server: {
        host: process.env.HOST || os.hostname() || 'localhost',
        port: Number(process.env.PORT) || 1337,
        proxy: false,
        cron: {
            enabled: false
        },
        admin: {
            autoOpen: false
        },
        dirs: {
            public: './public'
        },
        transfer: {
            remote: {
                enabled: true
            }
        },
        logger: {
            updates: {
                enabled: true
            },
            startup: {
                enabled: true
            }
        }
    },
    admin: {},
    api: {
        rest: {
            prefix: '/api'
        }
    }
};
const loadConfiguration = (opts)=>{
    const { appDir, distDir, autoReload = false, serveAdminPanel = true } = opts;
    const pkgJSON = require(path.resolve(appDir, 'package.json'));
    const configDir = path.resolve(distDir || process.cwd(), 'config');
    const rootConfig = {
        launchedAt: Date.now(),
        autoReload,
        environment: process.env.NODE_ENV,
        uuid: _.get(pkgJSON, 'strapi.uuid'),
        packageJsonStrapi: _.omit(_.get(pkgJSON, 'strapi', {}), 'uuid'),
        info: {
            ...pkgJSON,
            strapi: version
        },
        admin: {
            serveAdminPanel
        }
    };
    // See packages/core/core/src/domain/module/index.ts for plugin config loading
    const baseConfig = fp.omit('plugins', loadConfigDir(configDir)); // plugin config will be loaded later
    const envDir = path.resolve(configDir, 'env', process.env.NODE_ENV);
    const envConfig = loadConfigDir(envDir);
    const config = _.merge(rootConfig, defaultConfig$2, baseConfig, envConfig);
    const { serverUrl, adminUrl } = getConfigUrls(config);
    const serverAbsoluteUrl = getAbsoluteServerUrl(config);
    const adminAbsoluteUrl = getAbsoluteAdminUrl(config);
    const sameOrigin = new URL(adminAbsoluteUrl).origin === new URL(serverAbsoluteUrl).origin;
    const adminPath = sameOrigin ? adminUrl.replace(strapiUtils.strings.getCommonPath(serverUrl, adminUrl), '') : new URL(adminUrl).pathname;
    _.set(config, 'server.url', serverUrl);
    _.set(config, 'server.absoluteUrl', serverAbsoluteUrl);
    _.set(config, 'admin.url', adminUrl);
    _.set(config, 'admin.path', adminPath);
    _.set(config, 'admin.absoluteUrl', adminAbsoluteUrl);
    _.set(config, 'dirs', getDirs(opts, config));
    return config;
};

function isEntry(property) {
    return property === null || fp.isPlainObject(property) || Array.isArray(property);
}
function isDZEntries(property) {
    return Array.isArray(property);
}
const transformResponse = (resource, meta = {}, opts = {
    useJsonAPIFormat: false
})=>{
    if (fp.isNil(resource)) {
        return resource;
    }
    if (!fp.isPlainObject(resource) && !Array.isArray(resource)) {
        throw new Error('Entry must be an object or an array of objects');
    }
    return {
        data: opts.useJsonAPIFormat ? transformEntry(resource, opts?.contentType) : resource,
        meta
    };
};
function transformComponent(data, component) {
    if (Array.isArray(data)) {
        return data.map((datum)=>transformComponent(datum, component));
    }
    const res = transformEntry(data, component);
    if (fp.isNil(res)) {
        return res;
    }
    const { id, attributes } = res;
    return {
        id,
        ...attributes
    };
}
function transformEntry(entry, type) {
    if (fp.isNil(entry)) {
        return entry;
    }
    if (Array.isArray(entry)) {
        return entry.map((singleEntry)=>transformEntry(singleEntry, type));
    }
    if (!fp.isPlainObject(entry)) {
        throw new Error('Entry must be an object');
    }
    const { id, documentId, ...properties } = entry;
    const attributeValues = {};
    for (const key of Object.keys(properties)){
        const property = properties[key];
        const attribute = type && type.attributes[key];
        if (attribute && attribute.type === 'relation' && isEntry(property) && 'target' in attribute) {
            const data = transformEntry(property, strapi.contentType(attribute.target));
            attributeValues[key] = {
                data
            };
        } else if (attribute && attribute.type === 'component' && isEntry(property)) {
            attributeValues[key] = transformComponent(property, strapi.components[attribute.component]);
        } else if (attribute && attribute.type === 'dynamiczone' && isDZEntries(property)) {
            if (fp.isNil(property)) {
                attributeValues[key] = property;
            }
            attributeValues[key] = property.map((subProperty)=>{
                return transformComponent(subProperty, strapi.components[subProperty.__component]);
            });
        } else if (attribute && attribute.type === 'media' && isEntry(property)) {
            const data = transformEntry(property, strapi.contentType('plugin::upload.file'));
            attributeValues[key] = {
                data
            };
        } else {
            attributeValues[key] = property;
        }
    }
    return {
        id,
        documentId,
        attributes: attributeValues
    };
}

/**
 * Returns a single type controller to handle default core-api actions
 */ const createSingleTypeController = ({ contentType })=>{
    const uid = contentType.uid;
    // TODO: transform into a class
    return {
        /**
     * Retrieve single type content
     *
     */ async find (ctx) {
            await this.validateQuery(ctx);
            const sanitizedQuery = await this.sanitizeQuery(ctx);
            const entity = await strapi.service(uid).find(sanitizedQuery);
            const sanitizedEntity = await this.sanitizeOutput(entity, ctx);
            return this.transformResponse(sanitizedEntity);
        },
        /**
     * create or update single type content.
     */ async update (ctx) {
            const { query, body = {} } = ctx.request;
            if (!fp.isObject(body.data)) {
                throw new strapiUtils.errors.ValidationError('Missing "data" payload in the request body');
            }
            await this.validateInput(body.data, ctx);
            const sanitizedInputData = await this.sanitizeInput(body.data, ctx);
            const entity = await strapi.service(uid).createOrUpdate({
                ...query,
                data: sanitizedInputData
            });
            const sanitizedEntity = await this.sanitizeOutput(entity, ctx);
            return this.transformResponse(sanitizedEntity);
        },
        async delete (ctx) {
            const { query } = ctx;
            await strapi.service(uid).delete(query);
            ctx.status = 204;
        }
    };
};

/**
 *
 * Returns a collection type controller to handle default core-api actions
 */ const createCollectionTypeController = ({ contentType })=>{
    const uid = contentType.uid;
    // TODO: transform into a class
    return {
        /**
     * Retrieve records.
     */ async find (ctx) {
            await this.validateQuery(ctx);
            const sanitizedQuery = await this.sanitizeQuery(ctx);
            const { results, pagination } = await strapi.service(uid).find(sanitizedQuery);
            const sanitizedResults = await this.sanitizeOutput(results, ctx);
            return this.transformResponse(sanitizedResults, {
                pagination
            });
        },
        /**
     * Retrieve a record
     */ async findOne (ctx) {
            const { id } = ctx.params;
            await this.validateQuery(ctx);
            const sanitizedQuery = await this.sanitizeQuery(ctx);
            const entity = await strapi.service(uid).findOne(id, sanitizedQuery);
            const sanitizedEntity = await this.sanitizeOutput(entity, ctx);
            return this.transformResponse(sanitizedEntity);
        },
        /**
     * Create a record.
     */ async create (ctx) {
            await this.validateQuery(ctx);
            const sanitizedQuery = await this.sanitizeQuery(ctx);
            const { body = {} } = ctx.request;
            if (!fp.isObject(body.data)) {
                throw new strapiUtils.errors.ValidationError('Missing "data" payload in the request body');
            }
            await this.validateInput(body.data, ctx);
            const sanitizedInputData = await this.sanitizeInput(body.data, ctx);
            const entity = await strapi.service(uid).create({
                ...sanitizedQuery,
                data: sanitizedInputData
            });
            const sanitizedEntity = await this.sanitizeOutput(entity, ctx);
            ctx.status = 201;
            return this.transformResponse(sanitizedEntity);
        },
        /**
     * Update a record.
     */ async update (ctx) {
            const { id } = ctx.params;
            await this.validateQuery(ctx);
            const sanitizedQuery = await this.sanitizeQuery(ctx);
            const { body = {} } = ctx.request;
            if (!fp.isObject(body.data)) {
                throw new strapiUtils.errors.ValidationError('Missing "data" payload in the request body');
            }
            await this.validateInput(body.data, ctx);
            const sanitizedInputData = await this.sanitizeInput(body.data, ctx);
            const entity = await strapi.service(uid).update(id, {
                ...sanitizedQuery,
                data: sanitizedInputData
            });
            const sanitizedEntity = await this.sanitizeOutput(entity, ctx);
            return this.transformResponse(sanitizedEntity);
        },
        /**
     * Destroy a record.
     */ async delete (ctx) {
            const { id } = ctx.params;
            await this.validateQuery(ctx);
            const sanitizedQuery = await this.sanitizeQuery(ctx);
            await strapi.service(uid).delete(id, sanitizedQuery);
            ctx.status = 204;
        }
    };
};

const storage = new async_hooks.AsyncLocalStorage();
const requestCtx = {
    async run (store, cb) {
        return storage.run(store, cb);
    },
    get () {
        return storage.getStore();
    }
};

const isSingleType$1 = (contentType)=>strapiUtils.contentTypes.isSingleType(contentType);
const getAuthFromKoaContext = (ctx)=>fp.prop('state.auth', ctx) ?? {};
function createController({ contentType }) {
    // TODO: replace with Base class + SingleType and CollectionType classes
    const proto = {
        transformResponse (data, meta) {
            const ctx = requestCtx.get();
            return transformResponse(data, meta, {
                contentType,
                useJsonAPIFormat: ctx?.headers?.['strapi-response-format'] === 'v4'
            });
        },
        async sanitizeOutput (data, ctx) {
            const auth = getAuthFromKoaContext(ctx);
            return strapi.contentAPI.sanitize.output(data, contentType, {
                auth
            });
        },
        async sanitizeInput (data, ctx) {
            const auth = getAuthFromKoaContext(ctx);
            return strapi.contentAPI.sanitize.input(data, contentType, {
                auth
            });
        },
        async sanitizeQuery (ctx) {
            const auth = getAuthFromKoaContext(ctx);
            return strapi.contentAPI.sanitize.query(ctx.query, contentType, {
                auth
            });
        },
        async validateQuery (ctx) {
            const auth = getAuthFromKoaContext(ctx);
            return strapi.contentAPI.validate.query(ctx.query, contentType, {
                auth
            });
        },
        async validateInput (data, ctx) {
            const auth = getAuthFromKoaContext(ctx);
            return strapi.contentAPI.validate.input(data, contentType, {
                auth
            });
        }
    };
    let ctrl;
    if (isSingleType$1(contentType)) {
        ctrl = createSingleTypeController({
            contentType
        });
    } else {
        ctrl = createCollectionTypeController({
            contentType
        });
    }
    return Object.assign(Object.create(proto), ctrl);
}

class CoreService {
    getFetchParams(params = {}) {
        return {
            status: 'published',
            ...params
        };
    }
}

class SingleTypeService extends CoreService {
    async getDocumentId() {
        const { uid } = this.contentType;
        return strapi.db.query(uid).findOne().then((document)=>document?.documentId);
    }
    async find(params = {}) {
        const { uid } = this.contentType;
        return strapi.documents(uid).findFirst(this.getFetchParams(params));
    }
    async createOrUpdate(params = {}) {
        const { uid } = this.contentType;
        const documentId = await this.getDocumentId();
        if (documentId) {
            return strapi.documents(uid).update({
                ...this.getFetchParams(params),
                documentId
            });
        }
        return strapi.documents(uid).create(this.getFetchParams(params));
    }
    async delete(params = {}) {
        const { uid } = this.contentType;
        const documentId = await this.getDocumentId();
        if (!documentId) return {
            deletedEntries: 0
        };
        const { entries } = await strapi.documents(uid).delete({
            ...this.getFetchParams(params),
            documentId
        });
        return {
            deletedEntries: entries.length
        };
    }
    constructor(contentType){
        super();
        this.contentType = contentType;
    }
}
const createSingleTypeService = (contentType)=>{
    return new SingleTypeService(contentType);
};

/**
 * Default limit values from config
 */ const getLimitConfigDefaults = ()=>({
        defaultLimit: fp.toNumber(strapi.config.get('api.rest.defaultLimit', 25)),
        maxLimit: fp.toNumber(strapi.config.get('api.rest.maxLimit')) || null
    });
const isOffsetPagination = (pagination)=>fp.has('start', pagination) || fp.has('limit', pagination);
const isPagedPagination = (pagination)=>fp.has('page', pagination) || fp.has('pageSize', pagination) || !isOffsetPagination(pagination);
const shouldCount = (params)=>{
    if (fp.has('pagination.withCount', params)) {
        const withCount = params.pagination?.withCount;
        if (typeof withCount === 'boolean') {
            return withCount;
        }
        if (typeof withCount === 'undefined') {
            return false;
        }
        if ([
            'true',
            't',
            '1',
            1
        ].includes(withCount)) {
            return true;
        }
        if ([
            'false',
            'f',
            '0',
            0
        ].includes(withCount)) {
            return false;
        }
        throw new strapiUtils.errors.ValidationError('Invalid withCount parameter. Expected "t","1","true","false","0","f"');
    }
    return Boolean(strapi.config.get('api.rest.withCount', true));
};
const getPaginationInfo = (params)=>{
    const { defaultLimit, maxLimit } = getLimitConfigDefaults();
    const { start, limit } = strapiUtils.pagination.withDefaultPagination(params.pagination || {}, {
        defaults: {
            offset: {
                limit: defaultLimit
            },
            page: {
                pageSize: defaultLimit
            }
        },
        maxLimit: maxLimit || -1
    });
    return {
        start,
        limit
    };
};
const transformPaginationResponse = (paginationInfo, total, isPaged)=>{
    const transform = isPaged ? strapiUtils.pagination.transformPagedPaginationInfo : strapiUtils.pagination.transformOffsetPaginationInfo;
    const paginationResponse = transform(paginationInfo, total);
    if (fp.isNil(total)) {
        // Ignore total and pageCount if `total` value is not available.
        return fp.omit([
            'total',
            'pageCount'
        ], paginationResponse);
    }
    return paginationResponse;
};

class CollectionTypeService extends CoreService {
    async find(params = {}) {
        const { uid } = this.contentType;
        const fetchParams = this.getFetchParams(params);
        const paginationInfo = getPaginationInfo(fetchParams);
        const isPaged = isPagedPagination(fetchParams.pagination);
        const results = await strapi.documents(uid).findMany({
            ...fetchParams,
            ...paginationInfo
        });
        if (shouldCount(fetchParams)) {
            const count = await strapi.documents(uid).count({
                ...fetchParams,
                ...paginationInfo
            });
            if (typeof count !== 'number') {
                throw new Error('Count should be a number');
            }
            return {
                results,
                pagination: transformPaginationResponse(paginationInfo, count, isPaged)
            };
        }
        return {
            results,
            pagination: transformPaginationResponse(paginationInfo, undefined, isPaged)
        };
    }
    findOne(documentId, params = {}) {
        const { uid } = this.contentType;
        return strapi.documents(uid).findOne({
            ...this.getFetchParams(params),
            documentId
        });
    }
    async create(params = {
        data: {}
    }) {
        const { uid } = this.contentType;
        return strapi.documents(uid).create(this.getFetchParams(params));
    }
    update(documentId, params = {
        data: {}
    }) {
        const { uid } = this.contentType;
        return strapi.documents(uid).update({
            ...this.getFetchParams(params),
            documentId
        });
    }
    async delete(documentId, params = {}) {
        const { uid } = this.contentType;
        const { entries } = await strapi.documents(uid).delete({
            ...this.getFetchParams(params),
            documentId
        });
        return {
            deletedEntries: entries.length
        };
    }
    constructor(contentType){
        super();
        this.contentType = contentType;
    }
}
/**
 *
 * Returns a collection type service to handle default core-api actions
 */ const createCollectionTypeService = (contentType)=>{
    return new CollectionTypeService(contentType);
};

const isSingleType = (contentType)=>strapiUtils.contentTypes.isSingleType(contentType);
function createService({ contentType }) {
    if (isSingleType(contentType)) {
        return createSingleTypeService(contentType);
    }
    return createCollectionTypeService(contentType);
}

const createRoutes = ({ contentType })=>{
    if (strapiUtils.contentTypes.isSingleType(contentType)) {
        return getSingleTypeRoutes(contentType);
    }
    return getCollectionTypeRoutes(contentType);
};
const getSingleTypeRoutes = ({ uid, info })=>{
    return {
        find: {
            method: 'GET',
            path: `/${info.singularName}`,
            handler: `${uid}.find`,
            config: {}
        },
        update: {
            method: 'PUT',
            path: `/${info.singularName}`,
            handler: `${uid}.update`,
            config: {}
        },
        delete: {
            method: 'DELETE',
            path: `/${info.singularName}`,
            handler: `${uid}.delete`,
            config: {}
        }
    };
};
const getCollectionTypeRoutes = ({ uid, info })=>{
    return {
        find: {
            method: 'GET',
            path: `/${info.pluralName}`,
            handler: `${uid}.find`,
            config: {}
        },
        findOne: {
            method: 'GET',
            path: `/${info.pluralName}/:id`,
            handler: `${uid}.findOne`,
            config: {}
        },
        create: {
            method: 'POST',
            path: `/${info.pluralName}`,
            handler: `${uid}.create`,
            config: {}
        },
        update: {
            method: 'PUT',
            path: `/${info.pluralName}/:id`,
            handler: `${uid}.update`,
            config: {}
        },
        delete: {
            method: 'DELETE',
            path: `/${info.pluralName}/:id`,
            handler: `${uid}.delete`,
            config: {}
        }
    };
};

const symbols = {
    CustomController: Symbol('StrapiCustomCoreController')
};
const createCoreController = (uid, cfg)=>{
    return ({ strapi: strapi1 })=>{
        const baseController = createController({
            contentType: strapi1.contentType(uid)
        });
        const userCtrl = typeof cfg === 'function' ? cfg({
            strapi: strapi1
        }) : cfg ?? {};
        for (const methodName of Object.keys(baseController)){
            if (userCtrl[methodName] === undefined) {
                userCtrl[methodName] = baseController[methodName];
            }
        }
        Object.setPrototypeOf(userCtrl, baseController);
        const isCustom = typeof cfg !== 'undefined';
        if (isCustom) {
            Object.defineProperty(userCtrl, symbols.CustomController, {
                writable: false,
                configurable: false,
                enumerable: false
            });
        }
        return userCtrl;
    };
};
function createCoreService(uid, cfg) {
    return ({ strapi: strapi1 })=>{
        const baseService = createService({
            contentType: strapi1.contentType(uid)
        });
        const userService = typeof cfg === 'function' ? cfg({
            strapi: strapi1
        }) : cfg ?? {};
        for (const methodName of Object.keys(baseService)){
            if (userService[methodName] === undefined) {
                userService[methodName] = baseService[methodName];
            }
        }
        Object.setPrototypeOf(userService, baseService);
        return userService;
    };
}
function createCoreRouter(uid, cfg) {
    const { prefix, config = {}, only, except, type = 'content-api' } = cfg ?? {};
    let routes;
    return {
        type,
        prefix,
        get routes () {
            if (!routes) {
                const contentType = strapi.contentType(uid);
                const defaultRoutes = createRoutes({
                    contentType
                });
                const keys = Object.keys(defaultRoutes);
                keys.forEach((routeName)=>{
                    const defaultRoute = defaultRoutes[routeName];
                    Object.assign(defaultRoute.config, config[routeName] || {});
                });
                const selectedRoutes = fp.pipe((routes)=>except ? fp.omit(except, routes) : routes, (routes)=>only ? fp.pick(only, routes) : routes)(defaultRoutes);
                routes = Object.values(selectedRoutes);
            }
            return routes;
        }
    };
}
const isCustomController = (controller)=>{
    return symbols.CustomController in controller;
};

var factories = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createCoreController: createCoreController,
  createCoreRouter: createCoreRouter,
  createCoreService: createCoreService,
  isCustomController: isCustomController
});

const openBrowser = async (config)=>{
    const url = config.get('admin.absoluteUrl');
    return open(url);
};

/**
 * Test if the strapi application is considered as initialized (1st user has been created)
 */ const isInitialized = async (strapi)=>{
    try {
        if (fp.isEmpty(strapi.admin)) {
            return true;
        }
        // test if there is at least one admin
        const anyAdministrator = await strapi.db.query('admin::user').findOne({
            select: [
                'id'
            ]
        });
        return !fp.isNil(anyAdministrator);
    } catch (err) {
        strapi.stopWithError(err);
    }
};

const DEFAULT_FEATURES = {
    bronze: [],
    silver: [],
    gold: [
        {
            name: 'sso'
        },
        // Set a null retention duration to allow the user to override it
        // The default of 90 days is set in the audit logs service
        {
            name: 'audit-logs',
            options: {
                retentionDays: null
            }
        },
        {
            name: 'review-workflows'
        },
        {
            name: 'cms-content-releases'
        },
        {
            name: 'cms-content-history',
            options: {
                retentionDays: 99999
            }
        }
    ]
};
const publicKey = fs.readFileSync(path.resolve(__dirname, '../resources/key.pub'));
class LicenseCheckError extends Error {
    constructor(message, shouldFallback = false){
        super(message);
        this.shouldFallback = false;
        this.shouldFallback = shouldFallback;
    }
}
const readLicense = (directory)=>{
    try {
        const path$1 = path.join(directory, 'license.txt');
        return fs.readFileSync(path$1).toString();
    } catch (error) {
        if (typeof error === 'object' && error !== null && 'code' in error && error.code !== 'ENOENT') {
            throw Error('License file not readable, review its format and access rules.');
        }
    }
};
const verifyLicense = (license)=>{
    const [signature, base64Content] = Buffer.from(license, 'base64').toString().split('\n');
    if (!signature || !base64Content) {
        throw new Error('Invalid license.');
    }
    const stringifiedContent = Buffer.from(base64Content, 'base64').toString();
    const verify = crypto.createVerify('RSA-SHA256');
    verify.update(stringifiedContent);
    verify.end();
    const verified = verify.verify(publicKey, signature, 'base64');
    if (!verified) {
        throw new Error('Invalid license.');
    }
    const licenseInfo = JSON.parse(stringifiedContent);
    if (!licenseInfo.features) {
        licenseInfo.features = DEFAULT_FEATURES[licenseInfo.type];
    }
    Object.freeze(licenseInfo.features);
    return licenseInfo;
};
const throwError = ()=>{
    throw new LicenseCheckError('Could not proceed to the online validation of your license.', true);
};
const fetchLicense = async ({ strapi }, key, projectId)=>{
    const response = await strapi.fetch(`https://license.strapi.io/api/licenses/validate`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            key,
            projectId,
            deviceId: strapiUtils.machineID()
        })
    }).catch(throwError);
    const contentType = response.headers.get('Content-Type');
    if (contentType?.includes('application/json')) {
        const { data, error } = await response.json();
        switch(response.status){
            case 200:
                return data.license;
            case 400:
                throw new LicenseCheckError(error.message);
            case 404:
                throw new LicenseCheckError('The license used does not exists.');
            default:
                throwError();
        }
    } else {
        throwError();
    }
};

const INTEGER_REGEX = /^\d+$/;
const STEP_REGEX = /^\*\/\d+$/;
const COMPONENTS = [
    {
        limit: 60,
        zeroBasedIndices: true,
        functionName: 'getSeconds'
    },
    {
        limit: 60,
        zeroBasedIndices: true,
        functionName: 'getMinutes'
    },
    {
        limit: 24,
        zeroBasedIndices: true,
        functionName: 'getHours'
    },
    {
        limit: 31,
        zeroBasedIndices: false,
        functionName: 'getDate'
    },
    {
        limit: 12,
        zeroBasedIndices: false,
        functionName: 'getMonth'
    },
    {
        limit: 7,
        zeroBasedIndices: true,
        functionName: 'getDay'
    }
];
const shift = (component, index, date)=>{
    if (component === '*') {
        return '*';
    }
    const { limit, zeroBasedIndices, functionName } = COMPONENTS[index];
    const offset = +!zeroBasedIndices;
    const currentValue = date[functionName]();
    if (INTEGER_REGEX.test(component)) {
        return (Number.parseInt(component, 10) + currentValue) % limit + offset;
    }
    if (STEP_REGEX.test(component)) {
        const [, step] = component.split('/');
        const frequency = Math.floor(limit / Number(step));
        const list = Array.from({
            length: frequency
        }, (_, index)=>index * Number(step));
        return list.map((value)=>(value + currentValue) % limit + offset).sort((a, b)=>a - b);
    }
    // Unsupported syntax
    return component;
};
/**
 * Simulate an interval by shifting a cron expression using the specified date.
 * @param {string} rule A cron expression you want to shift.
 * @param {Date} date The date that's gonna be used as the start of the "interval", it defaults to now.
 * @returns The shifted cron expression.
 */ const shiftCronExpression = (rule, date = new Date())=>{
    const components = rule.trim().split(' ').filter(fp.negate(fp.isEmpty));
    const secondsIncluded = components.length === 6;
    return components.map((component, index)=>shift(component, secondsIncluded ? index : index + 1, date)).join(' ');
};

const ONE_MINUTE = 1000 * 60;
const ee = {
    enabled: false,
    licenseInfo: {}
};
const disable$1 = (message)=>{
    // Prevent emitting ee.disable if it was already disabled
    const shouldEmitEvent = ee.enabled !== false;
    ee.logger?.warn(`${message} Switching to CE.`);
    // Only keep the license key for potential re-enabling during a later check
    ee.licenseInfo = fp.pick('licenseKey', ee.licenseInfo);
    ee.enabled = false;
    if (shouldEmitEvent) {
        // Notify EE features that they should be disabled
        strapi.eventHub.emit('ee.disable');
    }
};
const enable$1 = ()=>{
    // Prevent emitting ee.enable if it was already enabled
    const shouldEmitEvent = ee.enabled !== true;
    ee.enabled = true;
    if (shouldEmitEvent) {
        // Notify EE features that they should be disabled
        strapi.eventHub.emit('ee.enable');
    }
};
let initialized = false;
/**
 * Optimistically enable EE if the format of the license is valid, only run once.
 */ const init = (licenseDir, logger)=>{
    if (initialized) {
        return;
    }
    initialized = true;
    ee.logger = logger;
    if (process.env.STRAPI_DISABLE_EE?.toLowerCase() === 'true') {
        return;
    }
    try {
        const license = process.env.STRAPI_LICENSE || readLicense(licenseDir);
        if (license) {
            ee.licenseInfo = verifyLicense(license);
            enable$1();
        }
    } catch (error) {
        if (error instanceof Error) {
            disable$1(error.message);
        } else {
            disable$1('Invalid license.');
        }
    }
};
/**
 * Contact the license registry to update the license to its latest state.
 *
 * Store the result in database to avoid unecessary requests, and will fallback to that in case of a network failure.
 */ const onlineUpdate = async ({ strapi: strapi1 })=>{
    const { get, commit, rollback } = await strapi1.db?.transaction();
    const transaction = get();
    try {
        const storedInfo = await strapi1.db?.queryBuilder('strapi::core-store').where({
            key: 'ee_information'
        }).select('value').first().transacting(transaction).forUpdate().execute().then((result)=>result ? JSON.parse(result.value) : result);
        const shouldContactRegistry = (storedInfo?.lastCheckAt ?? 0) < Date.now() - ONE_MINUTE;
        const result = {
            lastCheckAt: Date.now()
        };
        const fallback = (error)=>{
            if (error instanceof LicenseCheckError && error.shouldFallback && storedInfo?.license) {
                ee.logger?.warn(`${error.message} The last stored one will be used as a potential fallback.`);
                return storedInfo.license;
            }
            result.error = error.message;
            disable$1(error.message);
        };
        if (!ee?.licenseInfo?.licenseKey) {
            throw new Error('Missing license key.');
        }
        const license = shouldContactRegistry ? await fetchLicense({
            strapi: strapi1
        }, ee.licenseInfo.licenseKey, strapi1.config.get('uuid')).catch(fallback) : storedInfo.license;
        if (license) {
            try {
                // Verify license and check if its info changed
                const newLicenseInfo = verifyLicense(license);
                const licenseInfoChanged = !fp.isEqual(newLicenseInfo.features, ee.licenseInfo.features) || newLicenseInfo.seats !== ee.licenseInfo.seats || newLicenseInfo.type !== ee.licenseInfo.type;
                // Store the new license info
                ee.licenseInfo = newLicenseInfo;
                const wasEnabled = ee.enabled;
                validateInfo();
                // Notify EE features
                if (licenseInfoChanged && wasEnabled) {
                    strapi1.eventHub.emit('ee.update');
                }
            } catch (error) {
                if (error instanceof Error) {
                    disable$1(error.message);
                } else {
                    disable$1('Invalid license.');
                }
            }
        } else if (!shouldContactRegistry) {
            disable$1(storedInfo.error);
        }
        if (shouldContactRegistry) {
            result.license = license ?? null;
            const query = strapi1.db.queryBuilder('strapi::core-store').transacting(transaction);
            if (!storedInfo) {
                query.insert({
                    key: 'ee_information',
                    value: JSON.stringify(result)
                });
            } else {
                query.update({
                    value: JSON.stringify(result)
                }).where({
                    key: 'ee_information'
                });
            }
            await query.execute();
        }
        await commit();
    } catch (error) {
        // Example of errors: SQLite does not support FOR UPDATE
        await rollback();
    }
};
const validateInfo = ()=>{
    if (typeof ee.licenseInfo.expireAt === 'undefined') {
        throw new Error('Missing license key.');
    }
    const expirationTime = new Date(ee.licenseInfo.expireAt).getTime();
    if (expirationTime < new Date().getTime()) {
        return disable$1('License expired.');
    }
    enable$1();
};
const checkLicense = async ({ strapi: strapi1 })=>{
    const shouldStayOffline = ee.licenseInfo.type === 'gold' && // This env variable support is temporarily used to ease the migration between online vs offline
    process.env.STRAPI_DISABLE_LICENSE_PING?.toLowerCase() === 'true';
    if (!shouldStayOffline) {
        await onlineUpdate({
            strapi: strapi1
        });
        strapi1.cron.add({
            onlineUpdate: {
                task: ()=>onlineUpdate({
                        strapi: strapi1
                    }),
                options: shiftCronExpression('0 0 */12 * * *')
            }
        });
    } else {
        if (!ee.licenseInfo.expireAt) {
            return disable$1('Your license does not have offline support.');
        }
        validateInfo();
    }
};
const list = ()=>{
    return ee.licenseInfo.features?.map((feature)=>typeof feature === 'object' ? feature : {
            name: feature
        }) || [];
};
const get = (featureName)=>list().find((feature)=>feature.name === featureName);
var index = Object.freeze({
    init,
    checkLicense,
    get isEE () {
        return ee.enabled;
    },
    get seats () {
        return ee.licenseInfo.seats;
    },
    features: Object.freeze({
        list,
        get,
        isEnabled: (featureName)=>get(featureName) !== undefined
    })
});

const CHECK_INTERVAL = 1000 * 60 * 60 * 24 * 1; // 1 day
const NOTIF_INTERVAL = 1000 * 60 * 60 * 24 * 7; // 1 week
const boxenOptions = {
    padding: 1,
    margin: 1,
    align: 'center',
    borderColor: 'yellow',
    borderStyle: 'round'
};
const getUpdateMessage = (newVersion, currentVersion)=>{
    const currentVersionLog = chalk.dim(currentVersion);
    const newVersionLog = chalk.green(newVersion);
    const releaseLink = chalk.bold('https://github.com/strapi/strapi/releases');
    return `
A new version of Strapi is available ${currentVersionLog} → ${newVersionLog}
Check out the new releases at: ${releaseLink}
`.trim();
};
const createUpdateNotifier = (strapi)=>{
    let config;
    try {
        config = new Configstore(pkg.name, {}, {
            configPath: path.join(strapi.dirs.app.root, '.strapi-updater.json')
        });
    } catch  {
        // we don't have write access to the file system
        // we silence the error
        return;
    }
    const checkUpdate = async (checkInterval)=>{
        const now = Date.now();
        const lastUpdateCheck = config.get('lastUpdateCheck') || 0;
        if (lastUpdateCheck + checkInterval > now) {
            return;
        }
        try {
            const res = await packageJson(pkg.name);
            if (res.version) {
                config.set('latest', res.version);
                config.set('lastUpdateCheck', now);
            }
        } catch  {
        // silence error if offline
        }
    };
    const display = (notifInterval)=>{
        const now = Date.now();
        const latestVersion = config.get('latest');
        const lastNotification = config.get('lastNotification') || 0;
        if (!process.stdout.isTTY || lastNotification + notifInterval > now || !semver.valid(latestVersion) || !semver.valid(pkg.version) || semver.lte(latestVersion, pkg.version)) {
            return;
        }
        const message = boxen(getUpdateMessage(latestVersion, pkg.version), boxenOptions);
        config.set('lastNotification', now);
        console.log(message);
    };
    // TODO v6: Remove this warning
    if (strapiUtils.env.bool('STRAPI_DISABLE_UPDATE_NOTIFICATION', false)) {
        strapi.log.warn('STRAPI_DISABLE_UPDATE_NOTIFICATION is no longer supported. Instead, set logger.updates.enabled to false in your server configuration.');
    }
    if (!strapi.config.get('server.logger.updates.enabled') || !config) {
        return;
    }
    display(NOTIF_INTERVAL);
    checkUpdate(CHECK_INTERVAL); // doesn't need to await
};

// TODO: once core Node exposes a stable way to create a ProxyAgent we will use that instead of undici
// Create a wrapper for Node's Fetch API that applies a global proxy
const createStrapiFetch = (strapi)=>{
    function strapiFetch(url, options) {
        const fetchOptions = {
            ...strapiFetch.dispatcher ? {
                dispatcher: strapiFetch.dispatcher
            } : {},
            ...options
        };
        strapi.log.debug(`Making request for ${url}`);
        return fetch(url, fetchOptions);
    }
    const proxy = strapi.config.get('server.proxy.fetch') || strapi.config.get('server.proxy.global');
    if (proxy) {
        strapi.log.info(`Using proxy for Fetch requests: ${proxy}`);
        strapiFetch.dispatcher = new undici.ProxyAgent(proxy);
    }
    return strapiFetch;
};

const convertCustomFieldType = (strapi)=>{
    const allContentTypeSchemaAttributes = Object.values(strapi.contentTypes).map((schema)=>schema.attributes);
    const allComponentSchemaAttributes = Object.values(strapi.components).map((schema)=>schema.attributes);
    const allSchemasAttributes = [
        ...allContentTypeSchemaAttributes,
        ...allComponentSchemaAttributes
    ];
    for (const schemaAttrbutes of allSchemasAttributes){
        for (const attribute of Object.values(schemaAttrbutes)){
            if (attribute.type === 'customField') {
                const customField = strapi.get('custom-fields').get(attribute.customField);
                attribute.type = customField.type;
            }
        }
    }
};

const createStartupLogger = (app)=>{
    return {
        logStats () {
            const columns = Math.min(process.stderr.columns, 80) - 2;
            console.log();
            console.log(chalk.black.bgWhite(fp.padEnd(columns, ' Project information')));
            console.log();
            const infoTable = new CLITable({
                colWidths: [
                    20,
                    50
                ],
                chars: {
                    mid: '',
                    'left-mid': '',
                    'mid-mid': '',
                    'right-mid': ''
                }
            });
            const dbInfo = app.db?.getInfo();
            infoTable.push([
                chalk.blue('Time'),
                `${new Date()}`
            ], [
                chalk.blue('Launched in'),
                `${Date.now() - app.config.launchedAt} ms`
            ], [
                chalk.blue('Environment'),
                app.config.environment
            ], [
                chalk.blue('Process PID'),
                process.pid
            ], [
                chalk.blue('Version'),
                `${app.config.info.strapi} (node ${process.version})`
            ], [
                chalk.blue('Edition'),
                app.EE ? 'Enterprise' : 'Community'
            ], [
                chalk.blue('Database'),
                dbInfo?.client
            ], [
                chalk.blue('Database name'),
                dbInfo?.displayName
            ]);
            if (dbInfo?.schema) {
                infoTable.push([
                    chalk.blue('Database schema'),
                    dbInfo.schema
                ]);
            }
            console.log(infoTable.toString());
            console.log();
            console.log(chalk.black.bgWhite(fp.padEnd(columns, ' Actions available')));
            console.log();
        },
        logFirstStartupMessage () {
            if (!strapi.config.get('server.logger.startup.enabled')) {
                return;
            }
            this.logStats();
            console.log(chalk.bold('One more thing...'));
            console.log(chalk.grey('Create your first administrator 💻 by going to the administration panel at:'));
            console.log();
            const addressTable = new CLITable();
            const adminUrl = strapi.config.get('admin.absoluteUrl');
            addressTable.push([
                chalk.bold(adminUrl)
            ]);
            console.log(`${addressTable.toString()}`);
            console.log();
        },
        logDefaultStartupMessage () {
            if (!strapi.config.get('server.logger.startup.enabled')) {
                return;
            }
            this.logStats();
            console.log(chalk.bold('Welcome back!'));
            if (app.config.get('admin.serveAdminPanel') === true) {
                console.log(chalk.grey('To manage your project 🚀, go to the administration panel at:'));
                const adminUrl = strapi.config.get('admin.absoluteUrl');
                console.log(chalk.bold(adminUrl));
                console.log();
            }
            console.log(chalk.grey('To access the server ⚡️, go to:'));
            const serverUrl = strapi.config.get('server.absoluteUrl');
            console.log(chalk.bold(serverUrl));
            console.log();
        },
        logStartupMessage ({ isInitialized }) {
            if (!strapi.config.get('server.logger.startup.enabled')) {
                return;
            }
            if (!isInitialized) {
                this.logFirstStartupMessage();
            } else {
                this.logDefaultStartupMessage();
            }
        }
    };
};

/**
 * Because strapi/database models don't know about things like components or dynamic zones, we use this file to convert them
 * to a relations format that it recognizes
 *
 * Therefore we have to keep an additional set of helpers/extensions to the database naming methods
 *
 * IMPORTANT!
 * If we use short versions of anything, we MUST call getNameFromTokens directly; attempting to shorten them ourselves
 * prevents the unshortened name map from being filled properly, so for example it will think that the short name
 * 'collection4f3a_cmps' maps to the unshortened 'collectionname_cmps' rather than 'collectionname_components'
 * Therefore, we only use the identifiers helpers in cases where we do not do any of our own shortening
 */ const getComponentJoinTableName = (collectionName, identifiers)=>{
    return identifiers.getNameFromTokens([
        {
            name: collectionName,
            compressible: true
        },
        {
            name: 'components',
            shortName: 'cmps',
            compressible: false
        }
    ]);
};
const getDzJoinTableName = (collectionName, identifiers)=>{
    return identifiers.getNameFromTokens([
        {
            name: collectionName,
            compressible: true
        },
        {
            name: 'components',
            shortName: 'cmps',
            compressible: false
        }
    ]);
};
const getComponentJoinColumnEntityName = (identifiers)=>{
    return identifiers.getNameFromTokens([
        {
            name: 'entity',
            compressible: false
        },
        {
            name: 'id',
            compressible: false
        }
    ]);
};
const getComponentJoinColumnInverseName = (identifiers)=>{
    return identifiers.getNameFromTokens([
        {
            name: 'component',
            shortName: 'cmp',
            compressible: false
        },
        {
            name: 'id',
            compressible: false
        }
    ]);
};
const getComponentTypeColumn = (identifiers)=>{
    return identifiers.getNameFromTokens([
        {
            name: 'component_type',
            compressible: false
        }
    ]);
};
const getComponentFkIndexName = (contentType, identifiers)=>{
    return identifiers.getNameFromTokens([
        {
            name: contentType,
            compressible: true
        },
        {
            name: 'entity',
            compressible: false
        },
        {
            name: 'fk',
            compressible: false
        }
    ]);
};
// Transforms an attribute (particularly for relation types) into the format that strapi/database accepts
const transformAttribute = (name, attribute, contentType, identifiers)=>{
    switch(attribute.type){
        case 'media':
            {
                return {
                    type: 'relation',
                    relation: attribute.multiple === true ? 'morphMany' : 'morphOne',
                    target: 'plugin::upload.file',
                    morphBy: 'related'
                };
            }
        case 'component':
            {
                const joinTableName = getComponentJoinTableName(contentType.collectionName, identifiers);
                const joinColumnEntityName = getComponentJoinColumnEntityName(identifiers);
                const joinColumnInverseName = getComponentJoinColumnInverseName(identifiers);
                const compTypeColumn = getComponentTypeColumn(identifiers);
                return {
                    type: 'relation',
                    relation: attribute.repeatable === true ? 'oneToMany' : 'oneToOne',
                    target: attribute.component,
                    // We need the join table name to be deterministic,
                    // We need to allow passing the join table name as an option
                    joinTable: {
                        name: joinTableName,
                        joinColumn: {
                            name: joinColumnEntityName,
                            referencedColumn: identifiers.ID_COLUMN
                        },
                        inverseJoinColumn: {
                            name: joinColumnInverseName,
                            referencedColumn: identifiers.ID_COLUMN
                        },
                        on: {
                            field: name
                        },
                        orderColumnName: identifiers.ORDER_COLUMN,
                        orderBy: {
                            order: 'asc'
                        },
                        pivotColumns: [
                            joinColumnEntityName,
                            joinColumnInverseName,
                            identifiers.FIELD_COLUMN,
                            compTypeColumn
                        ]
                    }
                };
            }
        case 'dynamiczone':
            {
                const joinTableName = getDzJoinTableName(contentType.collectionName, identifiers);
                const joinColumnEntityName = getComponentJoinColumnEntityName(identifiers);
                const joinColumnInverseName = getComponentJoinColumnInverseName(identifiers);
                const compTypeColumn = getComponentTypeColumn(identifiers);
                return {
                    type: 'relation',
                    relation: 'morphToMany',
                    // TODO: handle restrictions at some point
                    // target: attribute.components,
                    joinTable: {
                        name: joinTableName,
                        joinColumn: {
                            name: joinColumnEntityName,
                            referencedColumn: identifiers.ID_COLUMN
                        },
                        morphColumn: {
                            idColumn: {
                                name: joinColumnInverseName,
                                referencedColumn: identifiers.ID_COLUMN
                            },
                            typeColumn: {
                                name: compTypeColumn
                            },
                            typeField: '__component'
                        },
                        on: {
                            field: name
                        },
                        orderBy: {
                            order: 'asc'
                        },
                        pivotColumns: [
                            joinColumnEntityName,
                            joinColumnInverseName,
                            identifiers.FIELD_COLUMN,
                            compTypeColumn
                        ]
                    }
                };
            }
        default:
            {
                return attribute;
            }
    }
};
const transformAttributes = (contentType, identifiers)=>{
    return Object.keys(contentType.attributes || {}).reduce((attrs, attrName)=>{
        return {
            ...attrs,
            [attrName]: transformAttribute(attrName, contentType.attributes[attrName], contentType, identifiers)
        };
    }, {});
};
const hasComponentsOrDz = (contentType)=>{
    return Object.values(contentType.attributes || {}).some(({ type })=>type === 'dynamiczone' || type === 'component');
};
const createDocumentId = cuid2.createId;
const createCompoLinkModel = (contentType, identifiers)=>{
    const name = getComponentJoinTableName(contentType.collectionName, identifiers);
    const entityId = getComponentJoinColumnEntityName(identifiers);
    const componentId = getComponentJoinColumnInverseName(identifiers);
    const compTypeColumn = getComponentTypeColumn(identifiers);
    const fkIndex = getComponentFkIndexName(contentType.collectionName, identifiers);
    return {
        // TODO: make sure there can't be any conflicts with a prefix
        singularName: name,
        uid: name,
        tableName: name,
        attributes: {
            [identifiers.ID_COLUMN]: {
                type: 'increments'
            },
            [entityId]: {
                type: 'integer',
                column: {
                    unsigned: true
                }
            },
            [componentId]: {
                type: 'integer',
                column: {
                    unsigned: true
                }
            },
            [compTypeColumn]: {
                type: 'string'
            },
            [identifiers.FIELD_COLUMN]: {
                type: 'string'
            },
            [identifiers.ORDER_COLUMN]: {
                type: 'float',
                column: {
                    unsigned: true,
                    defaultTo: null
                }
            }
        },
        indexes: [
            {
                name: identifiers.getIndexName([
                    contentType.collectionName,
                    identifiers.FIELD_COLUMN
                ]),
                columns: [
                    identifiers.FIELD_COLUMN
                ]
            },
            {
                name: identifiers.getIndexName([
                    contentType.collectionName,
                    compTypeColumn
                ]),
                columns: [
                    compTypeColumn
                ]
            },
            {
                name: fkIndex,
                columns: [
                    entityId
                ]
            },
            {
                // NOTE: since we don't include attribute names, we need to be careful not to create another unique index
                name: identifiers.getUniqueIndexName([
                    contentType.collectionName
                ]),
                columns: [
                    entityId,
                    componentId,
                    identifiers.FIELD_COLUMN,
                    compTypeColumn
                ],
                type: 'unique'
            }
        ],
        foreignKeys: [
            {
                name: fkIndex,
                columns: [
                    entityId
                ],
                referencedColumns: [
                    identifiers.ID_COLUMN
                ],
                referencedTable: identifiers.getTableName(contentType.collectionName),
                onDelete: 'CASCADE'
            }
        ]
    };
};
const transformContentTypesToModels = (contentTypes, identifiers)=>{
    const models = [];
    contentTypes.forEach((contentType)=>{
        assert(contentType.collectionName, 'Content type "collectionName" is required');
        assert(contentType.modelName, 'Content type "modelName" is required');
        assert(contentType.uid, 'Content type "uid" is required');
        // Add document id to content types
        // as it is not documented
        const documentIdAttribute = contentType.modelType === 'contentType' ? {
            documentId: {
                type: 'string',
                default: createDocumentId
            }
        } : {};
        // TODO: this needs to be combined with getReservedNames, we should not be maintaining two lists
        // Prevent user from creating a documentId attribute
        const reservedAttributeNames = [
            'document_id',
            identifiers.ID_COLUMN
        ];
        Object.keys(contentType.attributes || {}).forEach((attributeName)=>{
            const snakeCasedAttributeName = fp.snakeCase(attributeName);
            if (reservedAttributeNames.includes(snakeCasedAttributeName)) {
                throw new Error(`The attribute "${attributeName}" is reserved and cannot be used in a model. Please rename "${contentType.modelName}" attribute "${attributeName}" to something else.`);
            }
        });
        if (hasComponentsOrDz(contentType)) {
            const compoLinkModel = createCompoLinkModel(contentType, identifiers);
            models.push(compoLinkModel);
        }
        const model = {
            uid: contentType.uid,
            singularName: contentType.modelName,
            tableName: contentType.collectionName,
            attributes: {
                [identifiers.ID_COLUMN]: {
                    type: 'increments'
                },
                ...documentIdAttribute,
                ...transformAttributes(contentType, identifiers)
            },
            indexes: contentType.indexes,
            foreignKeys: contentType.foreignKeys,
            lifecycles: contentType?.lifecycles ?? {}
        };
        // Add indexes to model
        if (contentType.modelType === 'contentType') {
            model.indexes = [
                ...model.indexes || [],
                {
                    name: identifiers.getIndexName([
                        contentType.collectionName,
                        'documents'
                    ]),
                    // Filter attributes that are not in the schema
                    columns: [
                        'documentId',
                        'locale',
                        'publishedAt'
                    ].filter((n)=>model.attributes[n]).map((name)=>identifiers.getColumnName(fp.snakeCase(name)))
                }
            ];
        }
        models.push(model);
    });
    return models;
};

const destroyOnSignal = (strapi)=>{
    let signalReceived = false;
    // For unknown reasons, we receive signals 2 times.
    // As a temporary fix, we ignore the signals received after the first one.
    const terminateStrapi = async ()=>{
        if (!signalReceived) {
            signalReceived = true;
            await strapi.destroy();
            process.exit();
        }
    };
    [
        'SIGTERM',
        'SIGINT'
    ].forEach((signal)=>{
        process.on(signal, terminateStrapi);
    });
};

const LIFECYCLES$1 = {
    REGISTER: 'register',
    BOOTSTRAP: 'bootstrap',
    DESTROY: 'destroy'
};

/**
 * Resolve the working directories based on the instance options.
 *
 * Behavior:
 * - `appDir` is the directory where Strapi will write every file (schemas, generated APIs, controllers or services)
 * - `distDir` is the directory where Strapi will read configurations, schemas and any compiled code
 *
 * Default values:
 * - If `appDir` is `undefined`, it'll be set to `process.cwd()`
 * - If `distDir` is `undefined`, it'll be set to `appDir`
 */ const resolveWorkingDirectories = (opts)=>{
    const cwd = process.cwd();
    const appDir = opts.appDir ? path$1.resolve(cwd, opts.appDir) : cwd;
    const distDir = opts.distDir ? path$1.resolve(cwd, opts.distDir) : appDir;
    return {
        appDir,
        distDir
    };
};

class Container {
    add(name, resolver) {
        if (this.registerMap.has(name)) {
            throw new Error(`Cannot register already registered service ${name}`);
        }
        this.registerMap.set(name, resolver);
        return this;
    }
    get(name, args) {
        // TODO: handle singleton vs instantiation everytime
        if (this.serviceMap.has(name)) {
            return this.serviceMap.get(name);
        }
        if (this.registerMap.has(name)) {
            const resolver = this.registerMap.get(name);
            if (typeof resolver === 'function') {
                this.serviceMap.set(name, resolver(this, args));
            } else {
                this.serviceMap.set(name, resolver);
            }
            return this.serviceMap.get(name);
        }
        throw new Error(`Could not resolve service ${name}`);
    }
    constructor(){
        this.registerMap = new Map();
        this.serviceMap = new Map();
    }
}

/**
 * create strapi fs layer
 */ var createStrapiFs = ((strapi)=>{
    function normalizePath(optPath) {
        const filePath = Array.isArray(optPath) ? optPath.join('/') : optPath;
        const normalizedPath = path.normalize(filePath).replace(/^\/?(\.\/|\.\.\/)+/, '');
        return path.resolve(strapi.dirs.app.root, normalizedPath);
    }
    const strapiFS = {
        /**
     * Writes a file in a strapi app
     * @param {Array|string} optPath - file path
     * @param {string} data - content
     */ writeAppFile (optPath, data) {
            const writePath = normalizePath(optPath);
            return fse.ensureFile(writePath).then(()=>fse.writeFile(writePath, data));
        },
        /**
     * Writes a file in a plugin extensions folder
     * @param {string} plugin - plugin name
     * @param {Array|string} optPath - path to file
     * @param {string} data - content
     */ writePluginFile (plugin, optPath, data) {
            const newPath = [
                'extensions',
                plugin
            ].concat(optPath).join('/');
            return strapiFS.writeAppFile(newPath, data);
        },
        /**
     * Removes a file in strapi app
     */ removeAppFile (optPath) {
            const removePath = normalizePath(optPath);
            return fse.remove(removePath);
        },
        /**
     * Appends a file in strapi app
     */ appendFile (optPath, data) {
            const writePath = normalizePath(optPath);
            return fse.appendFileSync(writePath, data);
        }
    };
    return strapiFS;
});

/**
 * The event hub is Strapi's event control center.
 */ function createEventHub() {
    const listeners = new Map();
    // Default subscriber to easily add listeners with the on() method
    const defaultSubscriber = async (eventName, ...args)=>{
        if (listeners.has(eventName)) {
            for (const listener of listeners.get(eventName)){
                await listener(...args);
            }
        }
    };
    // Store of subscribers that will be called when an event is emitted
    const subscribers = [
        defaultSubscriber
    ];
    const eventHub = {
        async emit (eventName, ...args) {
            for (const subscriber of subscribers){
                await subscriber(eventName, ...args);
            }
        },
        subscribe (subscriber) {
            subscribers.push(subscriber);
            // Return a function to remove the subscriber
            return ()=>{
                eventHub.unsubscribe(subscriber);
            };
        },
        unsubscribe (subscriber) {
            const subscriberIndex = subscribers.indexOf(subscriber);
            // Only remove the subscriber if it exists
            if (subscriberIndex >= 0) {
                subscribers.splice(subscriberIndex, 1);
            }
        },
        on (eventName, listener) {
            if (!listeners.has(eventName)) {
                listeners.set(eventName, [
                    listener
                ]);
            } else {
                listeners.get(eventName).push(listener);
            }
            // Return a function to remove the listener
            return ()=>{
                eventHub.off(eventName, listener);
            };
        },
        off (eventName, listener) {
            listeners.get(eventName)?.splice(listeners.get(eventName).indexOf(listener), 1);
        },
        once (eventName, listener) {
            return eventHub.on(eventName, async (...args)=>{
                eventHub.off(eventName, listener);
                return listener(...args);
            });
        },
        destroy () {
            this.removeAllListeners();
            this.removeAllSubscribers();
            return this;
        },
        removeListener (eventName, listener) {
            return eventHub.off(eventName, listener);
        },
        removeAllListeners () {
            listeners.clear();
            return this;
        },
        removeAllSubscribers () {
            subscribers.length = 0;
            return this;
        },
        addListener (eventName, listener) {
            return eventHub.on(eventName, listener);
        }
    };
    return eventHub;
}

const createHTTPServer = (strapi, koaApp)=>{
    const connections = new Set();
    // lazy creation of the request listener
    let handler;
    const listener = function handleRequest(req, res) {
        if (!handler) {
            handler = koaApp.callback();
        }
        return handler(req, res);
    };
    const options = strapi.config.get('server.http.serverOptions', {});
    const server = http.createServer(options, listener);
    server.on('connection', (connection)=>{
        connections.add(connection);
        connection.on('close', ()=>{
            connections.delete(connection);
        });
    });
    // handle port in use cleanly
    server.on('error', (err)=>{
        if ('code' in err && 'port' in err && err.code === 'EADDRINUSE') {
            return strapi.stopWithError(`The port ${err.port} is already used by another application.`);
        }
        strapi.log.error(err);
    });
    const destroy = async ()=>{
        for (const connection of connections){
            connection.destroy();
            connections.delete(connection);
        }
        if (!server.listening) {
            return;
        }
        return new Promise((resolve, reject)=>{
            server.close((error)=>{
                if (error) {
                    reject(error);
                } else {
                    resolve();
                }
            });
        });
    };
    return Object.assign(server, {
        destroy
    });
};

const instantiateMiddleware = (middlewareFactory, name, config, strapi)=>{
    try {
        return middlewareFactory(config, {
            strapi
        });
    } catch (e) {
        if (e instanceof Error) {
            throw new Error(`Middleware "${name}": ${e.message}`);
        }
    }
};
const resolveRouteMiddlewares = (route, strapi)=>{
    const middlewaresConfig = route?.config?.middlewares ?? [];
    if (!fp.isArray(middlewaresConfig)) {
        throw new Error('Route middlewares config must be an array');
    }
    const middlewares = resolveMiddlewares(middlewaresConfig, strapi);
    return middlewares.map(({ handler })=>handler);
};
const dummyMiddleware = (_, next)=>next();
/**
 * Initialize every configured middlewares
 */ const resolveMiddlewares = (config, strapi)=>{
    const middlewares = [];
    for (const item of config){
        if (typeof item === 'function') {
            middlewares.push({
                name: null,
                handler: item
            });
            continue;
        }
        if (typeof item === 'string') {
            const middlewareFactory = strapi.middleware(item);
            if (!middlewareFactory) {
                throw new Error(`Middleware ${item} not found.`);
            }
            middlewares.push({
                name: item,
                handler: instantiateMiddleware(middlewareFactory, item, {}, strapi) ?? dummyMiddleware
            });
            continue;
        }
        if (typeof item === 'object' && item !== null) {
            const { name, resolve, config = {} } = item;
            if (name) {
                const middlewareFactory = strapi.middleware(name);
                middlewares.push({
                    name,
                    handler: instantiateMiddleware(middlewareFactory, name, config, strapi) ?? dummyMiddleware
                });
                continue;
            }
            if (resolve) {
                const resolvedMiddlewareFactory = resolveCustomMiddleware(resolve, strapi);
                middlewares.push({
                    name: resolve,
                    handler: instantiateMiddleware(resolvedMiddlewareFactory, resolve, config, strapi) ?? dummyMiddleware
                });
                continue;
            }
            throw new Error('Invalid middleware configuration. Missing name or resolve properties.');
        }
        throw new Error('Middleware config must either be a string or an object {name?: string, resolve?: string, config: any}.');
    }
    return middlewares;
};
/**
 * Resolve middleware from package name or path
 */ const resolveCustomMiddleware = (resolve, strapi)=>{
    let modulePath;
    try {
        modulePath = require.resolve(resolve);
    } catch (error) {
        if (error instanceof Error && 'code' in error && error.code === 'MODULE_NOT_FOUND') {
            modulePath = path.resolve(strapi.dirs.dist.root, resolve);
        } else {
            throw error;
        }
    }
    try {
        return strapiUtils.importDefault(modulePath);
    } catch (err) {
        throw new Error(`Could not load middleware "${modulePath}".`);
    }
};

const createPolicicesMiddleware = (route, strapi)=>{
    const policiesConfig = route?.config?.policies ?? [];
    const resolvedPolicies = strapi.get('policies').resolve(policiesConfig, route.info);
    const policiesMiddleware = async (ctx, next)=>{
        const context = strapiUtils.policy.createPolicyContext('koa', ctx);
        for (const { handler, config } of resolvedPolicies){
            const result = await handler(context, config, {
                strapi
            });
            if (![
                true,
                undefined
            ].includes(result)) {
                throw new strapiUtils.errors.PolicyError();
            }
        }
        await next();
    };
    return policiesMiddleware;
};

const getMethod = (route)=>{
    return fp.trim(fp.toLower(route.method));
};
const getPath = (route)=>fp.trim(route.path);
const createRouteInfoMiddleware = (routeInfo)=>(ctx, next)=>{
        const route = {
            ...routeInfo,
            config: routeInfo.config || {}
        };
        ctx.state.route = route;
        return next();
    };
const getAuthConfig = fp.prop('config.auth');
const createAuthorizeMiddleware = (strapi)=>async (ctx, next)=>{
        const { auth, route } = ctx.state;
        const authService = strapi.get('auth');
        try {
            await authService.verify(auth, getAuthConfig(route));
            return await next();
        } catch (error) {
            if (error instanceof strapiUtils.errors.UnauthorizedError) {
                return ctx.unauthorized();
            }
            if (error instanceof strapiUtils.errors.ForbiddenError) {
                // allow PolicyError as an exception to throw a publicly visible message in the API
                if (error instanceof strapiUtils.errors.PolicyError) {
                    throw error;
                }
                return ctx.forbidden();
            }
            throw error;
        }
    };
const createAuthenticateMiddleware = (strapi)=>async (ctx, next)=>{
        return strapi.get('auth').authenticate(ctx, next);
    };
const returnBodyMiddleware = async (ctx, next)=>{
    const values = await next();
    if (fp.isNil(ctx.body) && !fp.isNil(values)) {
        ctx.body = values;
    }
};
var createEndpointComposer = ((strapi)=>{
    const authenticate = createAuthenticateMiddleware(strapi);
    const authorize = createAuthorizeMiddleware(strapi);
    return (route, { router })=>{
        try {
            const method = getMethod(route);
            const path = getPath(route);
            const middlewares = resolveRouteMiddlewares(route, strapi);
            const action = getAction(route, strapi);
            const routeHandler = compose([
                createRouteInfoMiddleware(route),
                authenticate,
                authorize,
                createPolicicesMiddleware(route, strapi),
                ...middlewares,
                returnBodyMiddleware,
                ...fp.castArray(action)
            ]);
            router[method](path, routeHandler);
        } catch (error) {
            if (error instanceof Error) {
                error.message = `Error creating endpoint ${route.method} ${route.path}: ${error.message}`;
            }
            throw error;
        }
    };
});
const getController = (name, { pluginName, apiName }, strapi)=>{
    let ctrl;
    if (pluginName) {
        if (pluginName === 'admin') {
            ctrl = strapi.controller(`admin::${name}`);
        } else {
            ctrl = strapi.plugin(pluginName).controller(name);
        }
    } else if (apiName) {
        ctrl = strapi.controller(`api::${apiName}.${name}`);
    }
    if (!ctrl) {
        return strapi.controller(name);
    }
    return ctrl;
};
const extractHandlerParts = (name)=>{
    const controllerName = name.slice(0, name.lastIndexOf('.'));
    const actionName = name.slice(name.lastIndexOf('.') + 1);
    return {
        controllerName,
        actionName
    };
};
const getAction = (route, strapi)=>{
    const { handler, info } = route;
    const { pluginName, apiName, type } = info ?? {};
    if (Array.isArray(handler) || typeof handler === 'function') {
        return handler;
    }
    const { controllerName, actionName } = extractHandlerParts(fp.trim(handler));
    const controller = getController(controllerName, {
        pluginName,
        apiName,
        type
    }, strapi);
    if (typeof controller[actionName] !== 'function') {
        throw new Error(`Handler not found "${handler}"`);
    }
    if (Symbol.for('__type__') in controller[actionName]) {
        controller[actionName][Symbol.for('__type__')].push(type);
    } else {
        controller[actionName][Symbol.for('__type__')] = [
            type
        ];
    }
    return controller[actionName].bind(controller);
};

const policyOrMiddlewareSchema = strapiUtils.yup.lazy((value)=>{
    if (typeof value === 'string') {
        return strapiUtils.yup.string().required();
    }
    if (typeof value === 'function') {
        return strapiUtils.yup.mixed().isFunction();
    }
    return strapiUtils.yup.object({
        name: strapiUtils.yup.string().required(),
        options: strapiUtils.yup.object().notRequired()
    });
});
const routeSchema = strapiUtils.yup.object({
    method: strapiUtils.yup.string().oneOf([
        'GET',
        'POST',
        'PUT',
        'PATCH',
        'DELETE',
        'ALL'
    ]).required(),
    path: strapiUtils.yup.string().required(),
    handler: strapiUtils.yup.lazy((value)=>{
        if (typeof value === 'string') {
            return strapiUtils.yup.string().required();
        }
        if (Array.isArray(value)) {
            return strapiUtils.yup.array().required();
        }
        return strapiUtils.yup.mixed().isFunction().required();
    }),
    config: strapiUtils.yup.object({
        auth: strapiUtils.yup.lazy((value)=>{
            if (value === false) {
                return strapiUtils.yup.boolean().required();
            }
            return strapiUtils.yup.object({
                scope: strapiUtils.yup.array().of(strapiUtils.yup.string()).required()
            });
        }),
        policies: strapiUtils.yup.array()// FIXME: fixed in yup v1
        .of(policyOrMiddlewareSchema).notRequired(),
        middlewares: strapiUtils.yup.array()// FIXME: fixed in yup v1
        .of(policyOrMiddlewareSchema).notRequired()
    }).notRequired()
});
const validateRouteConfig = (routeConfig)=>{
    try {
        return routeSchema.validateSync(routeConfig, {
            strict: true,
            abortEarly: false,
            stripUnknown: true
        });
    } catch (error) {
        if (error instanceof strapiUtils.yup.ValidationError) {
            throw new Error(`Invalid route config ${error.message}`);
        }
    }
};
const createRouteManager = (strapi, opts = {})=>{
    const { type } = opts;
    const composeEndpoint = createEndpointComposer(strapi);
    const createRoute = (route, router)=>{
        validateRouteConfig(route);
        // NOTE: the router type is used to tag controller actions and for authentication / authorization so we need to pass this info down to the route level
        const routeWithInfo = Object.assign(route, {
            info: {
                ...route.info ?? {},
                type: type || 'api'
            }
        });
        composeEndpoint(routeWithInfo, {
            router
        });
    };
    const addRoutes = (routes, router)=>{
        if (Array.isArray(routes)) {
            routes.forEach((route)=>createRoute(route, router));
        } else if (routes.routes) {
            const subRouter = new Router({
                prefix: routes.prefix
            });
            routes.routes.forEach((route)=>{
                const hasPrefix = fp.has('prefix', route.config);
                createRoute(route, hasPrefix ? router : subRouter);
            });
            return router.use(subRouter.routes(), subRouter.allowedMethods());
        }
    };
    return {
        addRoutes
    };
};

const createAPI = (strapi, opts = {})=>{
    const { prefix, type } = opts;
    const api = new Router({
        prefix
    });
    const routeManager = createRouteManager(strapi, {
        type
    });
    return {
        listRoutes () {
            return [
                ...api.stack
            ];
        },
        use (fn) {
            api.use(fn);
            return this;
        },
        routes (routes) {
            routeManager.addRoutes(routes, api);
            return this;
        },
        mount (router) {
            router.use(api.routes(), api.allowedMethods());
            return this;
        }
    };
};

const createAdminAPI = (strapi)=>{
    const opts = {
        prefix: '',
        type: 'admin'
    };
    return createAPI(strapi, opts);
};

const createContentAPI$1 = (strapi)=>{
    const opts = {
        prefix: strapi.config.get('api.rest.prefix', '/api'),
        type: 'content-api'
    };
    return createAPI(strapi, opts);
};

const createRouteScopeGenerator = (namespace)=>(route)=>{
        const prefix = namespace.endsWith('::') ? namespace : `${namespace}.`;
        if (typeof route.handler === 'string') {
            _.defaultsDeep(route, {
                config: {
                    auth: {
                        scope: [
                            `${route.handler.startsWith(prefix) ? '' : prefix}${route.handler}`
                        ]
                    }
                }
            });
        }
    };
/**
 * Register all routes
 */ var registerAllRoutes = ((strapi)=>{
    registerAdminRoutes(strapi);
    registerAPIRoutes(strapi);
    registerPluginRoutes(strapi);
});
/**
 * Register admin routes
 * @param {import('../../').Strapi} strapi
 */ const registerAdminRoutes = (strapi)=>{
    const generateRouteScope = createRouteScopeGenerator(`admin::`);
    _.forEach(strapi.admin.routes, (router)=>{
        router.type = router.type || 'admin';
        router.prefix = router.prefix || `/admin`;
        router.routes.forEach((route)=>{
            generateRouteScope(route);
            route.info = {
                pluginName: 'admin'
            };
        });
        strapi.server.routes(router);
    });
};
/**
 * Register plugin routes
 * @param {import('../../').Strapi} strapi
 */ const registerPluginRoutes = (strapi)=>{
    for (const pluginName of Object.keys(strapi.plugins)){
        const plugin = strapi.plugins[pluginName];
        const generateRouteScope = createRouteScopeGenerator(`plugin::${pluginName}`);
        if (Array.isArray(plugin.routes)) {
            plugin.routes.forEach((route)=>{
                generateRouteScope(route);
                route.info = {
                    pluginName
                };
            });
            strapi.server.routes({
                type: 'admin',
                prefix: `/${pluginName}`,
                routes: plugin.routes
            });
        } else {
            _.forEach(plugin.routes, (router)=>{
                router.type = router.type || 'admin';
                router.prefix = router.prefix || `/${pluginName}`;
                router.routes.forEach((route)=>{
                    generateRouteScope(route);
                    route.info = {
                        pluginName
                    };
                });
                strapi.server.routes(router);
            });
        }
    }
};
/**
 * Register api routes
 */ const registerAPIRoutes = (strapi)=>{
    for (const apiName of Object.keys(strapi.apis)){
        const api = strapi.api(apiName);
        const generateRouteScope = createRouteScopeGenerator(`api::${apiName}`);
        _.forEach(api.routes, (router)=>{
            // TODO: remove once auth setup
            // pass meta down to compose endpoint
            router.type = 'content-api';
            router.routes?.forEach((route)=>{
                generateRouteScope(route);
                route.info = {
                    apiName
                };
            });
            return strapi.server.routes(router);
        });
    }
};

const defaultConfig$1 = [
    'strapi::logger',
    'strapi::errors',
    'strapi::security',
    'strapi::cors',
    'strapi::poweredBy',
    'strapi::session',
    'strapi::query',
    'strapi::body',
    'strapi::favicon',
    'strapi::public'
];
const requiredMiddlewares = [
    'strapi::errors',
    'strapi::security',
    'strapi::cors',
    'strapi::query',
    'strapi::body',
    'strapi::public',
    'strapi::favicon'
];
const middlewareConfigSchema = strapiUtils.yup.array().of(strapiUtils.yup.lazy((value)=>{
    if (typeof value === 'string') {
        return strapiUtils.yup.string().required();
    }
    if (typeof value === 'object') {
        return strapiUtils.yup.object({
            name: strapiUtils.yup.string(),
            resolve: strapiUtils.yup.string(),
            config: strapiUtils.yup.mixed()
        }).required().noUnknown();
    }
    return strapiUtils.yup.mixed().test(()=>false);
}));
/**
 * Register middlewares in router
 */ const registerApplicationMiddlewares = async (strapi)=>{
    const middlewareConfig = strapi.config.get('middlewares', defaultConfig$1);
    await validateMiddlewareConfig(middlewareConfig);
    const middlewares = await resolveMiddlewares(middlewareConfig, strapi);
    checkRequiredMiddlewares(middlewares);
    // NOTE: exclude middlewares that return nothing.
    // this is used for middlewares that only extend the app only need to be added in certain conditions
    for (const middleware of middlewares){
        strapi.server.use(middleware.handler);
    }
};
/**
 *
 * @param {MiddlewaresConfig} config
 */ const validateMiddlewareConfig = async (config)=>{
    try {
        await middlewareConfigSchema.validate(config, {
            strict: true,
            abortEarly: false
        });
    } catch (error) {
        throw new Error('Invalid middleware configuration. Expected Array<string|{name?: string, resolve?: string, config: any}.');
    }
};
/**
 * Check if some required middlewares are missing in configure middlewares
 * @param {Middlewares} middlewares
 */ const checkRequiredMiddlewares = (middlewares)=>{
    const missingMiddlewares = requiredMiddlewares.filter((name)=>{
        return middlewares.findIndex((mdl)=>mdl.name === name) === -1;
    });
    if (missingMiddlewares.length > 0) {
        throw new Error(`Missing required middlewares in configuration. Add the following middlewares: "${missingMiddlewares.join(', ')}".`);
    }
};

const mapErrorsAndStatus = [
    {
        classError: strapiUtils.errors.UnauthorizedError,
        status: 401
    },
    {
        classError: strapiUtils.errors.ForbiddenError,
        status: 403
    },
    {
        classError: strapiUtils.errors.NotFoundError,
        status: 404
    },
    {
        classError: strapiUtils.errors.PayloadTooLargeError,
        status: 413
    },
    {
        classError: strapiUtils.errors.RateLimitError,
        status: 429
    },
    {
        classError: strapiUtils.errors.NotImplementedError,
        status: 501
    }
];
const formatApplicationError = (error)=>{
    const errorAndStatus = mapErrorsAndStatus.find((pair)=>error instanceof pair.classError);
    const status = errorAndStatus ? errorAndStatus.status : 400;
    return {
        status,
        body: {
            data: null,
            error: {
                status,
                name: error.name,
                message: error.message,
                details: error.details
            }
        }
    };
};
const formatHttpError = (error)=>{
    return {
        status: error.status,
        body: {
            data: null,
            error: {
                status: error.status,
                name: error.name,
                message: error.message,
                details: error.details
            }
        }
    };
};
const formatInternalError = (error)=>{
    if (!(error instanceof Error)) {
        return formatHttpError(createError(500));
    }
    const httpError = createError(error);
    if (httpError.expose) {
        return formatHttpError(httpError);
    }
    return formatHttpError(createError(httpError.status || 500));
};

const addCustomMethods = (app)=>{
    const delegator = delegate(app.context, 'response');
    /* errors */ statuses.codes.filter((code)=>code >= 400 && code < 600).forEach((code)=>{
        const name = statuses(code);
        const camelCasedName = fp.camelCase(name);
        app.response[camelCasedName] = function responseCode(message = name, details = {}) {
            const httpError = createError(code, message, {
                details
            });
            const { status, body } = formatHttpError(httpError);
            this.status = status;
            this.body = body;
        };
        delegator.method(camelCasedName);
    });
    /* send, created, deleted */ app.response.send = function send(data, status = 200) {
        this.status = status;
        this.body = data;
    };
    app.response.created = function created(data) {
        this.status = 201;
        this.body = data;
    };
    app.response.deleted = function deleted(data) {
        if (fp.isNil(data)) {
            this.status = 204;
        } else {
            this.status = 200;
            this.body = data;
        }
    };
    delegator.method('send').method('created').method('deleted');
    return app;
};
const createKoaApp = ({ proxy, keys })=>{
    const app = new Koa({
        proxy
    });
    app.keys = keys;
    addCustomMethods(app);
    return app;
};

const healthCheck = async (ctx)=>{
    ctx.set('strapi', 'You are so French!');
    ctx.status = 204;
};
const createServer = (strapi)=>{
    const app = createKoaApp({
        proxy: strapi.config.get('server.proxy.koa'),
        keys: strapi.config.get('server.app.keys')
    });
    app.use((ctx, next)=>requestCtx.run(ctx, ()=>next()));
    const router = new Router();
    const routeManager = createRouteManager(strapi);
    const httpServer = createHTTPServer(strapi, app);
    const apis = {
        'content-api': createContentAPI$1(strapi),
        admin: createAdminAPI(strapi)
    };
    // init health check
    router.all('/_health', healthCheck);
    const state = {
        mounted: false
    };
    return {
        app,
        router,
        httpServer,
        api (name) {
            return apis[name];
        },
        use (...args) {
            app.use(...args);
            return this;
        },
        routes (routes) {
            if (!Array.isArray(routes) && routes.type) {
                const api = apis[routes.type];
                if (!api) {
                    throw new Error(`API ${routes.type} not found. Possible APIs are ${Object.keys(apis)}`);
                }
                apis[routes.type].routes(routes);
                return this;
            }
            routeManager.addRoutes(routes, router);
            return this;
        },
        mount () {
            state.mounted = true;
            Object.values(apis).forEach((api)=>api.mount(router));
            app.use(router.routes()).use(router.allowedMethods());
            return this;
        },
        initRouting () {
            registerAllRoutes(strapi);
            return this;
        },
        async initMiddlewares () {
            await registerApplicationMiddlewares(strapi);
            return this;
        },
        listRoutes () {
            return [
                ...router.stack
            ];
        },
        listen (...args) {
            if (!state.mounted) {
                this.mount();
            }
            return httpServer.listen(...args);
        },
        async destroy () {
            await httpServer.destroy();
        }
    };
};

const createReloader = (strapi)=>{
    const state = {
        shouldReload: 0,
        isWatching: true
    };
    function reload() {
        if (state.shouldReload > 0) {
            // Reset the reloading state
            state.shouldReload -= 1;
            reload.isReloading = false;
            return;
        }
        if (strapi.config.get('autoReload')) {
            process.send?.('reload');
        }
    }
    Object.defineProperty(reload, 'isWatching', {
        configurable: true,
        enumerable: true,
        set (value) {
            // Special state when the reloader is disabled temporarly (see GraphQL plugin example).
            if (state.isWatching === false && value === true) {
                state.shouldReload += 1;
            }
            state.isWatching = value;
        },
        get () {
            return state.isWatching;
        }
    });
    reload.isReloading = false;
    reload.isWatching = true;
    return reload;
};

const defineProvider = (provider)=>provider;

const LIFECYCLES = [
    'beforeCreate',
    'afterCreate',
    'beforeFindOne',
    'afterFindOne',
    'beforeFindMany',
    'afterFindMany',
    'beforeCount',
    'afterCount',
    'beforeCreateMany',
    'afterCreateMany',
    'beforeUpdate',
    'afterUpdate',
    'beforeUpdateMany',
    'afterUpdateMany',
    'beforeDelete',
    'afterDelete',
    'beforeDeleteMany',
    'afterDeleteMany'
];
/**
 * For enumerations the least common denomiator is GraphQL, where
 * values needs to match the secure name regex:
 * GraphQL Spec https://spec.graphql.org/June2018/#sec-Names
 *
 * Therefore we need to make sure our users only use values, which
 * can be returned by GraphQL, by checking the regressed values
 * agains the GraphQL regex.
 *
 * TODO V5: check if we can avoid this coupling by moving this logic
 * into the GraphQL plugin.
 */ const GRAPHQL_ENUM_REGEX = /^[_A-Za-z][_0-9A-Za-z]*$/;
const lifecyclesShape = _.mapValues(_.keyBy(LIFECYCLES), ()=>strapiUtils.yup.mixed().nullable().isFunction());
const contentTypeSchemaValidator = strapiUtils.yup.object().shape({
    schema: strapiUtils.yup.object().shape({
        info: strapiUtils.yup.object().shape({
            displayName: strapiUtils.yup.string().required(),
            singularName: strapiUtils.yup.string().isKebabCase().required(),
            pluralName: strapiUtils.yup.string().isKebabCase().required()
        }).required(),
        attributes: strapiUtils.yup.object().test({
            name: 'valuesCollide',
            message: 'Some values collide when normalized',
            test (attributes) {
                for (const attrName of Object.keys(attributes)){
                    const attr = attributes[attrName];
                    if (attr.type === 'enumeration') {
                        const regressedValues = attr.enum.map(strapiUtils.strings.toRegressedEnumValue);
                        // should match the GraphQL regex
                        if (!regressedValues.every((value)=>GRAPHQL_ENUM_REGEX.test(value))) {
                            const message = `Invalid enumeration value. Values should have at least one alphabetical character preceding the first occurence of a number. Update your enumeration '${attrName}'.`;
                            return this.createError({
                                message
                            });
                        }
                        // should not contain empty values
                        if (regressedValues.some((value)=>value === '')) {
                            return this.createError({
                                message: `At least one value of the enumeration '${attrName}' appears to be empty. Only alphanumerical characters are taken into account.`
                            });
                        }
                        // should not collide
                        const duplicates = _.uniq(regressedValues.filter((value, index, values)=>values.indexOf(value) !== index));
                        if (duplicates.length) {
                            const message = `Some enumeration values of the field '${attrName}' collide when normalized: ${duplicates.join(', ')}. Please modify your enumeration.`;
                            return this.createError({
                                message
                            });
                        }
                    }
                }
                return true;
            }
        })
    }),
    actions: strapiUtils.yup.object().onlyContainsFunctions(),
    lifecycles: strapiUtils.yup.object().shape(lifecyclesShape).noUnknown()
});
const validateContentTypeDefinition = (data)=>{
    return contentTypeSchemaValidator.validateSync(data, {
        strict: true,
        abortEarly: false
    });
};

const { CREATED_AT_ATTRIBUTE, UPDATED_AT_ATTRIBUTE, PUBLISHED_AT_ATTRIBUTE, CREATED_BY_ATTRIBUTE: CREATED_BY_ATTRIBUTE$1, UPDATED_BY_ATTRIBUTE: UPDATED_BY_ATTRIBUTE$1 } = strapiUtils.contentTypes.constants;
const createContentType = (uid, definition)=>{
    try {
        validateContentTypeDefinition(definition);
    } catch (e) {
        if (e instanceof strapiUtils.yup.ValidationError) {
            throw new Error(`Content Type Definition is invalid for ${uid}'.\n${e.errors}`);
        }
        throw e;
    }
    const { schema, actions, lifecycles } = fp.cloneDeep(definition);
    // general info
    Object.assign(schema, {
        uid,
        modelType: 'contentType',
        kind: schema.kind || 'collectionType',
        __schema__: pickSchema(definition.schema),
        modelName: definition.schema.info.singularName,
        actions,
        lifecycles
    });
    addTimestamps(schema);
    // Published at is added regardless of draft and publish being enabled
    // In case it is not enabled, value will be always published, and it will not contain a draft
    addDraftAndPublish(schema);
    addCreatorFields(schema);
    return schema;
};
const addTimestamps = (schema)=>{
    // attributes
    Object.assign(schema.attributes, {
        [CREATED_AT_ATTRIBUTE]: {
            type: 'datetime'
        },
        // TODO: handle on edit set to new date
        [UPDATED_AT_ATTRIBUTE]: {
            type: 'datetime'
        }
    });
};
const addDraftAndPublish = (schema)=>{
    if (!_.has(schema, 'options.draftAndPublish')) {
        _.set(schema, 'options.draftAndPublish', false); // Disabled by default
    }
    schema.attributes[PUBLISHED_AT_ATTRIBUTE] = {
        type: 'datetime',
        configurable: false,
        writable: true,
        visible: false,
        default () {
            return new Date();
        }
    };
};
const addCreatorFields = (schema)=>{
    const isPrivate = !_.get(schema, 'options.populateCreatorFields', false);
    schema.attributes[CREATED_BY_ATTRIBUTE$1] = {
        type: 'relation',
        relation: 'oneToOne',
        target: 'admin::user',
        configurable: false,
        writable: false,
        visible: false,
        useJoinTable: false,
        private: isPrivate
    };
    schema.attributes[UPDATED_BY_ATTRIBUTE$1] = {
        type: 'relation',
        relation: 'oneToOne',
        target: 'admin::user',
        configurable: false,
        writable: false,
        visible: false,
        useJoinTable: false,
        private: isPrivate
    };
};
const getGlobalId = (schema, prefix)=>{
    const modelName = schema.info.singularName;
    const globalId = prefix ? `${prefix}-${modelName}` : modelName;
    return schema.globalId || _.upperFirst(_.camelCase(globalId));
};
const pickSchema = (model)=>{
    const schema = _.cloneDeep(_.pick(model, [
        'connection',
        'collectionName',
        'info',
        'options',
        'pluginOptions',
        'attributes',
        'kind'
    ]));
    schema.kind = model.kind || 'collectionType';
    return schema;
};

async function loadAdmin(strapi) {
    // strapi.admin = require('@strapi/admin/strapi-server');
    strapi.get('services').add(`admin::`, strapi.admin?.services);
    strapi.get('controllers').add(`admin::`, strapi.admin?.controllers);
    strapi.get('content-types').add(`admin::`, formatContentTypes$1(strapi.admin?.contentTypes ?? {}));
    strapi.get('policies').add(`admin::`, strapi.admin?.policies);
    strapi.get('middlewares').add(`admin::`, strapi.admin?.middlewares);
    const userAdminConfig = strapi.config.get('admin');
    strapi.get('config').set('admin', _.merge(strapi.admin?.config, userAdminConfig));
}
const formatContentTypes$1 = (contentTypes)=>{
    Object.values(contentTypes).forEach((definition)=>{
        const { schema } = definition;
        Object.assign(schema, {
            plugin: 'admin',
            globalId: getGlobalId(schema, 'admin')
        });
    });
    return contentTypes;
};

var admin = defineProvider({
    init (strapi) {
        // eslint-disable-next-line node/no-missing-require
        strapi.add('admin', ()=>require('@strapi/admin/strapi-server'));
    },
    async register (strapi) {
        await loadAdmin(strapi);
        await strapi.get('admin')?.register({
            strapi
        });
    },
    async bootstrap (strapi) {
        await strapi.get('admin')?.bootstrap({
            strapi
        });
    },
    async destroy (strapi) {
        await strapi.get('admin')?.destroy({
            strapi
        });
    }
});

const coreStoreModel = {
    uid: 'strapi::core-store',
    singularName: 'strapi_core_store_settings',
    tableName: 'strapi_core_store_settings',
    attributes: {
        id: {
            type: 'increments'
        },
        key: {
            type: 'string'
        },
        value: {
            type: 'text'
        },
        type: {
            type: 'string'
        },
        environment: {
            type: 'string'
        },
        tag: {
            type: 'string'
        }
    }
};
const createCoreStore = ({ db })=>{
    const mergeParams = (defaultParams, params)=>{
        return {
            ...defaultParams,
            ...params
        };
    };
    const store = function(defaultParams) {
        return {
            get: (params)=>store.get(mergeParams(defaultParams, params)),
            set: (params)=>store.set(mergeParams(defaultParams, params)),
            delete: (params)=>store.delete(mergeParams(defaultParams, params))
        };
    };
    /**
   * Get value from the core store
   */ store.get = async (params)=>{
        const { key, type = 'core', environment, name, tag } = params;
        const prefix = `${type}${name ? `_${name}` : ''}`;
        const where = {
            key: `${prefix}_${key}`,
            environment: environment || null,
            tag: tag || null
        };
        const data = await db.query('strapi::core-store').findOne({
            where
        });
        if (!data) {
            return null;
        }
        if (data.type === 'object' || data.type === 'array' || data.type === 'boolean' || data.type === 'string') {
            try {
                return JSON.parse(data.value);
            } catch (err) {
                return new Date(data.value);
            }
        } else if (data.type === 'number') {
            return Number(data.value);
        } else {
            return null;
        }
    };
    /**
   * Set value in the core store
   * @param {Object} params
   * @returns {*}
   */ store.set = async (params)=>{
        const { key, value, type, environment, name, tag } = params;
        const prefix = `${type}${name ? `_${name}` : ''}`;
        const where = {
            key: `${prefix}_${key}`,
            environment: environment || null,
            tag: tag || null
        };
        const data = await db.query('strapi::core-store').findOne({
            where
        });
        if (data) {
            return db.query('strapi::core-store').update({
                where: {
                    id: data.id
                },
                data: {
                    value: JSON.stringify(value) || fp.toString(value),
                    type: typeof value
                }
            });
        }
        return db.query('strapi::core-store').create({
            data: {
                ...where,
                value: JSON.stringify(value) || fp.toString(value),
                type: typeof value
            }
        });
    };
    /**
   * Deletes a value from the core store
   * @param {Object} params
   * @returns {*}
   */ store.delete = async (params)=>{
        const { key, environment, type, name, tag } = params;
        const prefix = `${type}${name ? `_${name}` : ''}`;
        const where = {
            key: `${prefix}_${key}`,
            environment: environment || null,
            tag: tag || null
        };
        return db.query('strapi::core-store').delete({
            where
        });
    };
    return store;
};

var coreStore = defineProvider({
    init (strapi) {
        strapi.get('models').add(coreStoreModel);
        strapi.add('coreStore', ()=>createCoreStore({
                db: strapi.db
            }));
    }
});

const createCronService = ()=>{
    let jobsSpecs = [];
    let running = false;
    return {
        add (tasks = {}) {
            for (const taskExpression of Object.keys(tasks)){
                const taskValue = tasks[taskExpression];
                let fn;
                let options;
                let taskName;
                if (fp.isFunction(taskValue)) {
                    // don't use task name if key is the rule
                    taskName = null;
                    fn = taskValue.bind(tasks);
                    options = taskExpression;
                } else if (fp.isFunction(taskValue.task)) {
                    // set task name if key is not the rule
                    taskName = taskExpression;
                    fn = taskValue.task.bind(taskValue);
                    options = taskValue.options;
                } else {
                    throw new Error(`Could not schedule a cron job for "${taskExpression}": no function found.`);
                }
                const fnWithStrapi = (...args)=>fn({
                        strapi
                    }, ...args);
                // const job = new Job(null, fnWithStrapi);
                const job = new nodeSchedule.Job(fnWithStrapi);
                jobsSpecs.push({
                    job,
                    options,
                    name: taskName
                });
                if (running) {
                    job.schedule(options);
                }
            }
            return this;
        },
        remove (name) {
            if (!name) throw new Error('You must provide a name to remove a cron job.');
            const matchingJobsSpecs = jobsSpecs.filter(({ name: jobSpecName }, index)=>{
                if (jobSpecName === name) {
                    jobsSpecs.splice(index, 1);
                    return true;
                }
                return false;
            });
            matchingJobsSpecs.forEach(({ job })=>job.cancel());
            return this;
        },
        start () {
            jobsSpecs.forEach(({ job, options })=>job.schedule(options));
            running = true;
            return this;
        },
        stop () {
            jobsSpecs.forEach(({ job })=>job.cancel());
            running = false;
            return this;
        },
        destroy () {
            this.stop();
            jobsSpecs = [];
            return this;
        },
        jobs: jobsSpecs
    };
};

var cron = defineProvider({
    init (strapi) {
        strapi.add('cron', ()=>createCronService());
    },
    async bootstrap (strapi) {
        if (strapi.config.get('server.cron.enabled', true)) {
            const cronTasks = strapi.config.get('server.cron.tasks', {});
            strapi.get('cron').add(cronTasks);
        }
        strapi.get('cron').start();
    },
    async destroy (strapi) {
        strapi.get('cron').destroy();
    }
});

const hasNamespace = (name, namespace)=>{
    if (!namespace) {
        return true;
    }
    if (namespace.endsWith('::')) {
        return name.startsWith(namespace);
    }
    return name.startsWith(`${namespace}.`);
};
const addNamespace = (name, namespace)=>{
    if (namespace.endsWith('::')) {
        return `${namespace}${name}`;
    }
    return `${namespace}.${name}`;
};
const removeNamespace = (name, namespace)=>{
    if (namespace.endsWith('::')) {
        return name.replace(namespace, '');
    }
    return name.replace(`${namespace}.`, '');
};

const validateKeySameToSingularName = (contentTypes)=>{
    for (const ctName of Object.keys(contentTypes)){
        const contentType = contentTypes[ctName];
        if (ctName !== contentType.schema.info.singularName) {
            throw new Error(`The key of the content-type should be the same as its singularName. Found ${ctName} and ${contentType.schema.info.singularName}.`);
        }
    }
};
const contentTypesRegistry = ()=>{
    const contentTypes = {};
    return {
        /**
     * Returns this list of registered contentTypes uids
     */ keys () {
            return Object.keys(contentTypes);
        },
        /**
     * Returns the instance of a contentType. Instantiate the contentType if not already done
     */ get (uid) {
            return contentTypes[uid];
        },
        /**
     * Returns a map with all the contentTypes in a namespace
     */ getAll (namespace) {
            return fp.pickBy((_, uid)=>hasNamespace(uid, namespace))(contentTypes);
        },
        /**
     * Registers a contentType
     */ set (uid, contentType) {
            contentTypes[uid] = contentType;
            return this;
        },
        /**
     * Registers a map of contentTypes for a specific namespace
     */ add (namespace, newContentTypes) {
            validateKeySameToSingularName(newContentTypes);
            for (const rawCtName of Object.keys(newContentTypes)){
                const uid = addNamespace(rawCtName, namespace);
                if (fp.has(uid, contentTypes)) {
                    throw new Error(`Content-type ${uid} has already been registered.`);
                }
                contentTypes[uid] = createContentType(uid, newContentTypes[rawCtName]);
            }
        },
        /**
     * Wraps a contentType to extend it
     */ extend (ctUID, extendFn) {
            const currentContentType = this.get(ctUID);
            if (!currentContentType) {
                throw new Error(`Content-Type ${ctUID} doesn't exist`);
            }
            extendFn(currentContentType);
            return this;
        }
    };
};

const componentsRegistry = ()=>{
    const components = {};
    return {
        /**
     * Returns this list of registered components uids
     */ keys () {
            return Object.keys(components);
        },
        /**
     * Returns the instance of a component. Instantiate the component if not already done
     */ get (uid) {
            return components[uid];
        },
        /**
     * Returns a map with all the components in a namespace
     */ getAll () {
            return components;
        },
        /**
     * Registers a component
     */ set (uid, component) {
            if (fp.has(uid, components)) {
                throw new Error(`Component ${uid} has already been registered.`);
            }
            components[uid] = component;
            return this;
        },
        /**
     * Registers a map of components for a specific namespace
     */ add (newComponents) {
            for (const uid of Object.keys(newComponents)){
                this.set(uid, newComponents[uid]);
            }
        }
    };
};

const servicesRegistry = (strapi)=>{
    const services = {};
    const instantiatedServices = {};
    return {
        /**
     * Returns this list of registered services uids
     */ keys () {
            return Object.keys(services);
        },
        /**
     * Returns the instance of a service. Instantiate the service if not already done
     */ get (uid) {
            if (instantiatedServices[uid]) {
                return instantiatedServices[uid];
            }
            const service = services[uid];
            if (service) {
                instantiatedServices[uid] = typeof service === 'function' ? service({
                    strapi
                }) : service;
                return instantiatedServices[uid];
            }
        },
        /**
     * Returns a map with all the services in a namespace
     */ getAll (namespace) {
            const filteredServices = fp.pickBy((_, uid)=>hasNamespace(uid, namespace))(services);
            // create lazy accessor to avoid instantiating the services;
            const map = {};
            for (const uid of Object.keys(filteredServices)){
                Object.defineProperty(map, uid, {
                    enumerable: true,
                    get: ()=>{
                        return this.get(uid);
                    }
                });
            }
            return map;
        },
        /**
     * Registers a service
     */ set (uid, service) {
            services[uid] = service;
            delete instantiatedServices[uid];
            return this;
        },
        /**
     * Registers a map of services for a specific namespace
     */ add (namespace, newServices) {
            for (const serviceName of Object.keys(newServices)){
                const service = newServices[serviceName];
                const uid = addNamespace(serviceName, namespace);
                if (fp.has(uid, services)) {
                    throw new Error(`Service ${uid} has already been registered.`);
                }
                services[uid] = service;
            }
            return this;
        },
        /**
     * Wraps a service to extend it
     */ extend (uid, extendFn) {
            const currentService = this.get(uid);
            if (!currentService) {
                throw new Error(`Service ${uid} doesn't exist`);
            }
            const newService = extendFn(currentService);
            instantiatedServices[uid] = newService;
            return this;
        }
    };
};

const PLUGIN_PREFIX = 'plugin::';
const API_PREFIX = 'api::';
const parsePolicy = (policy)=>{
    if (typeof policy === 'string') {
        return {
            policyName: policy,
            config: {}
        };
    }
    const { name, config } = policy;
    return {
        policyName: name,
        config
    };
};
const policiesRegistry = ()=>{
    const policies = new Map();
    const find = (name, namespaceInfo)=>{
        const { pluginName, apiName } = namespaceInfo ?? {};
        // try to resolve a full name to avoid extra prefixing
        const policy = policies.get(name);
        if (policy) {
            return policy;
        }
        if (pluginName) {
            return policies.get(`${PLUGIN_PREFIX}${pluginName}.${name}`);
        }
        if (apiName) {
            return policies.get(`${API_PREFIX}${apiName}.${name}`);
        }
    };
    function resolveHandler(policyConfig, namespaceInfo) {
        if (Array.isArray(policyConfig)) {
            return policyConfig.map((config)=>{
                return resolveHandler(config, namespaceInfo);
            });
        }
        const { policyName, config } = parsePolicy(policyConfig);
        const policy = find(policyName, namespaceInfo);
        if (!policy) {
            throw new Error(`Policy ${policyName} not found.`);
        }
        if (typeof policy === 'function') {
            return policy;
        }
        if (policy.validator) {
            policy.validator(config);
        }
        return policy.handler;
    }
    return {
        /**
     * Returns this list of registered policies uids
     */ keys () {
            // Return an array so format stays the same as controllers, services, etc
            return Array.from(policies.keys());
        },
        /**
     * Returns the instance of a policy. Instantiate the policy if not already done
     */ get (name, namespaceInfo) {
            return find(name, namespaceInfo);
        },
        /**
     * Checks if a policy is registered
     */ has (name, namespaceInfo) {
            const res = find(name, namespaceInfo);
            return !!res;
        },
        /**
     * Returns a map with all the policies in a namespace
     */ getAll (namespace) {
            return fp.pickBy((_, uid)=>hasNamespace(uid, namespace))(Object.fromEntries(policies));
        },
        /**
     * Registers a policy
     */ set (uid, policy) {
            policies.set(uid, policy);
            return this;
        },
        /**
     * Registers a map of policies for a specific namespace
     */ add (namespace, newPolicies) {
            for (const policyName of Object.keys(newPolicies)){
                const policy = newPolicies[policyName];
                const uid = addNamespace(policyName, namespace);
                if (fp.has(uid, policies)) {
                    throw new Error(`Policy ${uid} has already been registered.`);
                }
                policies.set(uid, policy);
            }
        },
        /**
     * Resolves a list of policies
     */ resolve (config, namespaceInfo) {
            const { pluginName, apiName } = namespaceInfo ?? {};
            return fp.castArray(config).map((policyConfig)=>{
                return {
                    handler: resolveHandler(policyConfig, {
                        pluginName,
                        apiName
                    }),
                    config: typeof policyConfig === 'object' && policyConfig.config || {}
                };
            });
        }
    };
};

// TODO: move instantiation part here instead of in the server service
const middlewaresRegistry = ()=>{
    const middlewares = {};
    return {
        /**
     * Returns this list of registered middlewares uids
     */ keys () {
            return Object.keys(middlewares);
        },
        /**
     * Returns the instance of a middleware. Instantiate the middleware if not already done
     */ get (uid) {
            return middlewares[uid];
        },
        /**
     * Returns a map with all the middlewares in a namespace
     */ getAll (namespace) {
            return fp.pickBy((_, uid)=>hasNamespace(uid, namespace))(middlewares);
        },
        /**
     * Registers a middleware
     */ set (uid, middleware) {
            middlewares[uid] = middleware;
            return this;
        },
        /**
     * Registers a map of middlewares for a specific namespace
     */ add (namespace, rawMiddlewares = {}) {
            for (const middlewareName of Object.keys(rawMiddlewares)){
                const middleware = rawMiddlewares[middlewareName];
                const uid = addNamespace(middlewareName, namespace);
                if (fp.has(uid, middlewares)) {
                    throw new Error(`Middleware ${uid} has already been registered.`);
                }
                middlewares[uid] = middleware;
            }
        },
        /**
     * Wraps a middleware to extend it
     */ extend (uid, extendFn) {
            const currentMiddleware = this.get(uid);
            if (!currentMiddleware) {
                throw new Error(`Middleware ${uid} doesn't exist`);
            }
            const newMiddleware = extendFn(currentMiddleware);
            middlewares[uid] = newMiddleware;
            return this;
        }
    };
};

const hooksRegistry = ()=>{
    const hooks = {};
    return {
        /**
     * Returns this list of registered hooks uids
     */ keys () {
            return Object.keys(hooks);
        },
        /**
     * Returns the instance of a hook.
     */ get (uid) {
            return hooks[uid];
        },
        /**
     * Returns a map with all the hooks in a namespace
     */ getAll (namespace) {
            return fp.pickBy((_, uid)=>hasNamespace(uid, namespace))(hooks);
        },
        /**
     * Registers a hook
     */ set (uid, hook) {
            hooks[uid] = hook;
            return this;
        },
        /**
     * Registers a map of hooks for a specific namespace
     */ add (namespace, hooks) {
            for (const hookName of Object.keys(hooks)){
                const hook = hooks[hookName];
                const uid = addNamespace(hookName, namespace);
                this.set(uid, hook);
            }
            return this;
        },
        /**
     * Wraps a hook to extend it
     */ extend (uid, extendFn) {
            const currentHook = this.get(uid);
            if (!currentHook) {
                throw new Error(`Hook ${uid} doesn't exist`);
            }
            const newHook = extendFn(currentHook);
            hooks[uid] = newHook;
            return this;
        }
    };
};

const controllersRegistry = (strapi)=>{
    const controllers = {};
    const instances = {};
    return {
        /**
     * Returns this list of registered controllers uids
     */ keys () {
            return Object.keys(controllers);
        },
        /**
     * Returns the instance of a controller. Instantiate the controller if not already done
     */ get (uid) {
            if (instances[uid]) {
                return instances[uid];
            }
            const controller = controllers[uid];
            if (controller) {
                instances[uid] = typeof controller === 'function' ? controller({
                    strapi
                }) : controller;
                return instances[uid];
            }
        },
        /**
     * Returns a map with all the controller in a namespace
     */ getAll (namespace) {
            const filteredControllers = fp.pickBy((_, uid)=>hasNamespace(uid, namespace))(controllers);
            const map = {};
            for (const uid of Object.keys(filteredControllers)){
                Object.defineProperty(map, uid, {
                    enumerable: true,
                    get: ()=>{
                        return this.get(uid);
                    }
                });
            }
            return map;
        },
        /**
     * Registers a controller
     */ set (uid, value) {
            controllers[uid] = value;
            delete instances[uid];
            return this;
        },
        /**
     * Registers a map of controllers for a specific namespace
     */ add (namespace, newControllers) {
            for (const controllerName of Object.keys(newControllers)){
                const controller = newControllers[controllerName];
                const uid = addNamespace(controllerName, namespace);
                if (fp.has(uid, controllers)) {
                    throw new Error(`Controller ${uid} has already been registered.`);
                }
                controllers[uid] = controller;
            }
            return this;
        },
        /**
     * Wraps a controller to extend it
     */ extend (controllerUID, extendFn) {
            const currentController = this.get(controllerUID);
            if (!currentController) {
                throw new Error(`Controller ${controllerUID} doesn't exist`);
            }
            const newController = extendFn(currentController);
            instances[controllerUID] = newController;
            return this;
        }
    };
};

const strapiServerSchema = strapiUtils.yup.object().shape({
    bootstrap: strapiUtils.yup.mixed().isFunction(),
    destroy: strapiUtils.yup.mixed().isFunction(),
    register: strapiUtils.yup.mixed().isFunction(),
    config: strapiUtils.yup.object(),
    routes: strapiUtils.yup.lazy((value)=>{
        if (Array.isArray(value)) {
            return strapiUtils.yup.array();
        }
        return strapiUtils.yup.object();
    }),
    controllers: strapiUtils.yup.object(),
    services: strapiUtils.yup.object(),
    policies: strapiUtils.yup.object(),
    middlewares: strapiUtils.yup.object(),
    contentTypes: strapiUtils.yup.object()
}).noUnknown();
const validateModule = (data)=>{
    return strapiServerSchema.validateSync(data, {
        strict: true,
        abortEarly: false
    });
};

// Removes the namespace from a map with keys prefixed with a namespace
const removeNamespacedKeys = (map, namespace)=>{
    return _.mapKeys(map, (value, key)=>removeNamespace(key, namespace));
};
const defaultModule = {
    config: {},
    routes: [],
    controllers: {},
    services: {},
    contentTypes: {},
    policies: {},
    middlewares: {}
};
const createModule = (namespace, rawModule, strapi)=>{
    _.defaults(rawModule, defaultModule);
    try {
        validateModule(rawModule);
    } catch (e) {
        if (e instanceof strapiUtils.yup.ValidationError) {
            throw new Error(`strapi-server.js is invalid for '${namespace}'.\n${e.errors.join('\n')}`);
        }
    }
    const called = {};
    return {
        async bootstrap () {
            if (called.bootstrap) {
                throw new Error(`Bootstrap for ${namespace} has already been called`);
            }
            called.bootstrap = true;
            await (rawModule.bootstrap && rawModule.bootstrap({
                strapi
            }));
        },
        async register () {
            if (called.register) {
                throw new Error(`Register for ${namespace} has already been called`);
            }
            called.register = true;
            await (rawModule.register && rawModule.register({
                strapi
            }));
        },
        async destroy () {
            if (called.destroy) {
                throw new Error(`Destroy for ${namespace} has already been called`);
            }
            called.destroy = true;
            await (rawModule.destroy && rawModule.destroy({
                strapi
            }));
        },
        load () {
            strapi.get('content-types').add(namespace, rawModule.contentTypes);
            strapi.get('services').add(namespace, rawModule.services);
            strapi.get('policies').add(namespace, rawModule.policies);
            strapi.get('middlewares').add(namespace, rawModule.middlewares);
            strapi.get('controllers').add(namespace, rawModule.controllers);
            strapi.get('config').set(namespace, rawModule.config);
        },
        get routes () {
            return rawModule.routes ?? {};
        },
        config (path, defaultValue) {
            const pathArray = _.flatten([
                namespace,
                path
            ]);
            return strapi.get('config').get(pathArray, defaultValue);
        },
        contentType (ctName) {
            return strapi.get('content-types').get(`${namespace}.${ctName}`);
        },
        get contentTypes () {
            const contentTypes = strapi.get('content-types').getAll(namespace);
            return removeNamespacedKeys(contentTypes, namespace);
        },
        service (serviceName) {
            return strapi.get('services').get(`${namespace}.${serviceName}`);
        },
        get services () {
            const services = strapi.get('services').getAll(namespace);
            return removeNamespacedKeys(services, namespace);
        },
        policy (policyName) {
            return strapi.get('policies').get(`${namespace}.${policyName}`);
        },
        get policies () {
            const policies = strapi.get('policies').getAll(namespace);
            return removeNamespacedKeys(policies, namespace);
        },
        middleware (middlewareName) {
            return strapi.get('middlewares').get(`${namespace}.${middlewareName}`);
        },
        get middlewares () {
            const middlewares = strapi.get('middlewares').getAll(namespace);
            return removeNamespacedKeys(middlewares, namespace);
        },
        controller (controllerName) {
            return strapi.get('controllers').get(`${namespace}.${controllerName}`);
        },
        get controllers () {
            const controllers = strapi.get('controllers').getAll(namespace);
            return removeNamespacedKeys(controllers, namespace);
        }
    };
};

const modulesRegistry = (strapi)=>{
    const modules = {};
    return {
        get (namespace) {
            return modules[namespace];
        },
        getAll (prefix = '') {
            return fp.pickBy((mod, namespace)=>namespace.startsWith(prefix))(modules);
        },
        add (namespace, rawModule) {
            if (fp.has(namespace, modules)) {
                throw new Error(`Module ${namespace} has already been registered.`);
            }
            modules[namespace] = createModule(namespace, rawModule, strapi);
            modules[namespace].load();
            return modules[namespace];
        },
        async bootstrap () {
            for (const mod of Object.values(modules)){
                await mod.bootstrap();
            }
        },
        async register () {
            for (const mod of Object.values(modules)){
                await mod.register();
            }
        },
        async destroy () {
            for (const mod of Object.values(modules)){
                await mod.destroy();
            }
        }
    };
};

const pluginsRegistry = (strapi)=>{
    const plugins = {};
    return {
        get (name) {
            return plugins[name];
        },
        getAll () {
            return plugins;
        },
        add (name, pluginConfig) {
            if (fp.has(name, plugins)) {
                throw new Error(`Plugin ${name} has already been registered.`);
            }
            const pluginModule = strapi.get('modules').add(`plugin::${name}`, pluginConfig);
            plugins[name] = pluginModule;
            return plugins[name];
        }
    };
};

const ALLOWED_TYPES = [
    'biginteger',
    'boolean',
    'date',
    'datetime',
    'decimal',
    'email',
    'enumeration',
    'float',
    'integer',
    'json',
    'password',
    'richtext',
    'string',
    'text',
    'time',
    'uid'
];
const customFieldsRegistry = (strapi)=>{
    const customFields = {};
    return {
        getAll () {
            return customFields;
        },
        get (customField) {
            const registeredCustomField = customFields[customField];
            if (!registeredCustomField) {
                throw new Error(`Could not find Custom Field: ${customField}`);
            }
            return registeredCustomField;
        },
        add (customField) {
            const customFieldList = Array.isArray(customField) ? customField : [
                customField
            ];
            for (const cf of customFieldList){
                if (!fp.has('name', cf) || !fp.has('type', cf)) {
                    throw new Error(`Custom fields require a 'name' and 'type' key`);
                }
                const { name, plugin, type, inputSize } = cf;
                if (!ALLOWED_TYPES.includes(type)) {
                    throw new Error(`Custom field type: '${type}' is not a valid Strapi type or it can't be used with a Custom Field`);
                }
                const isValidObjectKey = /^(?![0-9])[a-zA-Z0-9$_-]+$/g;
                if (!isValidObjectKey.test(name)) {
                    throw new Error(`Custom field name: '${name}' is not a valid object key`);
                }
                // Validate inputSize when provided
                if (inputSize) {
                    if (!fp.isPlainObject(inputSize) || !fp.has('default', inputSize) || !fp.has('isResizable', inputSize)) {
                        throw new Error(`inputSize should be an object with 'default' and 'isResizable' keys`);
                    }
                    if (![
                        4,
                        6,
                        8,
                        12
                    ].includes(inputSize.default)) {
                        throw new Error('Custom fields require a valid default input size');
                    }
                    if (typeof inputSize.isResizable !== 'boolean') {
                        throw new Error('Custom fields should specify if their input is resizable');
                    }
                }
                // When no plugin is specified, or it isn't found in Strapi, default to global
                const uid = plugin && strapi.plugin(plugin) ? `plugin::${plugin}.${name}` : `global::${name}`;
                if (fp.has(uid, customFields)) {
                    throw new Error(`Custom field: '${uid}' has already been registered`);
                }
                customFields[uid] = cf;
            }
        }
    };
};

const apisRegistry = (strapi)=>{
    const apis = {};
    return {
        get (name) {
            return apis[name];
        },
        getAll () {
            return apis;
        },
        add (apiName, apiConfig) {
            if (fp.has(apiName, apis)) {
                throw new Error(`API ${apiName} has already been registered.`);
            }
            const api = strapi.get('modules').add(`api::${apiName}`, apiConfig);
            apis[apiName] = api;
            return apis[apiName];
        }
    };
};

const sanitizersRegistry = ()=>{
    const sanitizers = {};
    return {
        get (path) {
            return _.get(sanitizers, path, []);
        },
        add (path, sanitizer) {
            this.get(path).push(sanitizer);
            return this;
        },
        set (path, value = []) {
            _.set(sanitizers, path, value);
            return this;
        },
        has (path) {
            return _.has(sanitizers, path);
        }
    };
};

const validatorsRegistry = ()=>{
    const validators = {};
    return {
        get (path) {
            return _.get(validators, path, []);
        },
        add (path, validator) {
            this.get(path).push(validator);
            return this;
        },
        set (path, value = []) {
            _.set(validators, path, value);
            return this;
        },
        has (path) {
            return _.has(validators, path);
        }
    };
};

const registry = ()=>{
    const models = [];
    return {
        add (model) {
            models.push(model);
            return this;
        },
        get () {
            return models;
        }
    };
};

const srcSchema = strapiUtils.yup.object().shape({
    bootstrap: strapiUtils.yup.mixed().isFunction(),
    register: strapiUtils.yup.mixed().isFunction(),
    destroy: strapiUtils.yup.mixed().isFunction()
}).noUnknown();
const validateSrcIndex = (srcIndex)=>{
    return srcSchema.validateSync(srcIndex, {
        strict: true,
        abortEarly: false
    });
};
var loadSrcIndex = ((strapi)=>{
    if (!fs.existsSync(strapi.dirs.dist.src)) {
        return;
    }
    const pathToSrcIndex = path.resolve(strapi.dirs.dist.src, 'index.js');
    if (!fs.existsSync(pathToSrcIndex) || fs.statSync(pathToSrcIndex).isDirectory()) {
        return {};
    }
    const srcIndex = strapiUtils.importDefault(pathToSrcIndex);
    try {
        validateSrcIndex(srcIndex);
    } catch (e) {
        if (e instanceof strapiUtils.yup.ValidationError) {
            strapi.stopWithError({
                message: `Invalid file \`./src/index.js\`: ${e.message}`
            });
        }
        throw e;
    }
    strapi.app = srcIndex;
});

const DEFAULT_CONTENT_TYPE = {
    schema: {},
    actions: {},
    lifecycles: {}
};
// to handle names with numbers in it we first check if it is already in kebabCase
const normalizeName = (name)=>strapiUtils.strings.isKebabCase(name) ? name : _.kebabCase(name);
const isDirectory = (fd)=>fd.isDirectory();
const isDotFile = (fd)=>fd.name.startsWith('.');
async function loadAPIs(strapi) {
    if (!fse.existsSync(strapi.dirs.dist.api)) {
        return;
    }
    const apisFDs = await (await fse.readdir(strapi.dirs.dist.api, {
        withFileTypes: true
    })).filter(isDirectory).filter(_.negate(isDotFile));
    const apis = {};
    // only load folders
    for (const apiFD of apisFDs){
        const apiName = normalizeName(apiFD.name);
        const api = await loadAPI(apiName, path.join(strapi.dirs.dist.api, apiFD.name));
        // @ts-expect-error TODO verify that it's a valid api, not missing bootstrap, register, and destroy
        apis[apiName] = api;
    }
    validateContentTypesUnicity(apis);
    for (const apiName of Object.keys(apis)){
        strapi.get('apis').add(apiName, apis[apiName]);
    }
}
const validateContentTypesUnicity = (apis)=>{
    const allApisSchemas = Object.values(apis).flatMap((api)=>Object.values(api.contentTypes));
    const names = [];
    allApisSchemas.forEach(({ schema })=>{
        if (schema.info.singularName) {
            const singularName = _.kebabCase(schema.info.singularName);
            if (names.includes(singularName)) {
                throw new Error(`The singular name "${schema.info.singularName}" should be unique`);
            }
            names.push(singularName);
        }
        if (schema.info.pluralName) {
            const pluralName = _.kebabCase(schema.info.pluralName);
            if (names.includes(pluralName)) {
                throw new Error(`The plural name "${schema.info.pluralName}" should be unique`);
            }
            names.push(pluralName);
        }
    });
};
const loadAPI = async (apiName, dir)=>{
    const [index, config, routes, controllers, services, policies, middlewares, contentTypes] = (await Promise.all([
        loadIndex(dir),
        loadDir(path.join(dir, 'config')),
        loadDir(path.join(dir, 'routes')),
        loadDir(path.join(dir, 'controllers')),
        loadDir(path.join(dir, 'services')),
        loadDir(path.join(dir, 'policies')),
        loadDir(path.join(dir, 'middlewares')),
        loadContentTypes(apiName, path.join(dir, 'content-types'))
    ])).map((result)=>result?.result);
    return {
        ...index || {},
        config: config || {},
        routes: routes || [],
        controllers: controllers || {},
        services: services || {},
        policies: policies || {},
        middlewares: middlewares || {},
        contentTypes: contentTypes || {}
    };
};
const loadIndex = async (dir)=>{
    if (await fse.pathExists(path.join(dir, 'index.js'))) {
        return loadFile(path.join(dir, 'index.js'));
    }
};
// because this is async and its contents are dynamic, we must return it within an object to avoid a property called `then` being interpreted as a Promise
const loadContentTypes = async (apiName, dir)=>{
    if (!await fse.pathExists(dir)) {
        return;
    }
    const fds = await fse.readdir(dir, {
        withFileTypes: true
    });
    const contentTypes = {};
    // only load folders
    for (const fd of fds){
        if (fd.isFile()) {
            continue;
        }
        const contentTypeName = normalizeName(fd.name);
        const loadedContentType = (await loadDir(path.join(dir, fd.name)))?.result;
        if (fp.isEmpty(loadedContentType) || fp.isEmpty(loadedContentType.schema)) {
            throw new Error(`Could not load content type found at ${dir}`);
        }
        const contentType = {
            ...DEFAULT_CONTENT_TYPE,
            ...loadedContentType
        };
        Object.assign(contentType.schema, {
            apiName,
            collectionName: contentType.schema.collectionName || contentType.schema.info.singularName,
            globalId: getGlobalId(contentType.schema)
        });
        contentTypes[normalizeName(contentTypeName)] = contentType;
    }
    return {
        result: contentTypes
    };
};
// because this is async and its contents are dynamic, we must return it within an object to avoid a property called `then` being interpreted as a Promise
const loadDir = async (dir)=>{
    if (!await fse.pathExists(dir)) {
        return;
    }
    const fds = await fse.readdir(dir, {
        withFileTypes: true
    });
    const root = {};
    for (const fd of fds){
        if (!fd.isFile() || path.extname(fd.name) === '.map') {
            continue;
        }
        const key = path.basename(fd.name, path.extname(fd.name));
        root[normalizeName(key)] = (await loadFile(path.join(dir, fd.name))).result;
    }
    return {
        result: root
    };
};
// because this is async and its contents are dynamic, we must return it as an array to avoid a property called `then` being interpreted as a Promise
const loadFile = async (file)=>{
    const ext = path.extname(file);
    switch(ext){
        case '.js':
            return {
                result: strapiUtils.importDefault(file)
            };
        case '.json':
            return {
                result: await fse.readJSON(file)
            };
        default:
            return {
                result: {}
            };
    }
};

const compression = (config)=>compress(config);

const defaults$6 = {
    origin: '*',
    maxAge: 31536000,
    credentials: true,
    methods: [
        'GET',
        'POST',
        'PUT',
        'PATCH',
        'DELETE',
        'HEAD',
        'OPTIONS'
    ],
    headers: [
        'Content-Type',
        'Authorization',
        'Origin',
        'Accept'
    ],
    keepHeadersOnError: false
};
const cors = (config)=>{
    const { origin, expose, maxAge, credentials, methods, headers, keepHeadersOnError } = {
        ...defaults$6,
        ...config
    };
    if (config.enabled !== undefined) {
        strapi.log.warn('The strapi::cors middleware no longer supports the `enabled` option. Using it' + ' to conditionally enable CORS might cause an insecure default. To disable strapi::cors, remove it from' + ' the exported array in config/middleware.js');
    }
    return koaCors({
        async origin (ctx) {
            if (!ctx.get('Origin')) {
                return '*';
            }
            let originList;
            if (typeof origin === 'function') {
                originList = await origin(ctx);
            } else {
                originList = origin;
            }
            if (Array.isArray(originList)) {
                return originList.includes(ctx.get('Origin')) ? ctx.get('Origin') : '';
            }
            const parsedOrigin = originList.split(',').map((origin)=>origin.trim());
            if (parsedOrigin.length > 1) {
                return parsedOrigin.includes(ctx.get('Origin')) ? ctx.get('Origin') : '';
            }
            return originList;
        },
        exposeHeaders: expose,
        maxAge,
        credentials,
        allowMethods: methods,
        allowHeaders: headers,
        keepHeadersOnError
    });
};

const errorMiddleware = ()=>{
    return async (ctx, next)=>{
        try {
            await next();
            if (!ctx.response._explicitStatus) {
                return ctx.notFound();
            }
        } catch (error) {
            if (error instanceof strapiUtils.errors.ApplicationError) {
                const { status, body } = formatApplicationError(error);
                ctx.status = status;
                ctx.body = body;
                return;
            }
            if (error instanceof strapiUtils.errors.HttpError) {
                const { status, body } = formatHttpError(error);
                ctx.status = status;
                ctx.body = body;
                return;
            }
            strapi.log.error(error);
            const { status, body } = formatInternalError(error);
            ctx.status = status;
            ctx.body = body;
        }
    };
};

const defaults$5 = {
    path: 'favicon.png',
    maxAge: 86400000
};
const favicon = (config, { strapi })=>{
    const { maxAge, path: faviconDefaultPath } = {
        ...defaults$5,
        ...config
    };
    const { root: appRoot } = strapi.dirs.app;
    let faviconPath = faviconDefaultPath;
    /** TODO (v5): Updating the favicon to use a png caused
   *  https://github.com/strapi/strapi/issues/14693
   *
   *  This check ensures backwards compatibility until
   *  the next major version
   */ if (!fs.existsSync(path.resolve(appRoot, faviconPath))) {
        faviconPath = 'favicon.ico';
    }
    return koaFavicon(path.resolve(appRoot, faviconPath), {
        maxAge
    });
};

const ip = (config)=>koaIp(config);

const logger = (_, { strapi })=>{
    return async (ctx, next)=>{
        const start = Date.now();
        await next();
        const delta = Math.ceil(Date.now() - start);
        strapi.log.http(`${ctx.method} ${ctx.url} (${delta} ms) ${ctx.status}`);
    };
};

const defaults$4 = {
    poweredBy: 'Strapi <strapi.io>'
};
const poweredBy = (config)=>{
    const { poweredBy } = {
        ...defaults$4,
        ...config
    };
    return async (ctx, next)=>{
        await next();
        ctx.set('X-Powered-By', poweredBy);
    };
};

const defaults$3 = {
    multipart: true,
    patchKoa: true
};
function ensureFileMimeType(file) {
    if (!file.type) {
        file.type = mime.lookup(file.name) || 'application/octet-stream';
    }
}
function getFiles(ctx) {
    return ctx?.request?.files?.files;
}
const bodyMiddleware = (config, { strapi })=>{
    const bodyConfig = fp.defaultsDeep(defaults$3, config);
    let gqlEndpoint;
    if (strapi.plugin('graphql')) {
        const { config: gqlConfig } = strapi.plugin('graphql');
        gqlEndpoint = gqlConfig('endpoint');
    }
    return async (ctx, next)=>{
        // TODO: find a better way later
        if (gqlEndpoint && ctx.url === gqlEndpoint) {
            await next();
        } else {
            try {
                await koaBody.koaBody(bodyConfig)(ctx, async ()=>{});
                const files = getFiles(ctx);
                /**
         * in case the mime-type wasn't sent, Strapi tries to guess it
         * from the file extension, to avoid a corrupt database state
         */ if (files) {
                    if (Array.isArray(files)) {
                        files.forEach(ensureFileMimeType);
                    } else {
                        ensureFileMimeType(files);
                    }
                }
                await next();
            } catch (error) {
                if (error instanceof Error && error.message && error.message.includes('maxFileSize exceeded')) {
                    return ctx.payloadTooLarge('FileTooBig');
                }
                throw error;
            }
        }
        const files = getFiles(ctx);
        // clean any file that was uploaded
        if (files) {
            if (Array.isArray(files)) {
                // not awaiting to not slow the request
                Promise.all(files.map((file)=>fse.remove(file.filepath)));
            } else if (files && files.filepath) {
                // not awaiting to not slow the request
                fse.remove(files.filepath);
            }
            delete ctx.request.files;
        }
    };
};

const defaults$2 = {
    strictNullHandling: true,
    arrayLimit: 100,
    depth: 20
};
/**
 * Body parser hook
 */ const addQsParser = (app, settings)=>{
    Object.defineProperty(app.request, 'query', {
        configurable: false,
        enumerable: true,
        /*
     * Get parsed query-string.
     */ get () {
            const qstr = this.querystring;
            this._querycache = this._querycache || {};
            const cache = this._querycache;
            if (!cache[qstr]) {
                cache[qstr] = qs.parse(qstr, settings);
            }
            return cache[qstr];
        },
        /*
     * Set query-string as an object.
     */ set (obj) {
            this.querystring = qs.stringify(obj);
        }
    });
    return app;
};
const query = (config, { strapi })=>{
    addQsParser(strapi.server.app, {
        ...defaults$2,
        ...config
    });
};

const responseTime = ()=>{
    return async (ctx, next)=>{
        const start = Date.now();
        await next();
        const delta = Math.ceil(Date.now() - start);
        ctx.set('X-Response-Time', `${delta}ms`);
    };
};

const responses = (config = {})=>{
    return async (ctx, next)=>{
        await next();
        const { status } = ctx;
        const handler = config?.handlers?.[status];
        if (fp.isFunction(handler)) {
            await handler(ctx, next);
        }
    };
};

const defaults$1 = {
    crossOriginEmbedderPolicy: false,
    crossOriginOpenerPolicy: false,
    crossOriginResourcePolicy: false,
    originAgentCluster: false,
    contentSecurityPolicy: {
        useDefaults: true,
        directives: {
            'connect-src': [
                "'self'",
                'https:'
            ],
            'img-src': [
                "'self'",
                'data:',
                'blob:',
                'https://market-assets.strapi.io'
            ],
            'media-src': [
                "'self'",
                'data:',
                'blob:'
            ],
            upgradeInsecureRequests: null
        }
    },
    xssFilter: false,
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true
    },
    frameguard: {
        action: 'sameorigin'
    }
};
const mergeConfig = (existingConfig, newConfig)=>{
    return fp.mergeWith((obj, src)=>Array.isArray(obj) && Array.isArray(src) ? obj.concat(src) : undefined, existingConfig, newConfig);
};
const security = (config, { strapi })=>(ctx, next)=>{
        let helmetConfig = fp.defaultsDeep(defaults$1, config);
        const specialPaths = [
            '/documentation'
        ];
        const directives = {
            'script-src': [
                "'self'",
                "'unsafe-inline'",
                'cdn.jsdelivr.net'
            ],
            'img-src': [
                "'self'",
                'data:',
                'cdn.jsdelivr.net',
                'strapi.io'
            ],
            'manifest-src': [],
            'frame-src': []
        };
        // if apollo graphql playground is enabled, add exceptions for it
        if (strapi.plugin('graphql')?.service('utils').playground.isEnabled()) {
            const { config: gqlConfig } = strapi.plugin('graphql');
            specialPaths.push(gqlConfig('endpoint'));
            directives['script-src'].push(`https: 'unsafe-inline'`);
            directives['img-src'].push(`'apollo-server-landing-page.cdn.apollographql.com'`);
            directives['manifest-src'].push(`'self'`);
            directives['manifest-src'].push('apollo-server-landing-page.cdn.apollographql.com');
            directives['frame-src'].push(`'self'`);
            directives['frame-src'].push('sandbox.embed.apollographql.com');
        }
        // TODO: we shouldn't combine playground exceptions with documentation for all routes, we should first check the path and then return exceptions specific to that
        if (ctx.method === 'GET' && specialPaths.some((str)=>ctx.path.startsWith(str))) {
            helmetConfig = mergeConfig(helmetConfig, {
                crossOriginEmbedderPolicy: false,
                contentSecurityPolicy: {
                    directives
                }
            });
        }
        /**
     * These are for vite's watch mode so it can accurately
     * connect to the HMR websocket & reconnect on failure
     * or when the server restarts.
     *
     * It only applies in development, and only on GET requests
     * that are part of the admin route.
     */ if ([
            'development',
            'test'
        ].includes(process.env.NODE_ENV ?? '') && ctx.method === 'GET' && ctx.path.startsWith(strapi.config.get('admin.path'))) {
            helmetConfig = mergeConfig(helmetConfig, {
                contentSecurityPolicy: {
                    directives: {
                        'script-src': [
                            "'self'",
                            "'unsafe-inline'"
                        ],
                        'connect-src': [
                            "'self'",
                            'http:',
                            'https:',
                            'ws:'
                        ]
                    }
                }
            });
        }
        return helmet(helmetConfig)(ctx, next);
    };

const defaultConfig = {
    key: 'koa.sess',
    maxAge: 86400000,
    autoCommit: true,
    overwrite: true,
    httpOnly: true,
    signed: true,
    rolling: false,
    renew: false,
    secure: process.env.NODE_ENV === 'production',
    sameSite: undefined
};
const session = (userConfig, { strapi })=>{
    const { keys } = strapi.server.app;
    if (!fp.isArray(keys) || fp.isEmpty(keys) || keys.some(fp.isEmpty)) {
        throw new Error(`App keys are required. Please set app.keys in config/server.js (ex: keys: ['myKeyA', 'myKeyB'])`);
    }
    const config = {
        ...defaultConfig,
        ...userConfig
    };
    strapi.server.use(koaSession(config, strapi.server.app));
};

const defaults = {
    maxAge: 60000
};
const publicStatic = (config, { strapi })=>{
    const { maxAge } = fp.defaultsDeep(defaults, config);
    strapi.server.routes([
        {
            method: 'GET',
            path: '/',
            handler (ctx) {
                ctx.redirect(strapi.config.get('admin.url', '/admin'));
            },
            config: {
                auth: false
            }
        },
        // All other public GET-routes except /uploads/(.*) which is handled in upload middleware
        {
            method: 'GET',
            path: '/((?!uploads/).+)',
            handler: koaStatic(strapi.dirs.static.public, {
                maxage: maxAge,
                defer: true
            }),
            config: {
                auth: false
            }
        }
    ]);
};

const middlewares = {
    compression,
    cors,
    errors: errorMiddleware,
    favicon,
    ip,
    logger,
    poweredBy,
    body: bodyMiddleware,
    query,
    responseTime,
    responses,
    security,
    session,
    public: publicStatic
};

// TODO:: allow folders with index.js inside for bigger policies
async function loadMiddlewares(strapi) {
    const localMiddlewares = await loadLocalMiddlewares(strapi);
    strapi.get('middlewares').add(`global::`, localMiddlewares);
    strapi.get('middlewares').add(`strapi::`, middlewares);
}
const loadLocalMiddlewares = async (strapi)=>{
    const dir = strapi.dirs.dist.middlewares;
    if (!await fse.pathExists(dir)) {
        return {};
    }
    const middlewares = {};
    const paths = await fse.readdir(dir, {
        withFileTypes: true
    });
    for (const fd of paths){
        const { name } = fd;
        const fullPath = path.join(dir, name);
        if (fd.isFile() && path.extname(name) === '.js') {
            const key = path.basename(name, '.js');
            middlewares[key] = strapiUtils.importDefault(fullPath);
        }
    }
    return middlewares;
};

/**
 * Returns a path (as an array) from a file path
 */ const filePathToPropPath = (entryPath, useFileNameAsKey = true)=>{
    const transform = fp.pipe(// Remove the relative path prefixes: './' for posix (and some win32) and ".\" for win32
    removeRelativePrefix, // Remove the path metadata and extensions
    fp.replace(/(\.settings|\.json|\.js)/g, ''), // Transform to lowercase
    // Note: We're using fp.toLower instead of fp.lowercase as the latest removes special characters such as "/"
    fp.toLower, // Split the cleaned path by matching every possible separator (either "/" or "\" depending on the OS)
    fp.split(new RegExp(`[\\${path$1.win32.sep}|${path$1.posix.sep}]`, 'g')), // Make sure to remove leading '.' from the different path parts
    fp.map(fp.trimCharsStart('.')), // join + split in case some '.' characters are still present in different parts of the path
    fp.join('.'), fp.split('.'), // Remove the last portion of the path array if the file name shouldn't be used as a key
    useFileNameAsKey ? fp.identity : fp.slice(0, -1));
    return transform(entryPath);
};
const removeRelativePrefix = (filePath)=>{
    return filePath.startsWith(`.${path$1.win32.sep}`) || filePath.startsWith(`.${path$1.posix.sep}`) ? filePath.slice(2) : filePath;
};

/**
 * Returns an Object build from a list of files matching a glob pattern in a directory
 * It builds a tree structure resembling the folder structure in dir
 */ const loadFiles = async (dir, pattern, // eslint-disable-next-line @typescript-eslint/no-unused-vars
{ requireFn = strapiUtils.importDefault, shouldUseFileNameAsKey = (_)=>true, globArgs = {} } = {})=>{
    const root = {};
    const files = await glob.glob(pattern, {
        cwd: dir,
        ...globArgs
    });
    for (const file of files){
        const absolutePath = path.resolve(dir, file);
        // load module
        delete require.cache[absolutePath];
        let mod;
        if (path.extname(absolutePath) === '.json') {
            mod = await fse.readJson(absolutePath);
        } else {
            mod = requireFn(absolutePath);
        }
        Object.defineProperty(mod, '__filename__', {
            enumerable: true,
            configurable: false,
            writable: false,
            value: path.basename(file)
        });
        const propPath = filePathToPropPath(file, shouldUseFileNameAsKey(file));
        if (propPath.length === 0) _.merge(root, mod);
        _.merge(root, _.setWith({}, propPath, mod, Object));
    }
    return root;
};

async function loadComponents(strapi) {
    if (!await fse.pathExists(strapi.dirs.dist.components)) {
        return {};
    }
    const map = await loadFiles(strapi.dirs.dist.components, '*/*.*(js|json)');
    const components = Object.keys(map).reduce((acc, category)=>{
        Object.keys(map[category]).forEach((key)=>{
            const schema = map[category][key];
            if (!schema.collectionName) {
                // NOTE: We're using the filepath from the app directory instead of the dist for information purpose
                const filePath = path.join(strapi.dirs.app.components, category, schema.__filename__);
                return strapi.stopWithError(`Component ${key} is missing a "collectionName" property.\nVerify file ${filePath}.`);
            }
            const uid = `${category}.${key}`;
            acc[uid] = Object.assign(schema, {
                __schema__: _.cloneDeep(schema),
                uid,
                category,
                modelType: 'component',
                modelName: key,
                globalId: schema.globalId || _.upperFirst(_.camelCase(`component_${uid}`))
            });
        });
        return acc;
    }, {});
    strapi.get('components').add(components);
}

// TODO:: allow folders with index.js inside for bigger policies
async function loadPolicies(strapi) {
    const dir = strapi.dirs.dist.policies;
    if (!await fse.pathExists(dir)) {
        return;
    }
    const policies = {};
    const paths = await fse.readdir(dir, {
        withFileTypes: true
    });
    for (const fd of paths){
        const { name } = fd;
        const fullPath = path.join(dir, name);
        if (fd.isFile() && path.extname(name) === '.js') {
            const key = path.basename(name, '.js');
            policies[key] = strapiUtils.importDefault(fullPath);
        }
    }
    strapi.get('policies').add(`global::`, policies);
}

/**
 * Return user defined plugins' config
 * first load config from `config/plugins.js`
 * and then merge config from `config/env/{env}/plugins.js`
 */ const getUserPluginsConfig = async ()=>{
    const globalUserConfigPath = path.join(strapi.dirs.dist.config, 'plugins.js');
    const currentEnvUserConfigPath = path.join(strapi.dirs.dist.config, 'env', process.env.NODE_ENV, 'plugins.js');
    let config = {};
    // assign global user config if exists
    if (await fse.pathExists(globalUserConfigPath)) {
        config = loadConfigFile(globalUserConfigPath);
    }
    // and merge user config by environment if exists
    if (await fse.pathExists(currentEnvUserConfigPath)) {
        config = fp.merge(config, loadConfigFile(currentEnvUserConfigPath));
    }
    return config;
};

/**
 * otherwise known as "core features"
 *
 * NOTE: These are excluded from the content manager plugin list, as they are always enabled.
 *       See admin.ts server controller on the content-manager plugin for more details.
 */ const INTERNAL_PLUGINS = [
    '@strapi/content-manager',
    '@strapi/content-type-builder',
    '@strapi/email',
    '@strapi/upload',
    '@strapi/i18n',
    '@strapi/content-releases',
    '@strapi/review-workflows'
];
const isStrapiPlugin = (info)=>fp.get('strapi.kind', info) === 'plugin';
const validatePluginName = (pluginName)=>{
    if (!strapiUtils.strings.isKebabCase(pluginName)) {
        throw new Error(`Plugin name "${pluginName}" is not in kebab (an-example-of-kebab-case)`);
    }
};
const toDetailedDeclaration = (declaration)=>{
    if (typeof declaration === 'boolean') {
        return {
            enabled: declaration
        };
    }
    const detailedDeclaration = {
        enabled: declaration.enabled
    };
    if (declaration?.resolve) {
        let pathToPlugin = '';
        if (declaration.isModule) {
            /**
       * we only want the node_module here, not the package.json
       */ pathToPlugin = path.join(declaration.resolve, '..');
        } else {
            try {
                pathToPlugin = path.dirname(require.resolve(declaration.resolve));
            } catch (e) {
                pathToPlugin = path.resolve(strapi.dirs.app.root, declaration.resolve);
                if (!fs.existsSync(pathToPlugin) || !fs.statSync(pathToPlugin).isDirectory()) {
                    throw new Error(`${declaration.resolve} couldn't be resolved`);
                }
            }
        }
        detailedDeclaration.pathToPlugin = pathToPlugin;
    }
    return detailedDeclaration;
};
const getEnabledPlugins = async (strapi1, { client } = {
    client: false
})=>{
    const internalPlugins = {};
    for (const dep of INTERNAL_PLUGINS){
        const packagePath = path.join(dep, 'package.json');
        // NOTE: internal plugins should be resolved from the strapi package
        const packageModulePath = require.resolve(packagePath, {
            paths: [
                require.resolve('@strapi/strapi/package.json'),
                process.cwd()
            ]
        });
        const packageInfo = require(packageModulePath);
        validatePluginName(packageInfo.strapi.name);
        internalPlugins[packageInfo.strapi.name] = {
            ...toDetailedDeclaration({
                enabled: true,
                resolve: packageModulePath,
                isModule: client
            }),
            info: packageInfo.strapi,
            packageInfo
        };
    }
    const installedPlugins = {};
    const dependencies = strapi1.config.get('info.dependencies', {});
    for (const dep of Object.keys(dependencies)){
        const packagePath = path.join(dep, 'package.json');
        let packageInfo;
        try {
            packageInfo = require(packagePath);
        } catch  {
            continue;
        }
        if (isStrapiPlugin(packageInfo)) {
            validatePluginName(packageInfo.strapi.name);
            installedPlugins[packageInfo.strapi.name] = {
                ...toDetailedDeclaration({
                    enabled: true,
                    resolve: packagePath,
                    isModule: client
                }),
                info: {
                    ...packageInfo.strapi,
                    packageName: packageInfo.name
                },
                packageInfo
            };
        }
    }
    const declaredPlugins = {};
    const userPluginsConfig = await getUserPluginsConfig();
    _.forEach(userPluginsConfig, (declaration, pluginName)=>{
        validatePluginName(pluginName);
        declaredPlugins[pluginName] = {
            ...toDetailedDeclaration(declaration),
            info: {}
        };
        const { pathToPlugin } = declaredPlugins[pluginName];
        // for manually resolved plugins
        if (pathToPlugin) {
            const packagePath = path.join(pathToPlugin, 'package.json');
            const packageInfo = require(packagePath);
            if (isStrapiPlugin(packageInfo)) {
                declaredPlugins[pluginName].info = packageInfo.strapi || {};
                declaredPlugins[pluginName].packageInfo = packageInfo;
            }
        }
    });
    const declaredPluginsResolves = fp.map(fp.prop('pathToPlugin'), declaredPlugins);
    const installedPluginsNotAlreadyUsed = fp.pickBy((p)=>!declaredPluginsResolves.includes(p.pathToPlugin), installedPlugins);
    const enabledPlugins = fp.pipe(fp.defaultsDeep(declaredPlugins), fp.defaultsDeep(installedPluginsNotAlreadyUsed), fp.pickBy((p)=>p.enabled))(internalPlugins);
    return enabledPlugins;
};

const defaultPlugin = {
    bootstrap () {},
    destroy () {},
    register () {},
    config: {
        default: {},
        validator () {}
    },
    routes: [],
    controllers: {},
    services: {},
    policies: {},
    middlewares: {},
    contentTypes: {}
};
const applyUserExtension = async (plugins)=>{
    const extensionsDir = strapi.dirs.dist.extensions;
    if (!await fse.pathExists(extensionsDir)) {
        return;
    }
    const extendedSchemas = await loadFiles(extensionsDir, '**/content-types/**/schema.json');
    const strapiServers = await loadFiles(extensionsDir, '**/strapi-server.js');
    for (const pluginName of Object.keys(plugins)){
        const plugin = plugins[pluginName];
        // first: load json schema
        for (const ctName of Object.keys(plugin.contentTypes)){
            const extendedSchema = fp.get([
                pluginName,
                'content-types',
                ctName,
                'schema'
            ], extendedSchemas);
            if (extendedSchema) {
                plugin.contentTypes[ctName].schema = {
                    ...plugin.contentTypes[ctName].schema,
                    ...extendedSchema
                };
            }
        }
        // second: execute strapi-server extension
        const strapiServer = fp.get([
            pluginName,
            'strapi-server'
        ], strapiServers);
        if (strapiServer) {
            plugins[pluginName] = await strapiServer(plugin);
        }
    }
};
const applyUserConfig = async (plugins)=>{
    const userPluginsConfig = await getUserPluginsConfig();
    for (const pluginName of Object.keys(plugins)){
        const plugin = plugins[pluginName];
        const userPluginConfig = fp.getOr({}, `${pluginName}.config`, userPluginsConfig);
        const defaultConfig = typeof plugin.config.default === 'function' ? plugin.config.default({
            env: strapiUtils.env
        }) : plugin.config.default;
        const config = fp.defaultsDeep(defaultConfig, userPluginConfig);
        try {
            plugin.config.validator(config);
        } catch (e) {
            if (e instanceof Error) {
                throw new Error(`Error regarding ${pluginName} config: ${e.message}`);
            }
            throw e;
        }
        plugin.config = config;
    }
};
async function loadPlugins(strapi1) {
    const plugins = {};
    const enabledPlugins = await getEnabledPlugins(strapi1);
    strapi1.config.set('enabledPlugins', enabledPlugins);
    for (const pluginName of Object.keys(enabledPlugins)){
        const enabledPlugin = enabledPlugins[pluginName];
        let serverEntrypointPath;
        let resolvedExport = './strapi-server.js';
        try {
            resolvedExport = (resolve__namespace.exports(enabledPlugin.packageInfo, 'strapi-server', {
                require: true
            }) ?? './strapi-server.js').toString();
        } catch (e) {
        // no export map or missing strapi-server export => fallback to default
        }
        try {
            serverEntrypointPath = path.join(enabledPlugin.pathToPlugin, resolvedExport);
        } catch (e) {
            throw new Error(`Error loading the plugin ${pluginName} because ${pluginName} is not installed. Please either install the plugin or remove it's configuration.`);
        }
        // only load plugins with a server entrypoint
        if (!await fse.pathExists(serverEntrypointPath)) {
            continue;
        }
        const pluginServer = loadConfigFile(serverEntrypointPath);
        plugins[pluginName] = {
            ...defaultPlugin,
            ...pluginServer,
            contentTypes: formatContentTypes(pluginName, pluginServer.contentTypes ?? {}),
            config: fp.defaults(defaultPlugin.config, pluginServer.config),
            routes: pluginServer.routes ?? defaultPlugin.routes
        };
    }
    // TODO: validate plugin format
    await applyUserConfig(plugins);
    await applyUserExtension(plugins);
    for (const pluginName of Object.keys(plugins)){
        strapi1.get('plugins').add(pluginName, plugins[pluginName]);
    }
}
const formatContentTypes = (pluginName, contentTypes)=>{
    Object.values(contentTypes).forEach((definition)=>{
        const { schema } = definition;
        Object.assign(schema, {
            plugin: pluginName,
            collectionName: schema.collectionName || `${pluginName}_${schema.info.singularName}`.toLowerCase(),
            globalId: getGlobalId(schema, pluginName)
        });
    });
    return contentTypes;
};

var loadSanitizers = ((strapi)=>{
    strapi.get('sanitizers').set('content-api', {
        input: [],
        output: [],
        query: []
    });
});

var loadValidators = ((strapi)=>{
    strapi.get('validators').set('content-api', {
        input: [],
        query: []
    });
});

async function loadApplicationContext(strapi) {
    await Promise.all([
        loadSrcIndex(strapi),
        loadSanitizers(strapi),
        loadValidators(strapi),
        loadPlugins(strapi),
        loadAPIs(strapi),
        loadComponents(strapi),
        loadMiddlewares(strapi),
        loadPolicies(strapi)
    ]);
}

const databaseErrorsToTransform$1 = [
    database.errors.InvalidTimeError,
    database.errors.InvalidDateTimeError,
    database.errors.InvalidDateError,
    database.errors.InvalidRelationError
];
/**
 * Handle database errors
 */ const databaseErrorsMiddleware = async (ctx, next)=>{
    try {
        return await next();
    } catch (error) {
        if (databaseErrorsToTransform$1.some((errorToTransform)=>error instanceof errorToTransform)) {
            if (error instanceof Error) {
                throw new strapiUtils.errors.ValidationError(error.message);
            }
            throw error;
        }
        throw error;
    }
};

const createMiddlewareManager = ()=>{
    const middlewares = [];
    const manager = {
        use (middleware) {
            middlewares.push(middleware);
            return ()=>middlewares.splice(middlewares.indexOf(middleware), 1);
        },
        async run (ctx, cb) {
            let index = 0;
            const next = async ()=>{
                if (index < middlewares.length) {
                    // eslint-disable-next-line no-plusplus
                    return middlewares[index++](ctx, next);
                }
                return cb();
            };
            return next();
        },
        wrapObject (source, ctxDefaults = {}, opts = {}) {
            const facade = {};
            const { exclude = [] } = opts;
            for(const key in source){
                if (Object.hasOwnProperty.call(source, key)) {
                    const prop = source[key];
                    if (exclude.includes(key)) {
                        facade[key] = prop;
                    } else if (typeof prop === 'function') {
                        const newMethod = async (params = {})=>{
                            const ctx = {
                                ...ctxDefaults,
                                action: key,
                                params
                            };
                            return manager.run(ctx, ()=>prop(ctx.params));
                        };
                        facade[key] = newMethod;
                    } else {
                        facade[key] = prop;
                    }
                }
            }
            return facade;
        }
    };
    return manager;
};

const wrapInTransaction = (fn)=>{
    return (...args)=>strapi.db.transaction?.(()=>fn(...args));
};

/**
 * DP enabled -> set status to draft
 * DP disabled -> Used mostly for parsing relations, so there is not a need for a default.
 */ const setStatusToDraft = (contentType, params)=>{
    if (!strapiUtils.contentTypes.hasDraftAndPublish(contentType) && params.status) {
        return params;
    }
    return fp.assoc('status', 'draft', params);
};
/**
 * Adds a default status of `draft` to the params
 */ const defaultToDraft = (params)=>{
    // Default to draft if no status is provided or it's invalid
    if (!params.status || params.status !== 'published') {
        return fp.assoc('status', 'draft', params);
    }
    return params;
};
/**
 * DP disabled -> ignore status
 * DP enabled -> set status to draft if no status is provided or it's invalid
 */ const defaultStatus = (contentType, params)=>{
    if (!strapiUtils.contentTypes.hasDraftAndPublish(contentType)) {
        return params;
    }
    // Default to draft if no status is provided or it's invalid
    if (!params.status || params.status !== 'published') {
        return defaultToDraft(params);
    }
    return params;
};
/**
 * In mutating actions we don't want user to set the publishedAt attribute.
 */ const filterDataPublishedAt = (params)=>{
    if (params?.data?.publishedAt) {
        return fp.assoc([
            'data',
            'publishedAt'
        ], null, params);
    }
    return params;
};
/**
 * Add status lookup query to the params
 */ const statusToLookup = (contentType, params)=>{
    if (!strapiUtils.contentTypes.hasDraftAndPublish(contentType)) {
        return params;
    }
    const lookup = params.lookup || {};
    switch(params?.status){
        case 'published':
            return fp.assoc([
                'lookup',
                'publishedAt'
            ], {
                $notNull: true
            }, params);
        case 'draft':
            return fp.assoc([
                'lookup',
                'publishedAt'
            ], {
                $null: true
            }, params);
    }
    return fp.assoc('lookup', lookup, params);
};
/**
 * Translate publication status parameter into the data that will be saved
 */ const statusToData = (contentType, params)=>{
    if (!strapiUtils.contentTypes.hasDraftAndPublish(contentType)) {
        return fp.assoc([
            'data',
            'publishedAt'
        ], new Date(), params);
    }
    switch(params?.status){
        case 'published':
            return fp.assoc([
                'data',
                'publishedAt'
            ], new Date(), params);
        case 'draft':
            return fp.assoc([
                'data',
                'publishedAt'
            ], null, params);
    }
    return params;
};
const setStatusToDraftCurry = fp.curry(setStatusToDraft);
const defaultToDraftCurry = fp.curry(defaultToDraft);
const defaultStatusCurry = fp.curry(defaultStatus);
const filterDataPublishedAtCurry = fp.curry(filterDataPublishedAt);
const statusToLookupCurry = fp.curry(statusToLookup);
const statusToDataCurry = fp.curry(statusToData);

const getDefaultLocale$1 = async ()=>{
    return strapi.plugin('i18n').service('locales').getDefaultLocale();
};
const defaultLocale = async (contentType, params)=>{
    if (!strapi.plugin('i18n').service('content-types').isLocalizedContentType(contentType)) {
        return params;
    }
    if (!params.locale) {
        return fp.assoc('locale', await getDefaultLocale$1(), params);
    }
    return params;
};
/**
 * Add locale lookup query to the params
 */ const localeToLookup = (contentType, params)=>{
    if (!params.locale || !strapi.plugin('i18n').service('content-types').isLocalizedContentType(contentType)) {
        return params;
    }
    if (typeof params.locale !== 'string') {
        // localeToLookup accepts locales of '*'. This is because the document
        // service functions that use this transform work with the '*' locale
        // to return all locales.
        throw new strapiUtils.errors.ValidationError(`Invalid locale param ${String(params.locale)} provided. Document locales must be strings.`);
    }
    return fp.assoc([
        'lookup',
        'locale'
    ], params.locale, params);
};
/**
 * Add locale lookup query to the params
 */ const multiLocaleToLookup = (contentType, params)=>{
    if (!strapi.plugin('i18n').service('content-types').isLocalizedContentType(contentType)) {
        return params;
    }
    if (params.locale) {
        if (params.locale === '*') {
            return params;
        }
        return fp.assoc([
            'lookup',
            'locale'
        ], params.locale, params);
    }
    return params;
};
/**
 * Translate locale status parameter into the data that will be saved
 */ const localeToData = (contentType, params)=>{
    if (!strapi.plugin('i18n').service('content-types').isLocalizedContentType(contentType)) {
        return params;
    }
    if (params.locale) {
        const isValidLocale = typeof params.locale === 'string' && params.locale !== '*';
        if (isValidLocale) {
            return fp.assoc([
                'data',
                'locale'
            ], params.locale, params);
        }
        throw new strapiUtils.errors.ValidationError(`Invalid locale param ${params.locale} provided. Document locales must be strings.`);
    }
    return params;
};
const defaultLocaleCurry = fp.curry(defaultLocale);
const localeToLookupCurry = fp.curry(localeToLookup);
const multiLocaleToLookupCurry = fp.curry(multiLocaleToLookup);
const localeToDataCurry = fp.curry(localeToData);

const omitComponentData = fp.curry((schema, data)=>{
    const { attributes } = schema;
    const componentAttributes = Object.keys(attributes).filter((attributeName)=>strapiUtils.contentTypes.isComponentAttribute(attributes[attributeName]));
    return fp.omit(componentAttributes, data);
});
// NOTE: we could generalize the logic to allow CRUD of relation directly in the DB layer
const createComponents = async (uid, data)=>{
    const { attributes = {} } = strapi.getModel(uid);
    const componentBody = {};
    const attributeNames = Object.keys(attributes);
    for (const attributeName of attributeNames){
        const attribute = attributes[attributeName];
        if (!fp.has(attributeName, data) || !strapiUtils.contentTypes.isComponentAttribute(attribute)) {
            continue;
        }
        if (attribute.type === 'component') {
            const { component: componentUID, repeatable = false } = attribute;
            const componentValue = data[attributeName];
            if (componentValue === null) {
                continue;
            }
            if (repeatable === true) {
                if (!Array.isArray(componentValue)) {
                    throw new Error('Expected an array to create repeatable component');
                }
                const components = await strapiUtils.async.map(componentValue, (value)=>createComponent(componentUID, value));
                componentBody[attributeName] = components.map(({ id })=>{
                    return {
                        id,
                        __pivot: {
                            field: attributeName,
                            component_type: componentUID
                        }
                    };
                });
            } else {
                const component = await createComponent(componentUID, componentValue);
                componentBody[attributeName] = {
                    id: component.id,
                    __pivot: {
                        field: attributeName,
                        component_type: componentUID
                    }
                };
            }
            continue;
        }
        if (attribute.type === 'dynamiczone') {
            const dynamiczoneValues = data[attributeName];
            if (!Array.isArray(dynamiczoneValues)) {
                throw new Error('Expected an array to create repeatable component');
            }
            const createDynamicZoneComponents = async (value)=>{
                const { id } = await createComponent(value.__component, value);
                return {
                    id,
                    __component: value.__component,
                    __pivot: {
                        field: attributeName
                    }
                };
            };
            // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1
            componentBody[attributeName] = await strapiUtils.async.map(dynamiczoneValues, createDynamicZoneComponents);
            continue;
        }
    }
    return componentBody;
};
const getComponents = async (uid, entity)=>{
    const componentAttributes = strapiUtils.contentTypes.getComponentAttributes(strapi.getModel(uid));
    if (_.isEmpty(componentAttributes)) {
        return {};
    }
    return strapi.db.query(uid).load(entity, componentAttributes);
};
/*
  delete old components
  create or update
*/ const updateComponents = async (uid, entityToUpdate, data)=>{
    const { attributes = {} } = strapi.getModel(uid);
    const componentBody = {};
    for (const attributeName of Object.keys(attributes)){
        const attribute = attributes[attributeName];
        if (!fp.has(attributeName, data)) {
            continue;
        }
        if (attribute.type === 'component') {
            const { component: componentUID, repeatable = false } = attribute;
            const componentValue = data[attributeName];
            await deleteOldComponents(uid, componentUID, entityToUpdate, attributeName, componentValue);
            if (repeatable === true) {
                if (!Array.isArray(componentValue)) {
                    throw new Error('Expected an array to create repeatable component');
                }
                // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1
                const components = await strapiUtils.async.map(componentValue, (value)=>updateOrCreateComponent(componentUID, value));
                componentBody[attributeName] = components.filter(_.negate(_.isNil)).map(({ id })=>{
                    return {
                        id,
                        __pivot: {
                            field: attributeName,
                            component_type: componentUID
                        }
                    };
                });
            } else {
                const component = await updateOrCreateComponent(componentUID, componentValue);
                componentBody[attributeName] = component && {
                    id: component.id,
                    __pivot: {
                        field: attributeName,
                        component_type: componentUID
                    }
                };
            }
        } else if (attribute.type === 'dynamiczone') {
            const dynamiczoneValues = data[attributeName];
            await deleteOldDZComponents(uid, entityToUpdate, attributeName, dynamiczoneValues);
            if (!Array.isArray(dynamiczoneValues)) {
                throw new Error('Expected an array to create repeatable component');
            }
            // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1
            componentBody[attributeName] = await strapiUtils.async.map(dynamiczoneValues, async (value)=>{
                const { id } = await updateOrCreateComponent(value.__component, value);
                return {
                    id,
                    __component: value.__component,
                    __pivot: {
                        field: attributeName
                    }
                };
            });
        }
    }
    return componentBody;
};
const pickStringifiedId = ({ id })=>{
    if (typeof id === 'string') {
        return id;
    }
    return `${id}`;
};
const deleteOldComponents = async (uid, componentUID, entityToUpdate, attributeName, componentValue)=>{
    const previousValue = await strapi.db.query(uid).load(entityToUpdate, attributeName);
    const idsToKeep = _.castArray(componentValue).filter(fp.has('id')).map(pickStringifiedId);
    const allIds = _.castArray(previousValue).filter(fp.has('id')).map(pickStringifiedId);
    idsToKeep.forEach((id)=>{
        if (!allIds.includes(id)) {
            throw new strapiUtils.errors.ApplicationError(`Some of the provided components in ${attributeName} are not related to the entity`);
        }
    });
    const idsToDelete = _.difference(allIds, idsToKeep);
    if (idsToDelete.length > 0) {
        for (const idToDelete of idsToDelete){
            await deleteComponent(componentUID, {
                id: idToDelete
            });
        }
    }
};
const deleteOldDZComponents = async (uid, entityToUpdate, attributeName, dynamiczoneValues)=>{
    const previousValue = await strapi.db.query(uid).load(entityToUpdate, attributeName);
    const idsToKeep = _.castArray(dynamiczoneValues).filter(fp.has('id')).map((v)=>({
            id: pickStringifiedId(v),
            __component: v.__component
        }));
    const allIds = _.castArray(previousValue).filter(fp.has('id')).map((v)=>({
            id: pickStringifiedId(v),
            __component: v.__component
        }));
    idsToKeep.forEach(({ id, __component })=>{
        if (!allIds.find((el)=>el.id === id && el.__component === __component)) {
            const err = new Error(`Some of the provided components in ${attributeName} are not related to the entity`);
            Object.assign(err, {
                status: 400
            });
            throw err;
        }
    });
    const idsToDelete = allIds.reduce((acc, { id, __component })=>{
        if (!idsToKeep.find((el)=>el.id === id && el.__component === __component)) {
            acc.push({
                id,
                __component
            });
        }
        return acc;
    }, []);
    if (idsToDelete.length > 0) {
        for (const idToDelete of idsToDelete){
            const { id, __component } = idToDelete;
            await deleteComponent(__component, {
                id
            });
        }
    }
};
const deleteComponents = async (uid, entityToDelete, { loadComponents = true } = {})=>{
    const { attributes = {} } = strapi.getModel(uid);
    const attributeNames = Object.keys(attributes);
    for (const attributeName of attributeNames){
        const attribute = attributes[attributeName];
        if (attribute.type === 'component' || attribute.type === 'dynamiczone') {
            let value;
            if (loadComponents) {
                value = await strapi.db.query(uid).load(entityToDelete, attributeName);
            } else {
                value = entityToDelete[attributeName];
            }
            if (!value) {
                continue;
            }
            if (attribute.type === 'component') {
                const { component: componentUID } = attribute;
                await strapiUtils.async.map(_.castArray(value), (subValue)=>deleteComponent(componentUID, subValue));
            } else {
                await strapiUtils.async.map(_.castArray(value), (subValue)=>deleteComponent(subValue.__component, subValue));
            }
            continue;
        }
    }
};
/** *************************
    Component queries
************************** */ // components can have nested compos so this must be recursive
const createComponent = async (uid, data)=>{
    const schema = strapi.getModel(uid);
    const componentData = await createComponents(uid, data);
    const transform = fp.pipe(// Make sure we don't save the component with a pre-defined ID
    fp.omit('id'), assignComponentData(schema, componentData));
    return strapi.db.query(uid).create({
        data: transform(data)
    });
};
// components can have nested compos so this must be recursive
const updateComponent = async (uid, componentToUpdate, data)=>{
    const schema = strapi.getModel(uid);
    const componentData = await updateComponents(uid, componentToUpdate, data);
    return strapi.db.query(uid).update({
        where: {
            id: componentToUpdate.id
        },
        data: assignComponentData(schema, componentData, data)
    });
};
const updateOrCreateComponent = (componentUID, value)=>{
    if (value === null) {
        return null;
    }
    // update
    if ('id' in value && typeof value.id !== 'undefined') {
        // TODO: verify the compo is associated with the entity
        return updateComponent(componentUID, {
            id: value.id
        }, value);
    }
    // create
    return createComponent(componentUID, value);
};
const deleteComponent = async (uid, componentToDelete)=>{
    await deleteComponents(uid, componentToDelete);
    await strapi.db.query(uid).delete({
        where: {
            id: componentToDelete.id
        }
    });
};
const assignComponentData = fp.curry((schema, componentData, data)=>{
    return fp.pipe(omitComponentData(schema), fp.assign(componentData))(data);
});

const hasDraftAndPublish$1 = (uid)=>{
    const model = strapi.getModel(uid);
    return strapiUtils.contentTypes.hasDraftAndPublish(model);
};
/**
 * TODO: Find a better way to encode keys than this
 * This converts an object into a string by joining its keys and values,
 * so it can be used as a key in a Map.
 *
 * @example
 * const obj = { a: 1, b: 2 };
 * const key = encodeKey(obj);
 *      ^ "a:::1&&b:::2"
 */ const encodeKey = (obj)=>{
    // Ignore status field for models without draft and publish
    if (!hasDraftAndPublish$1(obj.uid)) {
        delete obj.status;
    }
    // Sort keys to always keep the same order when encoding
    const keys = Object.keys(obj).sort();
    return keys.map((key)=>`${key}:::${obj[key]}`).join('&&');
};
/**
 * Holds a registry of document ids and their corresponding entity ids.
 */ const createIdMap = ({ strapi: strapi1 })=>{
    const loadedIds = new Map();
    const toLoadIds = new Map();
    return {
        loadedIds,
        toLoadIds,
        /**
     * Register a new document id and its corresponding entity id.
     */ add (keyFields) {
            const key = encodeKey({
                status: 'published',
                locale: null,
                ...keyFields
            });
            // If the id is already loaded, do nothing
            if (loadedIds.has(key)) return;
            // If the id is already in the toLoadIds, do nothing
            if (toLoadIds.has(key)) return;
            // Add the id to the toLoadIds
            toLoadIds.set(key, keyFields);
        },
        /**
     * Load all ids from the registry.
     */ async load () {
            // Document Id to Entry Id queries are batched by its uid and locale
            // TODO: Add publication state too
            const loadIdValues = Array.from(toLoadIds.values());
            // 1. Group ids to query together
            const idsByUidAndLocale = loadIdValues.reduce((acc, { documentId, ...rest })=>{
                const key = encodeKey(rest);
                const ids = acc[key] || {
                    ...rest,
                    documentIds: []
                };
                ids.documentIds.push(documentId);
                return {
                    ...acc,
                    [key]: ids
                };
            }, {});
            // 2. Query ids
            await strapiUtils.async.map(Object.values(idsByUidAndLocale), async ({ uid, locale, documentIds, status })=>{
                const findParams = {
                    select: [
                        'id',
                        'documentId',
                        'locale',
                        'publishedAt'
                    ],
                    where: {
                        documentId: {
                            $in: documentIds
                        },
                        locale: locale || null
                    }
                };
                if (hasDraftAndPublish$1(uid)) {
                    findParams.where.publishedAt = status === 'draft' ? null : {
                        $ne: null
                    };
                }
                const result = await strapi1?.db?.query(uid).findMany(findParams);
                // 3. Store result in loadedIds
                result?.forEach(({ documentId, id, locale, publishedAt })=>{
                    const key = encodeKey({
                        documentId,
                        uid,
                        locale,
                        status: publishedAt ? 'published' : 'draft'
                    });
                    loadedIds.set(key, id);
                });
            });
            // 4. Clear toLoadIds
            toLoadIds.clear();
        },
        /**
     * Get the entity id for a given document id.
     */ get (keys) {
            const key = encodeKey({
                status: 'published',
                locale: null,
                ...keys
            });
            return loadedIds.get(key);
        },
        /**
     * Clear the registry.
     */ clear () {
            loadedIds.clear();
            toLoadIds.clear();
        }
    };
};

const isLocalizedContentType = (uid)=>{
    const model = strapi.getModel(uid);
    return strapi.plugin('i18n').service('content-types').isLocalizedContentType(model);
};
const getDefaultLocale = ()=>{
    return strapi.plugin('i18n').service('locales').getDefaultLocale();
};
const getRelationTargetLocale = (relation, opts)=>{
    const targetLocale = relation.locale || opts.sourceLocale;
    const isTargetLocalized = isLocalizedContentType(opts.targetUid);
    const isSourceLocalized = isLocalizedContentType(opts.sourceUid);
    // Both source and target locales should match
    if (isSourceLocalized && isTargetLocalized) {
        return opts.sourceLocale;
    }
    if (isTargetLocalized) {
        return targetLocale;
    }
    return null;
};

const getRelationTargetStatus = (relation, opts)=>{
    // Ignore if the target content type does not have draft and publish enabled
    const targetContentType = strapi.getModel(opts.targetUid);
    const sourceContentType = strapi.getModel(opts.sourceUid);
    const targetHasDP = strapiUtils.contentTypes.hasDraftAndPublish(targetContentType);
    const sourceHasDP = strapiUtils.contentTypes.hasDraftAndPublish(sourceContentType);
    if (!targetHasDP) {
        return [
            'published'
        ];
    }
    /**
   * If both source and target have DP enabled,
   * connect it to the same status as the source status
   */ if (sourceHasDP && !fp.isNil(opts.sourceStatus)) {
        return [
            opts.sourceStatus
        ];
    }
    /**
   * Use the status from the relation if it's set
   */ if (relation.status) {
        switch(relation.status){
            case 'published':
                return [
                    'published'
                ];
            default:
                // Default to draft if it's an invalid status (e.g. modified)
                return [
                    'draft'
                ];
        }
    }
    /**
   * If DP is disabled and relation does not specify any status
   * Connect to both draft and published versions
   */ if (!sourceHasDP) {
        return [
            'draft',
            'published'
        ];
    }
    // Default to draft as a fallback
    return [
        'draft'
    ];
};

const isNumeric = (value)=>{
    if (Array.isArray(value)) return false; // Handle [1, 'docId'] case
    const parsed = parseInt(value, 10);
    return !Number.isNaN(parsed);
};
const toArray = (value)=>{
    // Keep value as it is if it's a nullish value
    if (fp.isNil(value)) return value;
    if (Array.isArray(value)) return value;
    return [
        value
    ];
};
/**
 * There are multiple ways to create Strapi relations.
 * This is a utility to traverse and transform relation data
 *
 *
 * For consistency and ease of use, the response will always be an object with the following shape:
 * { set: [{...}], connect: [{...}], disconnect: [{...}] }
 *
 * @example
 * transformRelationData({
 *  onLongHand: (relation) => {
 *    // Change the id of the relation
 *    return { id: 'other' };
 *  },
 * }, relation)
 */ const mapRelation = async (callback, rel, isRecursive = false)=>{
    let relation = rel;
    const wrapInSet = (value)=>{
        // Ignore wrapping if it's a recursive call
        if (isRecursive) {
            return value;
        }
        return {
            set: toArray(value)
        };
    };
    // undefined | null
    if (fp.isNil(relation)) {
        return callback(relation);
    }
    // LongHand[] | ShortHand[]
    if (Array.isArray(relation)) {
        return strapiUtils.async.map(relation, (r)=>mapRelation(callback, r, true)).then((result)=>result.flat().filter(Boolean)).then(wrapInSet);
    }
    // LongHand
    if (fp.isObject(relation)) {
        // { id: 1 } || { documentId: 1 }
        if ('id' in relation || 'documentId' in relation) {
            const result = await callback(relation);
            return wrapInSet(result);
        }
        // If not connecting anything, return default visitor
        if (!relation.set && !relation.disconnect && !relation.connect) {
            return callback(relation);
        }
        // { set }
        if (relation.set) {
            const set = await mapRelation(callback, relation.set, true);
            relation = {
                ...relation,
                set: toArray(set)
            };
        }
        // { disconnect}
        if (relation.disconnect) {
            const disconnect = await mapRelation(callback, relation.disconnect, true);
            relation = {
                ...relation,
                disconnect: toArray(disconnect)
            };
        }
        // { connect }
        if (relation.connect) {
            // Transform the relation to connect
            const connect = await mapRelation(callback, relation.connect, true);
            relation = {
                ...relation,
                connect: toArray(connect)
            };
        }
        return relation;
    }
    // ShortHand
    if (isNumeric(relation)) {
        const result = await callback({
            id: relation
        });
        return wrapInSet(result);
    }
    if (typeof relation === 'string') {
        const result = await callback({
            documentId: relation
        });
        return wrapInSet(result);
    }
    // Anything else
    return callback(relation);
};
/**
 * Utility function, same as `traverseEntity` but only for relations.
 */ const traverseEntityRelations = async (visitor, options, data)=>{
    return strapiUtils.traverseEntity(async (options, utils)=>{
        const { attribute } = options;
        if (!attribute) {
            return;
        }
        if (attribute.type !== 'relation') {
            return;
        }
        // TODO: Handle join columns
        if (attribute.useJoinTable === false) {
            return;
        }
        return visitor(options, utils);
    }, options, data);
};
const mapRelationCurried = fp.curry(mapRelation);
const traverseEntityRelationsCurried = fp.curry(traverseEntityRelations);

const { isPolymorphic: isPolymorphic$1 } = strapiUtils.relations;
/**
 * Load a relation documentId into the idMap.
 */ const addRelationDocId = fp.curry((idMap, source, targetUid, relation)=>{
    const targetLocale = getRelationTargetLocale(relation, {
        targetUid,
        sourceUid: source.uid,
        sourceLocale: source.locale
    });
    const targetStatus = getRelationTargetStatus(relation, {
        targetUid,
        sourceUid: source.uid,
        sourceStatus: source.status
    });
    targetStatus.forEach((status)=>{
        idMap.add({
            uid: targetUid,
            documentId: relation.documentId,
            locale: targetLocale,
            status
        });
    });
});
/**
 * Iterate over all relations of a data object and extract all relational document ids.
 * Those will later be transformed to entity ids.
 */ const extractDataIds = (idMap, data, source)=>{
    return traverseEntityRelationsCurried(async ({ attribute, value })=>{
        if (!attribute) {
            return;
        }
        const isPolymorphicRelation = isPolymorphic$1(attribute);
        const addDocId = addRelationDocId(idMap, source);
        return mapRelationCurried((relation)=>{
            if (!relation || !relation.documentId) {
                return relation;
            }
            // Regular relations will always target the same target
            // if its a polymorphic relation we need to get it from the data itself
            const targetUid = isPolymorphicRelation ? relation.__type : attribute.target;
            addDocId(targetUid, relation);
            // Handle positional arguments
            const position = relation.position;
            // The positional relation target uid can be different for polymorphic relations
            let positionTargetUid = targetUid;
            if (isPolymorphicRelation && position?.__type) {
                positionTargetUid = position.__type;
            }
            if (position?.before) {
                addDocId(positionTargetUid, {
                    ...relation,
                    ...position,
                    documentId: position.before
                });
            }
            if (position?.after) {
                addDocId(positionTargetUid, {
                    ...relation,
                    ...position,
                    documentId: position.after
                });
            }
            return relation;
        }, value);
    }, {
        schema: strapi.getModel(source.uid),
        getModel: strapi.getModel.bind(strapi)
    }, data);
};

const { isPolymorphic } = strapiUtils.relations;
/**
 * Get the entry ids for a given documentId.
 */ const getRelationIds = fp.curry((idMap, source, targetUid, relation)=>{
    // locale to connect to
    const targetLocale = getRelationTargetLocale(relation, {
        targetUid,
        sourceUid: source.uid,
        sourceLocale: source.locale
    });
    // status(es) to connect to
    const targetStatus = getRelationTargetStatus(relation, {
        targetUid,
        sourceUid: source.uid,
        sourceStatus: source.status
    });
    const ids = [];
    // Find mapping between documentID -> id(s).
    // There are scenarios where a single documentID can map to multiple ids.
    // e.g when connecting Non DP -> DP and connecting to both the draft and publish version at the same time
    for (const tStatus of targetStatus){
        const entryId = idMap.get({
            uid: targetUid,
            documentId: relation.documentId,
            locale: targetLocale,
            status: tStatus
        });
        if (entryId) ids.push(entryId);
    }
    if (!ids.length && !source.allowMissingId) {
        throw new strapiUtils.errors.ValidationError(`Document with id "${relation.documentId}", locale "${targetLocale}" not found`);
    }
    return ids;
});
/**
 * Iterate over all relations of a data object and transform all relational document ids to entity ids.
 */ const transformDataIdsVisitor = (idMap, data, source)=>{
    return traverseEntityRelationsCurried(async ({ key, value, attribute }, { set })=>{
        if (!attribute) {
            return;
        }
        const isPolymorphicRelation = isPolymorphic(attribute);
        const getIds = getRelationIds(idMap, source);
        // Transform the relation documentId to entity id
        const newRelation = await mapRelationCurried((relation)=>{
            if (!relation || !relation.documentId) {
                return relation;
            }
            // Find relational attributes, and return the document ids
            // if its a polymorphic relation we need to get it from the data itself
            const targetUid = isPolymorphicRelation ? relation.__type : attribute.target;
            const ids = getIds(targetUid, relation);
            // Handle positional arguments
            const position = {
                ...relation.position
            };
            // The positional relation target uid can be different for polymorphic relations
            let positionTargetUid = targetUid;
            if (isPolymorphicRelation && position?.__type) {
                positionTargetUid = position.__type;
            }
            if (position.before) {
                const beforeRelation = {
                    ...relation,
                    ...position,
                    documentId: position.before
                };
                const beforeIds = getIds(positionTargetUid, beforeRelation);
                position.before = beforeIds.at(0);
            }
            if (position.after) {
                const afterRelation = {
                    ...relation,
                    ...position,
                    documentId: position.after
                };
                position.after = getIds(positionTargetUid, afterRelation).at(0);
            }
            // Transform all ids to new relations
            return ids?.map((id)=>{
                const newRelation = {
                    id
                };
                if (relation.position) {
                    newRelation.position = position;
                }
                // Insert type if its a polymorphic relation
                if (isPolymorphicRelation) {
                    newRelation.__type = targetUid;
                }
                return newRelation;
            });
        }, value);
        set(key, newRelation);
    }, {
        schema: strapi.getModel(source.uid),
        getModel: strapi.getModel.bind(strapi)
    }, data);
};

/**
 * In scenarios like Non i18n CT -> i18n CT
 * relations can be connected to multiple locales,
 * in case user does not provide the locale, this sets it to the default one.
 */ const setDefaultLocaleToRelations = (data, uid)=>{
    // I18n CT -> anything will already have a locale set (source locale)
    if (isLocalizedContentType(uid)) {
        return data;
    }
    // Store the default locale to avoid multiple calls
    let defaultLocale;
    /**
   * Traverse the entity input data and set the default locale to relations
   */ return traverseEntityRelationsCurried(async ({ key, value }, { set })=>{
        /**
       * Assign default locale on long hand expressed relations
       * e.g { documentId } -> { documentId, locale }
       */ const relation = await mapRelationCurried(async (relation)=>{
            if (!relation || !relation?.documentId || relation?.locale) {
                return relation;
            }
            // Set default locale if not provided
            if (!defaultLocale) {
                defaultLocale = await getDefaultLocale();
            }
            // Assign default locale to the positional argument
            const position = relation.position;
            if (position && typeof position === 'object' && !position.locale) {
                relation.position.locale = defaultLocale;
            }
            return {
                ...relation,
                locale: defaultLocale
            };
        }, value);
        // @ts-expect-error - fix type
        set(key, relation);
    }, {
        schema: strapi.getModel(uid),
        getModel: strapi.getModel.bind(strapi)
    }, data);
};

/**
 * Transforms input data, containing relation document ids, to entity ids.
 */ const transformData = async (data, opts)=>{
    const idMap = createIdMap({
        strapi
    });
    // Assign default locales
    const transformedData = await setDefaultLocaleToRelations(data, opts.uid);
    // Extract any relation ids from the input
    await extractDataIds(idMap, transformedData, opts);
    // Load any relation the extract methods found
    await idMap.load();
    // Transform any relation ids to entity ids
    return transformDataIdsVisitor(idMap, transformedData, opts);
};

const transformFields = (fields)=>{
    // If  it's a string, and it doesn't contain documentId, should be an array
    if (typeof fields === 'string') {
        // '*' => '*'
        if (fields === '*') {
            return fields;
        }
        // '' => 'documentId'
        if (fields === '') {
            return 'documentId';
        }
        // 'name,description' => 'name,description,documentId'
        if (!fields.split(',').includes('documentId')) {
            return `${fields},documentId`;
        }
    }
    // It's not an array, ignore it
    if (!fields || !Array.isArray(fields)) {
        // If fields is empty, return it as is
        return fields;
    }
    // Ensure we are always selecting the documentId
    // ['name', 'description'] => ['name', 'description', 'documentId']
    if (!fields.includes('documentId')) {
        fields.push('documentId');
    }
    return fields;
};

const transformPopulate = async (data, opts)=>{
    return strapiUtils.traverse.traverseQueryPopulate(async ({ attribute, key, value }, { set })=>{
        if (!value || typeof value !== 'object' || attribute?.type !== 'relation') {
            return;
        }
        /*
        If the attribute is a relation
        Look for fields in the value
        and apply the relevant transformation to these objects
      */ if ('fields' in value && Array.isArray(value.fields)) {
            value.fields = transformFields(value.fields);
        }
        set(key, value);
    }, {
        schema: strapi.getModel(opts.uid),
        getModel: strapi.getModel.bind(strapi)
    }, data);
};

/**
 * Transform input of a query to map document ids to entity ids.
 */ async function transformParamsDocumentId(uid, query) {
    // Transform relational documentIds to entity ids
    let data = query.data;
    if (query.data) {
        data = await transformData(query.data, {
            locale: query.locale,
            status: query.status,
            uid
        });
    }
    // Make sure documentId is always present in the response
    let fields = query.fields;
    if (query.fields) {
        fields = transformFields(query.fields);
    }
    let populate = query.populate;
    if (query.populate) {
        populate = await transformPopulate(query.populate, {
            uid
        });
    }
    return {
        ...query,
        data,
        fields,
        populate
    };
}
const curriedTransformParamsDocumentId = fp.curry(transformParamsDocumentId);

const transformParamsToQuery = fp.curry((uid, params)=>{
    const query = strapi.get('query-params').transform(uid, params);
    return fp.assoc('where', {
        ...params?.lookup,
        ...query.where
    }, query);
});

const pickSelectionParams = (data)=>{
    return fp.pick([
        'fields',
        'populate',
        'status'
    ], data);
};

const transforms = {
    password (value, context) {
        const { attribute } = context;
        if (attribute.type !== 'password') {
            throw new Error('Invalid attribute type');
        }
        if (!fp.isString(value) && !(value instanceof Buffer)) {
            return value;
        }
        const rounds = fp.toNumber(fp.getOr(10, 'encryption.rounds', attribute));
        return bcrypt.hashSync(value.toString(), rounds);
    }
};

const applyTransforms = fp.curry((schema, data)=>{
    const attributeNames = Object.keys(data);
    for (const attributeName of attributeNames){
        const value = data[attributeName];
        const attribute = schema.attributes[attributeName];
        if (!attribute) {
            continue;
        }
        const transform = transforms[attribute.type];
        if (transform) {
            const attributeContext = {
                attributeName,
                attribute
            };
            data[attributeName] = transform(value, attributeContext);
        }
    }
    return data;
});

const createEntriesService = (uid, entityValidator)=>{
    const contentType = strapi.contentType(uid);
    async function createEntry(params = {}) {
        const { data, ...restParams } = await curriedTransformParamsDocumentId(uid, params);
        const query = transformParamsToQuery(uid, pickSelectionParams(restParams)); // select / populate
        // Validation
        if (!data) {
            throw new Error('Create requires data attribute');
        }
        const validData = await entityValidator.validateEntityCreation(contentType, data, {
            // Note: publishedAt value will always be set when DP is disabled
            isDraft: !params?.data?.publishedAt,
            locale: params?.locale
        });
        // Component handling
        const componentData = await createComponents(uid, validData);
        const dataWithComponents = assignComponentData(contentType, componentData, validData);
        const entryData = applyTransforms(contentType, dataWithComponents);
        const doc = await strapi.db.query(uid).create({
            ...query,
            data: entryData
        });
        return doc;
    }
    async function deleteEntry(id) {
        const componentsToDelete = await getComponents(uid, {
            id
        });
        const deletedEntry = await strapi.db.query(uid).delete({
            where: {
                id
            }
        });
        await deleteComponents(uid, componentsToDelete, {
            loadComponents: false
        });
        return deletedEntry;
    }
    async function updateEntry(entryToUpdate, params = {}) {
        const { data, ...restParams } = await curriedTransformParamsDocumentId(uid, params);
        const query = transformParamsToQuery(uid, pickSelectionParams(restParams)); // select / populate
        const validData = await entityValidator.validateEntityUpdate(contentType, data, {
            isDraft: !params?.data?.publishedAt,
            locale: params?.locale
        }, entryToUpdate);
        // Component handling
        const componentData = await updateComponents(uid, entryToUpdate, validData);
        const dataWithComponents = assignComponentData(contentType, componentData, validData);
        const entryData = applyTransforms(contentType, dataWithComponents);
        return strapi.db.query(uid).update({
            ...query,
            where: {
                id: entryToUpdate.id
            },
            data: entryData
        });
    }
    async function publishEntry(entry, params = {}) {
        return strapiUtils.async.pipe(fp.omit('id'), fp.assoc('publishedAt', new Date()), (draft)=>{
            const opts = {
                uid,
                locale: draft.locale,
                status: 'published',
                allowMissingId: true
            };
            return transformData(draft, opts);
        }, // Create the published entry
        (draft)=>createEntry({
                ...params,
                data: draft,
                locale: draft.locale,
                status: 'published'
            }))(entry);
    }
    async function discardDraftEntry(entry, params = {}) {
        return strapiUtils.async.pipe(fp.omit('id'), fp.assoc('publishedAt', null), (entry)=>{
            const opts = {
                uid,
                locale: entry.locale,
                status: 'draft',
                allowMissingId: true
            };
            return transformData(entry, opts);
        }, // Create the draft entry
        (data)=>createEntry({
                ...params,
                locale: data.locale,
                data,
                status: 'draft'
            }))(entry);
    }
    return {
        create: createEntry,
        delete: deleteEntry,
        update: updateEntry,
        publish: publishEntry,
        discardDraft: discardDraftEntry
    };
};

const { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = strapiUtils.contentTypes.constants;
// We want to build a populate object based on the schema
const getDeepPopulate = (uid, opts = {})=>{
    const model = strapi.getModel(uid);
    const attributes = Object.entries(model.attributes);
    return attributes.reduce((acc, [attributeName, attribute])=>{
        switch(attribute.type){
            case 'relation':
                {
                    // TODO: Support polymorphic relations
                    const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');
                    if (isMorphRelation) {
                        break;
                    }
                    // Ignore not visible fields other than createdBy and updatedBy
                    const isVisible = strapiUtils.contentTypes.isVisibleAttribute(model, attributeName);
                    const isCreatorField = [
                        CREATED_BY_ATTRIBUTE,
                        UPDATED_BY_ATTRIBUTE
                    ].includes(attributeName);
                    if (isVisible || isCreatorField) {
                        acc[attributeName] = {
                            select: opts.relationalFields
                        };
                    }
                    break;
                }
            case 'media':
                {
                    // We populate all media fields for completeness of webhook responses
                    // see https://github.com/strapi/strapi/issues/21546
                    acc[attributeName] = {
                        select: [
                            '*'
                        ]
                    };
                    break;
                }
            case 'component':
                {
                    const populate = getDeepPopulate(attribute.component, opts);
                    acc[attributeName] = {
                        populate
                    };
                    break;
                }
            case 'dynamiczone':
                {
                    // Use fragments to populate the dynamic zone components
                    const populatedComponents = (attribute.components || []).reduce((acc, componentUID)=>{
                        acc[componentUID] = {
                            populate: getDeepPopulate(componentUID, opts)
                        };
                        return acc;
                    }, {});
                    acc[attributeName] = {
                        on: populatedComponents
                    };
                    break;
                }
        }
        return acc;
    }, {});
};

const EVENTS = {
    ENTRY_CREATE: 'entry.create',
    ENTRY_UPDATE: 'entry.update',
    ENTRY_DELETE: 'entry.delete',
    ENTRY_PUBLISH: 'entry.publish',
    ENTRY_UNPUBLISH: 'entry.unpublish',
    ENTRY_DRAFT_DISCARD: 'entry.draft-discard'
};
/**
 * Manager to trigger entry related events
 *
 * It will populate the entry if it is not a delete event.
 * So the event payload will contain the full entry.
 */ const createEventManager = (strapi, uid)=>{
    const populate = getDeepPopulate(uid, {});
    const model = strapi.getModel(uid);
    const emitEvent = async (eventName, entry)=>{
        // There is no need to populate the entry if it has been deleted
        let populatedEntry = entry;
        if (![
            EVENTS.ENTRY_DELETE,
            EVENTS.ENTRY_UNPUBLISH
        ].includes(eventName)) {
            populatedEntry = await strapi.db.query(uid).findOne({
                where: {
                    id: entry.id
                },
                populate
            });
        }
        const sanitizedEntry = await strapiUtils.sanitize.sanitizers.defaultSanitizeOutput({
            schema: model,
            getModel: (uid)=>strapi.getModel(uid)
        }, populatedEntry);
        await strapi.eventHub.emit(eventName, {
            model: model.modelName,
            uid: model.uid,
            entry: sanitizedEntry
        });
    };
    return {
        /**
     * strapi.db.query might reuse the transaction used in the doc service request,
     * so this is executed after that transaction is committed.
     */ emitEvent (eventName, entry) {
            strapi.db.transaction(({ onCommit })=>{
                onCommit(()=>emitEvent(eventName, entry));
            });
        }
    };
};

/**
 * Loads lingering relations that need to be updated when overriding a published or draft entry.
 * This is necessary because the relations are uni-directional and the target entry is not aware of the source entry.
 * This is not the case for bi-directional relations, where the target entry is also linked to the source entry.
 */ const load$1 = async (uid, { oldVersions, newVersions })=>{
    const updates = [];
    // Iterate all components and content types to find relations that need to be updated
    await strapi.db.transaction(async ({ trx })=>{
        const contentTypes = Object.values(strapi.contentTypes);
        const components = Object.values(strapi.components);
        for (const model of [
            ...contentTypes,
            ...components
        ]){
            const dbModel = strapi.db.metadata.get(model.uid);
            for (const attribute of Object.values(dbModel.attributes)){
                /**
         * Only consider unidirectional relations
         */ if (attribute.type !== 'relation' || attribute.target !== uid || attribute.inversedBy || attribute.mappedBy) {
                    continue;
                }
                // TODO: joinColumn relations
                const joinTable = attribute.joinTable;
                if (!joinTable) {
                    continue;
                }
                const { name: sourceColumnName } = joinTable.joinColumn;
                const { name: targetColumnName } = joinTable.inverseJoinColumn;
                /**
         * Load all relations that need to be updated
         */ // NOTE: when the model has draft and publish, we can assume relation are only draft to draft & published to published
                const ids = oldVersions.map((entry)=>entry.id);
                const oldVersionsRelations = await strapi.db.getConnection().select('*').from(joinTable.name).whereIn(targetColumnName, ids).transacting(trx);
                if (oldVersionsRelations.length > 0) {
                    updates.push({
                        joinTable,
                        relations: oldVersionsRelations
                    });
                }
                /**
         * if publishing
         *  if published version exists
         *    updated published versions links
         *  else
         *    create link to newly published version
         *
         * if discarding
         *    if published version link exists & not draft version link
         *       create link to new draft version
         */ if (!model.options?.draftAndPublish) {
                    const ids = newVersions.map((entry)=>entry.id);
                    const newVersionsRelations = await strapi.db.getConnection().select('*').from(joinTable.name).whereIn(targetColumnName, ids).transacting(trx);
                    if (newVersionsRelations.length > 0) {
                        // when publishing a draft that doesn't have a published version yet,
                        // copy the links to the draft over to the published version
                        // when discarding a published version, if no drafts exists
                        const discardToAdd = newVersionsRelations.filter((relation)=>{
                            const matchingOldVerion = oldVersionsRelations.find((oldRelation)=>{
                                return oldRelation[sourceColumnName] === relation[sourceColumnName];
                            });
                            return !matchingOldVerion;
                        }).map(fp.omit('id'));
                        updates.push({
                            joinTable,
                            relations: discardToAdd
                        });
                    }
                }
            }
        }
    });
    return updates;
};
/**
 * Updates uni directional relations to target the right entries when overriding published or draft entries.
 *
 * @param oldEntries The old entries that are being overridden
 * @param newEntries The new entries that are overriding the old ones
 * @param oldRelations The relations that were previously loaded with `load` @see load
 */ const sync$1 = async (oldEntries, newEntries, oldRelations)=>{
    /**
   * Create a map of old entry ids to new entry ids
   *
   * Will be used to update the relation target ids
   */ const newEntryByLocale = fp.keyBy('locale', newEntries);
    const oldEntriesMap = oldEntries.reduce((acc, entry)=>{
        const newEntry = newEntryByLocale[entry.locale];
        if (!newEntry) return acc;
        acc[entry.id] = newEntry.id;
        return acc;
    }, {});
    await strapi.db.transaction(async ({ trx })=>{
        // Iterate old relations that are deleted and insert the new ones
        for (const { joinTable, relations } of oldRelations){
            // Update old ids with the new ones
            const column = joinTable.inverseJoinColumn.name;
            const newRelations = relations.map((relation)=>{
                const newId = oldEntriesMap[relation[column]];
                return {
                    ...relation,
                    [column]: newId
                };
            });
            // Insert those relations into the join table
            await trx.batchInsert(joinTable.name, newRelations, 1000);
        }
    });
};

/**
 * Loads all bidirectional relations that need to be synchronized when content entries change state
 * (e.g., during publish/unpublish operations).
 *
 * In Strapi, bidirectional relations allow maintaining order from both sides of the relation.
 * When an entry is published, the following occurs:
 *
 * 1. The old published entry is deleted
 * 2. A new entry is created with all its relations
 *
 * This process affects relation ordering in the following way:
 *
 * Initial state (Entry A related to X, Y, Z):
 * ```
 *   Entry A (draft)     Entry A (published)
 *      │                     │
 *      ├──(1)→ X            ├──(1)→ X
 *      ├──(2)→ Y            ├──(2)→ Y
 *      └──(3)→ Z            └──(3)→ Z
 *
 *   X's perspective:         Y's perspective:         Z's perspective:
 *      └──(2)→ Entry A         └──(1)→ Entry A         └──(3)→ Entry A
 * ```
 *
 * After publishing Entry A (without relation order sync):
 * ```
 *   Entry A (draft)     Entry A (new published)
 *      │                     │
 *      ├──(1)→ X            ├──(1)→ X
 *      ├──(2)→ Y            ├──(2)→ Y
 *      └──(3)→ Z            └──(3)→ Z
 *
 *   X's perspective:         Y's perspective:         Z's perspective:
 *      └──(3)→ Entry A         └──(3)→ Entry A         └──(3)→ Entry A
 *                           (all relations appear last in order)
 * ```
 *
 * This module preserves the original ordering from both perspectives by:
 * 1. Capturing the relation order before the entry state changes
 * 2. Restoring this order after the new relations are created
 *
 * @param uid - The unique identifier of the content type being processed
 * @param context - Object containing arrays of old and new entry versions
 * @returns Array of objects containing join table metadata and relations to be updated
 */ const load = async (uid, { oldVersions })=>{
    const relationsToUpdate = [];
    await strapi.db.transaction(async ({ trx })=>{
        const contentTypes = Object.values(strapi.contentTypes);
        const components = Object.values(strapi.components);
        for (const model of [
            ...contentTypes,
            ...components
        ]){
            const dbModel = strapi.db.metadata.get(model.uid);
            for (const attribute of Object.values(dbModel.attributes)){
                // Skip if not a bidirectional relation targeting our content type
                if (attribute.type !== 'relation' || attribute.target !== uid || !(attribute.inversedBy || attribute.mappedBy)) {
                    continue;
                }
                // If it's a self referencing relation, there is no need to sync any relation
                // The order will already be handled as both sides are inside the same content type
                if (model.uid === uid) {
                    continue;
                }
                const joinTable = attribute.joinTable;
                if (!joinTable) {
                    continue;
                }
                const { name: targetColumnName } = joinTable.inverseJoinColumn;
                // Load all relations that need their order preserved
                const oldEntryIds = oldVersions.map((entry)=>entry.id);
                const existingRelations = await strapi.db.getConnection().select('*').from(joinTable.name).whereIn(targetColumnName, oldEntryIds).transacting(trx);
                if (existingRelations.length > 0) {
                    relationsToUpdate.push({
                        joinTable,
                        relations: existingRelations
                    });
                }
            }
        }
    });
    return relationsToUpdate;
};
/**
 * Synchronizes the order of bidirectional relations after content entries have changed state.
 *
 * When entries change state (e.g., draft → published), their IDs change and all relations are recreated.
 * While the order of relations from the entry's perspective is maintained (as they're created in order),
 * the inverse relations (from related entries' perspective) would all appear last in order since they're new.
 *
 * Example:
 * ```
 * Before publish:
 *   Article(id:1) →(order:1)→ Category(id:5)
 *   Category(id:5) →(order:3)→ Article(id:1)
 *
 * After publish (without sync):
 *   Article(id:2) →(order:1)→ Category(id:5)    [order preserved]
 *   Category(id:5) →(order:99)→ Article(id:2)   [order lost - appears last]
 *
 * After sync:
 *   Article(id:2) →(order:1)→ Category(id:5)    [order preserved]
 *   Category(id:5) →(order:3)→ Article(id:2)    [order restored]
 * ```
 *
 * @param oldEntries - Array of previous entry versions with their IDs and locales
 * @param newEntries - Array of new entry versions with their IDs and locales
 * @param existingRelations - Array of join table data containing the relations to be updated
 */ const sync = async (oldEntries, newEntries, existingRelations)=>{
    // Group new entries by locale for easier lookup
    const newEntriesByLocale = fp.keyBy('locale', newEntries);
    // Create a mapping of old entry IDs to new entry IDs based on locale
    const entryIdMapping = oldEntries.reduce((acc, oldEntry)=>{
        const newEntry = newEntriesByLocale[oldEntry.locale];
        if (!newEntry) return acc;
        acc[oldEntry.id] = newEntry.id;
        return acc;
    }, {});
    await strapi.db.transaction(async ({ trx })=>{
        for (const { joinTable, relations } of existingRelations){
            const sourceColumn = joinTable.inverseJoinColumn.name;
            const targetColumn = joinTable.joinColumn.name;
            const orderColumn = joinTable.orderColumnName;
            // Failsafe in case those don't exist
            if (!sourceColumn || !targetColumn || !orderColumn) {
                continue;
            }
            // Update order values for each relation
            // TODO: Find a way to batch it more efficiently
            await strapiUtils.async.map(relations, (relation)=>{
                const { [sourceColumn]: oldSourceId, [targetColumn]: targetId, [orderColumn]: originalOrder } = relation;
                // Update the order column for the new relation entry
                return trx.from(joinTable.name).where(sourceColumn, entryIdMapping[oldSourceId]).where(targetColumn, targetId).update({
                    [orderColumn]: originalOrder
                });
            });
        }
    });
};

const textNodeValidator = strapiUtils.yup.object().shape({
    type: strapiUtils.yup.string().equals([
        'text'
    ]).required(),
    text: strapiUtils.yup.string().test('is-valid-text', 'Text must be defined with at least an empty string', (text)=>{
        return typeof text === 'string' || text === '';
    }),
    bold: strapiUtils.yup.boolean(),
    italic: strapiUtils.yup.boolean(),
    underline: strapiUtils.yup.boolean(),
    strikethrough: strapiUtils.yup.boolean(),
    code: strapiUtils.yup.boolean()
});
const checkValidLink = (link)=>{
    try {
        // eslint-disable-next-line no-new
        new URL(link.startsWith('/') ? `https://strapi.io${link}` : link);
    } catch (error) {
        return false;
    }
    return true;
};
const linkNodeValidator = strapiUtils.yup.object().shape({
    type: strapiUtils.yup.string().equals([
        'link'
    ]).required(),
    url: strapiUtils.yup.string().test('invalid-url', 'Please specify a valid link.', (value)=>checkValidLink(value ?? '')),
    children: strapiUtils.yup.array().of(textNodeValidator).required()
});
// TODO: remove any with a correct Type
const inlineNodeValidator = strapiUtils.yup.lazy((value)=>{
    switch(value.type){
        case 'text':
            return textNodeValidator;
        case 'link':
            return linkNodeValidator;
        default:
            return strapiUtils.yup.mixed().test('invalid-type', 'Inline node must be Text or Link', ()=>{
                return false;
            });
    }
});
const paragraphNodeValidator = strapiUtils.yup.object().shape({
    type: strapiUtils.yup.string().equals([
        'paragraph'
    ]).required(),
    children: strapiUtils.yup.array().of(inlineNodeValidator).min(1, 'Paragraph node children must have at least one Text or Link node').required()
});
const headingNodeValidator = strapiUtils.yup.object().shape({
    type: strapiUtils.yup.string().equals([
        'heading'
    ]).required(),
    level: strapiUtils.yup.number().oneOf([
        1,
        2,
        3,
        4,
        5,
        6
    ]).required(),
    children: strapiUtils.yup.array().of(inlineNodeValidator).min(1, 'Heading node children must have at least one Text or Link node').required()
});
const quoteNodeValidator = strapiUtils.yup.object().shape({
    type: strapiUtils.yup.string().equals([
        'quote'
    ]).required(),
    children: strapiUtils.yup.array().of(inlineNodeValidator).min(1, 'Quote node children must have at least one Text or Link node').required()
});
const codeBlockValidator = strapiUtils.yup.object().shape({
    type: strapiUtils.yup.string().equals([
        'code'
    ]).required(),
    syntax: strapiUtils.yup.string().nullable(),
    children: strapiUtils.yup.array().of(textNodeValidator).min(1, 'Quote node children must have at least one Text or Link node').required()
});
const listItemNode = strapiUtils.yup.object().shape({
    type: strapiUtils.yup.string().equals([
        'list-item'
    ]).required(),
    children: strapiUtils.yup.array().of(inlineNodeValidator).required()
});
// Allow children to be either a listItemNode or a listNode itself
// @ts-expect-error - listChildrenValidator needs a type
const listChildrenValidator = strapiUtils.yup.lazy((value)=>{
    switch(value.type){
        case 'list':
            return listNodeValidator;
        case 'list-item':
            return listItemNode;
        default:
            return strapiUtils.yup.mixed().test('invalid-type', 'Inline node must be list-item or list', ()=>{
                return false;
            });
    }
});
// @ts-expect-error - listNodeValidator needs a type
const listNodeValidator = strapiUtils.yup.object().shape({
    type: strapiUtils.yup.string().equals([
        'list'
    ]).required(),
    format: strapiUtils.yup.string().equals([
        'ordered',
        'unordered'
    ]).required(),
    children: strapiUtils.yup.array().of(listChildrenValidator).min(1, 'List node children must have at least one ListItem or ListNode').required()
});
const imageNodeValidator = strapiUtils.yup.object().shape({
    type: strapiUtils.yup.string().equals([
        'image'
    ]).required(),
    image: strapiUtils.yup.object().shape({
        name: strapiUtils.yup.string().required(),
        alternativeText: strapiUtils.yup.string().nullable(),
        url: strapiUtils.yup.string().required(),
        caption: strapiUtils.yup.string().nullable(),
        width: strapiUtils.yup.number().required(),
        height: strapiUtils.yup.number().required(),
        formats: strapiUtils.yup.object().required(),
        hash: strapiUtils.yup.string().required(),
        ext: strapiUtils.yup.string().required(),
        mime: strapiUtils.yup.string().required(),
        size: strapiUtils.yup.number().required(),
        previewUrl: strapiUtils.yup.string().nullable(),
        provider: strapiUtils.yup.string().required(),
        provider_metadata: strapiUtils.yup.mixed().nullable(),
        createdAt: strapiUtils.yup.string().required(),
        updatedAt: strapiUtils.yup.string().required()
    }),
    children: strapiUtils.yup.array().of(inlineNodeValidator).required()
});
// TODO: remove the any and replace with a correct Type
const blockNodeValidator = strapiUtils.yup.lazy((value)=>{
    switch(value.type){
        case 'paragraph':
            return paragraphNodeValidator;
        case 'heading':
            return headingNodeValidator;
        case 'quote':
            return quoteNodeValidator;
        case 'list':
            return listNodeValidator;
        case 'image':
            return imageNodeValidator;
        case 'code':
            return codeBlockValidator;
        default:
            return strapiUtils.yup.mixed().test('invalid-type', 'Block node is of invalid type', ()=>{
                return false;
            });
    }
});
const blocksValidatorSchema = strapiUtils.yup.array().of(blockNodeValidator);
const blocksValidator = ()=>blocksValidatorSchema;

/* Validator utils */ /**
 * Adds minLength validator
 */ const addMinLengthValidator = (validator, { attr }, { isDraft })=>{
    return attr.minLength && _.isInteger(attr.minLength) && !isDraft ? validator.min(attr.minLength) : validator;
};
/**
 * Adds maxLength validator
 * @returns {StringSchema}
 */ const addMaxLengthValidator = (validator, { attr })=>{
    return attr.maxLength && _.isInteger(attr.maxLength) ? validator.max(attr.maxLength) : validator;
};
/**
 * Adds min integer validator
 * @returns {NumberSchema}
 */ const addMinIntegerValidator = (validator, { attr }, { isDraft })=>_.isNumber(attr.min) && !isDraft ? validator.min(_.toInteger(attr.min)) : validator;
/**
 * Adds max integer validator
 */ const addMaxIntegerValidator = (validator, { attr })=>_.isNumber(attr.max) ? validator.max(_.toInteger(attr.max)) : validator;
/**
 * Adds min float/decimal validator
 */ const addMinFloatValidator = (validator, { attr }, { isDraft })=>_.isNumber(attr.min) && !isDraft ? validator.min(attr.min) : validator;
/**
 * Adds max float/decimal validator
 */ const addMaxFloatValidator = (validator, { attr })=>_.isNumber(attr.max) ? validator.max(attr.max) : validator;
/**
 * Adds regex validator
 */ const addStringRegexValidator = (validator, { attr }, { isDraft })=>{
    return 'regex' in attr && !_.isUndefined(attr.regex) && !isDraft ? validator.matches(new RegExp(attr.regex), {
        excludeEmptyString: !attr.required
    }) : validator;
};
const addUniqueValidator = (validator, { attr, model, updatedAttribute, entity, componentContext }, options)=>{
    if (attr.type !== 'uid' && !attr.unique) {
        return validator;
    }
    const validateUniqueFieldWithinComponent = async (value)=>{
        if (!componentContext) {
            return false;
        }
        // If we are validating a unique field within a repeatable component,
        // we first need to ensure that the repeatable in the current entity is
        // valid against itself.
        const hasRepeatableData = componentContext.repeatableData.length > 0;
        if (hasRepeatableData) {
            const { name: updatedName, value: updatedValue } = updatedAttribute;
            // Construct the full path to the unique field within the component.
            const pathToCheck = [
                ...componentContext.pathToComponent.slice(1),
                updatedName
            ].join('.');
            // Extract the values from the repeatable data using the constructed path
            const values = componentContext.repeatableData.map((item)=>{
                return pathToCheck.split('.').reduce((acc, key)=>acc[key], item);
            });
            // Check if the value is repeated in the current entity
            const isUpdatedAttributeRepeatedInThisEntity = values.filter((value)=>value === updatedValue).length > 1;
            if (isUpdatedAttributeRepeatedInThisEntity) {
                return false;
            }
        }
        /**
     * When `componentContext` is present it means we are dealing with a unique
     * field within a component.
     *
     * The unique validation must consider the specific context of the
     * component, which will always be contained within a parent content type
     * and may also be nested within another component.
     *
     * We construct a query that takes into account the parent's model UID,
     * dimensions (such as draft and publish state/locale) and excludes the current
     * content type entity by its ID if provided.
     */ const { model: parentModel, options: parentOptions, id: excludeId } = componentContext.parentContent;
        const whereConditions = {};
        const isParentDraft = parentOptions && parentOptions.isDraft;
        whereConditions.publishedAt = isParentDraft ? null : {
            $notNull: true
        };
        if (parentOptions?.locale) {
            whereConditions.locale = parentOptions.locale;
        }
        if (excludeId && !Number.isNaN(excludeId)) {
            whereConditions.id = {
                $ne: excludeId
            };
        }
        const queryUid = parentModel.uid;
        const queryWhere = {
            ...componentContext.pathToComponent.reduceRight((acc, key)=>({
                    [key]: acc
                }), {
                [updatedAttribute.name]: value
            }),
            ...whereConditions
        };
        // The validation should pass if there is no other record found from the query
        return !await strapi.db.query(queryUid).findOne({
            where: queryWhere
        });
    };
    const validateUniqueFieldWithinDynamicZoneComponent = async (startOfPath)=>{
        if (!componentContext) {
            return false;
        }
        const targetComponentUID = model.uid;
        // Ensure that the value is unique within the dynamic zone in this entity.
        const countOfValueInThisEntity = (componentContext?.fullDynamicZoneContent ?? []).reduce((acc, component)=>{
            if (component.__component !== targetComponentUID) {
                return acc;
            }
            const updatedValue = component[updatedAttribute.name];
            return updatedValue === updatedAttribute.value ? acc + 1 : acc;
        }, 0);
        if (countOfValueInThisEntity > 1) {
            // If the value is repeated in the current entity, the validation fails.
            return false;
        }
        // Populate the dynamic zone for any components that share the same value
        // as the updated attribute.
        const query = {
            select: [
                'id'
            ],
            where: {},
            populate: {
                [startOfPath]: {
                    on: {
                        [targetComponentUID]: {
                            select: [
                                'id'
                            ],
                            where: {
                                [updatedAttribute.name]: updatedAttribute.value
                            }
                        }
                    }
                }
            }
        };
        const { options, id } = componentContext.parentContent;
        if (options?.isDraft !== undefined) {
            query.where.published_at = options.isDraft ? {
                $eq: null
            } : {
                $ne: null
            };
        }
        if (id) {
            query.where.id = {
                $ne: id
            };
        }
        if (options?.locale) {
            query.where.locale = options.locale;
        }
        const parentModelQueryResult = await strapi.db.query(componentContext.parentContent.model.uid).findMany(query);
        // Filter the results to only include results that have components in the
        // dynamic zone that match the target component type.
        const filteredResults = parentModelQueryResult.filter((result)=>Array.isArray(result[startOfPath]) && result[startOfPath].length).flatMap((result)=>result[startOfPath]).filter((dynamicZoneComponent)=>dynamicZoneComponent.__component === targetComponentUID);
        if (filteredResults.length >= 1) {
            return false;
        }
        return true;
    };
    return validator.test('unique', 'This attribute must be unique', async (value)=>{
        /**
     * If the attribute value is `null` or an empty string we want to skip the unique validation.
     * Otherwise it'll only accept a single entry with that value in the database.
     */ if (_.isNil(value) || value === '') {
            return true;
        }
        /**
     * We don't validate any unique constraint for draft entries.
     */ if (options.isDraft) {
            return true;
        }
        const hasPathToComponent = componentContext && componentContext.pathToComponent.length > 0;
        if (hasPathToComponent) {
            // Detect if we are validating within a dynamiczone by checking if the first
            // path is a dynamiczone attribute in the parent content type.
            const startOfPath = componentContext.pathToComponent[0];
            const testingDZ = componentContext.parentContent.model.attributes[startOfPath].type === 'dynamiczone';
            if (testingDZ) {
                return validateUniqueFieldWithinDynamicZoneComponent(startOfPath);
            }
            return validateUniqueFieldWithinComponent(value);
        }
        /**
     * Here we are validating a scalar unique field from the content type's schema.
     * We construct a query to check if the value is unique
     * considering dimensions (e.g. locale, publication state) and excluding the current entity by its ID if available.
     */ const scalarAttributeWhere = {
            [updatedAttribute.name]: value,
            publishedAt: {
                $notNull: true
            }
        };
        if (options?.locale) {
            scalarAttributeWhere.locale = options.locale;
        }
        if (entity?.id) {
            scalarAttributeWhere.id = {
                $ne: entity.id
            };
        }
        // The validation should pass if there is no other record found from the query
        return !await strapi.db.query(model.uid).findOne({
            where: scalarAttributeWhere,
            select: [
                'id'
            ]
        });
    });
};
/* Type validators */ const stringValidator = (metas, options)=>{
    let schema = strapiUtils.yup.string().transform((val, originalVal)=>originalVal);
    schema = addMinLengthValidator(schema, metas, options);
    schema = addMaxLengthValidator(schema, metas);
    schema = addStringRegexValidator(schema, metas, options);
    schema = addUniqueValidator(schema, metas, options);
    return schema;
};
const emailValidator = (metas, options)=>{
    const schema = stringValidator(metas, options);
    if (options.isDraft) {
        return schema;
    }
    return schema.email().min(1, // eslint-disable-next-line no-template-curly-in-string
    '${path} cannot be empty');
};
const uidValidator = (metas, options)=>{
    const schema = stringValidator(metas, options);
    if (options.isDraft) {
        return schema;
    }
    return schema.matches(/^[A-Za-z0-9-_.~]*$/);
};
const enumerationValidator = ({ attr })=>{
    return strapiUtils.yup.string().oneOf((Array.isArray(attr.enum) ? attr.enum : [
        attr.enum
    ]).concat(null));
};
const integerValidator = (metas, options)=>{
    let schema = strapiUtils.yup.number().integer();
    schema = addMinIntegerValidator(schema, metas, options);
    schema = addMaxIntegerValidator(schema, metas);
    schema = addUniqueValidator(schema, metas, options);
    return schema;
};
const floatValidator = (metas, options)=>{
    let schema = strapiUtils.yup.number();
    schema = addMinFloatValidator(schema, metas, options);
    schema = addMaxFloatValidator(schema, metas);
    schema = addUniqueValidator(schema, metas, options);
    return schema;
};
const bigintegerValidator = (metas, options)=>{
    const schema = strapiUtils.yup.mixed();
    return addUniqueValidator(schema, metas, options);
};
const datesValidator = (metas, options)=>{
    const schema = strapiUtils.yup.mixed();
    return addUniqueValidator(schema, metas, options);
};
const Validators = {
    string: stringValidator,
    text: stringValidator,
    richtext: stringValidator,
    password: stringValidator,
    email: emailValidator,
    enumeration: enumerationValidator,
    boolean: ()=>strapiUtils.yup.boolean(),
    uid: uidValidator,
    json: ()=>strapiUtils.yup.mixed(),
    integer: integerValidator,
    biginteger: bigintegerValidator,
    float: floatValidator,
    decimal: floatValidator,
    date: datesValidator,
    time: datesValidator,
    datetime: datesValidator,
    timestamp: datesValidator,
    blocks: blocksValidator
};

const { yup, validateYupSchema } = strapiUtils;
const { isMediaAttribute, isScalarAttribute, getWritableAttributes } = strapiUtils.contentTypes;
const { ValidationError: ValidationError$1 } = strapiUtils.errors;
const isInteger = (value)=>Number.isInteger(value);
const addMinMax = (validator, { attr, updatedAttribute })=>{
    let nextValidator = validator;
    if (isInteger(attr.min) && ('required' in attr && attr.required || Array.isArray(updatedAttribute.value) && updatedAttribute.value.length > 0)) {
        nextValidator = nextValidator.min(attr.min);
    }
    if (isInteger(attr.max)) {
        nextValidator = nextValidator.max(attr.max);
    }
    return nextValidator;
};
const addRequiredValidation = (createOrUpdate)=>{
    return (validator, { attr: { required } })=>{
        let nextValidator = validator;
        if (required) {
            if (createOrUpdate === 'creation') {
                nextValidator = nextValidator.notNil();
            } else if (createOrUpdate === 'update') {
                nextValidator = nextValidator.notNull();
            }
        } else {
            nextValidator = nextValidator.nullable();
        }
        return nextValidator;
    };
};
const addDefault = (createOrUpdate)=>{
    return (validator, { attr })=>{
        let nextValidator = validator;
        if (createOrUpdate === 'creation') {
            if ((attr.type === 'component' && attr.repeatable || attr.type === 'dynamiczone') && !attr.required) {
                nextValidator = nextValidator.default([]);
            } else {
                nextValidator = nextValidator.default(attr.default);
            }
        } else {
            nextValidator = nextValidator.default(undefined);
        }
        return nextValidator;
    };
};
const preventCast = (validator)=>validator.transform((val, originalVal)=>originalVal);
const createComponentValidator = (createOrUpdate)=>({ attr, updatedAttribute, componentContext }, { isDraft })=>{
        const model = strapi.getModel(attr.component);
        if (!model) {
            throw new Error('Validation failed: Model not found');
        }
        if (attr?.repeatable) {
            // FIXME: yup v1
            let validator = yup.array().of(yup.lazy((item)=>createModelValidator(createOrUpdate)({
                    componentContext,
                    model,
                    data: item
                }, {
                    isDraft
                }).notNull()));
            validator = addRequiredValidation(createOrUpdate)(validator, {
                attr: {
                    required: true
                },
                updatedAttribute
            });
            if (!isDraft) {
                validator = addMinMax(validator, {
                    attr,
                    updatedAttribute
                });
            }
            return validator;
        }
        let validator = createModelValidator(createOrUpdate)({
            model,
            data: updatedAttribute.value,
            componentContext
        }, {
            isDraft
        });
        validator = addRequiredValidation(createOrUpdate)(validator, {
            attr: {
                required: !isDraft && attr.required
            },
            updatedAttribute
        });
        return validator;
    };
const createDzValidator = (createOrUpdate)=>({ attr, updatedAttribute, componentContext }, { isDraft })=>{
        let validator;
        validator = yup.array().of(yup.lazy((item)=>{
            const model = strapi.getModel(fp.prop('__component', item));
            const schema = yup.object().shape({
                __component: yup.string().required().oneOf(Object.keys(strapi.components))
            }).notNull();
            return model ? schema.concat(createModelValidator(createOrUpdate)({
                model,
                data: item,
                componentContext
            }, {
                isDraft
            })) : schema;
        }));
        validator = addRequiredValidation(createOrUpdate)(validator, {
            attr: {
                required: true
            },
            updatedAttribute
        });
        if (!isDraft) {
            validator = addMinMax(validator, {
                attr,
                updatedAttribute
            });
        }
        return validator;
    };
const createRelationValidator = ({ updatedAttribute })=>{
    let validator;
    if (Array.isArray(updatedAttribute.value)) {
        validator = yup.array().of(yup.mixed());
    } else {
        validator = yup.mixed();
    }
    return validator;
};
const createScalarAttributeValidator = (createOrUpdate)=>(metas, options)=>{
        let validator;
        if (fp.has(metas.attr.type, Validators)) {
            validator = Validators[metas.attr.type](metas, options);
        } else {
            // No validators specified - fall back to mixed
            validator = yup.mixed();
        }
        validator = addRequiredValidation(createOrUpdate)(validator, {
            attr: {
                required: !options.isDraft && metas.attr.required
            },
            updatedAttribute: metas.updatedAttribute
        });
        return validator;
    };
const createAttributeValidator = (createOrUpdate)=>(metas, options)=>{
        let validator = yup.mixed();
        if (isMediaAttribute(metas.attr)) {
            validator = yup.mixed();
        } else if (isScalarAttribute(metas.attr)) {
            validator = createScalarAttributeValidator(createOrUpdate)(metas, options);
        } else {
            if (metas.attr.type === 'component' && metas.componentContext) {
                // Build the path to the component within the parent content type schema.
                const pathToComponent = [
                    ...metas?.componentContext?.pathToComponent ?? [],
                    metas.updatedAttribute.name
                ];
                // If working with a repeatable component, determine the repeatable data
                // based on the component's path.
                // In order to validate the repeatable within this entity we need
                // access to the full repeatable data. In case we are validating a
                // nested component within a repeatable.
                // Hence why we set this up when the path to the component is only one level deep.
                const repeatableData = metas.attr.repeatable && pathToComponent.length === 1 ? metas.updatedAttribute.value : metas.componentContext?.repeatableData;
                const newComponentContext = {
                    ...metas.componentContext,
                    pathToComponent,
                    repeatableData
                };
                validator = createComponentValidator(createOrUpdate)({
                    componentContext: newComponentContext,
                    attr: metas.attr,
                    updatedAttribute: metas.updatedAttribute
                }, options);
            } else if (metas.attr.type === 'dynamiczone' && metas.componentContext) {
                const newComponentContext = {
                    ...metas.componentContext,
                    fullDynamicZoneContent: metas.updatedAttribute.value,
                    pathToComponent: [
                        ...metas.componentContext.pathToComponent,
                        metas.updatedAttribute.name
                    ]
                };
                Object.assign(metas, {
                    componentContext: newComponentContext
                });
                validator = createDzValidator(createOrUpdate)(metas, options);
            } else if (metas.attr.type === 'relation') {
                validator = createRelationValidator({
                    attr: metas.attr,
                    updatedAttribute: metas.updatedAttribute
                });
            }
            validator = preventCast(validator);
        }
        validator = addDefault(createOrUpdate)(validator, metas);
        return validator;
    };
const createModelValidator = (createOrUpdate)=>({ componentContext, model, data, entity }, options)=>{
        const writableAttributes = model ? getWritableAttributes(model) : [];
        const schema = writableAttributes.reduce((validators, attributeName)=>{
            const metas = {
                attr: model.attributes[attributeName],
                updatedAttribute: {
                    name: attributeName,
                    value: fp.prop(attributeName, data)
                },
                model,
                entity,
                componentContext
            };
            const validator = createAttributeValidator(createOrUpdate)(metas, options);
            validators[attributeName] = validator;
            return validators;
        }, {});
        return yup.object().shape(schema);
    };
const createValidateEntity = (createOrUpdate)=>{
    return async (model, data, options, entity)=>{
        if (!fp.isObject(data)) {
            const { displayName } = model.info;
            throw new ValidationError$1(`Invalid payload submitted for the ${createOrUpdate} of an entity of type ${displayName}. Expected an object, but got ${typeof data}`);
        }
        const validator = createModelValidator(createOrUpdate)({
            model,
            data,
            entity,
            componentContext: {
                // Set up the initial component context.
                // Keeping track of parent content type context in which a component will be used.
                // This is necessary to validate component field constraints such as uniqueness.
                parentContent: {
                    id: entity?.id,
                    model,
                    options
                },
                pathToComponent: [],
                repeatableData: []
            }
        }, {
            isDraft: options?.isDraft ?? false,
            locale: options?.locale ?? null
        }).test('relations-test', 'check that all relations exist', async function relationsValidation(data) {
            try {
                await checkRelationsExist(buildRelationsStore({
                    uid: model.uid,
                    data
                }));
            } catch (e) {
                return this.createError({
                    path: this.path,
                    message: e instanceof ValidationError$1 && e.message || 'Invalid relations'
                });
            }
            return true;
        }).required();
        return validateYupSchema(validator, {
            strict: false,
            abortEarly: false
        })(data);
    };
};
/**
 * Builds an object containing all the media and relations being associated with an entity
 */ const buildRelationsStore = ({ uid, data })=>{
    if (!uid) {
        throw new ValidationError$1(`Cannot build relations store: "uid" is undefined`);
    }
    if (fp.isEmpty(data)) {
        return {};
    }
    const currentModel = strapi.getModel(uid);
    return Object.keys(currentModel.attributes).reduce((result, attributeName)=>{
        const attribute = currentModel.attributes[attributeName];
        const value = data[attributeName];
        if (_.isNil(value)) {
            return result;
        }
        switch(attribute.type){
            case 'relation':
            case 'media':
                {
                    if (attribute.type === 'relation' && (attribute.relation === 'morphToMany' || attribute.relation === 'morphToOne')) {
                        break;
                    }
                    const target = // eslint-disable-next-line no-nested-ternary
                    attribute.type === 'media' ? 'plugin::upload.file' : attribute.target;
                    // As there are multiple formats supported for associating relations
                    // with an entity, the value here can be an: array, object or number.
                    let source;
                    if (Array.isArray(value)) {
                        source = value;
                    } else if (fp.isObject(value)) {
                        if ('connect' in value && !_.isNil(value.connect)) {
                            source = value.connect;
                        } else if ('set' in value && !_.isNil(value.set)) {
                            source = value.set;
                        } else {
                            source = [];
                        }
                    } else {
                        source = _.castArray(value);
                    }
                    const idArray = source.map((v)=>({
                            id: typeof v === 'object' ? v.id : v
                        }));
                    // Update the relationStore to keep track of all associations being made
                    // with relations and media.
                    result[target] = result[target] || [];
                    result[target].push(...idArray);
                    break;
                }
            case 'component':
                {
                    return _.castArray(value).reduce((relationsStore, componentValue)=>{
                        if (!attribute.component) {
                            throw new ValidationError$1(`Cannot build relations store from component, component identifier is undefined`);
                        }
                        return _.mergeWith(relationsStore, buildRelationsStore({
                            uid: attribute.component,
                            data: componentValue
                        }), (objValue, srcValue)=>{
                            if (_.isArray(objValue)) {
                                return objValue.concat(srcValue);
                            }
                        });
                    }, result);
                }
            case 'dynamiczone':
                {
                    return _.castArray(value).reduce((relationsStore, dzValue)=>{
                        const value = dzValue;
                        if (!value.__component) {
                            throw new ValidationError$1(`Cannot build relations store from dynamiczone, component identifier is undefined`);
                        }
                        return _.mergeWith(relationsStore, buildRelationsStore({
                            uid: value.__component,
                            data: value
                        }), (objValue, srcValue)=>{
                            if (_.isArray(objValue)) {
                                return objValue.concat(srcValue);
                            }
                        });
                    }, result);
                }
        }
        return result;
    }, {});
};
/**
 * Iterate through the relations store and validates that every relation or media
 * mentioned exists
 */ const checkRelationsExist = async (relationsStore = {})=>{
    const promises = [];
    for (const [key, value] of Object.entries(relationsStore)){
        const evaluate = async ()=>{
            const uniqueValues = _.uniqBy(value, `id`);
            const count = await strapi.db.query(key).count({
                where: {
                    id: {
                        $in: uniqueValues.map((v)=>v.id)
                    }
                }
            });
            if (count !== uniqueValues.length) {
                throw new ValidationError$1(`${uniqueValues.length - count} relation(s) of type ${key} associated with this entity do not exist`);
            }
        };
        promises.push(evaluate());
    }
    return Promise.all(promises);
};
const entityValidator = {
    validateEntityCreation: createValidateEntity('creation'),
    validateEntityUpdate: createValidateEntity('update')
};

const { validators } = strapiUtils.validate;
// we have to typecast to reconcile the differences between validator and database getModel
const getModel = (schema)=>strapi.getModel(schema);
const createContentTypeRepository = (uid, validator = entityValidator)=>{
    const contentType = strapi.contentType(uid);
    const hasDraftAndPublish = strapiUtils.contentTypes.hasDraftAndPublish(contentType);
    // Define the validations that should be performed
    const sortValidations = [
        'nonAttributesOperators',
        'dynamicZones',
        'morphRelations'
    ];
    const fieldValidations = [
        'scalarAttributes'
    ];
    const filtersValidations = [
        'nonAttributesOperators',
        'dynamicZones',
        'morphRelations'
    ];
    const populateValidations = {
        sort: sortValidations,
        field: fieldValidations,
        filters: filtersValidations,
        populate: [
            'nonAttributesOperators'
        ]
    };
    const validateParams = async (params)=>{
        const ctx = {
            schema: contentType,
            getModel
        };
        await validators.validateFilters(ctx, params.filters, filtersValidations);
        await validators.validateSort(ctx, params.sort, sortValidations);
        await validators.validateFields(ctx, params.fields, fieldValidations);
        await validators.validatePopulate(ctx, params.populate, populateValidations);
        // Strip lookup from params, it's only used internally
        if (params.lookup) {
            throw new strapiUtils.errors.ValidationError("Invalid params: 'lookup'");
        }
        // TODO: add validate status, locale, pagination
        return params;
    };
    const entries = createEntriesService(uid, validator);
    const eventManager = createEventManager(strapi, uid);
    const emitEvent = fp.curry(eventManager.emitEvent);
    async function findMany(params = {}) {
        const query = await strapiUtils.async.pipe(validateParams, defaultToDraftCurry, statusToLookupCurry(contentType), defaultLocaleCurry(contentType), multiLocaleToLookupCurry(contentType), curriedTransformParamsDocumentId(uid), transformParamsToQuery(uid))(params || {});
        return strapi.db.query(uid).findMany(query);
    }
    async function findFirst(params = {}) {
        const query = await strapiUtils.async.pipe(validateParams, defaultToDraftCurry, statusToLookupCurry(contentType), defaultLocaleCurry(contentType), localeToLookupCurry(contentType), curriedTransformParamsDocumentId(uid), transformParamsToQuery(uid))(params);
        return strapi.db.query(uid).findOne(query);
    }
    // TODO: do we really want to add filters on the findOne now that we have findFirst ?
    async function findOne(opts = {}) {
        const { documentId, ...params } = opts;
        const query = await strapiUtils.async.pipe(validateParams, defaultToDraftCurry, statusToLookupCurry(contentType), defaultLocaleCurry(contentType), localeToLookupCurry(contentType), curriedTransformParamsDocumentId(uid), transformParamsToQuery(uid), (query)=>fp.assoc('where', {
                ...query.where,
                documentId
            }, query))(params);
        return strapi.db.query(uid).findOne(query);
    }
    async function deleteDocument(opts = {}) {
        const { documentId, ...params } = opts;
        const query = await strapiUtils.async.pipe(validateParams, fp.omit('status'), defaultLocaleCurry(contentType), multiLocaleToLookupCurry(contentType), transformParamsToQuery(uid), (query)=>fp.assoc('where', {
                ...query.where,
                documentId
            }, query))(params);
        if (params.status === 'draft') {
            throw new Error('Cannot delete a draft document');
        }
        const entriesToDelete = await strapi.db.query(uid).findMany(query);
        // Delete all matched entries and its components
        const deletedEntries = await strapiUtils.async.map(entriesToDelete, (entryToDelete)=>entries.delete(entryToDelete.id));
        entriesToDelete.forEach(emitEvent('entry.delete'));
        return {
            documentId,
            entries: deletedEntries
        };
    }
    async function create(opts = {}) {
        const { documentId, ...params } = opts;
        const queryParams = await strapiUtils.async.pipe(validateParams, filterDataPublishedAtCurry, setStatusToDraftCurry(contentType), statusToDataCurry(contentType), defaultLocaleCurry(contentType), localeToDataCurry(contentType))(params);
        const doc = await entries.create(queryParams);
        emitEvent('entry.create', doc);
        if (hasDraftAndPublish && params.status === 'published') {
            return publish({
                ...params,
                documentId: doc.documentId
            }).then((doc)=>doc.entries[0]);
        }
        return doc;
    }
    async function clone(opts = {}) {
        const { documentId, ...params } = opts;
        const queryParams = await strapiUtils.async.pipe(validateParams, filterDataPublishedAtCurry, defaultLocaleCurry(contentType), multiLocaleToLookupCurry(contentType))(params);
        // Get deep populate
        const entriesToClone = await strapi.db.query(uid).findMany({
            where: {
                ...queryParams?.lookup,
                documentId,
                // DP Enabled: Clone drafts
                // DP Disabled: Clone only the existing version (published)
                publishedAt: {
                    $null: hasDraftAndPublish
                }
            },
            populate: getDeepPopulate(uid, {
                relationalFields: [
                    'id'
                ]
            })
        });
        const clonedEntries = await strapiUtils.async.map(entriesToClone, strapiUtils.async.pipe(validateParams, fp.omit([
            'id',
            'createdAt',
            'updatedAt'
        ]), // assign new documentId
        fp.assoc('documentId', createDocumentId()), // Merge new data into it
        (data)=>fp.merge(data, queryParams.data), (data)=>entries.create({
                ...queryParams,
                data,
                status: 'draft'
            })));
        clonedEntries.forEach(emitEvent('entry.create'));
        return {
            documentId: clonedEntries.at(0)?.documentId,
            entries: clonedEntries
        };
    }
    async function update(opts = {}) {
        const { documentId, ...params } = opts;
        const queryParams = await strapiUtils.async.pipe(validateParams, filterDataPublishedAtCurry, setStatusToDraftCurry(contentType), statusToLookupCurry(contentType), statusToDataCurry(contentType), // Default locale will be set if not provided
        defaultLocaleCurry(contentType), localeToLookupCurry(contentType), localeToDataCurry(contentType))(params);
        const { data, ...restParams } = await curriedTransformParamsDocumentId(uid, queryParams || {});
        const query = transformParamsToQuery(uid, pickSelectionParams(restParams || {}));
        // Validation
        // Find if document exists
        const entryToUpdate = await strapi.db.query(uid).findOne({
            ...query,
            where: {
                ...queryParams?.lookup,
                ...query?.where,
                documentId
            }
        });
        let updatedDraft = null;
        if (entryToUpdate) {
            updatedDraft = await entries.update(entryToUpdate, queryParams);
            emitEvent('entry.update', updatedDraft);
        }
        if (!updatedDraft) {
            const documentExists = await strapi.db.query(contentType.uid).findOne({
                where: {
                    documentId
                }
            });
            if (documentExists) {
                updatedDraft = await entries.create({
                    ...queryParams,
                    data: {
                        ...queryParams.data,
                        documentId
                    }
                });
                emitEvent('entry.create', updatedDraft);
            }
        }
        if (hasDraftAndPublish && updatedDraft && params.status === 'published') {
            return publish({
                ...params,
                documentId
            }).then((doc)=>doc.entries[0]);
        }
        return updatedDraft;
    }
    async function count(params = {}) {
        const query = await strapiUtils.async.pipe(validateParams, defaultStatusCurry(contentType), statusToLookupCurry(contentType), defaultLocaleCurry(contentType), localeToLookupCurry(contentType), transformParamsToQuery(uid))(params);
        return strapi.db.query(uid).count(query);
    }
    async function publish(opts = {}) {
        const { documentId, ...params } = opts;
        const queryParams = await strapiUtils.async.pipe(validateParams, defaultLocaleCurry(contentType), multiLocaleToLookupCurry(contentType))(params);
        const [draftsToPublish, oldPublishedVersions] = await Promise.all([
            strapi.db.query(uid).findMany({
                where: {
                    ...queryParams?.lookup,
                    documentId,
                    publishedAt: null
                },
                // Populate relations, media, compos and dz
                populate: getDeepPopulate(uid, {
                    relationalFields: [
                        'documentId',
                        'locale'
                    ]
                })
            }),
            strapi.db.query(uid).findMany({
                where: {
                    ...queryParams?.lookup,
                    documentId,
                    publishedAt: {
                        $ne: null
                    }
                },
                select: [
                    'id',
                    'locale'
                ]
            })
        ]);
        // Load any unidirectional relation targetting the old published entries
        const relationsToSync = await load$1(uid, {
            newVersions: draftsToPublish,
            oldVersions: oldPublishedVersions
        });
        const bidirectionalRelationsToSync = await load(uid, {
            newVersions: draftsToPublish,
            oldVersions: oldPublishedVersions
        });
        // Delete old published versions
        await strapiUtils.async.map(oldPublishedVersions, (entry)=>entries.delete(entry.id));
        // Transform draft entry data and create published versions
        const publishedEntries = await strapiUtils.async.map(draftsToPublish, (draft)=>entries.publish(draft, queryParams));
        // Sync unidirectional relations with the new published entries
        await sync$1([
            ...oldPublishedVersions,
            ...draftsToPublish
        ], publishedEntries, relationsToSync);
        await sync([
            ...oldPublishedVersions,
            ...draftsToPublish
        ], publishedEntries, bidirectionalRelationsToSync);
        publishedEntries.forEach(emitEvent('entry.publish'));
        return {
            documentId,
            entries: publishedEntries
        };
    }
    async function unpublish(opts = {}) {
        const { documentId, ...params } = opts;
        const query = await strapiUtils.async.pipe(validateParams, defaultLocaleCurry(contentType), multiLocaleToLookupCurry(contentType), transformParamsToQuery(uid), (query)=>fp.assoc('where', {
                ...query.where,
                documentId,
                publishedAt: {
                    $ne: null
                }
            }, query))(params);
        // Delete all published versions
        const versionsToDelete = await strapi.db.query(uid).findMany(query);
        await strapiUtils.async.map(versionsToDelete, (entry)=>entries.delete(entry.id));
        versionsToDelete.forEach(emitEvent('entry.unpublish'));
        return {
            documentId,
            entries: versionsToDelete
        };
    }
    async function discardDraft(opts = {}) {
        const { documentId, ...params } = opts;
        const queryParams = await strapiUtils.async.pipe(validateParams, defaultLocaleCurry(contentType), multiLocaleToLookupCurry(contentType))(params);
        const [versionsToDraft, oldDrafts] = await Promise.all([
            strapi.db.query(uid).findMany({
                where: {
                    ...queryParams?.lookup,
                    documentId,
                    publishedAt: {
                        $ne: null
                    }
                },
                // Populate relations, media, compos and dz
                populate: getDeepPopulate(uid, {
                    relationalFields: [
                        'documentId',
                        'locale'
                    ]
                })
            }),
            strapi.db.query(uid).findMany({
                where: {
                    ...queryParams?.lookup,
                    documentId,
                    publishedAt: null
                },
                select: [
                    'id',
                    'locale'
                ]
            })
        ]);
        // Load any unidirectional relation targeting the old drafts
        const relationsToSync = await load$1(uid, {
            newVersions: versionsToDraft,
            oldVersions: oldDrafts
        });
        const bidirectionalRelationsToSync = await load(uid, {
            newVersions: versionsToDraft,
            oldVersions: oldDrafts
        });
        // Delete old drafts
        await strapiUtils.async.map(oldDrafts, (entry)=>entries.delete(entry.id));
        // Transform published entry data and create draft versions
        const draftEntries = await strapiUtils.async.map(versionsToDraft, (entry)=>entries.discardDraft(entry, queryParams));
        // Sync unidirectional relations with the new draft entries
        await sync$1([
            ...oldDrafts,
            ...versionsToDraft
        ], draftEntries, relationsToSync);
        await sync([
            ...oldDrafts,
            ...versionsToDraft
        ], draftEntries, bidirectionalRelationsToSync);
        draftEntries.forEach(emitEvent('entry.draft-discard'));
        return {
            documentId,
            entries: draftEntries
        };
    }
    async function updateComponents$1(entry, data) {
        return updateComponents(uid, entry, data);
    }
    function omitComponentData$1(data) {
        return omitComponentData(contentType, data);
    }
    return {
        findMany: wrapInTransaction(findMany),
        findFirst: wrapInTransaction(findFirst),
        findOne: wrapInTransaction(findOne),
        delete: wrapInTransaction(deleteDocument),
        create: wrapInTransaction(create),
        clone: wrapInTransaction(clone),
        update: wrapInTransaction(update),
        count: wrapInTransaction(count),
        publish: hasDraftAndPublish ? wrapInTransaction(publish) : undefined,
        unpublish: hasDraftAndPublish ? wrapInTransaction(unpublish) : undefined,
        discardDraft: hasDraftAndPublish ? wrapInTransaction(discardDraft) : undefined,
        updateComponents: updateComponents$1,
        omitComponentData: omitComponentData$1
    };
};

/**
 * Repository to :
 * - Access documents via actions (findMany, findOne, create, update, delete, ...)
 * - Execute middlewares on document actions
 * - Apply default parameters to document actions
 *
 * @param strapi
 * @param validator - validator for database entries
 * @returns DocumentService
 *
 * @example Access documents
 * const article = strapi.documents('api::article.article').create(params)
 * const allArticles = strapi.documents('api::article.article').findMany(params)
 *
 */ const createDocumentService = (strapi, validator = entityValidator)=>{
    // Cache the repositories (one per content type)
    const repositories = new Map();
    // Manager to handle document service middlewares
    const middlewares = createMiddlewareManager();
    middlewares.use(databaseErrorsMiddleware);
    const factory = function factory(uid) {
        if (repositories.has(uid)) {
            return repositories.get(uid);
        }
        const contentType = strapi.contentType(uid);
        const repository = createContentTypeRepository(uid, validator);
        const instance = middlewares.wrapObject(repository, {
            uid,
            contentType
        }, {
            exclude: [
                'updateComponents',
                'omitComponentData'
            ]
        });
        repositories.set(uid, instance);
        return instance;
    };
    return Object.assign(factory, {
        utils: {
            transformData
        },
        use: middlewares.use.bind(middlewares)
    });
};

/**
 * Check if the model has draft and publish enabled.
 */ const hasDraftAndPublish = async (trx, meta)=>{
    const hasTable = await trx.schema.hasTable(meta.tableName);
    if (!hasTable) {
        return false;
    }
    const uid = meta.uid;
    const model = strapi.getModel(uid);
    const hasDP = strapiUtils.contentTypes.hasDraftAndPublish(model);
    if (!hasDP) {
        return false;
    }
    return true;
};
/**
 * Copy all the published entries to draft entries, without it's components, dynamic zones or relations.
 * This ensures all necessary draft's exist before copying it's relations.
 */ async function copyPublishedEntriesToDraft({ db, trx, uid }) {
    // Extract all scalar attributes to use in the insert query
    const meta = db.metadata.get(uid);
    // Get scalar attributes that will be copied over the new draft
    const scalarAttributes = Object.values(meta.attributes).reduce((acc, attribute)=>{
        if ([
            'id'
        ].includes(attribute.columnName)) {
            return acc;
        }
        if (strapiUtils.contentTypes.isScalarAttribute(attribute)) {
            acc.push(attribute.columnName);
        }
        return acc;
    }, []);
    /**
   * Query to copy the published entries into draft entries.
   *
   * INSERT INTO tableName (columnName1, columnName2, columnName3, ...)
   * SELECT columnName1, columnName2, columnName3, ...
   * FROM tableName
   */ await trx// INSERT INTO tableName (columnName1, columnName2, columnName3, ...)
    .into(trx.raw(`?? (${scalarAttributes.map(()=>`??`).join(', ')})`, [
        meta.tableName,
        ...scalarAttributes
    ])).insert((subQb)=>{
        // SELECT columnName1, columnName2, columnName3, ...
        subQb.select(...scalarAttributes.map((att)=>{
            // Override 'publishedAt' and 'updatedAt' attributes
            if (att === 'published_at') {
                return trx.raw('NULL as ??', 'published_at');
            }
            return att;
        })).from(meta.tableName)// Only select entries that were published
        .whereNotNull('published_at');
    });
}
/**
 * Load a batch of versions to discard.
 *
 * Versions with only a draft version will be ignored.
 * Only versions with a published version (which always have a draft version) will be discarded.
 */ async function* getBatchToDiscard({ db, trx, uid, defaultBatchSize = 1000 }) {
    const client = db.config.connection.client;
    const isSQLite = typeof client === 'string' && [
        'sqlite',
        'sqlite3',
        'better-sqlite3'
    ].includes(client);
    // The SQLite documentation states that the maximum number of terms in a
    // compound SELECT statement is 500 by default.
    // See: https://www.sqlite.org/limits.html
    // To ensure a successful migration, we limit the batch size to 500 for SQLite.
    const batchSize = isSQLite ? Math.min(defaultBatchSize, 500) : defaultBatchSize;
    let offset = 0;
    let hasMore = true;
    while(hasMore){
        // Look for the published entries to discard
        const batch = await db.queryBuilder(uid).select([
            'id',
            'documentId',
            'locale'
        ]).where({
            publishedAt: {
                $ne: null
            }
        }).limit(batchSize).offset(offset).orderBy('id').transacting(trx).execute();
        if (batch.length < batchSize) {
            hasMore = false;
        }
        offset += batchSize;
        yield batch;
    }
}
/**
 * 2 pass migration to create the draft entries for all the published entries.
 * And then discard the drafts to copy the relations.
 */ const migrateUp = async (trx, db)=>{
    const dpModels = [];
    for (const meta of db.metadata.values()){
        const hasDP = await hasDraftAndPublish(trx, meta);
        if (hasDP) {
            dpModels.push(meta);
        }
    }
    /**
   * Create plain draft entries for all the entries that were published.
   */ for (const model of dpModels){
        await copyPublishedEntriesToDraft({
            db,
            trx,
            uid: model.uid
        });
    }
    /**
   * Discard the drafts will copy the relations from the published entries to the newly created drafts.
   *
   * Load a batch of entries (batched to prevent loading millions of rows at once ),
   * and discard them using the document service.
   *
   * NOTE: This is using a custom document service without any validations,
   *       to prevent the migration from failing if users already had invalid data in V4.
   *       E.g. @see https://github.com/strapi/strapi/issues/21583
   */ const documentService = createDocumentService(strapi, {
        async validateEntityCreation (_, data) {
            return data;
        },
        async validateEntityUpdate (_, data) {
            // Data can be partially empty on partial updates
            // This migration doesn't trigger any update (or partial update),
            // so it's safe to return the data as is.
            return data;
        }
    });
    for (const model of dpModels){
        const discardDraft = async (entry)=>documentService(model.uid).discardDraft({
                documentId: entry.documentId,
                locale: entry.locale
            });
        for await (const batch of getBatchToDiscard({
            db,
            trx,
            uid: model.uid
        })){
            // NOTE: concurrency had to be disabled to prevent a race condition with self-references
            // TODO: improve performance in a safe way
            await strapiUtils.async.map(batch, discardDraft, {
                concurrency: 1
            });
        }
    }
};
const discardDocumentDrafts = {
    name: 'core::5.0.0-discard-drafts',
    async up (trx, db) {
        await migrateUp(trx, db);
    },
    async down () {
        throw new Error('not implemented');
    }
};

/**
 * Enable draft and publish for content types.
 *
 * Draft and publish disabled content types will have their entries published,
 * this migration clones those entries as drafts.
 *
 * TODO: Clone components, dynamic zones and relations
 */ const enableDraftAndPublish = async ({ oldContentTypes, contentTypes })=>{
    if (!oldContentTypes) {
        return;
    }
    // run the after content types migrations
    return strapi.db.transaction(async (trx)=>{
        for(const uid in contentTypes){
            if (!oldContentTypes[uid]) {
                continue;
            }
            const oldContentType = oldContentTypes[uid];
            const contentType = contentTypes[uid];
            // if d&p was enabled set publishedAt to eq createdAt
            if (!strapiUtils.contentTypes.hasDraftAndPublish(oldContentType) && strapiUtils.contentTypes.hasDraftAndPublish(contentType)) {
                const discardDraft = async (entry)=>strapi.documents(uid)// Discard draft by referencing the documentId and locale
                    .discardDraft({
                        documentId: entry.documentId,
                        locale: entry.locale
                    });
                /**
         * Load a batch of entries (batched to prevent loading millions of rows at once ),
         * and discard them using the document service.
         */ for await (const batch of getBatchToDiscard({
                    db: strapi.db,
                    trx,
                    uid
                })){
                    await strapiUtils.async.map(batch, discardDraft, {
                        concurrency: 10
                    });
                }
            }
        }
    });
};
const disableDraftAndPublish = async ({ oldContentTypes, contentTypes })=>{
    if (!oldContentTypes) {
        return;
    }
    for(const uid in contentTypes){
        if (!oldContentTypes[uid]) {
            continue;
        }
        const oldContentType = oldContentTypes[uid];
        const contentType = contentTypes[uid];
        // if d&p was disabled remove unpublish content before sync
        if (strapiUtils.contentTypes.hasDraftAndPublish(oldContentType) && !strapiUtils.contentTypes.hasDraftAndPublish(contentType)) {
            await strapi.db?.queryBuilder(uid).delete().where({
                published_at: null
            }).execute();
        }
    }
};

// if i18N enabled set default locale
const enableI18n = async ({ oldContentTypes, contentTypes })=>{
    const { isLocalizedContentType } = strapi.plugin('i18n')?.service('content-types') ?? {};
    const { getDefaultLocale } = strapi.plugin('i18n')?.service('locales') ?? {};
    if (!oldContentTypes) {
        return;
    }
    for(const uid in contentTypes){
        if (!oldContentTypes[uid]) {
            continue;
        }
        const oldContentType = oldContentTypes[uid];
        const contentType = contentTypes[uid];
        if (!isLocalizedContentType(oldContentType) && isLocalizedContentType(contentType)) {
            const defaultLocale = await getDefaultLocale();
            await strapi.db.query(uid).updateMany({
                where: {
                    locale: null
                },
                data: {
                    locale: defaultLocale
                }
            });
        }
    }
};
const disableI18n = async ({ oldContentTypes, contentTypes })=>{
    const { isLocalizedContentType } = strapi.plugin('i18n')?.service('content-types') ?? {};
    const { getDefaultLocale } = strapi.plugin('i18n')?.service('locales') ?? {};
    if (!oldContentTypes) {
        return;
    }
    for(const uid in contentTypes){
        if (!oldContentTypes[uid]) {
            continue;
        }
        const oldContentType = oldContentTypes[uid];
        const contentType = contentTypes[uid];
        // if i18N is disabled remove non default locales before sync
        if (isLocalizedContentType(oldContentType) && !isLocalizedContentType(contentType)) {
            const defaultLocale = await getDefaultLocale();
            await Promise.all([
                // Delete all entities that are not in the default locale
                strapi.db.query(uid).deleteMany({
                    where: {
                        locale: {
                            $ne: defaultLocale
                        }
                    }
                }),
                // Set locale to null for the rest
                strapi.db.query(uid).updateMany({
                    where: {
                        locale: {
                            $eq: defaultLocale
                        }
                    },
                    data: {
                        locale: null
                    }
                })
            ]);
        }
    }
};

const enable = async ({ oldContentTypes, contentTypes })=>{
    await enableI18n({
        oldContentTypes,
        contentTypes
    });
    await enableDraftAndPublish({
        oldContentTypes,
        contentTypes
    });
};
const disable = async ({ oldContentTypes, contentTypes })=>{
    await disableI18n({
        oldContentTypes,
        contentTypes
    });
    await disableDraftAndPublish({
        oldContentTypes,
        contentTypes
    });
};

var registries = defineProvider({
    init (strapi) {
        strapi.add('content-types', ()=>contentTypesRegistry()).add('components', ()=>componentsRegistry()).add('services', ()=>servicesRegistry(strapi)).add('policies', ()=>policiesRegistry()).add('middlewares', ()=>middlewaresRegistry()).add('hooks', ()=>hooksRegistry()).add('controllers', ()=>controllersRegistry(strapi)).add('modules', ()=>modulesRegistry(strapi)).add('plugins', ()=>pluginsRegistry(strapi)).add('custom-fields', ()=>customFieldsRegistry(strapi)).add('apis', ()=>apisRegistry(strapi)).add('models', ()=>registry()).add('sanitizers', sanitizersRegistry()).add('validators', validatorsRegistry());
    },
    async register (strapi) {
        await loadApplicationContext(strapi);
        strapi.get('hooks').set('strapi::content-types.beforeSync', strapiUtils.hooks.createAsyncParallelHook());
        strapi.get('hooks').set('strapi::content-types.afterSync', strapiUtils.hooks.createAsyncParallelHook());
        // Content migration to enable draft and publish
        strapi.hook('strapi::content-types.beforeSync').register(disable);
        strapi.hook('strapi::content-types.afterSync').register(enable);
        // Database migrations
        strapi.db.migrations.providers.internal.register(discardDocumentDrafts);
    }
});

function nextResetDate$1() {
    return Date.now() + 24 * 60 * 60 * 1000; // Now + 24 hours.
}
var wrapWithRateLimit = ((sender, { limitedEvents = [] } = {})=>{
    let cacheExpiresAt = nextResetDate$1();
    const eventCache = new Map();
    return async (event, ...args)=>{
        if (!limitedEvents.includes(event)) {
            return sender(event, ...args);
        }
        if (Date.now() > cacheExpiresAt) {
            eventCache.clear();
            cacheExpiresAt = nextResetDate$1();
        }
        if (eventCache.has(event)) {
            return false;
        }
        eventCache.set(event, true);
        return sender(event, ...args);
    };
});

/**
 * Generate an admin user hash
 */ const generateAdminUserHash = (strapi)=>{
    const ctx = strapi?.requestContext?.get();
    if (!ctx?.state?.user?.email) {
        return '';
    }
    return crypto.createHash('sha256').update(ctx.state.user.email).digest('hex');
};

const defaultQueryOpts = {
    timeout: 1000,
    headers: {
        'Content-Type': 'application/json'
    }
};
const ANALYTICS_URI = 'https://analytics.strapi.io';
/**
 * Add properties from the package.json strapi key in the metadata
 */ const addPackageJsonStrapiMetadata = (metadata, strapi)=>{
    const { packageJsonStrapi = {} } = strapi.config;
    _.defaults(metadata, packageJsonStrapi);
};
/**
 * Create a send function for event with all the necessary metadata
 */ var createSender = ((strapi)=>{
    const { uuid } = strapi.config;
    const deviceId = strapiUtils.machineID();
    const serverRootPath = strapi.dirs.app.root;
    const adminRootPath = path.join(strapi.dirs.app.root, 'src', 'admin');
    const anonymousUserProperties = {
        environment: strapi.config.environment,
        os: os.type(),
        osPlatform: os.platform(),
        osArch: os.arch(),
        osRelease: os.release(),
        nodeVersion: process.versions.node
    };
    const anonymousGroupProperties = {
        docker: process.env.DOCKER || isDocker(),
        isCI: ciEnv.isCI,
        version: strapi.config.get('info.strapi'),
        useTypescriptOnServer: tsUtils.isUsingTypeScriptSync(serverRootPath),
        useTypescriptOnAdmin: tsUtils.isUsingTypeScriptSync(adminRootPath),
        projectId: uuid,
        isHostedOnStrapiCloud: strapiUtils.env('STRAPI_HOSTING', null) === 'strapi.cloud'
    };
    addPackageJsonStrapiMetadata(anonymousGroupProperties, strapi);
    return async (event, payload = {}, opts = {})=>{
        const userId = generateAdminUserHash(strapi);
        const reqParams = {
            method: 'POST',
            body: JSON.stringify({
                event,
                userId,
                deviceId,
                eventProperties: payload.eventProperties,
                userProperties: userId ? {
                    ...anonymousUserProperties,
                    ...payload.userProperties
                } : {},
                groupProperties: {
                    ...anonymousGroupProperties,
                    projectType: strapi.EE ? 'Enterprise' : 'Community',
                    ...payload.groupProperties
                }
            }),
            ..._.merge({
                headers: {
                    'X-Strapi-Event': event
                }
            }, defaultQueryOpts, opts)
        };
        try {
            const res = await strapi.fetch(`${ANALYTICS_URI}/api/v2/track`, reqParams);
            return res.ok;
        } catch (err) {
            return false;
        }
    };
});

function nextResetDate() {
    return Date.now() + 24 * 60 * 60 * 1000; // Now + 24 hours.
}
const createMiddleware = ({ sendEvent })=>{
    const state = {
        expires: nextResetDate(),
        counter: 0
    };
    const middleware = async (ctx, next)=>{
        const { url, method } = ctx.request;
        if (!url.includes('.') && [
            'GET',
            'PUT',
            'POST',
            'DELETE'
        ].includes(method)) {
            if (Date.now() > state.expires) {
                state.expires = nextResetDate();
                state.counter = 0;
            }
            // Send max. 1000 events per day.
            if (state.counter < 1000) {
                sendEvent('didReceiveRequest', {
                    eventProperties: {
                        url: ctx.request.url
                    }
                });
                // Increase counter.
                state.counter += 1;
            }
        }
        await next();
    };
    return middleware;
};

const isTruthy = (val)=>{
    return [
        1,
        true
    ].includes(val) || [
        'true',
        '1'
    ].includes(_.toLower(val));
};

const LIMITED_EVENTS = [
    'didSaveMediaWithAlternativeText',
    'didSaveMediaWithCaption',
    'didDisableResponsiveDimensions',
    'didEnableResponsiveDimensions',
    'didInitializePluginUpload'
];
const createTelemetryInstance = (strapi)=>{
    const uuid = strapi.config.get('uuid');
    const telemetryDisabled = strapi.config.get('packageJsonStrapi.telemetryDisabled');
    const isDisabled = !uuid || isTruthy(process.env.STRAPI_TELEMETRY_DISABLED) || isTruthy(telemetryDisabled);
    const crons = [];
    const sender = createSender(strapi);
    const sendEvent = wrapWithRateLimit(sender, {
        limitedEvents: LIMITED_EVENTS
    });
    return {
        get isDisabled () {
            return isDisabled;
        },
        register () {
            if (!isDisabled) {
                const pingCron = nodeSchedule.scheduleJob('0 0 12 * * *', ()=>sendEvent('ping'));
                crons.push(pingCron);
                strapi.server.use(createMiddleware({
                    sendEvent
                }));
            }
        },
        bootstrap () {},
        destroy () {
            // Clear open handles
            crons.forEach((cron)=>cron.cancel());
        },
        async send (event, payload = {}) {
            if (isDisabled) return true;
            return sendEvent(event, payload);
        }
    };
};

var telemetry = defineProvider({
    init (strapi) {
        strapi.add('telemetry', ()=>createTelemetryInstance(strapi));
    },
    async register (strapi) {
        strapi.get('telemetry').register();
    },
    async bootstrap (strapi) {
        strapi.get('telemetry').bootstrap();
    },
    async destroy (strapi) {
        strapi.get('telemetry').destroy();
    }
});

const { ValidationError } = strapiUtils.errors;
const webhookModel = {
    uid: 'strapi::webhook',
    singularName: 'strapi_webhooks',
    tableName: 'strapi_webhooks',
    attributes: {
        id: {
            type: 'increments'
        },
        name: {
            type: 'string'
        },
        url: {
            type: 'text'
        },
        headers: {
            type: 'json'
        },
        events: {
            type: 'json'
        },
        enabled: {
            type: 'boolean'
        }
    }
};
const toDBObject = (data)=>{
    return {
        name: data.name,
        url: data.url,
        headers: data.headers,
        events: data.events,
        enabled: data.isEnabled
    };
};
const fromDBObject = (row)=>{
    return {
        id: typeof row.id === 'number' ? row.id.toString() : row.id,
        name: row.name,
        url: row.url,
        headers: row.headers,
        events: row.events,
        isEnabled: row.enabled
    };
};
const webhookEventValidator = async (allowedEvents, events)=>{
    const allowedValues = Array.from(allowedEvents.values());
    events.forEach((event)=>{
        if (allowedValues.includes(event)) {
            return;
        }
        throw new ValidationError(`Webhook event ${event} is not supported`);
    });
};
const createWebhookStore = ({ db })=>{
    return {
        allowedEvents: new Map([
            [
                'ENTRY_CREATE',
                'entry.create'
            ],
            [
                'ENTRY_UPDATE',
                'entry.update'
            ],
            [
                'ENTRY_DELETE',
                'entry.delete'
            ],
            [
                'ENTRY_PUBLISH',
                'entry.publish'
            ],
            [
                'ENTRY_UNPUBLISH',
                'entry.unpublish'
            ],
            [
                'ENTRY_DRAFT_DISCARD',
                'entry.draft-discard'
            ]
        ]),
        addAllowedEvent (key, value) {
            this.allowedEvents.set(key, value);
        },
        removeAllowedEvent (key) {
            this.allowedEvents.delete(key);
        },
        listAllowedEvents () {
            return Array.from(this.allowedEvents.keys());
        },
        getAllowedEvent (key) {
            return this.allowedEvents.get(key);
        },
        async findWebhooks () {
            const results = await db.query('strapi::webhook').findMany();
            return results.map(fromDBObject);
        },
        async findWebhook (id) {
            const result = await db.query('strapi::webhook').findOne({
                where: {
                    id
                }
            });
            return result ? fromDBObject(result) : null;
        },
        async createWebhook (data) {
            await webhookEventValidator(this.allowedEvents, data.events);
            return db.query('strapi::webhook').create({
                data: toDBObject({
                    ...data,
                    isEnabled: true
                })
            }).then(fromDBObject);
        },
        async updateWebhook (id, data) {
            await webhookEventValidator(this.allowedEvents, data.events);
            const webhook = await db.query('strapi::webhook').update({
                where: {
                    id
                },
                data: toDBObject(data)
            });
            return webhook ? fromDBObject(webhook) : null;
        },
        async deleteWebhook (id) {
            const webhook = await db.query('strapi::webhook').delete({
                where: {
                    id
                }
            });
            return webhook ? fromDBObject(webhook) : null;
        }
    };
};

const debug$1 = createDebugger('strapi:worker-queue');
const noop = ()=>{};
class WorkerQueue {
    subscribe(worker) {
        debug$1('Subscribe to worker queue');
        this.worker = worker;
    }
    enqueue(payload) {
        debug$1('Enqueue event in worker queue');
        if (this.running < this.concurrency) {
            this.running += 1;
            this.execute(payload);
        } else {
            this.queue.unshift(payload);
        }
    }
    pop() {
        debug$1('Pop worker queue and execute');
        const payload = this.queue.pop();
        if (payload) {
            this.execute(payload);
        } else {
            this.running -= 1;
        }
    }
    async execute(payload) {
        debug$1('Execute worker');
        try {
            await this.worker(payload);
        } catch (error) {
            this.logger.error(error);
        } finally{
            this.pop();
        }
    }
    constructor({ logger, concurrency = 5 }){
        debug$1('Initialize worker queue');
        this.logger = logger;
        this.worker = noop;
        this.concurrency = concurrency;
        this.running = 0;
        this.queue = [];
    }
}

const debug = createDebugger('strapi:webhook');
const defaultConfiguration = {
    defaultHeaders: {}
};
class WebhookRunner {
    deleteListener(event) {
        debug(`Deleting listener for event '${event}'`);
        const fn = this.listeners.get(event);
        if (fn !== undefined) {
            this.eventHub.off(event, fn);
            this.listeners.delete(event);
        }
    }
    createListener(event) {
        debug(`Creating listener for event '${event}'`);
        if (this.listeners.has(event)) {
            this.logger.error(`The webhook runner is already listening for the event '${event}'. Did you mean to call .register() ?`);
        }
        const listen = async (info)=>{
            this.queue.enqueue({
                event,
                info
            });
        };
        this.listeners.set(event, listen);
        this.eventHub.on(event, listen);
    }
    async executeListener({ event, info }) {
        debug(`Executing webhook for event '${event}'`);
        const webhooks = this.webhooksMap.get(event) || [];
        const activeWebhooks = webhooks.filter((webhook)=>webhook.isEnabled === true);
        for (const webhook of activeWebhooks){
            await this.run(webhook, event, info).catch((error)=>{
                this.logger.error('Error running webhook');
                this.logger.error(error);
            });
        }
    }
    run(webhook, event, info = {}) {
        const { url, headers } = webhook;
        return this.fetch(url, {
            method: 'post',
            body: JSON.stringify({
                event,
                createdAt: new Date(),
                ...info
            }),
            headers: {
                ...this.config.defaultHeaders,
                ...headers,
                'X-Strapi-Event': event,
                'Content-Type': 'application/json'
            },
            signal: AbortSignal.timeout(10000)
        }).then(async (res)=>{
            if (res.ok) {
                return {
                    statusCode: res.status
                };
            }
            return {
                statusCode: res.status,
                message: await res.text()
            };
        }).catch((err)=>{
            return {
                statusCode: 500,
                message: err.message
            };
        });
    }
    add(webhook) {
        debug(`Registering webhook '${webhook.id}'`);
        const { events } = webhook;
        events.forEach((event)=>{
            if (this.webhooksMap.has(event)) {
                this.webhooksMap.get(event)?.push(webhook);
            } else {
                this.webhooksMap.set(event, [
                    webhook
                ]);
                this.createListener(event);
            }
        });
    }
    update(webhook) {
        debug(`Refreshing webhook '${webhook.id}'`);
        this.remove(webhook);
        this.add(webhook);
    }
    remove(webhook) {
        debug(`Unregistering webhook '${webhook.id}'`);
        this.webhooksMap.forEach((webhooks, event)=>{
            const filteredWebhooks = webhooks.filter((value)=>value.id !== webhook.id);
            // Cleanup hanging listeners
            if (filteredWebhooks.length === 0) {
                this.webhooksMap.delete(event);
                this.deleteListener(event);
            } else {
                this.webhooksMap.set(event, filteredWebhooks);
            }
        });
    }
    constructor({ eventHub, logger, configuration = {}, fetch }){
        this.webhooksMap = new Map();
        this.listeners = new Map();
        debug('Initialized webhook runner');
        this.eventHub = eventHub;
        this.logger = logger;
        this.fetch = fetch;
        if (typeof configuration !== 'object') {
            throw new Error('Invalid configuration provided to the webhookRunner.\nCheck your server.json -> webhooks configuration');
        }
        this.config = _.merge(defaultConfiguration, configuration);
        this.queue = new WorkerQueue({
            logger,
            concurrency: 5
        });
        this.queue.subscribe(this.executeListener.bind(this));
    }
}
/**
 * Expose a factory function instead of the class
 */ function createWebhookRunner(opts) {
    return new WebhookRunner(opts);
}

var webhooks = defineProvider({
    init (strapi) {
        strapi.get('models').add(webhookModel);
        strapi.add('webhookStore', ()=>createWebhookStore({
                db: strapi.db
            }));
        strapi.add('webhookRunner', ()=>createWebhookRunner({
                eventHub: strapi.eventHub,
                logger: strapi.log,
                configuration: strapi.config.get('server.webhooks', {}),
                fetch: strapi.fetch
            }));
    },
    async bootstrap (strapi) {
        const webhooks = await strapi.get('webhookStore').findWebhooks();
        if (!webhooks) {
            return;
        }
        for (const webhook of webhooks){
            strapi.get('webhookRunner').add(webhook);
        }
    }
});

const providers = [
    registries,
    admin,
    coreStore,
    webhooks,
    telemetry,
    cron
];

const transformLoadParamsToQuery = (uid, field, params, pagination = {})=>{
    const query = strapi.get('query-params').transform(uid, {
        populate: {
            [field]: params
        }
    });
    const res = {
        ...query.populate[field],
        ...pagination
    };
    return res;
};
const databaseErrorsToTransform = [
    database.errors.InvalidTimeError,
    database.errors.InvalidDateTimeError,
    database.errors.InvalidDateError,
    database.errors.InvalidRelationError
];
const createDefaultImplementation = ({ strapi: strapi1, db })=>({
        async wrapParams (options = {}) {
            return options;
        },
        async wrapResult (result = {}) {
            return result;
        },
        async findMany (uid, opts) {
            const { kind } = strapi1.getModel(uid);
            const wrappedParams = await this.wrapParams(opts, {
                uid,
                action: 'findMany'
            });
            if (kind === 'singleType') {
                const entity = strapi1.documents(uid).findFirst(wrappedParams);
                return this.wrapResult(entity, {
                    uid,
                    action: 'findOne'
                });
            }
            const entities = await strapi1.documents(uid).findMany(wrappedParams);
            return this.wrapResult(entities, {
                uid,
                action: 'findMany'
            });
        },
        async findPage (uid, opts) {
            const wrappedParams = await this.wrapParams(opts, {
                uid,
                action: 'findPage'
            });
            const query = strapi1.get('query-params').transform(uid, wrappedParams);
            const entities = await db.query(uid).findPage(query);
            return this.wrapResult(entities, {
                uid,
                action: 'findMany'
            });
        },
        async findOne (uid, entityId, opts) {
            const wrappedParams = await this.wrapParams(opts, {
                uid,
                action: 'findOne'
            });
            const res = await db.query(uid).findOne({
                where: {
                    id: entityId
                }
            });
            if (!res) {
                return this.wrapResult(null, {
                    uid,
                    action: 'findOne'
                });
            }
            const entity = await strapi1.documents(uid).findOne({
                ...wrappedParams,
                documentId: res.documentId
            });
            return this.wrapResult(entity, {
                uid,
                action: 'findOne'
            });
        },
        async count (uid, opts) {
            const wrappedParams = await this.wrapParams(opts, {
                uid,
                action: 'count'
            });
            return strapi1.documents(uid).count(wrappedParams);
        },
        async create (uid, params) {
            const wrappedParams = await this.wrapParams(params, {
                uid,
                action: 'create'
            });
            const { data } = wrappedParams;
            if (!data) {
                throw new Error('cannot create');
            }
            const shouldPublish = !strapiUtils.contentTypes.isDraft(data, strapi1.getModel(uid));
            const entity = await strapi1.documents(uid).create({
                ...wrappedParams,
                status: shouldPublish ? 'published' : 'draft'
            });
            return this.wrapResult(entity, {
                uid,
                action: 'create'
            });
        },
        async update (uid, entityId, opts) {
            const wrappedParams = await this.wrapParams(opts, {
                uid,
                action: 'update'
            });
            const entityToUpdate = await db.query(uid).findOne({
                where: {
                    id: entityId
                }
            });
            if (!entityToUpdate) {
                return this.wrapResult(null, {
                    uid,
                    action: 'update'
                });
            }
            const shouldPublish = !strapiUtils.contentTypes.isDraft(entityToUpdate, strapi1.getModel(uid));
            const entity = strapi1.documents(uid).update({
                ...wrappedParams,
                status: shouldPublish ? 'published' : 'draft',
                documentId: entityToUpdate.documentId
            });
            return this.wrapResult(entity, {
                uid,
                action: 'update'
            });
        },
        async delete (uid, entityId, opts) {
            const wrappedParams = await this.wrapParams(opts, {
                uid,
                action: 'delete'
            });
            const entityToDelete = await db.query(uid).findOne({
                where: {
                    id: entityId
                }
            });
            if (!entityToDelete) {
                return this.wrapResult(null, {
                    uid,
                    action: 'delete'
                });
            }
            await strapi1.documents(uid).delete({
                ...wrappedParams,
                documentId: entityToDelete.documentId
            });
            return this.wrapResult(entityToDelete, {
                uid,
                action: 'delete'
            });
        },
        async load (uid, entity, field, params) {
            if (!_.isString(field)) {
                throw new Error(`Invalid load. Expected "${field}" to be a string`);
            }
            const loadedEntity = await db.query(uid).load(entity, field, transformLoadParamsToQuery(uid, field, params ?? {}));
            return this.wrapResult(loadedEntity, {
                uid,
                field,
                action: 'load'
            });
        },
        async loadPages (uid, entity, field, params, pagination = {}) {
            if (!_.isString(field)) {
                throw new Error(`Invalid load. Expected "${field}" to be a string`);
            }
            const { attributes } = strapi1.getModel(uid);
            const attribute = attributes[field];
            if (!strapiUtils.relations.isAnyToMany(attribute)) {
                throw new Error(`Invalid load. Expected "${field}" to be an anyToMany relational attribute`);
            }
            const query = transformLoadParamsToQuery(uid, field, params ?? {}, pagination);
            const loadedPage = await db.query(uid).loadPages(entity, field, query);
            return {
                ...loadedPage,
                results: await this.wrapResult(loadedPage.results, {
                    uid,
                    field,
                    action: 'load'
                })
            };
        }
    });
var createEntityService = ((ctx)=>{
    const implementation = createDefaultImplementation(ctx);
    const service = {
        implementation,
        decorate (decorator) {
            if (typeof decorator !== 'function') {
                throw new Error(`Decorator must be a function, received ${typeof decorator}`);
            }
            this.implementation = {
                ...this.implementation,
                ...decorator(this.implementation)
            };
            return this;
        }
    };
    const delegator = delegate(service, 'implementation');
    // delegate every method in implementation
    Object.keys(service.implementation).forEach((key)=>delegator.method(key));
    // wrap methods to handle Database Errors
    service.decorate((oldService)=>{
        const newService = _.mapValues(oldService, (method, methodName)=>async function(...args) {
                try {
                    return await oldService[methodName].call(this, ...args);
                } catch (error) {
                    if (databaseErrorsToTransform.some((errorToTransform)=>error instanceof errorToTransform)) {
                        if (error instanceof Error) {
                            throw new strapiUtils.errors.ValidationError(error.message);
                        }
                        throw error;
                    }
                    throw error;
                }
            });
        return newService;
    });
    return service;
});

var createQueryParamService = ((strapi)=>{
    const { transformQueryParams } = strapiUtils.queryParams.createTransformer({
        getModel: (uid)=>strapi.getModel(uid)
    });
    return {
        transform: transformQueryParams
    };
});

const INVALID_STRATEGY_MSG = 'Invalid auth strategy. Expecting an object with properties {name: string, authenticate: function, verify: function}';
const validStrategy = (strategy)=>{
    assert$1(fp.has('authenticate', strategy), INVALID_STRATEGY_MSG);
    assert$1(typeof strategy.authenticate === 'function', INVALID_STRATEGY_MSG);
    if (fp.has('verify', strategy)) {
        assert$1(typeof strategy.verify === 'function', INVALID_STRATEGY_MSG);
    }
};
const createAuthentication = ()=>{
    const strategies = {};
    return {
        register (type, strategy) {
            validStrategy(strategy);
            if (!strategies[type]) {
                strategies[type] = [];
            }
            strategies[type].push(strategy);
            return this;
        },
        async authenticate (ctx, next) {
            const route = ctx.state.route;
            // use route strategy
            const config = route?.config?.auth;
            if (config === false) {
                return next();
            }
            const routeStrategies = route.info.type ? strategies[route.info.type] : [];
            const configStrategies = config?.strategies ?? routeStrategies ?? [];
            const strategiesToUse = configStrategies.reduce((acc, strategy)=>{
                // Resolve by strategy name
                if (typeof strategy === 'string') {
                    const routeStrategy = routeStrategies.find((rs)=>rs.name === strategy);
                    if (routeStrategy) {
                        acc.push(routeStrategy);
                    }
                } else if (typeof strategy === 'object') {
                    validStrategy(strategy);
                    acc.push(strategy);
                }
                return acc;
            }, []);
            for (const strategy of strategiesToUse){
                const result = await strategy.authenticate(ctx);
                const { authenticated = false, credentials, ability = null, error = null } = result || {};
                if (error !== null) {
                    return ctx.unauthorized(error);
                }
                if (authenticated) {
                    ctx.state.isAuthenticated = true;
                    ctx.state.auth = {
                        strategy,
                        credentials,
                        ability
                    };
                    return next();
                }
            }
            return ctx.unauthorized('Missing or invalid credentials');
        },
        async verify (auth, config = {}) {
            if (config === false) {
                return;
            }
            if (!auth) {
                throw new strapiUtils.errors.UnauthorizedError();
            }
            if (typeof auth.strategy.verify === 'function') {
                return auth.strategy.verify(auth, config);
            }
        }
    };
};

const createCustomFields = (strapi)=>{
    return {
        register (customField) {
            strapi.get('custom-fields').add(customField);
        }
    };
};

var createActionProvider = ((options = {})=>{
    const provider = strapiUtils.providerFactory(options);
    return {
        ...provider,
        async register (action, payload) {
            if (strapi.isLoaded) {
                throw new Error(`You can't register new actions outside the bootstrap function.`);
            }
            return provider.register(action, payload);
        }
    };
});

var createConditionProvider = ((options = {})=>{
    const provider = strapiUtils.providerFactory(options);
    return {
        ...provider,
        async register (condition) {
            if (strapi.isLoaded) {
                throw new Error(`You can't register new conditions outside the bootstrap function.`);
            }
            return provider.register(condition.name, condition);
        }
    };
});

var createPermissionEngine = (({ providers })=>permissions.engine.new({
        providers
    }));

const typeSymbol = Symbol.for('__type__');
/**
 * Creates a handler that checks if the permission's action exists in the action registry
 */ const createValidatePermissionHandler = (actionProvider)=>({ permission })=>{
        const action = actionProvider.get(permission.action);
        // If the action isn't registered into the action provider, then ignore the permission and warn the user
        if (!action) {
            strapi.log.debug(`Unknown action "${permission.action}" supplied when registering a new permission`);
            return false;
        }
        return true;
    };
/**
 * Create instances of providers and permission engine for the core content-API service.
 * Also, expose utilities to get information about available actions and such.
 */ var instantiatePermissionsUtilities = ((strapi1)=>{
    // NOTE: Here we define both an action and condition provider,
    // but at the moment, we're only using the action one.
    const providers = {
        action: createActionProvider(),
        condition: createConditionProvider()
    };
    /**
   * Get a tree representation of the available Content API actions
   * based on the methods of the Content API controllers.
   *
   * @note Only actions bound to a content-API route are returned.
   */ const getActionsMap = ()=>{
        const actionMap = {};
        /**
     * Check if a controller's action is bound to the
     * content-api by looking at a potential __type__ symbol
     */ const isContentApi = (action)=>{
            if (!_.has(action, typeSymbol)) {
                return false;
            }
            return action[typeSymbol].includes('content-api');
        };
        /**
     * Register actions from a specific API source into the result tree
     */ const registerAPIsActions = (apis, source)=>{
            _.forEach(apis, (api, apiName)=>{
                const controllers = _.reduce(api.controllers, (acc, controller, controllerName)=>{
                    const contentApiActions = _.pickBy(controller, isContentApi);
                    if (_.isEmpty(contentApiActions)) {
                        return acc;
                    }
                    acc[controllerName] = Object.keys(contentApiActions);
                    return acc;
                }, {});
                if (!_.isEmpty(controllers)) {
                    actionMap[`${source}::${apiName}`] = {
                        controllers
                    };
                }
            });
        };
        registerAPIsActions(strapi1.apis, 'api');
        registerAPIsActions(strapi1.plugins, 'plugin');
        return actionMap;
    };
    /**
   * Register all the content-API controllers actions into the action provider.
   * This method make use of the {@link getActionsMap} to generate the list of actions to register.
   */ const registerActions = async ()=>{
        const actionsMap = getActionsMap();
        // For each API
        for (const [api, value] of Object.entries(actionsMap)){
            const { controllers } = value;
            // Register controllers methods as actions
            for (const [controller, actions] of Object.entries(controllers)){
                // Register each action individually
                await Promise.all(actions.map((action)=>{
                    const actionUID = `${api}.${controller}.${action}`;
                    return providers.action.register(actionUID, {
                        api,
                        controller,
                        action,
                        uid: actionUID
                    });
                }));
            }
        }
    };
    // Create an instance of a content-API permission engine
    // and binds a custom validation handler to it
    const engine = createPermissionEngine({
        providers
    });
    engine.on('before-format::validate.permission', createValidatePermissionHandler(providers.action));
    return {
        engine,
        providers,
        registerActions,
        getActionsMap
    };
});

const transformRoutePrefixFor = (pluginName)=>(route)=>{
        const prefix = route.config && route.config.prefix;
        const path = prefix !== undefined ? `${prefix}${route.path}` : `/${pluginName}${route.path}`;
        return {
            ...route,
            path
        };
    };
const filterContentAPI = (route)=>route.info.type === 'content-api';
/**
 * Create a content API container that holds logic, tools and utils. (eg: permissions, ...)
 */ const createContentAPI = (strapi)=>{
    const getRoutesMap = async ()=>{
        const routesMap = {};
        _.forEach(strapi.apis, (api, apiName)=>{
            const routes = _.flatMap(api.routes, (route)=>{
                if ('routes' in route) {
                    return route.routes;
                }
                return route;
            }).filter(filterContentAPI);
            if (routes.length === 0) {
                return;
            }
            const apiPrefix = strapi.config.get('api.rest.prefix');
            routesMap[`api::${apiName}`] = routes.map((route)=>({
                    ...route,
                    path: `${apiPrefix}${route.path}`
                }));
        });
        _.forEach(strapi.plugins, (plugin, pluginName)=>{
            const transformPrefix = transformRoutePrefixFor(pluginName);
            if (Array.isArray(plugin.routes)) {
                return plugin.routes.map(transformPrefix).filter(filterContentAPI);
            }
            const routes = _.flatMap(plugin.routes, (route)=>route.routes.map(transformPrefix)).filter(filterContentAPI);
            if (routes.length === 0) {
                return;
            }
            const apiPrefix = strapi.config.get('api.rest.prefix');
            routesMap[`plugin::${pluginName}`] = routes.map((route)=>({
                    ...route,
                    path: `${apiPrefix}${route.path}`
                }));
        });
        return routesMap;
    };
    const sanitizer = strapiUtils.sanitize.createAPISanitizers({
        getModel (uid) {
            return strapi.getModel(uid);
        },
        // NOTE: use lazy access to allow registration of sanitizers after the creation of the container
        get sanitizers () {
            return {
                input: strapi.sanitizers.get('content-api.input'),
                output: strapi.sanitizers.get('content-api.output')
            };
        }
    });
    const validator = strapiUtils.validate.createAPIValidators({
        getModel (uid) {
            return strapi.getModel(uid);
        },
        // NOTE: use lazy access to allow registration of validators after the creation of the container
        get validators () {
            return {
                input: strapi.validators.get('content-api.input')
            };
        }
    });
    return {
        permissions: instantiatePermissionsUtilities(strapi),
        getRoutesMap,
        sanitize: sanitizer,
        validate: validator
    };
};

const getNumberOfDynamicZones = ()=>{
    const contentTypes = strapi.contentTypes;
    return fp.pipe(fp.map('attributes'), fp.flatMap(fp.values), fp.sumBy((item)=>{
        if (item.type === 'dynamiczone') {
            return 1;
        }
        return 0;
    }))(contentTypes);
};

/**
 * The features service is responsible for managing features within strapi,
 * including interacting with the feature configuration file to know
 * which are enabled and disabled.
 */ const createFeaturesService = (strapi)=>{
    const service = {
        get config () {
            return strapi.config.get('features');
        },
        future: {
            isEnabled (futureFlagName) {
                return service.config?.future?.[futureFlagName] === true;
            }
        }
    };
    return service;
};

const createConfigProvider = (initialConfig = {}, strapi)=>{
    const state = {
        config: {
            ...initialConfig
        }
    };
    // Accessing model configs with dot (.) was deprecated between v4->v5, but to avoid a major breaking change
    // we will still support certain namespaces, currently only 'plugin.'
    const transformPathString = (path)=>{
        if (path.startsWith('plugin.')) {
            const newPath = path.replace('plugin.', 'plugin::');
            // strapi logger may not be loaded yet, so fall back to console
            (strapi?.log?.warn ?? console.warn)(`Using dot notation for model config namespaces is deprecated, for example "plugin::myplugin" should be used instead of "plugin.myplugin". Modifying requested path ${path} to ${newPath}`);
            return newPath;
        }
        return path;
    };
    const transformDeprecatedPaths = (path)=>{
        if (_.isString(path)) {
            return transformPathString(path);
        }
        if (_.isArray(path)) {
            // if the path is not joinable, we won't apply our deprecation support
            if (path.some((part)=>!(_.isString(part) || _.isNumber(part)))) {
                return path;
            }
            return transformPathString(path.join('.'));
        }
        return path;
    };
    return {
        ...state.config,
        get (path, defaultValue) {
            return _.get(state.config, transformDeprecatedPaths(path), defaultValue);
        },
        set (path, val) {
            _.set(state.config, transformDeprecatedPaths(path), val);
            return this;
        },
        has (path) {
            return _.has(state.config, transformDeprecatedPaths(path));
        }
    };
};

class Strapi extends Container {
    get admin() {
        return this.get('admin');
    }
    get EE() {
        return index.isEE;
    }
    get ee() {
        return index;
    }
    get dirs() {
        return this.config.get('dirs');
    }
    get reload() {
        return this.get('reload');
    }
    get db() {
        return this.get('db');
    }
    get requestContext() {
        return this.get('requestContext');
    }
    get customFields() {
        return this.get('customFields');
    }
    get entityValidator() {
        return this.get('entityValidator');
    }
    /**
   * @deprecated `strapi.entityService` will be removed in the next major version
   */ get entityService() {
        return this.get('entityService');
    }
    get documents() {
        return this.get('documents');
    }
    get features() {
        return this.get('features');
    }
    get fetch() {
        return this.get('fetch');
    }
    get cron() {
        return this.get('cron');
    }
    get log() {
        return this.get('logger');
    }
    get startupLogger() {
        return this.get('startupLogger');
    }
    get eventHub() {
        return this.get('eventHub');
    }
    get fs() {
        return this.get('fs');
    }
    get server() {
        return this.get('server');
    }
    get telemetry() {
        return this.get('telemetry');
    }
    get store() {
        return this.get('coreStore');
    }
    get config() {
        return this.get('config');
    }
    get services() {
        return this.get('services').getAll();
    }
    service(uid) {
        return this.get('services').get(uid);
    }
    get controllers() {
        return this.get('controllers').getAll();
    }
    controller(uid) {
        return this.get('controllers').get(uid);
    }
    get contentTypes() {
        return this.get('content-types').getAll();
    }
    contentType(name) {
        return this.get('content-types').get(name);
    }
    get components() {
        return this.get('components').getAll();
    }
    get policies() {
        return this.get('policies').getAll();
    }
    policy(name) {
        return this.get('policies').get(name);
    }
    get middlewares() {
        return this.get('middlewares').getAll();
    }
    middleware(name) {
        return this.get('middlewares').get(name);
    }
    get plugins() {
        return this.get('plugins').getAll();
    }
    plugin(name) {
        return this.get('plugins').get(name);
    }
    get hooks() {
        return this.get('hooks').getAll();
    }
    hook(name) {
        return this.get('hooks').get(name);
    }
    get apis() {
        return this.get('apis').getAll();
    }
    api(name) {
        return this.get('apis').get(name);
    }
    get auth() {
        return this.get('auth');
    }
    get contentAPI() {
        return this.get('content-api');
    }
    get sanitizers() {
        return this.get('sanitizers');
    }
    get validators() {
        return this.get('validators');
    }
    async start() {
        try {
            if (!this.isLoaded) {
                await this.load();
            }
            await this.listen();
            return this;
        } catch (error) {
            return this.stopWithError(error);
        }
    }
    // TODO: split into more providers
    registerInternalServices() {
        const config = createConfigProvider(this.internal_config, this);
        const logger = logger$1.createLogger({
            level: 'http',
            ...config.get('logger'),
            ...config.get('server.logger.config')
        });
        // Instantiate the Strapi container
        this.add('config', ()=>config).add('query-params', createQueryParamService(this)).add('content-api', createContentAPI(this)).add('auth', createAuthentication()).add('server', ()=>createServer(this)).add('fs', ()=>createStrapiFs(this)).add('eventHub', ()=>createEventHub()).add('startupLogger', ()=>createStartupLogger(this)).add('logger', ()=>logger).add('fetch', ()=>createStrapiFetch(this)).add('features', ()=>createFeaturesService(this)).add('requestContext', requestCtx).add('customFields', createCustomFields(this)).add('entityValidator', entityValidator).add('entityService', ()=>createEntityService({
                strapi: this,
                db: this.db
            })).add('documents', ()=>createDocumentService(this)).add('db', ()=>{
            const tsDir = tsUtils.resolveOutDirSync(this.dirs.app.root);
            const tsMigrationsEnabled = this.config.get('database.settings.useTypescriptMigrations') === true && tsDir;
            const projectDir = tsMigrationsEnabled ? tsDir : this.dirs.app.root;
            return new database.Database(_.merge(this.config.get('database'), {
                logger,
                settings: {
                    migrations: {
                        dir: path.join(projectDir, 'database/migrations')
                    }
                }
            }));
        }).add('reload', ()=>createReloader(this));
    }
    sendStartupTelemetry() {
        // Emit started event.
        // do not await to avoid slower startup
        // This event is anonymous
        this.telemetry.send('didStartServer', {
            groupProperties: {
                database: this.config.get('database.connection.client'),
                plugins: Object.keys(this.plugins),
                numberOfAllContentTypes: _.size(this.contentTypes),
                numberOfComponents: _.size(this.components),
                numberOfDynamicZones: getNumberOfDynamicZones(),
                numberOfCustomControllers: Object.values(this.controllers).filter(// TODO: Fix this at the content API loader level to prevent future types issues
                (controller)=>controller !== undefined && isCustomController(controller)).length,
                environment: this.config.environment
            }
        }).catch(this.log.error);
    }
    async openAdmin({ isInitialized }) {
        const shouldOpenAdmin = this.config.get('environment') === 'development' && this.config.get('admin.autoOpen', true) !== false;
        if (shouldOpenAdmin && !isInitialized) {
            try {
                await openBrowser(this.config);
                this.telemetry.send('didOpenTab');
            } catch (e) {
                this.telemetry.send('didNotOpenTab');
            }
        }
    }
    async postListen() {
        const isInitialized$1 = await isInitialized(this);
        this.startupLogger.logStartupMessage({
            isInitialized: isInitialized$1
        });
        this.log.info('Strapi started successfully');
        this.sendStartupTelemetry();
        this.openAdmin({
            isInitialized: isInitialized$1
        });
    }
    /**
   * Add behaviors to the server
   */ async listen() {
        return new Promise((resolve, reject)=>{
            const onListen = async ()=>{
                try {
                    await this.postListen();
                    resolve();
                } catch (error) {
                    reject(error);
                }
            };
            const listenSocket = this.config.get('server.socket');
            if (listenSocket) {
                this.server.listen(listenSocket, onListen);
            } else {
                const { host, port } = this.config.get('server');
                this.server.listen(port, host, onListen);
            }
        });
    }
    stopWithError(err, customMessage) {
        this.log.debug(`⛔️ Server wasn't able to start properly.`);
        if (customMessage) {
            this.log.error(customMessage);
        }
        this.log.error(err);
        return this.stop();
    }
    stop(exitCode = 1) {
        this.destroy();
        if (this.config.get('autoReload')) {
            process.send?.('stop');
        }
        // Kill process
        process.exit(exitCode);
    }
    async load() {
        await this.register();
        await this.bootstrap();
        this.isLoaded = true;
        return this;
    }
    async register() {
        // @ts-expect-error: init is internal
        this.ee.init(this.dirs.app.root, this.log);
        for (const provider of providers){
            await provider.register?.(this);
        }
        await this.runPluginsLifecycles(LIFECYCLES$1.REGISTER);
        await this.runUserLifecycles(LIFECYCLES$1.REGISTER);
        // NOTE: Swap type customField for underlying data type
        convertCustomFieldType(this);
        return this;
    }
    async bootstrap() {
        this.configureGlobalProxy();
        const models = [
            ...transformContentTypesToModels([
                ...Object.values(this.contentTypes),
                ...Object.values(this.components)
            ], this.db.metadata.identifiers),
            ...this.get('models').get()
        ];
        await this.db.init({
            models
        });
        let oldContentTypes;
        if (await this.db.getSchemaConnection().hasTable(coreStoreModel.tableName)) {
            oldContentTypes = await this.store.get({
                type: 'strapi',
                name: 'content_types',
                key: 'schema'
            });
        }
        await this.hook('strapi::content-types.beforeSync').call({
            oldContentTypes,
            contentTypes: this.contentTypes
        });
        const status = await this.db.schema.sync();
        // if schemas have changed, run repairs
        if (status === 'CHANGED') {
            await this.db.repair.removeOrphanMorphType({
                pivot: 'component_type'
            });
        }
        if (this.EE) {
            await index.checkLicense({
                strapi: this
            });
        }
        await this.hook('strapi::content-types.afterSync').call({
            oldContentTypes,
            contentTypes: this.contentTypes
        });
        await this.store.set({
            type: 'strapi',
            name: 'content_types',
            key: 'schema',
            value: this.contentTypes
        });
        await this.server.initMiddlewares();
        this.server.initRouting();
        await this.contentAPI.permissions.registerActions();
        await this.runPluginsLifecycles(LIFECYCLES$1.BOOTSTRAP);
        for (const provider of providers){
            await provider.bootstrap?.(this);
        }
        await this.runUserLifecycles(LIFECYCLES$1.BOOTSTRAP);
        return this;
    }
    configureGlobalProxy() {
        const globalProxy = this.config.get('server.proxy.global');
        const httpProxy = this.config.get('server.proxy.http') || globalProxy;
        const httpsProxy = this.config.get('server.proxy.https') || globalProxy;
        if (!httpProxy && !httpsProxy) {
            return;
        }
        globalAgent__namespace.bootstrap();
        if (httpProxy) {
            this.log.info(`Using HTTP proxy: ${httpProxy}`);
            global.GLOBAL_AGENT.HTTP_PROXY = httpProxy;
        }
        if (httpsProxy) {
            this.log.info(`Using HTTPS proxy: ${httpsProxy}`);
            global.GLOBAL_AGENT.HTTPS_PROXY = httpsProxy;
        }
    }
    async destroy() {
        this.log.info('Shutting down Strapi');
        await this.runPluginsLifecycles(LIFECYCLES$1.DESTROY);
        for (const provider of providers){
            await provider.destroy?.(this);
        }
        await this.runUserLifecycles(LIFECYCLES$1.DESTROY);
        await this.server.destroy();
        this.eventHub.destroy();
        await this.db?.destroy();
        process.removeAllListeners();
        // @ts-expect-error: Allow clean delete of global.strapi to allow re-instanciation
        delete global.strapi;
        this.log.info('Strapi has been shut down');
    }
    async runPluginsLifecycles(lifecycleName) {
        // plugins
        await this.get('modules')[lifecycleName]();
    }
    async runUserLifecycles(lifecycleName) {
        // user
        const userLifecycleFunction = this.app && this.app[lifecycleName];
        if (fp.isFunction(userLifecycleFunction)) {
            await userLifecycleFunction({
                strapi: this
            });
        }
    }
    getModel(uid) {
        if (uid in this.contentTypes) {
            return this.contentTypes[uid];
        }
        if (uid in this.components) {
            return this.components[uid];
        }
    }
    /**
   * @deprecated Use `strapi.db.query` instead
   */ query(uid) {
        return this.db.query(uid);
    }
    constructor(opts){
        super();
        this.isLoaded = false;
        this.internal_config = {};
        this.internal_config = loadConfiguration(opts);
        this.registerInternalServices();
        for (const provider of providers){
            provider.init?.(this);
        }
    }
}

async function compile(options) {
    const { appDir = process.cwd(), ignoreDiagnostics = false } = options ?? {};
    const isTSProject = await tsUtils.isUsingTypeScript(appDir);
    const outDir = await tsUtils.resolveOutDir(appDir);
    if (isTSProject) {
        await tsUtils.compile(appDir, {
            configOptions: {
                options: {
                    incremental: true
                },
                ignoreDiagnostics
            }
        });
    }
    const distDir = isTSProject ? outDir : appDir;
    return {
        appDir,
        distDir
    };
}

const createStrapi = (options = {})=>{
    const strapi = new Strapi({
        ...options,
        ...resolveWorkingDirectories(options)
    });
    destroyOnSignal(strapi);
    createUpdateNotifier(strapi);
    // TODO: deprecate and remove in next major
    global.strapi = strapi;
    return strapi;
};

exports.compileStrapi = compile;
exports.createStrapi = createStrapi;
exports.factories = factories;
//# sourceMappingURL=index.js.map
