'use strict';

var _ = require('lodash');
var utils = require('@strapi/utils');
var range = require('koa-range');
var koaStatic = require('koa-static');
var fp = require('lodash/fp');
var os = require('os');
var path = require('path');
var crypto = require('crypto');
var fs = require('fs');
var fse = require('fs-extra');
var mimeTypes = require('mime-types');
var sharp = require('sharp');
var dateFns = require('date-fns');

/**
 * Programmatic upload middleware. We do not want to expose it in the plugin
 */ var registerUploadMiddleware = (({ strapi })=>{
    strapi.server.app.on('error', (err)=>{
        if (err.code === 'EPIPE') {
            // when serving audio or video the browsers sometimes close the connection to go to range requests instead.
            // This causes koa to emit a write EPIPE error. We can ignore it.
            // Right now this ignores it globally and we cannot do much more because it is how koa handles it.
            return;
        }
        strapi.server.app.onerror(err);
    });
    const localServerConfig = strapi.config.get('plugin::upload.providerOptions.localServer', {});
    strapi.server.routes([
        {
            method: 'GET',
            path: '/uploads/(.*)',
            handler: [
                range,
                koaStatic(strapi.dirs.static.public, {
                    defer: true,
                    ...localServerConfig
                })
            ],
            config: {
                auth: false
            }
        }
    ]);
});

var paths = {
    "/upload": {
        post: {
            description: "Upload files",
            responses: {
                "200": {
                    description: "response",
                    content: {
                        "application/json": {
                            schema: {
                                type: "array",
                                items: {
                                    $ref: "#/components/schemas/UploadFile"
                                }
                            }
                        }
                    }
                }
            },
            summary: "",
            tags: [
                "Upload - File"
            ],
            requestBody: {
                description: "Upload files",
                required: true,
                content: {
                    "multipart/form-data": {
                        schema: {
                            required: [
                                "files"
                            ],
                            type: "object",
                            properties: {
                                path: {
                                    type: "string",
                                    description: "The folder where the file(s) will be uploaded to (only supported on strapi-provider-upload-aws-s3)."
                                },
                                refId: {
                                    type: "string",
                                    description: "The ID of the entry which the file(s) will be linked to"
                                },
                                ref: {
                                    type: "string",
                                    description: "The unique ID (uid) of the model which the file(s) will be linked to (api::restaurant.restaurant)."
                                },
                                field: {
                                    type: "string",
                                    description: "The field of the entry which the file(s) will be precisely linked to."
                                },
                                files: {
                                    type: "array",
                                    items: {
                                        type: "string",
                                        format: "binary"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    "/upload?id={id}": {
        post: {
            parameters: [
                {
                    name: "id",
                    "in": "query",
                    description: "File id",
                    required: true,
                    schema: {
                        type: "string"
                    }
                }
            ],
            description: "Upload file information",
            responses: {
                "200": {
                    description: "response",
                    content: {
                        "application/json": {
                            schema: {
                                type: "array",
                                items: {
                                    $ref: "#/components/schemas/UploadFile"
                                }
                            }
                        }
                    }
                }
            },
            summary: "",
            tags: [
                "Upload - File"
            ],
            requestBody: {
                description: "Upload files",
                required: true,
                content: {
                    "multipart/form-data": {
                        schema: {
                            type: "object",
                            properties: {
                                fileInfo: {
                                    type: "object",
                                    properties: {
                                        name: {
                                            type: "string"
                                        },
                                        alternativeText: {
                                            type: "string"
                                        },
                                        caption: {
                                            type: "string"
                                        }
                                    }
                                },
                                files: {
                                    type: "string",
                                    format: "binary"
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    "/upload/files": {
        get: {
            tags: [
                "Upload - File"
            ],
            responses: {
                "200": {
                    description: "Get a list of files",
                    content: {
                        "application/json": {
                            schema: {
                                type: "array",
                                items: {
                                    $ref: "#/components/schemas/UploadFile"
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    "/upload/files/{id}": {
        get: {
            parameters: [
                {
                    name: "id",
                    "in": "path",
                    description: "",
                    deprecated: false,
                    required: true,
                    schema: {
                        type: "string"
                    }
                }
            ],
            tags: [
                "Upload - File"
            ],
            responses: {
                "200": {
                    description: "Get a specific file",
                    content: {
                        "application/json": {
                            schema: {
                                $ref: "#/components/schemas/UploadFile"
                            }
                        }
                    }
                }
            }
        },
        "delete": {
            parameters: [
                {
                    name: "id",
                    "in": "path",
                    description: "",
                    deprecated: false,
                    required: true,
                    schema: {
                        type: "string"
                    }
                }
            ],
            tags: [
                "Upload - File"
            ],
            responses: {
                "200": {
                    description: "Delete a file",
                    content: {
                        "application/json": {
                            schema: {
                                $ref: "#/components/schemas/UploadFile"
                            }
                        }
                    }
                }
            }
        }
    }
};
var components = {
    schemas: {
        UploadFile: {
            properties: {
                id: {
                    type: "number"
                },
                name: {
                    type: "string"
                },
                alternativeText: {
                    type: "string"
                },
                caption: {
                    type: "string"
                },
                width: {
                    type: "number",
                    format: "integer"
                },
                height: {
                    type: "number",
                    format: "integer"
                },
                formats: {
                    type: "number"
                },
                hash: {
                    type: "string"
                },
                ext: {
                    type: "string"
                },
                mime: {
                    type: "string"
                },
                size: {
                    type: "number",
                    format: "double"
                },
                url: {
                    type: "string"
                },
                previewUrl: {
                    type: "string"
                },
                provider: {
                    type: "string"
                },
                provider_metadata: {
                    type: "object"
                },
                createdAt: {
                    type: "string",
                    format: "date-time"
                },
                updatedAt: {
                    type: "string",
                    format: "date-time"
                }
            }
        }
    }
};
var spec = {
    paths: paths,
    components: components
};

const { PayloadTooLargeError } = utils.errors;
const { bytesToHumanReadable, kbytesToBytes } = utils.file;
/**
 * Register upload plugin
 */ async function register({ strapi }) {
    strapi.plugin('upload').provider = createProvider(strapi.config.get('plugin::upload'));
    await registerUploadMiddleware({
        strapi
    });
    if (strapi.plugin('graphql')) {
        const { installGraphqlExtension } = await Promise.resolve().then(function () { return require('./graphql-BTbIs_EU.js'); });
        installGraphqlExtension({
            strapi
        });
    }
    if (strapi.plugin('documentation')) {
        strapi.plugin('documentation').service('override').registerOverride(spec, {
            pluginOrigin: 'upload',
            excludeFromGeneration: [
                'upload'
            ]
        });
    }
}
const createProvider = (config)=>{
    const { providerOptions, actionOptions = {} } = config;
    const providerName = _.toLower(config.provider);
    let provider;
    let modulePath;
    try {
        modulePath = require.resolve(`@strapi/provider-upload-${providerName}`);
    } catch (error) {
        if (typeof error === 'object' && error !== null && 'code' in error && error.code === 'MODULE_NOT_FOUND') {
            modulePath = providerName;
        } else {
            throw error;
        }
    }
    try {
        provider = require(modulePath);
    } catch (err) {
        const newError = new Error(`Could not load upload provider "${providerName}".`);
        if (err instanceof Error) {
            newError.stack = err.stack;
        }
        throw newError;
    }
    const providerInstance = provider.init(providerOptions);
    if (!providerInstance.delete) {
        throw new Error(`The upload provider "${providerName}" doesn't implement the delete method.`);
    }
    if (!providerInstance.upload && !providerInstance.uploadStream) {
        throw new Error(`The upload provider "${providerName}" doesn't implement the uploadStream nor the upload method.`);
    }
    if (!providerInstance.uploadStream) {
        process.emitWarning(`The upload provider "${providerName}" doesn't implement the uploadStream function. Strapi will fallback on the upload method. Some performance issues may occur.`);
    }
    const wrappedProvider = _.mapValues(providerInstance, (method, methodName)=>{
        return async (file, options = actionOptions[methodName])=>providerInstance[methodName](file, options);
    });
    return Object.assign(Object.create(baseProvider), wrappedProvider);
};
const baseProvider = {
    extend (obj) {
        Object.assign(this, obj);
    },
    checkFileSize (file, { sizeLimit }) {
        if (sizeLimit && kbytesToBytes(file.size) > sizeLimit) {
            throw new PayloadTooLargeError(`${file.originalFilename} exceeds size limit of ${bytesToHumanReadable(sizeLimit)}.`);
        }
    },
    getSignedUrl (file) {
        return file;
    },
    isPrivate () {
        return false;
    }
};

const getService = (name)=>{
    return strapi.plugin('upload').service(name);
};

const ACTIONS = {
    read: 'plugin::upload.read',
    readSettings: 'plugin::upload.settings.read',
    create: 'plugin::upload.assets.create',
    update: 'plugin::upload.assets.update',
    download: 'plugin::upload.assets.download',
    copyLink: 'plugin::upload.assets.copy-link',
    configureView: 'plugin::upload.configure-view'
};
const ALLOWED_SORT_STRINGS = [
    'createdAt:DESC',
    'createdAt:ASC',
    'name:ASC',
    'name:DESC',
    'updatedAt:DESC',
    'updatedAt:ASC'
];
const ALLOWED_WEBHOOK_EVENTS = {
    MEDIA_CREATE: 'media.create',
    MEDIA_UPDATE: 'media.update',
    MEDIA_DELETE: 'media.delete'
};
const FOLDER_MODEL_UID = 'plugin::upload.folder';
const FILE_MODEL_UID = 'plugin::upload.file';
const API_UPLOAD_FOLDER_BASE_NAME = 'API Uploads';

async function bootstrap({ strapi: strapi1 }) {
    const defaultConfig = {
        settings: {
            sizeOptimization: true,
            responsiveDimensions: true,
            autoOrientation: false
        },
        view_configuration: {
            pageSize: 10,
            sort: ALLOWED_SORT_STRINGS[0]
        }
    };
    for (const [key, defaultValue] of Object.entries(defaultConfig)){
        // set plugin store
        const configurator = strapi1.store({
            type: 'plugin',
            name: 'upload',
            key
        });
        const config = await configurator.get({});
        if (config && Object.keys(defaultValue).every((key)=>Object.prototype.hasOwnProperty.call(config, key))) {
            continue;
        }
        // if the config does not exist or does not have all the required keys
        // set from the defaultValue ensuring all required settings are present
        await configurator.set({
            value: Object.assign(defaultValue, config || {})
        });
    }
    await registerPermissionActions();
    await registerWebhookEvents();
    await getService('weeklyMetrics').registerCron();
    getService('metrics').sendUploadPluginMetrics();
    getService('extensions').signFileUrlsOnDocumentService();
}
const registerWebhookEvents = async ()=>Object.entries(ALLOWED_WEBHOOK_EVENTS).forEach(([key, value])=>{
        strapi.get('webhookStore').addAllowedEvent(key, value);
    });
const registerPermissionActions = async ()=>{
    const actions = [
        {
            section: 'plugins',
            displayName: 'Access the Media Library',
            uid: 'read',
            pluginName: 'upload'
        },
        {
            section: 'plugins',
            displayName: 'Create (upload)',
            uid: 'assets.create',
            subCategory: 'assets',
            pluginName: 'upload'
        },
        {
            section: 'plugins',
            displayName: 'Update (crop, details, replace) + delete',
            uid: 'assets.update',
            subCategory: 'assets',
            pluginName: 'upload'
        },
        {
            section: 'plugins',
            displayName: 'Download',
            uid: 'assets.download',
            subCategory: 'assets',
            pluginName: 'upload'
        },
        {
            section: 'plugins',
            displayName: 'Copy link',
            uid: 'assets.copy-link',
            subCategory: 'assets',
            pluginName: 'upload'
        },
        {
            section: 'plugins',
            displayName: 'Configure view',
            uid: 'configure-view',
            pluginName: 'upload'
        },
        {
            section: 'settings',
            displayName: 'Access the Media Library settings page',
            uid: 'settings.read',
            category: 'media library',
            pluginName: 'upload'
        }
    ];
    await strapi.service('admin::permission').actionProvider.registerMany(actions);
};

var file$1 = {
    schema: {
        collectionName: 'files',
        info: {
            singularName: 'file',
            pluralName: 'files',
            displayName: 'File',
            description: ''
        },
        options: {},
        pluginOptions: {
            'content-manager': {
                visible: false
            },
            'content-type-builder': {
                visible: false
            }
        },
        attributes: {
            name: {
                type: 'string',
                configurable: false,
                required: true
            },
            alternativeText: {
                type: 'string',
                configurable: false
            },
            caption: {
                type: 'string',
                configurable: false
            },
            width: {
                type: 'integer',
                configurable: false
            },
            height: {
                type: 'integer',
                configurable: false
            },
            formats: {
                type: 'json',
                configurable: false
            },
            hash: {
                type: 'string',
                configurable: false,
                required: true
            },
            ext: {
                type: 'string',
                configurable: false
            },
            mime: {
                type: 'string',
                configurable: false,
                required: true
            },
            size: {
                type: 'decimal',
                configurable: false,
                required: true
            },
            url: {
                type: 'string',
                configurable: false,
                required: true
            },
            previewUrl: {
                type: 'string',
                configurable: false
            },
            provider: {
                type: 'string',
                configurable: false,
                required: true
            },
            provider_metadata: {
                type: 'json',
                configurable: false
            },
            related: {
                type: 'relation',
                relation: 'morphToMany',
                configurable: false
            },
            folder: {
                type: 'relation',
                relation: 'manyToOne',
                target: FOLDER_MODEL_UID,
                inversedBy: 'files',
                private: true
            },
            folderPath: {
                type: 'string',
                minLength: 1,
                required: true,
                private: true,
                searchable: false
            }
        },
        // experimental feature:
        indexes: [
            {
                name: 'upload_files_folder_path_index',
                columns: [
                    'folder_path'
                ],
                type: null
            },
            {
                name: `upload_files_created_at_index`,
                columns: [
                    'created_at'
                ],
                type: null
            },
            {
                name: `upload_files_updated_at_index`,
                columns: [
                    'updated_at'
                ],
                type: null
            },
            {
                name: `upload_files_name_index`,
                columns: [
                    'name'
                ],
                type: null
            },
            {
                name: `upload_files_size_index`,
                columns: [
                    'size'
                ],
                type: null
            },
            {
                name: `upload_files_ext_index`,
                columns: [
                    'ext'
                ],
                type: null
            }
        ]
    }
};

var folder$1 = {
    schema: {
        collectionName: 'upload_folders',
        info: {
            singularName: 'folder',
            pluralName: 'folders',
            displayName: 'Folder'
        },
        options: {},
        pluginOptions: {
            'content-manager': {
                visible: false
            },
            'content-type-builder': {
                visible: false
            }
        },
        attributes: {
            name: {
                type: 'string',
                minLength: 1,
                required: true
            },
            pathId: {
                type: 'integer',
                unique: true,
                required: true
            },
            parent: {
                type: 'relation',
                relation: 'manyToOne',
                target: FOLDER_MODEL_UID,
                inversedBy: 'children'
            },
            children: {
                type: 'relation',
                relation: 'oneToMany',
                target: FOLDER_MODEL_UID,
                mappedBy: 'parent'
            },
            files: {
                type: 'relation',
                relation: 'oneToMany',
                target: FILE_MODEL_UID,
                mappedBy: 'folder'
            },
            path: {
                type: 'string',
                minLength: 1,
                required: true
            }
        },
        // experimental feature:
        indexes: [
            {
                name: 'upload_folders_path_id_index',
                columns: [
                    'path_id'
                ],
                type: 'unique'
            },
            {
                name: 'upload_folders_path_index',
                columns: [
                    'path'
                ],
                type: 'unique'
            }
        ]
    }
};

const contentTypes = {
    file: file$1,
    folder: folder$1
};

var provider = (({ strapi })=>({
        async checkFileSize (file) {
            const { sizeLimit } = strapi.config.get('plugin::upload');
            await strapi.plugin('upload').provider.checkFileSize(file, {
                sizeLimit
            });
        },
        async upload (file) {
            if (fp.isFunction(strapi.plugin('upload').provider.uploadStream)) {
                file.stream = file.getStream();
                await strapi.plugin('upload').provider.uploadStream(file);
                delete file.stream;
                if ('filepath' in file) {
                    delete file.filepath;
                }
            } else {
                file.buffer = await utils.file.streamToBuffer(file.getStream());
                await strapi.plugin('upload').provider.upload(file);
                delete file.buffer;
                if ('filepath' in file) {
                    delete file.filepath;
                }
            }
        }
    }));

const { UPDATED_BY_ATTRIBUTE, CREATED_BY_ATTRIBUTE } = utils.contentTypes.constants;
const { MEDIA_CREATE, MEDIA_UPDATE, MEDIA_DELETE } = ALLOWED_WEBHOOK_EVENTS;
const { ApplicationError, NotFoundError } = utils.errors;
const { bytesToKbytes: bytesToKbytes$1 } = utils.file;
var upload = (({ strapi })=>{
    const randomSuffix = ()=>crypto.randomBytes(5).toString('hex');
    const generateFileName = (name)=>{
        const baseName = utils.strings.nameToSlug(name, {
            separator: '_',
            lowercase: false
        });
        return `${baseName}_${randomSuffix()}`;
    };
    const sendMediaMetrics = (data)=>{
        if (_.has(data, 'caption') && !_.isEmpty(data.caption)) {
            strapi.telemetry.send('didSaveMediaWithCaption');
        }
        if (_.has(data, 'alternativeText') && !_.isEmpty(data.alternativeText)) {
            strapi.telemetry.send('didSaveMediaWithAlternativeText');
        }
    };
    const createAndAssignTmpWorkingDirectoryToFiles = async (files)=>{
        const tmpWorkingDirectory = await fse.mkdtemp(path.join(os.tmpdir(), 'strapi-upload-'));
        if (Array.isArray(files)) {
            files.forEach((file)=>{
                file.tmpWorkingDirectory = tmpWorkingDirectory;
            });
        } else {
            files.tmpWorkingDirectory = tmpWorkingDirectory;
        }
        return tmpWorkingDirectory;
    };
    function filenameReservedRegex() {
        // eslint-disable-next-line no-control-regex
        return /[<>:"/\\|?*\u0000-\u001F]/g;
    }
    function windowsReservedNameRegex() {
        return /^(con|prn|aux|nul|com\d|lpt\d)$/i;
    }
    /**
   * Copied from https://github.com/sindresorhus/valid-filename package
   */ function isValidFilename(string) {
        if (!string || string.length > 255) {
            return false;
        }
        if (filenameReservedRegex().test(string) || windowsReservedNameRegex().test(string)) {
            return false;
        }
        if (string === '.' || string === '..') {
            return false;
        }
        return true;
    }
    async function emitEvent(event, data) {
        const modelDef = strapi.getModel(FILE_MODEL_UID);
        const sanitizedData = await utils.sanitize.sanitizers.defaultSanitizeOutput({
            schema: modelDef,
            getModel (uid) {
                return strapi.getModel(uid);
            }
        }, data);
        strapi.eventHub.emit(event, {
            media: sanitizedData
        });
    }
    async function formatFileInfo({ filename, type, size }, fileInfo = {}, metas = {}) {
        const fileService = getService('file');
        if (!isValidFilename(filename)) {
            throw new ApplicationError('File name contains invalid characters');
        }
        let ext = path.extname(filename);
        if (!ext) {
            ext = `.${mimeTypes.extension(type)}`;
        }
        const usedName = (fileInfo.name || filename).normalize();
        const basename = path.basename(usedName, ext);
        // Prevent null characters in file name
        if (!isValidFilename(filename)) {
            throw new ApplicationError('File name contains invalid characters');
        }
        const entity = {
            name: usedName,
            alternativeText: fileInfo.alternativeText,
            caption: fileInfo.caption,
            folder: fileInfo.folder,
            folderPath: await fileService.getFolderPath(fileInfo.folder),
            hash: generateFileName(basename),
            ext,
            mime: type,
            size: bytesToKbytes$1(size),
            sizeInBytes: size
        };
        const { refId, ref, field } = metas;
        if (refId && ref && field) {
            entity.related = [
                {
                    id: refId,
                    __type: ref,
                    __pivot: {
                        field
                    }
                }
            ];
        }
        if (metas.path) {
            entity.path = metas.path;
        }
        if (metas.tmpWorkingDirectory) {
            entity.tmpWorkingDirectory = metas.tmpWorkingDirectory;
        }
        return entity;
    }
    async function enhanceAndValidateFile(file, fileInfo, metas) {
        const currentFile = await formatFileInfo({
            filename: file.originalFilename ?? 'unamed',
            type: file.mimetype ?? 'application/octet-stream',
            size: file.size
        }, fileInfo, {
            ...metas,
            tmpWorkingDirectory: file.tmpWorkingDirectory
        });
        currentFile.filepath = file.filepath;
        currentFile.getStream = ()=>fs.createReadStream(file.filepath);
        const { optimize, isImage, isFaultyImage, isOptimizableImage } = strapi.plugin('upload').service('image-manipulation');
        if (await isImage(currentFile)) {
            if (await isFaultyImage(currentFile)) {
                throw new ApplicationError('File is not a valid image');
            }
            if (await isOptimizableImage(currentFile)) {
                return optimize(currentFile);
            }
        }
        return currentFile;
    }
    async function upload({ data, files }, opts) {
        const { user } = opts ?? {};
        // create temporary folder to store files for stream manipulation
        const tmpWorkingDirectory = await createAndAssignTmpWorkingDirectoryToFiles(files);
        let uploadedFiles = [];
        try {
            const { fileInfo, ...metas } = data;
            const fileArray = Array.isArray(files) ? files : [
                files
            ];
            const fileInfoArray = Array.isArray(fileInfo) ? fileInfo : [
                fileInfo
            ];
            const doUpload = async (file, fileInfo)=>{
                const fileData = await enhanceAndValidateFile(file, fileInfo, metas);
                return uploadFileAndPersist(fileData, {
                    user
                });
            };
            uploadedFiles = await Promise.all(fileArray.map((file, idx)=>doUpload(file, fileInfoArray[idx] || {})));
        } finally{
            // delete temporary folder
            await fse.remove(tmpWorkingDirectory);
        }
        return uploadedFiles;
    }
    /**
   * When uploading an image, an additional thumbnail is generated.
   * Also, if there are responsive formats defined, another set of images will be generated too.
   *
   * @param {*} fileData
   */ async function uploadImage(fileData) {
        const { getDimensions, generateThumbnail, generateResponsiveFormats, isResizableImage } = getService('image-manipulation');
        // Store width and height of the original image
        const { width, height } = await getDimensions(fileData);
        // Make sure this is assigned before calling any upload
        // That way it can mutate the width and height
        _.assign(fileData, {
            width,
            height
        });
        // For performance reasons, all uploads are wrapped in a single Promise.all
        const uploadThumbnail = async (thumbnailFile)=>{
            await getService('provider').upload(thumbnailFile);
            _.set(fileData, 'formats.thumbnail', thumbnailFile);
        };
        // Generate thumbnail and responsive formats
        const uploadResponsiveFormat = async (format)=>{
            const { key, file } = format;
            await getService('provider').upload(file);
            _.set(fileData, [
                'formats',
                key
            ], file);
        };
        const uploadPromises = [];
        // Upload image
        uploadPromises.push(getService('provider').upload(fileData));
        // Generate & Upload thumbnail and responsive formats
        if (await isResizableImage(fileData)) {
            const thumbnailFile = await generateThumbnail(fileData);
            if (thumbnailFile) {
                uploadPromises.push(uploadThumbnail(thumbnailFile));
            }
            const formats = await generateResponsiveFormats(fileData);
            if (Array.isArray(formats) && formats.length > 0) {
                for (const format of formats){
                    // eslint-disable-next-line no-continue
                    if (!format) continue;
                    uploadPromises.push(uploadResponsiveFormat(format));
                }
            }
        }
        // Wait for all uploads to finish
        await Promise.all(uploadPromises);
    }
    /**
   * Upload a file. If it is an image it will generate a thumbnail
   * and responsive formats (if enabled).
   */ async function uploadFileAndPersist(fileData, opts) {
        const { user } = opts ?? {};
        const config = strapi.config.get('plugin::upload');
        const { isImage } = getService('image-manipulation');
        await getService('provider').checkFileSize(fileData);
        if (await isImage(fileData)) {
            await uploadImage(fileData);
        } else {
            await getService('provider').upload(fileData);
        }
        _.set(fileData, 'provider', config.provider);
        // Persist file(s)
        return add(fileData, {
            user
        });
    }
    async function updateFileInfo(id, { name, alternativeText, caption, folder }, opts) {
        const { user } = opts ?? {};
        const dbFile = await findOne(id);
        if (!dbFile) {
            throw new NotFoundError();
        }
        const fileService = getService('file');
        const newName = _.isNil(name) ? dbFile.name : name;
        const newInfos = {
            name: newName,
            alternativeText: _.isNil(alternativeText) ? dbFile.alternativeText : alternativeText,
            caption: _.isNil(caption) ? dbFile.caption : caption,
            folder: _.isUndefined(folder) ? dbFile.folder : folder,
            folderPath: _.isUndefined(folder) ? dbFile.path : await fileService.getFolderPath(folder)
        };
        return update(id, newInfos, {
            user
        });
    }
    async function replace(id, { data, file }, opts) {
        const { user } = opts ?? {};
        const config = strapi.config.get('plugin::upload');
        const { isImage } = getService('image-manipulation');
        const dbFile = await findOne(id);
        if (!dbFile) {
            throw new NotFoundError();
        }
        // create temporary folder to store files for stream manipulation
        const tmpWorkingDirectory = await createAndAssignTmpWorkingDirectoryToFiles(file);
        let fileData;
        try {
            const { fileInfo } = data;
            fileData = await enhanceAndValidateFile(file, fileInfo);
            // keep a constant hash and extension so the file url doesn't change when the file is replaced
            _.assign(fileData, {
                hash: dbFile.hash,
                ext: dbFile.ext
            });
            // execute delete function of the provider
            if (dbFile.provider === config.provider) {
                await strapi.plugin('upload').provider.delete(dbFile);
                if (dbFile.formats) {
                    await Promise.all(Object.keys(dbFile.formats).map((key)=>{
                        return strapi.plugin('upload').provider.delete(dbFile.formats[key]);
                    }));
                }
            }
            // clear old formats
            _.set(fileData, 'formats', {});
            if (await isImage(fileData)) {
                await uploadImage(fileData);
            } else {
                await getService('provider').upload(fileData);
            }
            _.set(fileData, 'provider', config.provider);
        } finally{
            // delete temporary folder
            await fse.remove(tmpWorkingDirectory);
        }
        return update(id, fileData, {
            user
        });
    }
    async function update(id, values, opts) {
        const { user } = opts ?? {};
        const fileValues = {
            ...values
        };
        if (user) {
            Object.assign(fileValues, {
                [UPDATED_BY_ATTRIBUTE]: user.id
            });
        }
        sendMediaMetrics(fileValues);
        const res = await strapi.db.query(FILE_MODEL_UID).update({
            where: {
                id
            },
            data: fileValues
        });
        await emitEvent(MEDIA_UPDATE, res);
        return res;
    }
    async function add(values, opts) {
        const { user } = opts ?? {};
        const fileValues = {
            ...values
        };
        if (user) {
            Object.assign(fileValues, {
                [UPDATED_BY_ATTRIBUTE]: user.id,
                [CREATED_BY_ATTRIBUTE]: user.id
            });
        }
        sendMediaMetrics(fileValues);
        const res = await strapi.db.query(FILE_MODEL_UID).create({
            data: fileValues
        });
        await emitEvent(MEDIA_CREATE, res);
        return res;
    }
    function findOne(id, populate = {}) {
        const query = strapi.get('query-params').transform(FILE_MODEL_UID, {
            populate
        });
        return strapi.db.query(FILE_MODEL_UID).findOne({
            where: {
                id
            },
            ...query
        });
    }
    function findMany(query = {}) {
        return strapi.db.query(FILE_MODEL_UID).findMany(strapi.get('query-params').transform(FILE_MODEL_UID, query));
    }
    function findPage(query = {}) {
        return strapi.db.query(FILE_MODEL_UID).findPage(strapi.get('query-params').transform(FILE_MODEL_UID, query));
    }
    async function remove(file) {
        const config = strapi.config.get('plugin::upload');
        // execute delete function of the provider
        if (file.provider === config.provider) {
            await strapi.plugin('upload').provider.delete(file);
            if (file.formats) {
                const keys = Object.keys(file.formats);
                await Promise.all(keys.map((key)=>{
                    return strapi.plugin('upload').provider.delete(file.formats[key]);
                }));
            }
        }
        const media = await strapi.db.query(FILE_MODEL_UID).findOne({
            where: {
                id: file.id
            }
        });
        await emitEvent(MEDIA_DELETE, media);
        return strapi.db.query(FILE_MODEL_UID).delete({
            where: {
                id: file.id
            }
        });
    }
    async function getSettings() {
        const res = await strapi.store({
            type: 'plugin',
            name: 'upload',
            key: 'settings'
        }).get({});
        return res;
    }
    function setSettings(value) {
        if (value.responsiveDimensions === true) {
            strapi.telemetry.send('didEnableResponsiveDimensions');
        } else {
            strapi.telemetry.send('didDisableResponsiveDimensions');
        }
        return strapi.store({
            type: 'plugin',
            name: 'upload',
            key: 'settings'
        }).set({
            value
        });
    }
    async function getConfiguration() {
        const res = await strapi.store({
            type: 'plugin',
            name: 'upload',
            key: 'view_configuration'
        }).get({});
        return res;
    }
    function setConfiguration(value) {
        return strapi.store({
            type: 'plugin',
            name: 'upload',
            key: 'view_configuration'
        }).set({
            value
        });
    }
    return {
        formatFileInfo,
        upload,
        updateFileInfo,
        replace,
        findOne,
        findMany,
        findPage,
        remove,
        getSettings,
        setSettings,
        getConfiguration,
        setConfiguration,
        /**
     * exposed for testing only
     * @internal
     */ _uploadImage: uploadImage
    };
});

const { bytesToKbytes } = utils.file;
const FORMATS_TO_RESIZE = [
    'jpeg',
    'png',
    'webp',
    'tiff',
    'gif'
];
const FORMATS_TO_PROCESS = [
    'jpeg',
    'png',
    'webp',
    'tiff',
    'svg',
    'gif',
    'avif'
];
const FORMATS_TO_OPTIMIZE = [
    'jpeg',
    'png',
    'webp',
    'tiff',
    'avif'
];
const isOptimizableFormat = (format)=>format !== undefined && FORMATS_TO_OPTIMIZE.includes(format);
const writeStreamToFile = (stream, path)=>new Promise((resolve, reject)=>{
        const writeStream = fs.createWriteStream(path);
        // Reject promise if there is an error with the provided stream
        stream.on('error', reject);
        stream.pipe(writeStream);
        writeStream.on('close', resolve);
        writeStream.on('error', reject);
    });
const getMetadata = (file)=>{
    if (!file.filepath) {
        return new Promise((resolve, reject)=>{
            const pipeline = sharp();
            pipeline.metadata().then(resolve).catch(reject);
            file.getStream().pipe(pipeline);
        });
    }
    return sharp(file.filepath).metadata();
};
const getDimensions = async (file)=>{
    const { width = null, height = null } = await getMetadata(file);
    return {
        width,
        height
    };
};
const THUMBNAIL_RESIZE_OPTIONS = {
    width: 245,
    height: 156,
    fit: 'inside'
};
const resizeFileTo = async (file, options, { name, hash })=>{
    const filePath = file.tmpWorkingDirectory ? path.join(file.tmpWorkingDirectory, hash) : hash;
    let newInfo;
    if (!file.filepath) {
        const transform = sharp().resize(options).on('info', (info)=>{
            newInfo = info;
        });
        await writeStreamToFile(file.getStream().pipe(transform), filePath);
    } else {
        newInfo = await sharp(file.filepath).resize(options).toFile(filePath);
    }
    const { width, height, size } = newInfo ?? {};
    const newFile = {
        name,
        hash,
        ext: file.ext,
        mime: file.mime,
        filepath: filePath,
        path: file.path || null,
        getStream: ()=>fs.createReadStream(filePath)
    };
    Object.assign(newFile, {
        width,
        height,
        size: size ? bytesToKbytes(size) : 0,
        sizeInBytes: size
    });
    return newFile;
};
const generateThumbnail = async (file)=>{
    if (file.width && file.height && (file.width > THUMBNAIL_RESIZE_OPTIONS.width || file.height > THUMBNAIL_RESIZE_OPTIONS.height)) {
        return resizeFileTo(file, THUMBNAIL_RESIZE_OPTIONS, {
            name: `thumbnail_${file.name}`,
            hash: `thumbnail_${file.hash}`
        });
    }
    return null;
};
/**
 * Optimize image by:
 *    - auto orienting image based on EXIF data
 *    - reduce image quality
 *
 */ const optimize = async (file)=>{
    const { sizeOptimization = false, autoOrientation = false } = await getService('upload').getSettings() ?? {};
    const { format, size } = await getMetadata(file);
    if ((sizeOptimization || autoOrientation) && isOptimizableFormat(format)) {
        let transformer;
        if (!file.filepath) {
            transformer = sharp();
        } else {
            transformer = sharp(file.filepath);
        }
        // reduce image quality
        transformer[format]({
            quality: sizeOptimization ? 80 : 100
        });
        // rotate image based on EXIF data
        if (autoOrientation) {
            transformer.rotate();
        }
        const filePath = file.tmpWorkingDirectory ? path.join(file.tmpWorkingDirectory, `optimized-${file.hash}`) : `optimized-${file.hash}`;
        let newInfo;
        if (!file.filepath) {
            transformer.on('info', (info)=>{
                newInfo = info;
            });
            await writeStreamToFile(file.getStream().pipe(transformer), filePath);
        } else {
            newInfo = await transformer.toFile(filePath);
        }
        const { width: newWidth, height: newHeight, size: newSize } = newInfo ?? {};
        const newFile = {
            ...file
        };
        newFile.getStream = ()=>fs.createReadStream(filePath);
        newFile.filepath = filePath;
        if (newSize && size && newSize > size) {
            // Ignore optimization if output is bigger than original
            return file;
        }
        return Object.assign(newFile, {
            width: newWidth,
            height: newHeight,
            size: newSize ? bytesToKbytes(newSize) : 0,
            sizeInBytes: newSize
        });
    }
    return file;
};
const DEFAULT_BREAKPOINTS = {
    large: 1000,
    medium: 750,
    small: 500
};
const getBreakpoints = ()=>strapi.config.get('plugin::upload.breakpoints', DEFAULT_BREAKPOINTS);
const generateResponsiveFormats = async (file)=>{
    const { responsiveDimensions = false } = await getService('upload').getSettings() ?? {};
    if (!responsiveDimensions) return [];
    const originalDimensions = await getDimensions(file);
    const breakpoints = getBreakpoints();
    return Promise.all(Object.keys(breakpoints).map((key)=>{
        const breakpoint = breakpoints[key];
        if (breakpointSmallerThan(breakpoint, originalDimensions)) {
            return generateBreakpoint(key, {
                file,
                breakpoint
            });
        }
        return undefined;
    }));
};
const generateBreakpoint = async (key, { file, breakpoint })=>{
    const newFile = await resizeFileTo(file, {
        width: breakpoint,
        height: breakpoint,
        fit: 'inside'
    }, {
        name: `${key}_${file.name}`,
        hash: `${key}_${file.hash}`
    });
    return {
        key,
        file: newFile
    };
};
const breakpointSmallerThan = (breakpoint, { width, height })=>{
    return breakpoint < (width ?? 0) || breakpoint < (height ?? 0);
};
/**
 *  Applies a simple image transformation to see if the image is faulty/corrupted.
 */ const isFaultyImage = async (file)=>{
    if (!file.filepath) {
        return new Promise((resolve, reject)=>{
            const pipeline = sharp();
            pipeline.stats().then(resolve).catch(reject);
            file.getStream().pipe(pipeline);
        });
    }
    try {
        await sharp(file.filepath).stats();
        return false;
    } catch (e) {
        return true;
    }
};
const isOptimizableImage = async (file)=>{
    let format;
    try {
        const metadata = await getMetadata(file);
        format = metadata.format;
    } catch (e) {
        // throw when the file is not a supported image
        return false;
    }
    return format && FORMATS_TO_OPTIMIZE.includes(format);
};
const isResizableImage = async (file)=>{
    let format;
    try {
        const metadata = await getMetadata(file);
        format = metadata.format;
    } catch (e) {
        // throw when the file is not a supported image
        return false;
    }
    return format && FORMATS_TO_RESIZE.includes(format);
};
const isImage = async (file)=>{
    let format;
    try {
        const metadata = await getMetadata(file);
        format = metadata.format;
    } catch (e) {
        // throw when the file is not a supported image
        return false;
    }
    return format && FORMATS_TO_PROCESS.includes(format);
};
var imageManipulation = {
    isFaultyImage,
    isOptimizableImage,
    isResizableImage,
    isImage,
    getDimensions,
    generateResponsiveFormats,
    generateThumbnail,
    optimize
};

const setPathIdAndPath = async (folder)=>{
    const { max } = await strapi.db.queryBuilder(FOLDER_MODEL_UID).max('pathId').first().execute();
    const pathId = max + 1;
    let parentPath = '/';
    if (folder.parent) {
        const parentFolder = await strapi.db.query(FOLDER_MODEL_UID).findOne({
            where: {
                id: folder.parent
            }
        });
        parentPath = parentFolder.path;
    }
    return Object.assign(folder, {
        pathId,
        path: utils.strings.joinBy('/', parentPath, `${pathId}`)
    });
};
const create = async (folderData, opts)=>{
    const folderService = getService('folder');
    const { user } = opts || {};
    let enrichedFolder = await folderService.setPathIdAndPath(folderData);
    if (user) {
        enrichedFolder = await utils.setCreatorFields({
            user
        })(enrichedFolder);
    }
    const folder = await strapi.db.query(FOLDER_MODEL_UID).create({
        data: enrichedFolder
    });
    strapi.eventHub.emit('media-folder.create', {
        folder
    });
    return folder;
};
/**
 * Recursively delete folders and included files
 * @param ids ids of the folders to delete
 * @returns {Promise<Object[]>}
 */ const deleteByIds$1 = async (ids = [])=>{
    const folders = await strapi.db.query(FOLDER_MODEL_UID).findMany({
        where: {
            id: {
                $in: ids
            }
        }
    });
    if (folders.length === 0) {
        return {
            folders: [],
            totalFolderNumber: 0,
            totalFileNumber: 0
        };
    }
    const pathsToDelete = fp.map('path', folders);
    // delete files
    const filesToDelete = await strapi.db.query(FILE_MODEL_UID).findMany({
        where: {
            $or: pathsToDelete.flatMap((path)=>[
                    {
                        folderPath: {
                            $eq: path
                        }
                    },
                    {
                        folderPath: {
                            $startsWith: `${path}/`
                        }
                    }
                ])
        }
    });
    await Promise.all(filesToDelete.map((file)=>getService('upload').remove(file)));
    // delete folders and subfolders
    const { count: totalFolderNumber } = await strapi.db.query(FOLDER_MODEL_UID).deleteMany({
        where: {
            $or: pathsToDelete.flatMap((path)=>[
                    {
                        path: {
                            $eq: path
                        }
                    },
                    {
                        path: {
                            $startsWith: `${path}/`
                        }
                    }
                ])
        }
    });
    strapi.eventHub.emit('media-folder.delete', {
        folders
    });
    return {
        folders,
        totalFolderNumber,
        totalFileNumber: filesToDelete.length
    };
};
/**
 * Update name and location of a folder and its belonging folders and files
 */ const update = async (id, { name, parent }, { user })=>{
    // only name is updated
    if (fp.isUndefined(parent)) {
        const existingFolder = await strapi.db.query(FOLDER_MODEL_UID).findOne({
            where: {
                id
            }
        });
        if (!existingFolder) {
            return undefined;
        }
        const newFolder = utils.setCreatorFields({
            user,
            isEdition: true
        })({
            name,
            parent
        });
        if (fp.isUndefined(parent)) {
            const folder = await strapi.db.query(FOLDER_MODEL_UID).update({
                where: {
                    id
                },
                data: newFolder
            });
            return folder;
        }
    // location is updated => using transaction
    } else {
        const trx = await strapi.db.transaction();
        try {
            // fetch existing folder
            const existingFolder = await strapi.db.queryBuilder(FOLDER_MODEL_UID).select([
                'pathId',
                'path'
            ]).where({
                id
            }).transacting(trx.get()).forUpdate().first().execute();
            // update parent folder (delete + insert; upsert not possible)
            // @ts-expect-error - no dynamic types
            const { joinTable } = strapi.db.metadata.get(FOLDER_MODEL_UID).attributes.parent;
            await strapi.db.queryBuilder(joinTable.name).transacting(trx.get()).delete().where({
                [joinTable.joinColumn.name]: id
            }).execute();
            if (parent !== null) {
                await strapi.db.queryBuilder(joinTable.name).transacting(trx.get()).insert({
                    [joinTable.inverseJoinColumn.name]: parent,
                    [joinTable.joinColumn.name]: id
                }).where({
                    [joinTable.joinColumn.name]: id
                }).execute();
            }
            // fetch destinationFolder path
            let destinationFolderPath = '/';
            if (parent !== null) {
                const destinationFolder = await strapi.db.queryBuilder(FOLDER_MODEL_UID).select('path').where({
                    id: parent
                }).transacting(trx.get()).first().execute();
                destinationFolderPath = destinationFolder.path;
            }
            const folderTable = strapi.getModel(FOLDER_MODEL_UID).collectionName;
            const fileTable = strapi.getModel(FILE_MODEL_UID).collectionName;
            const folderPathColumnName = // @ts-expect-error - no dynamic types
            strapi.db.metadata.get(FILE_MODEL_UID).attributes.folderPath.columnName;
            // @ts-expect-error - no dynamic types
            const pathColumnName = strapi.db.metadata.get(FOLDER_MODEL_UID).attributes.path.columnName;
            // update folders below
            await strapi.db.getConnection(folderTable).transacting(trx.get()).where(pathColumnName, existingFolder.path).orWhere(pathColumnName, 'like', `${existingFolder.path}/%`).update(pathColumnName, strapi.db.connection.raw('REPLACE(??, ?, ?)', [
                pathColumnName,
                existingFolder.path,
                utils.strings.joinBy('/', destinationFolderPath, `${existingFolder.pathId}`)
            ]));
            // update files below
            await strapi.db.getConnection(fileTable).transacting(trx.get()).where(folderPathColumnName, existingFolder.path).orWhere(folderPathColumnName, 'like', `${existingFolder.path}/%`).update(folderPathColumnName, strapi.db.connection.raw('REPLACE(??, ?, ?)', [
                folderPathColumnName,
                existingFolder.path,
                utils.strings.joinBy('/', destinationFolderPath, `${existingFolder.pathId}`)
            ]));
            await trx.commit();
        } catch (e) {
            await trx.rollback();
            throw e;
        }
        // update less critical information (name + updatedBy)
        const newFolder = utils.setCreatorFields({
            user,
            isEdition: true
        })({
            name
        });
        const folder = await strapi.db.query(FOLDER_MODEL_UID).update({
            where: {
                id
            },
            data: newFolder
        });
        strapi.eventHub.emit('media-folder.update', {
            folder
        });
        return folder;
    }
};
/**
 * Check if a folder exists in database
 * @param params query params to find the folder
 * @returns {Promise<boolean>}
 */ const exists = async (params = {})=>{
    const count = await strapi.db.query(FOLDER_MODEL_UID).count({
        where: params
    });
    return count > 0;
};
/**
 * Returns the nested structure of folders
 * @returns {Promise<array>}
 */ const getStructure = async ()=>{
    // @ts-expect-error - no dynamic types
    const { joinTable } = strapi.db.metadata.get(FOLDER_MODEL_UID).attributes.parent;
    const qb = strapi.db.queryBuilder(FOLDER_MODEL_UID);
    const alias = qb.getAlias();
    const folders = await qb.select([
        'id',
        'name',
        `${alias}.${joinTable.inverseJoinColumn.name} as parent`
    ]).join({
        alias,
        referencedTable: joinTable.name,
        referencedColumn: joinTable.joinColumn.name,
        rootColumn: joinTable.joinColumn.referencedColumn,
        rootTable: qb.alias
    }).execute({
        mapResults: false
    });
    const folderMap = {
        null: {
            children: []
        }
    };
    folders.forEach((f)=>{
        folderMap[f.id] = {
            ...f,
            children: []
        };
    });
    folders.forEach((f)=>{
        const parentId = f.parent || 'null';
        if (!folderMap[parentId]) {
            folderMap[parentId] = {
                children: []
            };
        }
        folderMap[parentId].children.push(folderMap[f.id]);
        folderMap[parentId].children = fp.sortBy('name', folderMap[parentId].children);
        delete folderMap[f.id].parent;
    });
    return folderMap.null.children;
};
var folder = {
    create,
    exists,
    deleteByIds: deleteByIds$1,
    update,
    setPathIdAndPath,
    getStructure
};

const getFolderPath = async (folderId)=>{
    if (!folderId) return '/';
    const parentFolder = await strapi.db.query(FOLDER_MODEL_UID).findOne({
        where: {
            id: folderId
        }
    });
    return parentFolder.path;
};
const deleteByIds = async (ids = [])=>{
    const filesToDelete = await strapi.db.query(FILE_MODEL_UID).findMany({
        where: {
            id: {
                $in: ids
            }
        }
    });
    await Promise.all(filesToDelete.map((file)=>getService('upload').remove(file)));
    return filesToDelete;
};
const signFileUrls = async (file)=>{
    const { provider } = strapi.plugins.upload;
    const { provider: providerConfig } = strapi.config.get('plugin::upload');
    const isPrivate = await provider.isPrivate();
    file.isUrlSigned = false;
    // Check file provider and if provider is private
    if (file.provider !== providerConfig || !isPrivate) {
        return file;
    }
    const signUrl = async (file)=>{
        const signedUrl = await provider.getSignedUrl(file);
        file.url = signedUrl.url;
        file.isUrlSigned = true;
    };
    const signedFile = fp.cloneDeep(file);
    // Sign each file format
    await signUrl(signedFile);
    if (file.formats) {
        await utils.async.map(Object.values(signedFile.formats ?? {}), signUrl);
    }
    return signedFile;
};
var file = {
    getFolderPath,
    deleteByIds,
    signFileUrls
};

const getWeeklyCronScheduleAt = (date)=>`${date.getSeconds()} ${date.getMinutes()} ${date.getHours()} * * ${date.getDay()}`;

const ONE_WEEK = 7 * 24 * 60 * 60 * 1000;
const getMetricsStoreValue = async ()=>{
    const value = await strapi.store.get({
        type: 'plugin',
        name: 'upload',
        key: 'metrics'
    });
    return fp.defaultTo({}, value);
};
const setMetricsStoreValue = (value)=>strapi.store.set({
        type: 'plugin',
        name: 'upload',
        key: 'metrics',
        value
    });
var weeklyMetrics = (({ strapi: strapi1 })=>({
        async computeMetrics () {
            // Folder metrics
            // @ts-expect-error - no dynamic types for the metadata
            const pathColName = strapi1.db.metadata.get(FOLDER_MODEL_UID).attributes.path.columnName;
            const folderTable = strapi1.getModel(FOLDER_MODEL_UID).collectionName;
            let keepOnlySlashesSQLString = '??';
            const queryParams = [
                pathColName
            ];
            for(let i = 0; i < 10; i += 1){
                keepOnlySlashesSQLString = `REPLACE(${keepOnlySlashesSQLString}, ?, ?)`;
                queryParams.push(String(i), '');
            }
            /*
      The following query goal is to count the number of folders with depth 1, depth 2 etc.
      The query returns :
      [
        { depth: 1, occurence: 4 },
        { depth: 2, occurence: 2 },
        { depth: 3, occurence: 5 },
      ]

      The query is built as follow:
      1. In order to get the depth level of a folder:
        - we take their path
        - remove all numbers (by replacing 0123456789 by '', thus the 10 REPLACE in the query)
        - count the remaining `/`, which correspond to their depth (by using LENGTH)
        We now have, for each folder, its depth.
      2. In order to get the number of folders for each depth:
        - we group them by their depth and use COUNT(*)
    */ const res = await strapi1.db.getConnection(folderTable).select(strapi1.db.connection.raw(`LENGTH(${keepOnlySlashesSQLString}) AS depth, COUNT(*) AS occurence`, queryParams)).groupBy('depth');
            const folderLevelsArray = res.map((map)=>({
                    depth: Number(map.depth),
                    occurence: Number(map.occurence)
                })); // values can be strings depending on the database
            let product = 0;
            let folderNumber = 0;
            let maxDepth = 0;
            for (const folderLevel of folderLevelsArray){
                product += folderLevel.depth * folderLevel.occurence;
                folderNumber += folderLevel.occurence;
                if (folderLevel.depth > maxDepth) {
                    maxDepth = folderLevel.depth;
                }
            }
            const averageDepth = folderNumber !== 0 ? product / folderNumber : 0;
            let sumOfDeviation = 0;
            for (const folderLevel of folderLevelsArray){
                sumOfDeviation += Math.abs(folderLevel.depth - averageDepth) * folderLevel.occurence;
            }
            const averageDeviationDepth = folderNumber !== 0 ? sumOfDeviation / folderNumber : 0;
            // File metrics
            const assetNumber = await strapi1.db.query(FILE_MODEL_UID).count();
            return {
                assetNumber,
                folderNumber,
                averageDepth,
                maxDepth,
                averageDeviationDepth
            };
        },
        async sendMetrics () {
            const metrics = await this.computeMetrics();
            strapi1.telemetry.send('didSendUploadPropertiesOnceAWeek', {
                groupProperties: {
                    metrics
                }
            });
            const metricsInfoStored = await getMetricsStoreValue();
            await setMetricsStoreValue({
                ...metricsInfoStored,
                lastWeeklyUpdate: new Date().getTime()
            });
        },
        async ensureWeeklyStoredCronSchedule () {
            const metricsInfoStored = await getMetricsStoreValue();
            const { weeklySchedule: currentSchedule, lastWeeklyUpdate } = metricsInfoStored;
            const now = new Date();
            let weeklySchedule = currentSchedule;
            if (!weeklySchedule || !lastWeeklyUpdate || lastWeeklyUpdate + ONE_WEEK < now.getTime()) {
                weeklySchedule = getWeeklyCronScheduleAt(dateFns.add(now, {
                    minutes: 5
                }));
                await setMetricsStoreValue({
                    ...metricsInfoStored,
                    weeklySchedule
                });
                return weeklySchedule;
            }
            return weeklySchedule;
        },
        async registerCron () {
            const weeklySchedule = await this.ensureWeeklyStoredCronSchedule();
            strapi1.cron.add({
                uploadWeekly: {
                    task: this.sendMetrics.bind(this),
                    options: weeklySchedule
                }
            });
        }
    }));

const getProviderName = ()=>strapi.config.get('plugin::upload.provider', 'local');
const isProviderPrivate = async ()=>strapi.plugin('upload').provider.isPrivate();
var metrics = (({ strapi: strapi1 })=>({
        async sendUploadPluginMetrics () {
            const uploadProvider = getProviderName();
            const privateProvider = await isProviderPrivate();
            strapi1.telemetry.send('didInitializePluginUpload', {
                groupProperties: {
                    uploadProvider,
                    privateProvider
                }
            });
        }
    }));

const getStore = ()=>strapi.store({
        type: 'plugin',
        name: 'upload',
        key: 'api-folder'
    });
const createApiUploadFolder = async ()=>{
    let name = API_UPLOAD_FOLDER_BASE_NAME;
    const folderService = getService('folder');
    let exists = true;
    let index = 1;
    while(exists){
        exists = await folderService.exists({
            name,
            parent: null
        });
        if (exists) {
            name = `${API_UPLOAD_FOLDER_BASE_NAME} (${index})`;
            index += 1;
        }
    }
    const folder = await folderService.create({
        name
    });
    await getStore().set({
        value: {
            id: folder.id
        }
    });
    return folder;
};
const getAPIUploadFolder = async ()=>{
    const storeValue = await getStore().get({});
    const folderId = fp.get('id', storeValue);
    const folder = folderId ? await strapi.db.query(FOLDER_MODEL_UID).findOne({
        where: {
            id: folderId
        }
    }) : null;
    return fp.isNil(folder) ? createApiUploadFolder() : folder;
};
var apiUploadFolder = {
    getAPIUploadFolder
};

function isFile(value, attribute) {
    if (!value || attribute.type !== 'media') {
        return false;
    }
    return true;
}
/**
 * Visitor function to sign media URLs
 */ const signEntityMediaVisitor = async ({ key, value, attribute }, { set })=>{
    const { signFileUrls } = getService('file');
    if (!attribute) {
        return;
    }
    if (attribute.type !== 'media') {
        return;
    }
    if (isFile(value, attribute)) {
        // If the attribute is repeatable sign each file
        if (attribute.multiple) {
            const signedFiles = await utils.async.map(value, signFileUrls);
            set(key, signedFiles);
            return;
        }
        // If the attribute is not repeatable only sign a single file
        const signedFile = await signFileUrls(value);
        set(key, signedFile);
    }
};
/**
 *
 * Iterate through an entity manager result
 * Check which modelAttributes are media and pre sign the image URLs
 * if they are from the current upload provider
 *
 * @param {Object} entity
 * @param {Object} modelAttributes
 * @returns
 */ const signEntityMedia = async (entity, uid)=>{
    const model = strapi.getModel(uid);
    return utils.traverseEntity(// @ts-expect-error - FIXME: fix traverseEntity using wrong types
    signEntityMediaVisitor, {
        schema: model,
        getModel: strapi.getModel.bind(strapi)
    }, entity);
};

const signFileUrlsOnDocumentService = async ()=>{
    const { provider } = strapi.plugins.upload;
    const isPrivate = await provider.isPrivate();
    // We only need to sign the file urls if the provider is private
    if (!isPrivate) {
        return;
    }
    strapi.documents.use(async (ctx, next)=>{
        const uid = ctx.uid;
        const result = await next();
        if (ctx.action === 'findMany') {
            // Shape: [ entry ]
            return utils.async.map(result, (entry)=>signEntityMedia(entry, uid));
        }
        if (ctx.action === 'findFirst' || ctx.action === 'findOne' || ctx.action === 'create' || ctx.action === 'update') {
            // Shape: entry
            return signEntityMedia(result, uid);
        }
        if (ctx.action === 'delete' || ctx.action === 'clone' || ctx.action === 'publish' || ctx.action === 'unpublish' || ctx.action === 'discardDraft') {
            // Shape: { entries: [ entry ] }
            // ...
            return {
                ...result,
                entries: await utils.async.map(result.entries, (entry)=>signEntityMedia(entry, uid))
            };
        }
        return result;
    });
};
var extensions = {
    signFileUrlsOnDocumentService
};

const services = {
    provider,
    upload,
    folder,
    file,
    weeklyMetrics,
    metrics,
    'image-manipulation': imageManipulation,
    'api-upload-folder': apiUploadFolder,
    extensions
};

const routes$3 = {
    type: 'admin',
    routes: [
        {
            method: 'GET',
            path: '/settings',
            handler: 'admin-settings.getSettings',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::upload.settings.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'PUT',
            path: '/settings',
            handler: 'admin-settings.updateSettings',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::upload.settings.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/',
            handler: 'admin-upload.upload',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin'
                ]
            }
        },
        {
            method: 'GET',
            path: '/files',
            handler: 'admin-file.find',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::upload.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/files/:id',
            handler: 'admin-file.findOne',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::upload.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'DELETE',
            path: '/files/:id',
            handler: 'admin-file.destroy',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::upload.assets.update'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/folders/:id',
            handler: 'admin-folder.findOne',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::upload.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/folders',
            handler: 'admin-folder.find',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::upload.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/folders',
            handler: 'admin-folder.create',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::upload.assets.create'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'PUT',
            path: '/folders/:id',
            handler: 'admin-folder.update',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::upload.assets.update'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/folder-structure',
            handler: 'admin-folder.getStructure',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::upload.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/actions/bulk-delete',
            handler: 'admin-folder-file.deleteMany',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::upload.assets.update'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/actions/bulk-move',
            handler: 'admin-folder-file.moveMany',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::upload.assets.update'
                            ]
                        }
                    }
                ]
            }
        }
    ]
};

const routes$2 = {
    type: 'content-api',
    routes: [
        {
            method: 'POST',
            path: '/',
            handler: 'content-api.upload'
        },
        {
            method: 'GET',
            path: '/files',
            handler: 'content-api.find'
        },
        {
            method: 'GET',
            path: '/files/:id',
            handler: 'content-api.findOne'
        },
        {
            method: 'DELETE',
            path: '/files/:id',
            handler: 'content-api.destroy'
        }
    ]
};

const routes$1 = {
    type: 'admin',
    routes: [
        {
            method: 'GET',
            path: '/configuration',
            handler: 'view-configuration.findViewConfiguration',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin'
                ]
            }
        },
        {
            method: 'PUT',
            path: '/configuration',
            handler: 'view-configuration.updateViewConfiguration',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                ACTIONS.configureView
                            ]
                        }
                    }
                ]
            }
        }
    ]
};

const routes = {
    admin: routes$3,
    'content-api': routes$2,
    viewConfiguration: routes$1
};

const config = {
    default: {
        enabled: true,
        provider: 'local',
        sizeLimit: 1000000000,
        actionOptions: {}
    },
    validator () {}
};

const findEntityAndCheckPermissions = async (ability, action, model, id)=>{
    const file = await getService('upload').findOne(id, [
        utils.contentTypes.constants.CREATED_BY_ATTRIBUTE,
        'folder'
    ]);
    if (_.isNil(file)) {
        throw new utils.errors.NotFoundError();
    }
    const pm = strapi.service('admin::permission').createPermissionsManager({
        ability,
        action,
        model
    });
    const creatorId = _.get(file, [
        utils.contentTypes.constants.CREATED_BY_ATTRIBUTE,
        'id'
    ]);
    const author = creatorId ? await strapi.service('admin::user').findOne(creatorId, [
        'roles'
    ]) : null;
    const fileWithRoles = _.set(_.cloneDeep(file), 'createdBy', author);
    if (pm.ability.cannot(pm.action, pm.toSubject(fileWithRoles))) {
        throw new utils.errors.ForbiddenError();
    }
    return {
        pm,
        file
    };
};

var adminFile = {
    async find (ctx) {
        const { state: { userAbility } } = ctx;
        const defaultQuery = {
            populate: {
                folder: true
            }
        };
        const pm = strapi.service('admin::permission').createPermissionsManager({
            ability: userAbility,
            action: ACTIONS.read,
            model: FILE_MODEL_UID
        });
        if (!pm.isAllowed) {
            return ctx.forbidden();
        }
        // validate the incoming user query params
        await pm.validateQuery(ctx.query);
        const query = await utils.async.pipe(// Start by sanitizing the incoming query
        (q)=>pm.sanitizeQuery(q), // Add the default query which should not be validated or sanitized
        (q)=>fp.merge(defaultQuery, q), // Add the dynamic filters based on permissions' conditions
        (q)=>pm.addPermissionsQueryTo(q))(ctx.query);
        const { results: files, pagination } = await getService('upload').findPage(query);
        // Sign file urls for private providers
        const signedFiles = await utils.async.map(files, getService('file').signFileUrls);
        const sanitizedFiles = await pm.sanitizeOutput(signedFiles);
        return {
            results: sanitizedFiles,
            pagination
        };
    },
    async findOne (ctx) {
        const { state: { userAbility }, params: { id } } = ctx;
        const { pm, file } = await findEntityAndCheckPermissions(userAbility, ACTIONS.read, FILE_MODEL_UID, id);
        const signedFile = await getService('file').signFileUrls(file);
        ctx.body = await pm.sanitizeOutput(signedFile);
    },
    async destroy (ctx) {
        const { id } = ctx.params;
        const { userAbility } = ctx.state;
        const { pm, file } = await findEntityAndCheckPermissions(userAbility, ACTIONS.update, FILE_MODEL_UID, id);
        const [body] = await Promise.all([
            pm.sanitizeOutput(file, {
                action: ACTIONS.read
            }),
            getService('upload').remove(file)
        ]);
        ctx.body = body;
    }
};

const folderExists = async (folderId)=>{
    if (fp.isNil(folderId)) {
        return true;
    }
    const exists = await getService('folder').exists({
        id: folderId
    });
    return exists;
};

const isFolderOrChild = (folderOrChild, folder)=>folderOrChild.path === folder.path || folderOrChild.path.startsWith(`${folder.path}/`);

const NO_SLASH_REGEX = /^[^/]+$/;
const NO_SPACES_AROUND = RegExp("^(?! ).+(?<! )$");
const isNameUniqueInFolder = (id)=>{
    return async function test(name) {
        const { exists } = getService('folder');
        const filters = {
            name,
            parent: this.parent.parent || null
        };
        if (id) {
            filters.id = {
                $ne: id
            };
            if (fp.isUndefined(name)) {
                const existingFolder = await strapi.db.query(FOLDER_MODEL_UID).findOne({
                    where: {
                        id
                    }
                });
                filters.name = fp.get('name', existingFolder);
            }
        }
        const doesExist = await exists(filters);
        return !doesExist;
    };
};
const validateCreateFolderSchema = utils.yup.object().shape({
    name: utils.yup.string().min(1).matches(NO_SLASH_REGEX, 'name cannot contain slashes').matches(NO_SPACES_AROUND, 'name cannot start or end with a whitespace').required().test('is-folder-unique', 'A folder with this name already exists', isNameUniqueInFolder()),
    parent: utils.yup.strapiID().nullable().test('folder-exists', 'parent folder does not exist', folderExists)
}).noUnknown().required();
const validateUpdateFolderSchema = (id)=>utils.yup.object().shape({
        name: utils.yup.string().min(1).matches(NO_SLASH_REGEX, 'name cannot contain slashes').matches(NO_SPACES_AROUND, 'name cannot start or end with a whitespace').test('is-folder-unique', 'A folder with this name already exists', isNameUniqueInFolder(id)),
        parent: utils.yup.strapiID().nullable().test('folder-exists', 'parent folder does not exist', folderExists).test('dont-move-inside-self', 'folder cannot be moved inside itself', async function test(parent) {
            if (fp.isNil(parent)) return true;
            const destinationFolder = await strapi.db.query(FOLDER_MODEL_UID).findOne({
                select: [
                    'path'
                ],
                where: {
                    id: parent
                }
            });
            const currentFolder = await strapi.db.query(FOLDER_MODEL_UID).findOne({
                select: [
                    'path'
                ],
                where: {
                    id
                }
            });
            if (!destinationFolder || !currentFolder) return true;
            return !isFolderOrChild(destinationFolder, currentFolder);
        })
    }).noUnknown().required();
const validateCreateFolder = utils.validateYupSchema(validateCreateFolderSchema);
const validateUpdateFolder = (id)=>utils.validateYupSchema(validateUpdateFolderSchema(id));

var adminFolder = {
    async findOne (ctx) {
        const { id } = ctx.params;
        const permissionsManager = strapi.service('admin::permission').createPermissionsManager({
            ability: ctx.state.userAbility,
            model: FOLDER_MODEL_UID
        });
        await permissionsManager.validateQuery(ctx.query);
        const query = await permissionsManager.sanitizeQuery(ctx.query);
        const { results } = await strapi.db.query(FOLDER_MODEL_UID).findPage(strapi.get('query-params').transform(FOLDER_MODEL_UID, fp.defaultsDeep({
            filters: {
                id
            },
            populate: {
                children: {
                    count: true
                },
                files: {
                    count: true
                }
            }
        }, query)));
        if (results.length === 0) {
            return ctx.notFound('folder not found');
        }
        ctx.body = {
            data: await permissionsManager.sanitizeOutput(results[0])
        };
    },
    async find (ctx) {
        const permissionsManager = strapi.service('admin::permission').createPermissionsManager({
            ability: ctx.state.userAbility,
            model: FOLDER_MODEL_UID
        });
        await permissionsManager.validateQuery(ctx.query);
        const query = await permissionsManager.sanitizeQuery(ctx.query);
        const results = await strapi.db.query(FOLDER_MODEL_UID).findMany(strapi.get('query-params').transform(FOLDER_MODEL_UID, fp.defaultsDeep({
            populate: {
                children: {
                    count: true
                },
                files: {
                    count: true
                }
            }
        }, query)));
        ctx.body = {
            data: await permissionsManager.sanitizeOutput(results)
        };
    },
    async create (ctx) {
        const { user } = ctx.state;
        const { body } = ctx.request;
        await validateCreateFolder(body);
        const folderService = getService('folder');
        const folder = await folderService.create(body, {
            user
        });
        const permissionsManager = strapi.service('admin::permission').createPermissionsManager({
            ability: ctx.state.userAbility,
            model: FOLDER_MODEL_UID
        });
        ctx.created({
            data: await permissionsManager.sanitizeOutput(folder)
        });
    },
    async update (ctx) {
        const { id } = ctx.params;
        const { user } = ctx.state;
        const { body } = ctx.request;
        const permissionsManager = strapi.service('admin::permission').createPermissionsManager({
            ability: ctx.state.userAbility,
            model: FOLDER_MODEL_UID
        });
        await validateUpdateFolder(id)(body);
        const folderService = getService('folder');
        const updatedFolder = await folderService.update(id, body, {
            user
        });
        if (!updatedFolder) {
            return ctx.notFound('folder not found');
        }
        ctx.body = {
            data: await permissionsManager.sanitizeOutput(updatedFolder)
        };
    },
    async getStructure (ctx) {
        const { getStructure } = getService('folder');
        const structure = await getStructure();
        ctx.body = {
            data: structure
        };
    }
};

const validateDeleteManyFoldersFilesSchema = utils.yup.object().shape({
    fileIds: utils.yup.array().of(utils.yup.strapiID().required()),
    folderIds: utils.yup.array().of(utils.yup.strapiID().required())
}).noUnknown().required();
const validateStructureMoveManyFoldersFilesSchema = utils.yup.object().shape({
    destinationFolderId: utils.yup.strapiID().nullable().defined().test('folder-exists', 'destination folder does not exist', folderExists),
    fileIds: utils.yup.array().of(utils.yup.strapiID().required()),
    folderIds: utils.yup.array().of(utils.yup.strapiID().required())
}).noUnknown().required();
const validateDuplicatesMoveManyFoldersFilesSchema = utils.yup.object().test('are-folders-unique', 'some folders already exist', async function areFoldersUnique(value) {
    const { folderIds, destinationFolderId } = value;
    if (fp.isEmpty(folderIds)) return true;
    const folders = await strapi.db.query(FOLDER_MODEL_UID).findMany({
        select: [
            'name'
        ],
        where: {
            id: {
                $in: folderIds
            }
        }
    });
    const existingFolders = await strapi.db.query(FOLDER_MODEL_UID).findMany({
        select: [
            'name'
        ],
        where: {
            parent: {
                id: destinationFolderId
            }
        }
    });
    const duplicatedNames = fp.intersection(fp.map('name', folders), fp.map('name', existingFolders));
    if (duplicatedNames.length > 0) {
        return this.createError({
            message: `some folders already exists: ${duplicatedNames.join(', ')}`
        });
    }
    return true;
});
const validateMoveFoldersNotInsideThemselvesSchema = utils.yup.object().test('dont-move-inside-self', 'folders cannot be moved inside themselves or one of its children', async function validateMoveFoldersNotInsideThemselves(value) {
    const { folderIds, destinationFolderId } = value;
    if (destinationFolderId === null || fp.isEmpty(folderIds)) return true;
    const destinationFolder = await strapi.db.query(FOLDER_MODEL_UID).findOne({
        select: [
            'path'
        ],
        where: {
            id: destinationFolderId
        }
    });
    const folders = await strapi.db.query(FOLDER_MODEL_UID).findMany({
        select: [
            'name',
            'path'
        ],
        where: {
            id: {
                $in: folderIds
            }
        }
    });
    const unmovableFoldersNames = folders.filter((folder)=>isFolderOrChild(destinationFolder, folder)).map((f)=>f.name);
    if (unmovableFoldersNames.length > 0) {
        return this.createError({
            message: `folders cannot be moved inside themselves or one of its children: ${unmovableFoldersNames.join(', ')}`
        });
    }
    return true;
});
const validateDeleteManyFoldersFiles = utils.validateYupSchema(validateDeleteManyFoldersFilesSchema);
async function validateMoveManyFoldersFiles(body) {
    await utils.validateYupSchema(validateStructureMoveManyFoldersFilesSchema)(body);
    await utils.validateYupSchema(validateDuplicatesMoveManyFoldersFilesSchema)(body);
    await utils.validateYupSchema(validateMoveFoldersNotInsideThemselvesSchema)(body);
}

var adminFolderFile = {
    async deleteMany (ctx) {
        const { body } = ctx.request;
        const { state: { userAbility } } = ctx;
        const pmFolder = strapi.service('admin::permission').createPermissionsManager({
            ability: ctx.state.userAbility,
            model: FOLDER_MODEL_UID
        });
        const pmFile = strapi.service('admin::permission').createPermissionsManager({
            ability: userAbility,
            action: ACTIONS.read,
            model: FILE_MODEL_UID
        });
        await validateDeleteManyFoldersFiles(body);
        const fileService = getService('file');
        const folderService = getService('folder');
        const deletedFiles = await fileService.deleteByIds(body.fileIds);
        const { folders: deletedFolders, totalFolderNumber, totalFileNumber } = await folderService.deleteByIds(body.folderIds);
        if (deletedFiles.length + deletedFolders.length > 1) {
            strapi.telemetry.send('didBulkDeleteMediaLibraryElements', {
                eventProperties: {
                    rootFolderNumber: deletedFolders.length,
                    rootAssetNumber: deletedFiles.length,
                    totalFolderNumber,
                    totalAssetNumber: totalFileNumber + deletedFiles.length
                }
            });
        }
        ctx.body = {
            data: {
                files: await pmFile.sanitizeOutput(deletedFiles),
                folders: await pmFolder.sanitizeOutput(deletedFolders)
            }
        };
    },
    async moveMany (ctx) {
        const { body } = ctx.request;
        const { state: { userAbility } } = ctx;
        const pmFolder = strapi.service('admin::permission').createPermissionsManager({
            ability: ctx.state.userAbility,
            model: FOLDER_MODEL_UID
        });
        const pmFile = strapi.service('admin::permission').createPermissionsManager({
            ability: userAbility,
            action: ACTIONS.read,
            model: FILE_MODEL_UID
        });
        await validateMoveManyFoldersFiles(body);
        const { folderIds = [], fileIds = [], destinationFolderId } = body;
        let totalFolderNumber = 0;
        let totalFileNumber = 0;
        const trx = await strapi.db.transaction();
        try {
            // fetch folders
            const existingFolders = await strapi.db.queryBuilder(FOLDER_MODEL_UID).select([
                'id',
                'pathId',
                'path'
            ]).where({
                id: {
                    $in: folderIds
                }
            }).transacting(trx.get()).forUpdate().execute();
            // fetch files
            const existingFiles = await strapi.db.queryBuilder(FILE_MODEL_UID).select([
                'id'
            ]).where({
                id: {
                    $in: fileIds
                }
            }).transacting(trx.get()).forUpdate().execute();
            // fetch destinationFolder path
            let destinationFolderPath = '/';
            if (destinationFolderId !== null) {
                const destinationFolder = await strapi.db.queryBuilder(FOLDER_MODEL_UID).select('path').where({
                    id: destinationFolderId
                }).transacting(trx.get()).first().execute();
                destinationFolderPath = destinationFolder.path;
            }
            const fileTable = strapi.getModel(FILE_MODEL_UID).collectionName;
            const folderTable = strapi.getModel(FOLDER_MODEL_UID).collectionName;
            const folderPathColName = // @ts-expect-error - no dynamic typings for the models
            strapi.db.metadata.get(FILE_MODEL_UID).attributes.folderPath.columnName;
            // @ts-expect-error - no dynamic typings for the models
            const pathColName = strapi.db.metadata.get(FOLDER_MODEL_UID).attributes.path.columnName;
            if (existingFolders.length > 0) {
                // update folders' parent relation
                // @ts-expect-error - no dynamic typings for the models
                const { joinTable } = strapi.db.metadata.get(FOLDER_MODEL_UID).attributes.parent;
                await strapi.db.queryBuilder(joinTable.name).transacting(trx.get()).delete().where({
                    [joinTable.joinColumn.name]: {
                        $in: folderIds
                    }
                }).execute();
                if (destinationFolderId !== null) {
                    await strapi.db.queryBuilder(joinTable.name).transacting(trx.get()).insert(existingFolders.map((folder)=>({
                            [joinTable.inverseJoinColumn.name]: destinationFolderId,
                            [joinTable.joinColumn.name]: folder.id
                        }))).execute();
                }
                for (const existingFolder of existingFolders){
                    let replaceQuery;
                    switch(strapi.db.dialect.client){
                        case 'sqlite':
                            replaceQuery = '? || SUBSTRING(??, ?)';
                            break;
                        case 'postgres':
                            replaceQuery = 'CONCAT(?::TEXT, SUBSTRING(??, ?::INTEGER))';
                            break;
                        default:
                            replaceQuery = 'CONCAT(?, SUBSTRING(??, ?))';
                    }
                    // update path for folders themselves & folders below
                    totalFolderNumber = await strapi.db.getConnection(folderTable).transacting(trx.get()).where(pathColName, existingFolder.path).orWhere(pathColName, 'like', `${existingFolder.path}/%`).update(pathColName, strapi.db.connection.raw(replaceQuery, [
                        utils.strings.joinBy('/', destinationFolderPath, `${existingFolder.pathId}`),
                        pathColName,
                        existingFolder.path.length + 1
                    ]));
                    // update path of files below
                    totalFileNumber = await strapi.db.getConnection(fileTable).transacting(trx.get()).where(folderPathColName, existingFolder.path).orWhere(folderPathColName, 'like', `${existingFolder.path}/%`).update(folderPathColName, strapi.db.connection.raw(replaceQuery, [
                        utils.strings.joinBy('/', destinationFolderPath, `${existingFolder.pathId}`),
                        folderPathColName,
                        existingFolder.path.length + 1
                    ]));
                }
            }
            if (existingFiles.length > 0) {
                // update files' folder relation (delete + insert; upsert not possible)
                // @ts-expect-error - no dynamic typings for the models
                const fileJoinTable = strapi.db.metadata.get(FILE_MODEL_UID).attributes.folder.joinTable;
                await strapi.db.queryBuilder(fileJoinTable.name).transacting(trx.get()).delete().where({
                    [fileJoinTable.joinColumn.name]: {
                        $in: fileIds
                    }
                }).execute();
                if (destinationFolderId !== null) {
                    await strapi.db.queryBuilder(fileJoinTable.name).transacting(trx.get()).insert(existingFiles.map((file)=>({
                            [fileJoinTable.inverseJoinColumn.name]: destinationFolderId,
                            [fileJoinTable.joinColumn.name]: file.id
                        }))).execute();
                }
                // update files main fields (path + updatedBy)
                await strapi.db.getConnection(fileTable).transacting(trx.get()).whereIn('id', fileIds).update(folderPathColName, destinationFolderPath);
            }
            await trx.commit();
        } catch (e) {
            await trx.rollback();
            throw e;
        }
        const updatedFolders = await strapi.db.query(FOLDER_MODEL_UID).findMany({
            where: {
                id: {
                    $in: folderIds
                }
            }
        });
        const updatedFiles = await strapi.db.query(FILE_MODEL_UID).findMany({
            where: {
                id: {
                    $in: fileIds
                }
            }
        });
        strapi.telemetry.send('didBulkMoveMediaLibraryElements', {
            eventProperties: {
                rootFolderNumber: updatedFolders.length,
                rootAssetNumber: updatedFiles.length,
                totalFolderNumber,
                totalAssetNumber: totalFileNumber + updatedFiles.length
            }
        });
        ctx.body = {
            data: {
                files: await pmFile.sanitizeOutput(updatedFiles),
                folders: await pmFolder.sanitizeOutput(updatedFolders)
            }
        };
    }
};

const settingsSchema = utils.yup.object({
    sizeOptimization: utils.yup.boolean().required(),
    responsiveDimensions: utils.yup.boolean().required(),
    autoOrientation: utils.yup.boolean()
});
var validateSettings = utils.validateYupSchema(settingsSchema);

var adminSettings = {
    async updateSettings (ctx) {
        const { request: { body }, state: { userAbility } } = ctx;
        if (userAbility.cannot(ACTIONS.readSettings, FILE_MODEL_UID)) {
            return ctx.forbidden();
        }
        const data = await validateSettings(body);
        await getService('upload').setSettings(data);
        ctx.body = {
            data
        };
    },
    async getSettings (ctx) {
        const { state: { userAbility } } = ctx;
        if (userAbility.cannot(ACTIONS.readSettings, FILE_MODEL_UID)) {
            return ctx.forbidden();
        }
        const data = await getService('upload').getSettings();
        ctx.body = {
            data
        };
    }
};

const fileInfoSchema$1 = utils.yup.object({
    name: utils.yup.string().nullable(),
    alternativeText: utils.yup.string().nullable(),
    caption: utils.yup.string().nullable(),
    folder: utils.yup.strapiID().nullable().test('folder-exists', 'the folder does not exist', async (folderId)=>{
        if (fp.isNil(folderId)) {
            return true;
        }
        const exists = await getService('folder').exists({
            id: folderId
        });
        return exists;
    })
});
const uploadSchema$1 = utils.yup.object({
    fileInfo: fileInfoSchema$1
});
const multiUploadSchema$1 = utils.yup.object({
    fileInfo: utils.yup.array().of(fileInfoSchema$1)
});
const validateUploadBody$1 = (data = {}, isMulti = false)=>{
    const schema = isMulti ? multiUploadSchema$1 : uploadSchema$1;
    return utils.validateYupSchema(schema, {
        strict: false
    })(data);
};

var adminUpload = {
    async updateFileInfo (ctx) {
        const { state: { userAbility, user }, query: { id }, request: { body } } = ctx;
        if (typeof id !== 'string') {
            throw new utils.errors.ValidationError('File id is required');
        }
        const uploadService = getService('upload');
        const { pm } = await findEntityAndCheckPermissions(userAbility, ACTIONS.update, FILE_MODEL_UID, id);
        const data = await validateUploadBody$1(body);
        const file = await uploadService.updateFileInfo(id, data.fileInfo, {
            user
        });
        ctx.body = await pm.sanitizeOutput(file, {
            action: ACTIONS.read
        });
    },
    async replaceFile (ctx) {
        const { state: { userAbility, user }, query: { id }, request: { body, files: { files } = {} } } = ctx;
        if (typeof id !== 'string') {
            throw new utils.errors.ValidationError('File id is required');
        }
        const uploadService = getService('upload');
        const { pm } = await findEntityAndCheckPermissions(userAbility, ACTIONS.update, FILE_MODEL_UID, id);
        if (Array.isArray(files)) {
            throw new utils.errors.ApplicationError('Cannot replace a file with multiple ones');
        }
        const data = await validateUploadBody$1(body);
        const replacedFile = await uploadService.replace(id, {
            data,
            file: files
        }, {
            user
        });
        // Sign file urls for private providers
        const signedFile = await getService('file').signFileUrls(replacedFile);
        ctx.body = await pm.sanitizeOutput(signedFile, {
            action: ACTIONS.read
        });
    },
    async uploadFiles (ctx) {
        const { state: { userAbility, user }, request: { body, files: { files } = {} } } = ctx;
        const uploadService = getService('upload');
        const pm = strapi.service('admin::permission').createPermissionsManager({
            ability: userAbility,
            action: ACTIONS.create,
            model: FILE_MODEL_UID
        });
        if (!pm.isAllowed) {
            return ctx.forbidden();
        }
        const data = await validateUploadBody$1(body);
        const uploadedFiles = await uploadService.upload({
            data,
            files
        }, {
            user
        });
        // Sign file urls for private providers
        const signedFiles = await utils.async.map(uploadedFiles, getService('file').signFileUrls);
        ctx.body = await pm.sanitizeOutput(signedFiles, {
            action: ACTIONS.read
        });
        ctx.status = 201;
    },
    // TODO: split into multiple endpoints
    async upload (ctx) {
        const { query: { id }, request: { files: { files } = {} } } = ctx;
        if (_.isEmpty(files) || !Array.isArray(files) && files.size === 0) {
            if (id) {
                return this.updateFileInfo(ctx);
            }
            throw new utils.errors.ApplicationError('Files are empty');
        }
        await (id ? this.replaceFile : this.uploadFiles)(ctx);
    }
};

const fileInfoSchema = utils.yup.object({
    name: utils.yup.string().nullable(),
    alternativeText: utils.yup.string().nullable(),
    caption: utils.yup.string().nullable()
}).noUnknown();
const uploadSchema = utils.yup.object({
    fileInfo: fileInfoSchema
});
const multiUploadSchema = utils.yup.object({
    fileInfo: utils.yup.array().of(fileInfoSchema)
});
const validateUploadBody = (data = {}, isMulti = false)=>{
    const schema = isMulti ? multiUploadSchema : uploadSchema;
    return utils.validateYupSchema(schema, {
        strict: false
    })(data);
};

const { ValidationError } = utils.errors;
var contentApi = (({ strapi })=>{
    const sanitizeOutput = async (data, ctx)=>{
        const schema = strapi.getModel(FILE_MODEL_UID);
        const { auth } = ctx.state;
        return strapi.contentAPI.sanitize.output(data, schema, {
            auth
        });
    };
    const validateQuery = async (data, ctx)=>{
        const schema = strapi.getModel(FILE_MODEL_UID);
        const { auth } = ctx.state;
        return strapi.contentAPI.validate.query(data, schema, {
            auth
        });
    };
    const sanitizeQuery = async (data, ctx)=>{
        const schema = strapi.getModel(FILE_MODEL_UID);
        const { auth } = ctx.state;
        return strapi.contentAPI.sanitize.query(data, schema, {
            auth
        });
    };
    return {
        async find (ctx) {
            await validateQuery(ctx.query, ctx);
            const sanitizedQuery = await sanitizeQuery(ctx.query, ctx);
            const files = await getService('upload').findMany(sanitizedQuery);
            ctx.body = await sanitizeOutput(files, ctx);
        },
        async findOne (ctx) {
            const { params: { id } } = ctx;
            await validateQuery(ctx.query, ctx);
            const sanitizedQuery = await sanitizeQuery(ctx.query, ctx);
            const file = await getService('upload').findOne(id, sanitizedQuery.populate);
            if (!file) {
                return ctx.notFound('file.notFound');
            }
            ctx.body = await sanitizeOutput(file, ctx);
        },
        async destroy (ctx) {
            const { params: { id } } = ctx;
            const file = await getService('upload').findOne(id);
            if (!file) {
                return ctx.notFound('file.notFound');
            }
            await getService('upload').remove(file);
            ctx.body = await sanitizeOutput(file, ctx);
        },
        async updateFileInfo (ctx) {
            const { query: { id }, request: { body } } = ctx;
            const data = await validateUploadBody(body);
            if (!id || typeof id !== 'string' && typeof id !== 'number') {
                throw new ValidationError('File id is required and must be a single value');
            }
            const result = await getService('upload').updateFileInfo(id, data.fileInfo);
            ctx.body = await sanitizeOutput(result, ctx);
        },
        async replaceFile (ctx) {
            const { query: { id }, request: { body, files: { files } = {} } } = ctx;
            // cannot replace with more than one file
            if (Array.isArray(files)) {
                throw new ValidationError('Cannot replace a file with multiple ones');
            }
            if (!id || typeof id !== 'string' && typeof id !== 'number') {
                throw new ValidationError('File id is required and must be a single value');
            }
            const data = await validateUploadBody(body);
            const replacedFiles = await getService('upload').replace(id, {
                data,
                file: files
            });
            ctx.body = await sanitizeOutput(replacedFiles, ctx);
        },
        async uploadFiles (ctx) {
            const { request: { body, files: { files } = {} } } = ctx;
            const data = await validateUploadBody(body, Array.isArray(files));
            const apiUploadFolderService = getService('api-upload-folder');
            const apiUploadFolder = await apiUploadFolderService.getAPIUploadFolder();
            if (Array.isArray(files)) {
                data.fileInfo = data.fileInfo || [];
                data.fileInfo = files.map((_f, i)=>({
                        ...data.fileInfo[i],
                        folder: apiUploadFolder.id
                    }));
            } else {
                data.fileInfo = {
                    ...data.fileInfo,
                    folder: apiUploadFolder.id
                };
            }
            const uploadedFiles = await getService('upload').upload({
                data,
                files
            });
            ctx.body = await sanitizeOutput(uploadedFiles, ctx);
            ctx.status = 201;
        },
        // TODO: split into multiple endpoints
        async upload (ctx) {
            const { query: { id }, request: { files: { files } = {} } } = ctx;
            if (_.isEmpty(files) || !Array.isArray(files) && files.size === 0) {
                if (id) {
                    return this.updateFileInfo(ctx);
                }
                throw new ValidationError('Files are empty');
            }
            await (id ? this.replaceFile : this.uploadFiles)(ctx);
        }
    };
});

const configSchema = utils.yup.object({
    pageSize: utils.yup.number().required(),
    sort: utils.yup.mixed().oneOf(ALLOWED_SORT_STRINGS)
});
const validateViewConfiguration = utils.validateYupSchema(configSchema);

var viewConfiguration = {
    async updateViewConfiguration (ctx) {
        const { request: { body }, state: { userAbility } } = ctx;
        if (userAbility.cannot(ACTIONS.configureView)) {
            return ctx.forbidden();
        }
        const data = await validateViewConfiguration(body);
        await getService('upload').setConfiguration(data);
        ctx.body = {
            data
        };
    },
    async findViewConfiguration (ctx) {
        const data = await getService('upload').getConfiguration();
        ctx.body = {
            data
        };
    }
};

const controllers = {
    'admin-file': adminFile,
    'admin-folder': adminFolder,
    'admin-folder-file': adminFolderFile,
    'admin-settings': adminSettings,
    'admin-upload': adminUpload,
    'content-api': contentApi,
    'view-configuration': viewConfiguration
};

var index = (()=>({
        register,
        bootstrap,
        config,
        routes,
        controllers,
        contentTypes,
        services
    }));

exports.FILE_MODEL_UID = FILE_MODEL_UID;
exports.index = index;
//# sourceMappingURL=index-BkUy20d9.js.map
