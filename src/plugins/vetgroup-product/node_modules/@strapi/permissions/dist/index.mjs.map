{"version":3,"file":"index.mjs","sources":["../src/domain/permission/index.ts","../src/engine/hooks.ts","../src/engine/abilities/casl-ability.ts","../src/engine/index.ts"],"sourcesContent":["import _ from 'lodash/fp';\n\nconst PERMISSION_FIELDS = ['action', 'subject', 'properties', 'conditions'] as const;\n\nconst sanitizePermissionFields = _.pick(PERMISSION_FIELDS);\n\nexport interface Permission {\n  action: string;\n  actionParameters?: Record<string, unknown>;\n  subject?: string | object | null;\n  properties?: Record<string, any>;\n  conditions?: string[];\n}\n\n/**\n * Creates a permission with default values for optional properties\n */\nconst getDefaultPermission = (): Pick<Permission, 'conditions' | 'properties' | 'subject'> => ({\n  conditions: [],\n  properties: {},\n  subject: null,\n});\n\n/**\n * Create a new permission based on given attributes\n *\n * @param {object} attributes\n */\nconst create = _.pipe(_.pick(PERMISSION_FIELDS), _.merge(getDefaultPermission()));\n\n/**\n * Add a condition to a permission\n */\nconst addCondition = _.curry((condition: string, permission: Permission): Permission => {\n  const { conditions } = permission;\n\n  const newConditions = Array.isArray(conditions)\n    ? _.uniq(conditions.concat(condition))\n    : [condition];\n\n  return _.set('conditions', newConditions, permission);\n});\n\n/**\n * Gets a property or a part of a property from a permission.\n */\nconst getProperty = _.curry(\n  <T extends keyof Permission['properties']>(\n    property: T,\n    permission: Permission\n  ): Permission['properties'][T] => _.get(`properties.${property}`, permission)\n);\n\nexport { create, sanitizePermissionFields, addCondition, getProperty };\n","import { cloneDeep, has, isArray } from 'lodash/fp';\nimport { hooks } from '@strapi/utils';\n\nimport * as domain from '../domain';\nimport type { Permission } from '../domain/permission';\nimport type { PermissionRule } from '../types';\n\nexport interface PermissionEngineHooks {\n  'before-format::validate.permission': ReturnType<typeof hooks.createAsyncBailHook>;\n  'format.permission': ReturnType<typeof hooks.createAsyncSeriesWaterfallHook>;\n  'after-format::validate.permission': ReturnType<typeof hooks.createAsyncBailHook>;\n  'before-evaluate.permission': ReturnType<typeof hooks.createAsyncSeriesHook>;\n  'before-register.permission': ReturnType<typeof hooks.createAsyncSeriesHook>;\n}\n\nexport type HookName = keyof PermissionEngineHooks;\n\n/**\n * Create a hook map used by the permission Engine\n */\nconst createEngineHooks = (): PermissionEngineHooks => ({\n  'before-format::validate.permission': hooks.createAsyncBailHook(),\n  'format.permission': hooks.createAsyncSeriesWaterfallHook(),\n  'after-format::validate.permission': hooks.createAsyncBailHook(),\n  'before-evaluate.permission': hooks.createAsyncSeriesHook(),\n  'before-register.permission': hooks.createAsyncSeriesHook(),\n});\n\n/**\n * Create a context from a domain {@link Permission} used by the validate hooks\n */\nconst createValidateContext = (permission: Permission) => ({\n  get permission(): Readonly<Permission> {\n    return cloneDeep(permission);\n  },\n});\n\n/**\n * Create a context from a domain {@link Permission} used by the before valuate hook\n */\nconst createBeforeEvaluateContext = (permission: Permission) => ({\n  get permission(): Readonly<Permission> {\n    return cloneDeep(permission);\n  },\n\n  addCondition(condition: string) {\n    Object.assign(permission, domain.permission.addCondition(condition, permission));\n\n    return this;\n  },\n});\n\ninterface WillRegisterContextParams {\n  permission: PermissionRule;\n  options: Record<string, unknown>;\n}\n\n/**\n * Create a context from a casl Permission & some options\n * @param caslPermission\n */\nconst createWillRegisterContext = ({ permission, options }: WillRegisterContextParams) => ({\n  ...options,\n\n  get permission() {\n    return cloneDeep(permission);\n  },\n\n  condition: {\n    and(rawConditionObject: unknown) {\n      if (!permission.condition) {\n        permission.condition = { $and: [] };\n      }\n\n      if (isArray(permission.condition.$and)) {\n        permission.condition.$and.push(rawConditionObject);\n      }\n\n      return this;\n    },\n\n    or(rawConditionObject: unknown) {\n      if (!permission.condition) {\n        permission.condition = { $and: [] };\n      }\n\n      if (isArray(permission.condition.$and)) {\n        const orClause = permission.condition.$and.find(has('$or'));\n\n        if (orClause) {\n          orClause.$or.push(rawConditionObject);\n        } else {\n          permission.condition.$and.push({ $or: [rawConditionObject] });\n        }\n      }\n\n      return this;\n    },\n  },\n});\n\nexport {\n  createEngineHooks,\n  createValidateContext,\n  createBeforeEvaluateContext,\n  createWillRegisterContext,\n};\n","import * as sift from 'sift';\nimport qs from 'qs';\nimport { AbilityBuilder, Ability } from '@casl/ability';\nimport { pick, isNil, isObject } from 'lodash/fp';\nimport type { ParametrizedAction, PermissionRule } from '../../types';\n\nexport interface CustomAbilityBuilder {\n  can(permission: PermissionRule): ReturnType<AbilityBuilder<Ability>['can']>;\n  buildParametrizedAction: (parametrizedAction: ParametrizedAction) => string;\n  build(): Ability;\n}\n\nconst allowedOperations = [\n  '$or',\n  '$and',\n  '$eq',\n  '$ne',\n  '$in',\n  '$nin',\n  '$lt',\n  '$lte',\n  '$gt',\n  '$gte',\n  '$exists',\n  '$elemMatch',\n] as const;\n\nconst operations = pick(allowedOperations, sift);\n\nconst conditionsMatcher = (conditions: unknown) => {\n  return sift.createQueryTester(conditions, { operations });\n};\n\nconst buildParametrizedAction = ({ name, params }: ParametrizedAction) => {\n  return `${name}?${qs.stringify(params)}`;\n};\n\n/**\n * Casl Ability Builder.\n */\nexport const caslAbilityBuilder = (): CustomAbilityBuilder => {\n  const { can, build, ...rest } = new AbilityBuilder(Ability);\n\n  return {\n    can(permission: PermissionRule) {\n      const { action, subject, properties = {}, condition } = permission;\n      const { fields } = properties;\n\n      const caslAction = typeof action === 'string' ? action : buildParametrizedAction(action);\n\n      return can(\n        caslAction,\n        isNil(subject) ? 'all' : subject,\n        fields,\n        isObject(condition) ? condition : undefined\n      );\n    },\n\n    buildParametrizedAction({ name, params }: ParametrizedAction) {\n      return `${name}?${qs.stringify(params)}`;\n    },\n\n    build() {\n      const ability = build({ conditionsMatcher });\n\n      function decorateCan(originalCan: Ability['can']) {\n        return function (...args: Parameters<Ability['can']>) {\n          const [action, ...rest] = args;\n          const caslAction = typeof action === 'string' ? action : buildParametrizedAction(action);\n\n          // Call the original `can` method\n          return originalCan.apply(ability, [caslAction, ...rest]);\n        };\n      }\n\n      ability.can = decorateCan(ability.can);\n      return ability;\n    },\n\n    ...rest,\n  };\n};\n","import _ from 'lodash/fp';\nimport qs from 'qs';\nimport { Ability } from '@casl/ability';\nimport { providerFactory } from '@strapi/utils';\n\nimport {\n  createEngineHooks,\n  createWillRegisterContext,\n  createBeforeEvaluateContext,\n  createValidateContext,\n} from './hooks';\nimport type { PermissionEngineHooks, HookName } from './hooks';\n\nimport * as abilities from './abilities';\nimport { Permission } from '../domain/permission';\nimport type { PermissionRule } from '../types';\n\nexport { abilities };\n\ntype Provider = Omit<ReturnType<typeof providerFactory>, 'register'> & {\n  register(...args: unknown[]): Promise<Provider> | Provider;\n};\n\ntype ActionProvider = Provider;\ntype ConditionProvider = Provider;\n\nexport interface Engine {\n  hooks: PermissionEngineHooks;\n  on(hook: HookName, handler: (...args: any[]) => any): Engine;\n  generateAbility(permissions: Permission[], options?: object): Promise<Ability>;\n  createRegisterFunction(\n    can: (permission: PermissionRule) => unknown,\n    options: Record<string, unknown>\n  ): (permission: PermissionRule) => Promise<unknown>;\n}\n\nexport interface EngineParams {\n  providers: { action: ActionProvider; condition: ConditionProvider };\n  abilityBuilderFactory?(): abilities.CustomAbilityBuilder;\n}\n\ninterface EvaluateParams {\n  options: Record<string, unknown>;\n  register: (permission: PermissionRule) => Promise<unknown>;\n  permission: Permission;\n}\n\ninterface Condition {\n  name: string;\n  handler(...params: unknown[]): boolean | object;\n}\n\n/**\n * Create a default state object for the engine\n */\nconst createEngineState = () => {\n  const hooks = createEngineHooks();\n\n  return { hooks };\n};\n\nconst newEngine = (params: EngineParams): Engine => {\n  const { providers, abilityBuilderFactory = abilities.caslAbilityBuilder } = params;\n\n  const state = createEngineState();\n\n  const runValidationHook = async (hook: HookName, context: unknown) =>\n    state.hooks[hook].call(context);\n\n  /**\n   * Evaluate a permission using local and registered behaviors (using hooks).\n   * Validate, format (add condition, etc...), evaluate (evaluate conditions) and register a permission\n   */\n  const evaluate = async (params: EvaluateParams) => {\n    const { options, register } = params;\n\n    const preFormatValidation = await runValidationHook(\n      'before-format::validate.permission',\n      createBeforeEvaluateContext(params.permission)\n    );\n\n    if (preFormatValidation === false) {\n      return;\n    }\n\n    const permission = (await state.hooks['format.permission'].call(\n      params.permission\n    )) as Permission;\n\n    const afterFormatValidation = await runValidationHook(\n      'after-format::validate.permission',\n      createValidateContext(permission)\n    );\n\n    if (afterFormatValidation === false) {\n      return;\n    }\n\n    await state.hooks['before-evaluate.permission'].call(createBeforeEvaluateContext(permission));\n\n    const {\n      action: actionName,\n      subject,\n      properties,\n      conditions = [],\n      actionParameters = {},\n    } = permission;\n\n    let action = actionName;\n\n    if (actionParameters && Object.keys(actionParameters).length > 0) {\n      action = `${actionName}?${qs.stringify(actionParameters)}`;\n    }\n\n    if (conditions.length === 0) {\n      return register({ action, subject, properties });\n    }\n\n    const resolveConditions = _.map(providers.condition.get);\n\n    const removeInvalidConditions = _.filter((condition: Condition) =>\n      _.isFunction(condition.handler)\n    );\n\n    const evaluateConditions = (conditions: Condition[]) => {\n      return Promise.all(\n        conditions.map(async (condition) => ({\n          condition,\n          result: await condition.handler(\n            _.merge(options, { permission: _.cloneDeep(permission) })\n          ),\n        }))\n      );\n    };\n\n    const removeInvalidResults = _.filter(\n      ({ result }) => _.isBoolean(result) || _.isObject(result)\n    );\n\n    const evaluatedConditions = await Promise.resolve(conditions)\n      .then(resolveConditions)\n      .then(removeInvalidConditions)\n      .then(evaluateConditions)\n      .then(removeInvalidResults);\n\n    const resultPropEq = _.propEq('result');\n    const pickResults = _.map(_.prop('result'));\n\n    if (evaluatedConditions.every(resultPropEq(false))) {\n      return;\n    }\n\n    if (_.isEmpty(evaluatedConditions) || evaluatedConditions.some(resultPropEq(true))) {\n      return register({ action, subject, properties });\n    }\n\n    const results = pickResults(evaluatedConditions).filter(_.isObject);\n\n    if (_.isEmpty(results)) {\n      return register({ action, subject, properties });\n    }\n\n    return register({\n      action,\n      subject,\n      properties,\n      condition: { $and: [{ $or: results }] },\n    });\n  };\n\n  return {\n    get hooks() {\n      return state.hooks;\n    },\n\n    /**\n     * Create a register function that wraps a `can` function\n     * used to register a permission in the ability builder\n     */\n    createRegisterFunction(can, options: Record<string, unknown>) {\n      return async (permission: PermissionRule) => {\n        const hookContext = createWillRegisterContext({ options, permission });\n\n        await state.hooks['before-register.permission'].call(hookContext);\n\n        return can(permission);\n      };\n    },\n\n    /**\n     * Register a new handler for a given hook\n     */\n    on(hook, handler) {\n      const validHooks = Object.keys(state.hooks);\n      const isValidHook = validHooks.includes(hook);\n\n      if (!isValidHook) {\n        throw new Error(\n          `Invalid hook supplied when trying to register an handler to the permission engine. Got \"${hook}\" but expected one of ${validHooks.join(\n            ', '\n          )}`\n        );\n      }\n\n      state.hooks[hook].register(handler);\n\n      return this;\n    },\n\n    /**\n     * Generate an ability based on the instance's\n     * ability builder and the given permissions\n     */\n    async generateAbility(permissions, options: Record<string, unknown> = {}) {\n      const { can, build } = abilityBuilderFactory();\n\n      for (const permission of permissions) {\n        const register = this.createRegisterFunction(can, options);\n\n        await evaluate({ permission, options, register });\n      }\n\n      return build();\n    },\n  };\n};\n\nexport { newEngine as new };\n"],"names":["PERMISSION_FIELDS","sanitizePermissionFields","_","pick","getDefaultPermission","conditions","properties","subject","create","pipe","merge","addCondition","curry","condition","permission","newConditions","Array","isArray","uniq","concat","set","getProperty","property","get","createEngineHooks","hooks","createAsyncBailHook","createAsyncSeriesWaterfallHook","createAsyncSeriesHook","createValidateContext","cloneDeep","createBeforeEvaluateContext","Object","assign","domain","createWillRegisterContext","options","and","rawConditionObject","$and","push","or","orClause","find","has","$or","allowedOperations","operations","sift","conditionsMatcher","createQueryTester","buildParametrizedAction","name","params","qs","stringify","caslAbilityBuilder","can","build","rest","AbilityBuilder","Ability","action","fields","caslAction","isNil","isObject","undefined","ability","decorateCan","originalCan","args","apply","createEngineState","newEngine","providers","abilityBuilderFactory","abilities","state","runValidationHook","hook","context","call","evaluate","register","preFormatValidation","afterFormatValidation","actionName","actionParameters","keys","length","resolveConditions","map","removeInvalidConditions","filter","isFunction","handler","evaluateConditions","Promise","all","result","removeInvalidResults","isBoolean","evaluatedConditions","resolve","then","resultPropEq","propEq","pickResults","prop","every","isEmpty","some","results","createRegisterFunction","hookContext","on","validHooks","isValidHook","includes","Error","join","generateAbility","permissions"],"mappings":"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"}