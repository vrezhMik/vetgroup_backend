'use strict';

var commander = require('commander');
var cloudCli = require('@strapi/cloud-cli');
var utils = require('@strapi/utils');
var _ = require('lodash');
var inquirer = require('inquirer');
var core = require('@strapi/core');
var chalk = require('chalk');
var fp = require('lodash/fp');
var boxen = require('boxen');
var CLITable = require('cli-table3');
var fs = require('fs');
var path = require('path');
var fse = require('fs-extra');
var crypto = require('crypto');
var tsUtils = require('@strapi/typescript-utils');
var os = require('node:os');
var fs$1 = require('node:fs/promises');
var path$1 = require('node:path');
var semver = require('semver');
var resolveFrom = require('resolve-from');
var execa = require('execa');
var readPkgUp = require('read-pkg-up');
var perf_hooks = require('perf_hooks');
var browserslist = require('browserslist');
var dotenv = require('dotenv');
var node = require('esbuild-register/dist/node');
var fs$2 = require('node:fs');
var camelCase = require('lodash/camelCase');
var outdent = require('outdent');
var react = require('react');
var server = require('react-dom/server');
var _internal = require('@strapi/admin/_internal');
var REPL = require('repl');
var cluster = require('node:cluster');
var chokidar = require('chokidar');
var os$1 = require('os');
var logger = require('@strapi/logger');
var ora = require('ora');
var dataTransfer = require('@strapi/data-transfer');
var cliProgress = require('cli-progress');
var ts = require('typescript');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var tsUtils__namespace = /*#__PURE__*/_interopNamespaceDefault(tsUtils);
var cliProgress__namespace = /*#__PURE__*/_interopNamespaceDefault(cliProgress);

/**
 * Helper functions for the Strapi CLI
 */ const bytesPerKb = 1024;
const sizes = [
    'B ',
    'KB',
    'MB',
    'GB',
    'TB',
    'PB'
];
/**
 * Convert bytes to a human readable formatted string, for example "1024" becomes "1KB"
 */ const readableBytes = (bytes, decimals = 1, padStart = 0)=>{
    if (!bytes) {
        return '0';
    }
    const i = Math.floor(Math.log(bytes) / Math.log(bytesPerKb));
    const result = `${parseFloat((bytes / bytesPerKb ** i).toFixed(decimals))} ${sizes[i].padStart(2)}`;
    return result.padStart(padStart);
};
/**
 *
 * Display message(s) to console and then call process.exit with code.
 * If code is zero, console.log and green text is used for messages, otherwise console.error and red text.
 *
 */ const exitWith = (code, message, options = {})=>{
    const { logger = console, prc = process } = options;
    const log = (message)=>{
        if (code === 0) {
            logger.log(chalk.green(message));
        } else {
            logger.error(chalk.red(message));
        }
    };
    if (fp.isString(message)) {
        log(message);
    } else if (fp.isArray(message)) {
        message.forEach((msg)=>log(msg));
    }
    prc.exit(code);
};
/**
 * assert that a URL object has a protocol value
 *
 */ const assertUrlHasProtocol = (url, protocol)=>{
    if (!url.protocol) {
        exitWith(1, `${url.toString()} does not have a protocol`);
    }
    // if just checking for the existence of a protocol, return
    if (!protocol) {
        return;
    }
    if (fp.isString(protocol)) {
        if (protocol !== url.protocol) {
            exitWith(1, `${url.toString()} must have the protocol ${protocol}`);
        }
        return;
    }
    // assume an array
    if (!protocol.some((protocol)=>url.protocol === protocol)) {
        return exitWith(1, `${url.toString()} must have one of the following protocols: ${protocol.join(',')}`);
    }
};
/**
 * Passes commander options to conditionCallback(). If it returns true, call isMetCallback otherwise call isNotMetCallback
 */ const ifOptions = (conditionCallback, isMetCallback = async ()=>{}, isNotMetCallback = async ()=>{})=>{
    return async (command)=>{
        const opts = command.opts();
        if (await conditionCallback(opts)) {
            await isMetCallback(command);
        } else {
            await isNotMetCallback(command);
        }
    };
};
const assertCwdContainsStrapiProject = (name)=>{
    const logErrorAndExit = ()=>{
        console.log(`You need to run ${chalk.yellow(`strapi ${name}`)} in a Strapi project. Make sure you are in the right directory.`);
        process.exit(1);
    };
    try {
        const pkgJSON = require(`${process.cwd()}/package.json`);
        if (!fp.has('dependencies.@strapi/strapi', pkgJSON) && !fp.has('devDependencies.@strapi/strapi', pkgJSON)) {
            logErrorAndExit();
        }
    } catch (err) {
        logErrorAndExit();
    }
};
const runAction = (name, action)=>(...args)=>{
        assertCwdContainsStrapiProject(name);
        Promise.resolve().then(()=>{
            return action(...args);
        }).catch((error)=>{
            console.error(error);
            process.exit(1);
        });
    };

const emailValidator = utils.yup.string().email('Invalid email address').lowercase();
const passwordValidator = utils.yup.string().min(8, 'Password must be at least 8 characters long').matches(/[a-z]/, 'Password must contain at least one lowercase character').matches(/[A-Z]/, 'Password must contain at least one uppercase character').matches(/\d/, 'Password must contain at least one number');
const adminCreateSchema = utils.yup.object().shape({
    email: emailValidator,
    password: passwordValidator,
    firstname: utils.yup.string().trim().required('First name is required'),
    lastname: utils.yup.string()
});
/**
 * It's not an observable, in reality this is
 * `ReadOnlyArray<inquirer.DistinctQuestion<Answers>>`
 * but then the logic of the validate function needs to change.
 */ // eslint-disable-next-line rxjs/finnish
const promptQuestions$1 = [
    {
        type: 'input',
        name: 'email',
        message: 'Admin email?',
        async validate (value) {
            const validEmail = await emailValidator.validate(value);
            return validEmail === value || validEmail;
        }
    },
    {
        type: 'password',
        name: 'password',
        message: 'Admin password?',
        async validate (value) {
            const validPassword = await passwordValidator.validate(value);
            return validPassword === value || validPassword;
        }
    },
    {
        type: 'input',
        name: 'firstname',
        message: 'First name?'
    },
    {
        type: 'input',
        name: 'lastname',
        message: 'Last name?'
    },
    {
        type: 'confirm',
        name: 'confirm',
        message: 'Do you really want to create a new admin?'
    }
];
async function createAdmin({ email, password, firstname, lastname }) {
    const appContext = await core.compileStrapi();
    const app = await core.createStrapi(appContext).load();
    const user = await app.admin.services.user.exists({
        email
    });
    if (user) {
        console.error(`User with email "${email}" already exists`);
        process.exit(1);
    }
    const superAdminRole = await app.admin.services.role.getSuperAdmin();
    await app.admin.services.user.create({
        email,
        firstname,
        lastname,
        isActive: true,
        roles: [
            superAdminRole.id
        ],
        ...password && {
            password,
            registrationToken: null
        }
    });
    console.log(`Successfully created new admin`);
    process.exit(0);
}
/**
 * Create new admin user
 */ const action$m = async (cmdOptions = {})=>{
    let { email, password, firstname, lastname } = cmdOptions;
    if (_.isEmpty(email) && _.isEmpty(password) && _.isEmpty(firstname) && _.isEmpty(lastname) && process.stdin.isTTY) {
        const inquiry = await inquirer.prompt(promptQuestions$1);
        if (!inquiry.confirm) {
            process.exit(0);
        }
        ({ email, password, firstname, lastname } = inquiry);
    }
    try {
        await adminCreateSchema.validate({
            email,
            password,
            firstname,
            lastname
        });
    } catch (err) {
        if (err instanceof utils.yup.ValidationError) {
            console.error(err.errors[0]);
        }
        process.exit(1);
    }
    return createAdmin({
        email,
        password,
        firstname,
        lastname
    });
};
/**
 * `$ strapi admin:create-user`
 */ const command$p = ()=>{
    return commander.createCommand('admin:create-user').alias('admin:create').description('Create a new admin').option('-e, --email <email>', 'Email of the new admin').option('-p, --password <password>', 'Password of the new admin').option('-f, --firstname <first name>', 'First name of the new admin').option('-l, --lastname <last name>', 'Last name of the new admin').action(runAction('admin:create-user', action$m));
};

const promptQuestions = [
    {
        type: 'input',
        name: 'email',
        message: 'User email?'
    },
    {
        type: 'password',
        name: 'password',
        message: 'New password?'
    },
    {
        type: 'confirm',
        name: 'confirm',
        message: "Do you really want to reset this user's password?"
    }
];
async function changePassword({ email, password }) {
    const appContext = await core.compileStrapi();
    const app = await core.createStrapi(appContext).load();
    await app.admin.services.user.resetPasswordByEmail(email, password);
    console.log(`Successfully reset user's password`);
    process.exit(0);
}
/**
 * Reset user's password
 */ const action$l = async (cmdOptions = {})=>{
    const { email, password } = cmdOptions;
    if (_.isEmpty(email) && _.isEmpty(password) && process.stdin.isTTY) {
        const inquiry = await inquirer.prompt(promptQuestions);
        if (!inquiry.confirm) {
            process.exit(0);
        }
        return changePassword(inquiry);
    }
    if (_.isEmpty(email) || _.isEmpty(password)) {
        console.error('Missing required options `email` or `password`');
        process.exit(1);
    }
    return changePassword({
        email,
        password
    });
};
/**
 * `$ strapi admin:reset-user-password`
 */ const command$o = ()=>{
    return commander.createCommand('admin:reset-user-password').alias('admin:reset-password').description("Reset an admin user's password").option('-e, --email <email>', 'The user email').option('-p, --password <password>', 'New password for the user').action(runAction('admin:reset-user-password', action$l));
};

const action$k = async ()=>{
    const appContext = await core.compileStrapi();
    const app = await core.createStrapi(appContext).register();
    const list = Object.keys(app.components);
    const infoTable = new CLITable({
        head: [
            chalk.blue('Name')
        ]
    });
    list.forEach((name)=>infoTable.push([
            name
        ]));
    console.log(infoTable.toString());
    await app.destroy();
};
/**
 * `$ strapi components:list`
 */ const command$n = ()=>{
    return commander.createCommand('components:list').description('List all the application components').action(runAction('components:list', action$k));
};

const CHUNK_SIZE = 100;
/**
 * Will dump configurations to a file or stdout
 * @param {string} file filepath to use as output
 */ const action$j = async ({ file: filePath, pretty })=>{
    const output = filePath ? fs.createWriteStream(filePath) : process.stdout;
    const appContext = await core.compileStrapi();
    const app = await core.createStrapi(appContext).load();
    const count = await app.query('strapi::core-store').count();
    const exportData = [];
    const pageCount = Math.ceil(count / CHUNK_SIZE);
    for(let page = 0; page < pageCount; page += 1){
        const results = await app.query('strapi::core-store').findMany({
            limit: CHUNK_SIZE,
            offset: page * CHUNK_SIZE,
            orderBy: 'key'
        });
        results.filter((result)=>result.key.startsWith('plugin_')).forEach((result)=>{
            exportData.push({
                key: result.key,
                value: result.value,
                type: result.type,
                environment: result.environment,
                tag: result.tag
            });
        });
    }
    const str = JSON.stringify(exportData, null, pretty ? 2 : undefined);
    output.write(str);
    output.write('\n');
    output.end();
    // log success only when writting to file
    if (filePath) {
        console.log(`Successfully exported ${exportData.length} configuration entries`);
    }
    process.exit(0);
};
/**
 * `$ strapi configuration:dump`
 */ const command$m = ()=>{
    return commander.createCommand('configuration:dump').alias('config:dump').description('Dump configurations of your application').option('-f, --file <file>', 'Output file, default output is stdout').option('-p, --pretty', 'Format the output JSON with indentation and line breaks', false).action(runAction('configuration:dump', action$j));
};

/**
 * Will restore configurations. It reads from a file or stdin
 */ const action$i = async ({ file: filePath, strategy = 'replace' })=>{
    const input = filePath ? fs.readFileSync(filePath) : await readStdin();
    const appContext = await core.compileStrapi();
    const app = await core.createStrapi(appContext).load();
    let dataToImport;
    try {
        dataToImport = JSON.parse(_.toString(input));
    } catch (error) {
        if (error instanceof Error) {
            throw new Error(`Invalid input data: ${error.message}. Expected a valid JSON array.`);
        }
        throw error;
    }
    if (!Array.isArray(dataToImport)) {
        throw new Error(`Invalid input data. Expected a valid JSON array.`);
    }
    if (!app.db) {
        throw new Error('Cannot import configuration without a database connection.');
    }
    const importer = createImporter(app.db, strategy);
    for (const config of dataToImport){
        await importer.import(config);
    }
    console.log(`Successfully imported configuration with ${strategy} strategy. Statistics: ${importer.printStatistics()}.`);
    process.exit(0);
};
const readStdin = ()=>{
    const { stdin } = process;
    let result = '';
    if (stdin.isTTY) return Promise.resolve(result);
    return new Promise((resolve, reject)=>{
        stdin.setEncoding('utf8');
        stdin.on('readable', ()=>{
            let chunk;
            // eslint-disable-next-line no-cond-assign
            while(chunk = stdin.read()){
                result += chunk;
            }
        });
        stdin.on('end', ()=>{
            resolve(result);
        });
        stdin.on('error', reject);
    });
};
const createImporter = (db, strategy)=>{
    switch(strategy){
        case 'replace':
            return createReplaceImporter(db);
        case 'merge':
            return createMergeImporter(db);
        case 'keep':
            return createKeepImporter(db);
        default:
            throw new Error(`No importer available for strategy "${strategy}"`);
    }
};
/**
 * Replace importer. Will replace the keys that already exist and create the new ones
 */ const createReplaceImporter = (db)=>{
    const stats = {
        created: 0,
        replaced: 0
    };
    return {
        printStatistics () {
            return `${stats.created} created, ${stats.replaced} replaced`;
        },
        async import (conf) {
            const matching = await db.query('strapi::core-store').count({
                where: {
                    key: conf.key
                }
            });
            if (matching > 0) {
                stats.replaced += 1;
                await db.query('strapi::core-store').update({
                    where: {
                        key: conf.key
                    },
                    data: conf
                });
            } else {
                stats.created += 1;
                await db.query('strapi::core-store').create({
                    data: conf
                });
            }
        }
    };
};
/**
 * Merge importer. Will merge the keys that already exist with their new value and create the new ones
 */ const createMergeImporter = (db)=>{
    const stats = {
        created: 0,
        merged: 0
    };
    return {
        printStatistics () {
            return `${stats.created} created, ${stats.merged} merged`;
        },
        async import (conf) {
            const existingConf = await db.query('strapi::core-store').findOne({
                where: {
                    key: conf.key
                }
            });
            if (existingConf) {
                stats.merged += 1;
                await db.query('strapi::core-store').update({
                    where: {
                        key: conf.key
                    },
                    data: _.merge(existingConf, conf)
                });
            } else {
                stats.created += 1;
                await db.query('strapi::core-store').create({
                    data: conf
                });
            }
        }
    };
};
/**
 * Merge importer. Will keep the keys that already exist without changing them and create the new ones
 */ const createKeepImporter = (db)=>{
    const stats = {
        created: 0,
        untouched: 0
    };
    return {
        printStatistics () {
            return `${stats.created} created, ${stats.untouched} untouched`;
        },
        async import (conf) {
            const matching = await db.query('strapi::core-store').count({
                where: {
                    key: conf.key
                }
            });
            if (matching > 0) {
                stats.untouched += 1;
                // if configuration already exists do not overwrite it
                return;
            }
            stats.created += 1;
            await db.query('strapi::core-store').create({
                data: conf
            });
        }
    };
};
/**
 * `$ strapi configuration:restore`
 */ const command$l = ()=>{
    return commander.createCommand('configuration:restore').alias('config:restore').description('Restore configurations of your application').option('-f, --file <file>', 'Input file, default input is stdin').option('-s, --strategy <strategy>', 'Strategy name, one of: "replace", "merge", "keep"').action(runAction('configuration:restore', action$i));
};

const action$h = async ()=>{
    const appContext = await core.compileStrapi();
    const app = await core.createStrapi(appContext).register();
    const list = app.get('content-types').keys();
    const infoTable = new CLITable({
        head: [
            chalk.blue('Name')
        ]
    });
    list.forEach((name)=>infoTable.push([
            name
        ]));
    console.log(infoTable.toString());
    await app.destroy();
};
/**
 * `$ strapi content-types:list`
 */ const command$k = ()=>{
    return commander.createCommand('content-types:list').description('List all the application content-types').action(runAction('content-types:list', action$h));
};

const action$g = async ()=>{
    const appContext = await core.compileStrapi();
    const app = await core.createStrapi(appContext).register();
    const list = app.get('controllers').keys();
    const infoTable = new CLITable({
        head: [
            chalk.blue('Name')
        ]
    });
    list.forEach((name)=>infoTable.push([
            name
        ]));
    console.log(infoTable.toString());
    await app.destroy();
};
/**
 * `$ strapi controllers:list`
 */ const command$j = ()=>{
    return commander.createCommand('controllers:list').description('List all the application controllers').action(runAction('controllers:list', action$g));
};

const action$f = async ()=>{
    const appContext = await core.compileStrapi();
    const app = await core.createStrapi(appContext).register();
    const list = app.get('hooks').keys();
    const infoTable = new CLITable({
        head: [
            chalk.blue('Name')
        ]
    });
    list.forEach((name)=>infoTable.push([
            name
        ]));
    console.log(infoTable.toString());
    await app.destroy();
};
/**
 * `$ strapi hooks:list`
 */ const command$i = ()=>{
    return commander.createCommand('hooks:list').description('List all the application hooks').action(runAction('hooks:list', action$f));
};

const action$e = async ()=>{
    const appContext = await core.compileStrapi();
    const app = await core.createStrapi(appContext).register();
    const list = app.get('middlewares').keys();
    const infoTable = new CLITable({
        head: [
            chalk.blue('Name')
        ]
    });
    list.forEach((name)=>infoTable.push([
            name
        ]));
    console.log(infoTable.toString());
    await app.destroy();
};
/**
 * `$ strapi middlewares:list`
 */ const command$h = ()=>{
    return commander.createCommand('middlewares:list').description('List all the application middlewares').action(runAction('middlewares:list', action$e));
};

const action$d = async ()=>{
    const appContext = await core.compileStrapi();
    const app = await core.createStrapi(appContext).register();
    const list = app.get('policies').keys();
    const infoTable = new CLITable({
        head: [
            chalk.blue('Name')
        ]
    });
    list.forEach((name)=>infoTable.push([
            name
        ]));
    console.log(infoTable.toString());
    await app.destroy();
};
/**
 * `$ strapi policies:list`
 */ const command$g = ()=>{
    return commander.createCommand('policies:list').description('List all the application policies').action(runAction('policies:list', action$d));
};

const action$c = async ()=>{
    const appContext = await core.compileStrapi();
    const app = await core.createStrapi(appContext).load();
    const list = app.server.mount().listRoutes();
    const infoTable = new CLITable({
        head: [
            chalk.blue('Method'),
            chalk.blue('Path')
        ],
        colWidths: [
            20
        ]
    });
    list.filter((route)=>route.methods.length).forEach((route)=>{
        infoTable.push([
            route.methods.map(fp.toUpper).join('|'),
            route.path
        ]);
    });
    console.log(infoTable.toString());
    await app.destroy();
};
/**
 * `$ strapi routes:list``
 */ const command$f = ()=>{
    return commander.createCommand('routes:list').description('List all the application routes').action(runAction('routes:list', action$c));
};

const action$b = async ()=>{
    const appContext = await core.compileStrapi();
    const app = await core.createStrapi(appContext).register();
    const list = app.get('services').keys();
    const infoTable = new CLITable({
        head: [
            chalk.blue('Name')
        ]
    });
    list.forEach((name)=>infoTable.push([
            name
        ]));
    console.log(infoTable.toString());
    await app.destroy();
};
/**
 * `$ strapi services:list`
 */ const command$e = ()=>{
    return commander.createCommand('services:list').description('List all the application services').action(runAction('services:list', action$b));
};

const sendEvent = async (event, uuid)=>{
    try {
        await fetch('https://analytics.strapi.io/api/v2/track', {
            method: 'POST',
            body: JSON.stringify({
                event,
                deviceId: utils.machineID(),
                groupProperties: {
                    projectId: uuid
                }
            }),
            headers: {
                'Content-Type': 'application/json',
                'X-Strapi-Event': event
            }
        });
    } catch (e) {
    // ...
    }
};

const readPackageJSON$1 = async (path)=>{
    try {
        const packageObj = await fse.readJson(path);
        const uuid = packageObj.strapi ? packageObj.strapi.uuid : null;
        return {
            uuid,
            packageObj
        };
    } catch (err) {
        if (err instanceof Error) {
            console.error(`${chalk.red('Error')}: ${err.message}`);
        }
    }
};
const writePackageJSON$1 = async (path, file, spacing)=>{
    try {
        await fse.writeJson(path, file, {
            spaces: spacing
        });
        return true;
    } catch (err) {
        if (err instanceof Error) {
            console.error(`${chalk.red('Error')}: ${err.message}`);
        }
    }
};
const action$a = async ()=>{
    const packageJSONPath = path.resolve(process.cwd(), 'package.json');
    const exists = await fse.pathExists(packageJSONPath);
    if (!exists) {
        console.log(`${chalk.yellow('Warning')}: could not find package.json`);
        process.exit(0);
    }
    const { uuid, packageObj } = await readPackageJSON$1(packageJSONPath) ?? {};
    if (packageObj.strapi && packageObj.strapi.telemetryDisabled || !uuid) {
        console.log(`${chalk.yellow('Warning:')} telemetry is already disabled`);
        process.exit(0);
    }
    const updatedPackageJSON = {
        ...packageObj,
        strapi: {
            ...packageObj.strapi,
            telemetryDisabled: true
        }
    };
    const write = await writePackageJSON$1(packageJSONPath, updatedPackageJSON, 2);
    if (!write) {
        console.log(`${chalk.yellow('Warning')}: There has been an error, please set "telemetryDisabled": true in the "strapi" object of your package.json manually.`);
        process.exit(0);
    }
    await sendEvent('didOptOutTelemetry', uuid);
    console.log(`${chalk.green('Successfully opted out of Strapi telemetry')}`);
    process.exit(0);
};
/**
 * `$ strapi telemetry:disable`
 */ const command$d = ()=>{
    return commander.createCommand('telemetry:disable').description('Disable anonymous telemetry and metadata sending to Strapi analytics').action(runAction('telemetry:disable', action$a));
};

const readPackageJSON = async (path)=>{
    try {
        const packageObj = await fse.readJson(path);
        return packageObj;
    } catch (err) {
        if (err instanceof Error) {
            console.error(`${chalk.red('Error')}: ${err.message}`);
        } else {
            throw err;
        }
    }
};
const writePackageJSON = async (path, file, spacing)=>{
    try {
        await fse.writeJson(path, file, {
            spaces: spacing
        });
        return true;
    } catch (err) {
        if (err instanceof Error) {
            console.error(`${chalk.red('Error')}: ${err.message}`);
            console.log(`${chalk.yellow('Warning')}: There has been an error, please set "telemetryDisabled": false in the "strapi" object of your package.json manually.`);
            return false;
        }
        throw err;
    }
};
const generateNewPackageJSON = (packageObj)=>{
    if (!packageObj.strapi) {
        return {
            ...packageObj,
            strapi: {
                uuid: crypto.randomUUID(),
                telemetryDisabled: false
            }
        };
    }
    return {
        ...packageObj,
        strapi: {
            ...packageObj.strapi,
            uuid: packageObj.strapi.uuid ? packageObj.strapi.uuid : crypto.randomUUID(),
            telemetryDisabled: false
        }
    };
};
const action$9 = async ()=>{
    const packageJSONPath = path.resolve(process.cwd(), 'package.json');
    const exists = await fse.pathExists(packageJSONPath);
    if (!exists) {
        console.log(`${chalk.yellow('Warning')}: could not find package.json`);
        process.exit(0);
    }
    const packageObj = await readPackageJSON(packageJSONPath);
    if (packageObj.strapi && packageObj.strapi.uuid) {
        if (packageObj.strapi.telemetryDisabled === false) {
            console.log(`${chalk.yellow('Warning:')} telemetry is already enabled`);
            process.exit(0);
        }
    }
    const updatedPackageJSON = generateNewPackageJSON(packageObj);
    const write = await writePackageJSON(packageJSONPath, updatedPackageJSON, 2);
    if (!write) {
        process.exit(0);
    }
    await sendEvent('didOptInTelemetry', updatedPackageJSON.strapi.uuid);
    console.log(`${chalk.green('Successfully opted into and enabled Strapi telemetry')}`);
    process.exit(0);
};
/**
 * `$ strapi telemetry:enable`
 */ const command$c = ()=>{
    return commander.createCommand('telemetry:enable').description('Enable anonymous telemetry and metadata sending to Strapi analytics').action(runAction('telemetry:enable', action$9));
};

/**
 *`$ strapi templates:generate <directory>`
 */ const command$b = ()=>{
    return commander.createCommand('templates:generate <directory>').description('(deprecated) Generate template from Strapi project').action(()=>{
        console.warn('This command is deprecated and will be removed in the next major release.');
        console.warn('You can now copy an existing app and use it as a template.');
    });
};

const action$8 = async ({ debug, silent, verbose, outDir })=>{
    if ((debug || verbose) && silent) {
        console.error('Flags conflict: both silent and debug mode are enabled, exiting...');
        process.exit(1);
    }
    const appContext = await core.compileStrapi({
        ignoreDiagnostics: true
    });
    const app = await core.createStrapi(appContext).register();
    await tsUtils.generators.generate({
        strapi: app,
        pwd: appContext.appDir,
        rootDir: outDir ?? undefined,
        logger: {
            silent,
            debug
        },
        artifacts: {
            contentTypes: true,
            components: true
        }
    });
    await app.destroy();
};
/**
 * `$ strapi ts:generate-types`
 */ const command$a = ()=>{
    return commander.createCommand('ts:generate-types').description(`Generate TypeScript typings for your schemas`).option('-d, --debug', `Run the generation with debug messages`, false).option('-s, --silent', `Run the generation silently, without any output`, false).option('-o, --out-dir <outDir>', 'Specify a relative root directory in which the definitions will be generated. Changing this value might break types exposed by Strapi that relies on generated types.').action(runAction('ts:generate-types', action$8));
};

/**
 * @description Supports the following managers:
 * – npm
 * – yarn
 * – pnpm
 */ const getPackageManager = ()=>{
    // Yes, the env var is lowercase - it is set by the package managers themselves
    const agent = process.env.npm_config_user_agent || '';
    if (agent.includes('yarn')) {
        return 'yarn';
    }
    if (agent.includes('pnpm')) {
        return 'pnpm';
    }
    // Both yarn and pnpm does a `npm/?` thing, thus the slightly different match here
    // Theoretically not needed since we check for yarn/pnpm above, but in case other
    // package managers do the same thing, we'll (hopefully) catch them here.
    if (/^npm\/\d/.test(agent)) {
        return 'npm';
    }
    return undefined;
};

/**
 * From V5 this will be imported from the package.json of `@strapi/strapi`.
 */ const PEER_DEPS = {
    react: '^18.0.0',
    'react-dom': '^18.0.0',
    'react-router-dom': '^6.0.0',
    'styled-components': '^6.0.0'
};
/**
 * Checks the user's project that it has declared and installed the required dependencies
 * needed by the Strapi admin project. Whilst generally speaking most modules will be
 * declared by the actual packages there are some packages where you only really want one of
 * and thus they are declared as peer dependencies – react / styled-components / etc.
 *
 * If these deps are not installed or declared, then we prompt the user to correct this. In
 * V4 this is not a hard requirement, but in V5 it will be. Might as well get people started now.
 */ const checkRequiredDependencies = async ({ cwd, logger })=>{
    /**
   * This enables us to use experimental deps for libraries like
   * react or styled-components. This is useful for testing against.
   */ if (process.env.USE_EXPERIMENTAL_DEPENDENCIES === 'true') {
        logger.warn('You are using experimental dependencies that may not be compatible with Strapi.');
        return {
            didInstall: false
        };
    }
    const pkg = await readPkgUp({
        cwd
    });
    if (!pkg) {
        throw new Error(`Could not find package.json at path: ${cwd}`);
    }
    logger.debug('Loaded package.json:', os.EOL, pkg.packageJson);
    /**
   * Run through each of the peer deps and figure out if they need to be
   * installed or they need their version checked against.
   */ const { install, review } = Object.entries(PEER_DEPS).reduce((acc, [name, version])=>{
        if (!pkg.packageJson.dependencies) {
            throw new Error(`Could not find dependencies in package.json at path: ${cwd}`);
        }
        const declaredVersion = pkg.packageJson.dependencies[name];
        if (!declaredVersion) {
            acc.install.push({
                name,
                wantedVersion: version
            });
        } else {
            acc.review.push({
                name,
                wantedVersion: version,
                declaredVersion
            });
        }
        return acc;
    }, {
        install: [],
        review: []
    });
    if (install.length > 0) {
        logger.info('The Strapi admin needs to install the following dependencies:', os.EOL, install.map(({ name, wantedVersion })=>`  - ${name}@${wantedVersion}`).join(os.EOL));
        await installDependencies(install, {
            cwd,
            logger
        });
        const [file, ...args] = process.argv;
        /**
     * Re-run the same command after installation e.g. strapi build because the yarn.lock might
     * not be the same and could break installations. It's not the best solution, but it works.
     */ await execa(file, args, {
            cwd,
            stdio: 'inherit'
        });
        return {
            didInstall: true
        };
    }
    if (review.length) {
        const errors = [];
        for (const dep of review){
            // The version specified in package.json could be incorrect, eg `foo`
            let minDeclaredVersion = null;
            try {
                minDeclaredVersion = semver.minVersion(dep.declaredVersion);
            } catch (err) {
            // Intentional fall-through (variable will be left as null, throwing below)
            }
            if (!minDeclaredVersion) {
                errors.push(`The declared dependency, ${dep.name} has an invalid version in package.json: ${dep.declaredVersion}`);
            } else if (!semver.satisfies(minDeclaredVersion, dep.wantedVersion)) {
                /**
         * The delcared version should be semver compatible with our required version
         * of the dependency. If it's not, we should advise the user to change it.
         */ logger.warn([
                    `Declared version of ${dep.name} (${minDeclaredVersion}) is not compatible with the version required by Strapi (${dep.wantedVersion}).`,
                    'You may experience issues, we recommend you change this.'
                ].join(os.EOL));
            }
            const installedVersion = await getModuleVersion(dep.name, cwd);
            if (!installedVersion) {
                /**
         * TODO: when we know the packageManager we can advise the actual install command.
         */ errors.push(`The declared dependency, ${dep.name} is not installed. You should install before re-running this command`);
            } else if (!semver.satisfies(installedVersion, dep.wantedVersion)) {
                logger.warn([
                    `Declared version of ${dep.name} (${installedVersion}) is not compatible with the version required by Strapi (${dep.wantedVersion}).`,
                    'You may experience issues, we recommend you change this.'
                ].join(os.EOL));
            }
        }
        if (errors.length > 0 && process.env.NODE_ENV === 'development') {
            throw new Error(`${os.EOL}- ${errors.join(`${os.EOL}- `)}`);
        }
    }
    return {
        didInstall: false
    };
};
const getModule = async (name, cwd)=>{
    const modulePackagePath = resolveFrom.silent(cwd, path$1.join(name, 'package.json'));
    if (!modulePackagePath) {
        return null;
    }
    const file = await fs$1.readFile(modulePackagePath, 'utf8').then((res)=>JSON.parse(res));
    return file;
};
const getModuleVersion = async (name, cwd)=>{
    const pkg = await getModule(name, cwd);
    return pkg?.version || null;
};
const installDependencies = async (install, { cwd, logger })=>{
    const packageManager = getPackageManager();
    if (!packageManager) {
        logger.error('Could not find a supported package manager, please install the dependencies manually.');
        process.exit(1);
    }
    const execOptions = {
        encoding: 'utf8',
        cwd,
        stdio: 'inherit'
    };
    const packages = install.map(({ name, wantedVersion })=>`${name}@${wantedVersion}`);
    let result;
    if (packageManager === 'npm') {
        const npmArgs = [
            'install',
            '--legacy-peer-deps',
            '--save',
            ...packages
        ];
        logger.info(`Running 'npm ${npmArgs.join(' ')}'`);
        result = await execa('npm', npmArgs, execOptions);
    } else if (packageManager === 'yarn') {
        const yarnArgs = [
            'add',
            ...packages
        ];
        logger.info(`Running 'yarn ${yarnArgs.join(' ')}'`);
        result = await execa('yarn', yarnArgs, execOptions);
    } else if (packageManager === 'pnpm') {
        const pnpmArgs = [
            'add',
            '--save-prod',
            ...packages
        ];
        logger.info(`Running 'pnpm ${pnpmArgs.join(' ')}'`);
        result = await execa('pnpm', pnpmArgs, execOptions);
    }
    if (result?.exitCode || result?.failed) {
        throw new Error('Package installation failed');
    }
};

function getTimer() {
    const timings = {};
    const startTimes = {};
    function start(name) {
        if (typeof startTimes[name] !== 'undefined') {
            throw new Error(`Timer "${name}" already started, cannot overwrite`);
        }
        startTimes[name] = perf_hooks.performance.now();
    }
    function end(name) {
        if (typeof startTimes[name] === 'undefined') {
            throw new Error(`Timer "${name}" never started, cannot end`);
        }
        timings[name] = perf_hooks.performance.now() - startTimes[name];
        return timings[name];
    }
    return {
        start,
        end,
        getTimings: ()=>timings
    };
}
const prettyTime = (timeInMs)=>{
    return `${Math.ceil(timeInMs)}ms`;
};

/**
 * @internal
 */ const pathExists = async (path)=>{
    try {
        await fs$1.access(path);
        return true;
    } catch (error) {
        return false;
    }
};
/**
 * @internal
 */ const loadFile = async (path)=>{
    if (await pathExists(path)) {
        const esbuildOptions = {
            extensions: [
                '.js',
                '.mjs',
                '.ts'
            ]
        };
        const { unregister } = node.register(esbuildOptions);
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const mod = require(path);
        unregister();
        /**
     * handles esm or cjs exporting.
     */ const file = mod?.default || mod || undefined;
        return file;
    }
    return undefined;
};
/**
 * @internal
 *
 * @description Converts a system path to a module path mainly for `Windows` systems.
 * where the path separator is `\` instead of `/`, on linux systems the path separator
 * is identical to the module path separator.
 */ const convertSystemPathToModulePath = (sysPath)=>{
    if (process.platform === 'win32') {
        return sysPath.split(path$1.sep).join(path$1.posix.sep);
    }
    return sysPath;
};
/**
 * @internal
 *
 * @description Converts a module path to a system path, again largely used for Windows systems.
 * The original use case was plugins where the resolve path was in module format but we want to
 * have it relative to the runtime directory.
 */ const convertModulePathToSystemPath = (modulePath)=>{
    if (process.platform === 'win32') {
        return modulePath.split(path$1.posix.sep).join(path$1.sep);
    }
    return modulePath;
};

/**
 * @internal
 *
 * @description Load the .env file if it exists
 */ const loadEnv = async (cwd)=>{
    const pathToEnv = path$1.resolve(cwd, '.env');
    if (await pathExists(pathToEnv)) {
        dotenv.config({
            path: pathToEnv
        });
    }
};
/**
 * @internal
 *
 * @description Get all the environment variables that start with `STRAPI_ADMIN_`
 */ const getStrapiAdminEnvVars = (defaultEnv)=>{
    return Object.keys(process.env).filter((key)=>key.toUpperCase().startsWith('STRAPI_ADMIN_')).reduce((acc, key)=>{
        acc[key] = process.env[key];
        return acc;
    }, defaultEnv);
};

const isError = (err)=>err instanceof Error;
/**
 * @description Handle unexpected errors. No, but really, your CLI should anticipate error cases.
 * If a user hits an error we don't expect, then we need to flag to them that this is not normal
 * and they should use the `--debug` flag to get more information (assuming you've implemented this
 * in your action).
 */ const handleUnexpectedError = (err)=>{
    console.error(chalk.red(`[ERROR] `, 'There seems to be an unexpected error, try again with --debug for more information', os.EOL));
    if (isError(err) && err.stack) {
        // eslint-disable-next-line no-console
        console.log(chalk.red(boxen(err.stack, {
            padding: 1,
            align: 'left'
        })));
    }
    if (err instanceof utils.errors.YupValidationError) {
        const message = [];
        const size = err.details.errors.length;
        for (const error of err.details.errors){
            // No need to repeat the error message as it's the same as the err.message
            if (size === 1) {
                message.push(`  value: ${error.value}`);
                continue;
            }
            message.push([
                `  [${error.name}]`,
                `    message: ${error.message}`,
                `      value: ${error.value}`
            ].join('\n'));
        }
        console.log(chalk.red(boxen([
            'Details:',
            message.join('\n\n')
        ].join('\n'), {
            padding: 1,
            align: 'left'
        })));
    }
    process.exit(1);
};

const validatePackageHasStrapi = (pkg)=>'strapi' in pkg && typeof pkg.strapi === 'object' && !Array.isArray(pkg.strapi) && pkg.strapi !== null;
const validatePackageIsPlugin = (pkg)=>validatePackageHasStrapi(pkg) && pkg.strapi.kind === 'plugin';
const getEnabledPlugins = async ({ cwd, logger, runtimeDir, strapi })=>{
    const plugins = {};
    /**
   * This is the list of dependencies that are installed in the user's project.
   * It will include libraries like "react", so we need to collect the ones that
   * are plugins.
   */ const deps = strapi.config.get('info.dependencies', {});
    logger.debug("Dependencies from user's project", os.EOL, deps);
    for (const dep of Object.keys(deps)){
        const pkg = await getModule(dep, cwd);
        if (pkg && validatePackageIsPlugin(pkg)) {
            const name = pkg.strapi.name || pkg.name;
            if (!name) {
                /**
         * Unlikely to happen, but you never know.
         */ throw Error("You're trying to import a plugin that doesn't have a name – check the package.json of that plugin!");
            }
            plugins[name] = {
                name,
                importName: camelCase(name),
                type: 'module',
                modulePath: dep
            };
        }
    }
    const userPluginsFile = await loadUserPluginsFile(strapi.dirs.app.config);
    logger.debug("User's plugins file", os.EOL, userPluginsFile);
    for (const [userPluginName, userPluginConfig] of Object.entries(userPluginsFile)){
        if (userPluginConfig.enabled && userPluginConfig.resolve) {
            const sysPath = convertModulePathToSystemPath(userPluginConfig.resolve);
            plugins[userPluginName] = {
                name: userPluginName,
                importName: camelCase(userPluginName),
                type: 'local',
                /**
         * User plugin paths are resolved from the entry point
         * of the app, because that's how you import them.
         */ modulePath: convertSystemPathToModulePath(path$1.relative(runtimeDir, sysPath)),
                path: sysPath
            };
        }
    }
    return plugins;
};
const PLUGIN_CONFIGS = [
    'plugins.js',
    'plugins.mjs',
    'plugins.ts'
];
const loadUserPluginsFile = async (root)=>{
    for (const file of PLUGIN_CONFIGS){
        const filePath = path$1.join(root, file);
        const configFile = await loadFile(filePath);
        if (configFile) {
            /**
       * Configs can be a function or they can be just an object!
       */ return typeof configFile === 'function' ? configFile({
                env: utils.env
            }) : configFile;
        }
    }
    return {};
};
const getMapOfPluginsWithAdmin = (plugins)=>{
    /**
   * This variable stores the import paths for plugins.
   * The keys are the module paths of the plugins, and the values are the paths
   * to the admin part of the plugins, which is either loaded from the
   * package.json exports or from the legacy strapi-admin.js file.
   */ const pluginImportPaths = {};
    return Object.values(plugins).filter((plugin)=>{
        if (!plugin) {
            return false;
        }
        /**
       * There are two ways a plugin should be imported, either it's local to the strapi app,
       * or it's an actual npm module that's installed and resolved via node_modules.
       *
       * We first check if the plugin is local to the strapi app, using a regular `fs.existsSync` because
       * the pathToPlugin will be relative i.e. `/Users/my-name/strapi-app/src/plugins/my-plugin`.
       *
       * If the file doesn't exist well then it's probably a node_module, so instead we use `require.resolve`
       * which will resolve the path to the module in node_modules. If it fails with the specific code `MODULE_NOT_FOUND`
       * then it doesn't have an admin part to the package.
       */ try {
            const localPluginPath = plugin.path;
            if (localPluginPath) {
                // Here we are loading a locally installed plugin
                const packageJsonPath = path$1.join(localPluginPath, 'package.json');
                if (fs$2.existsSync(packageJsonPath)) {
                    const packageJson = JSON.parse(fs$2.readFileSync(packageJsonPath, 'utf-8'));
                    const localAdminPath = packageJson?.exports?.['./strapi-admin']?.import;
                    if (localAdminPath) {
                        pluginImportPaths[plugin.modulePath] = localAdminPath;
                        return true;
                    }
                }
                // Check if legacy admin file exists in local plugin
                if (fs$2.existsSync(path$1.join(localPluginPath, 'strapi-admin.js'))) {
                    pluginImportPaths[plugin.modulePath] = 'strapi-admin';
                    return true;
                }
            }
            // This plugin is a module, so we need to check if it has a strapi-admin export
            if (require.resolve(`${plugin.modulePath}/strapi-admin`)) {
                pluginImportPaths[plugin.modulePath] = 'strapi-admin';
                return true;
            }
            return false;
        } catch (err) {
            if (isError(err) && 'code' in err && (err.code === 'MODULE_NOT_FOUND' || err.code === 'ERR_PACKAGE_PATH_NOT_EXPORTED')) {
                /**
           * the plugin does not contain FE code, so we
           * don't want to import it anyway
           */ return false;
            }
            throw err;
        }
    }).map((plugin)=>({
            ...plugin,
            modulePath: `${plugin.modulePath}/${pluginImportPaths[plugin.modulePath]}`
        }));
};

const ADMIN_APP_FILES = [
    'app.js',
    'app.mjs',
    'app.ts',
    'app.jsx',
    'app.tsx'
];
const loadUserAppFile = async ({ runtimeDir, appDir })=>{
    for (const file of ADMIN_APP_FILES){
        const filePath = path$1.join(appDir, 'src', 'admin', file);
        if (await pathExists(filePath)) {
            return {
                path: filePath,
                modulePath: convertSystemPathToModulePath(path$1.relative(runtimeDir, filePath))
            };
        }
    }
    return undefined;
};

const DEFAULT_BROWSERSLIST = [
    'last 3 major versions',
    'Firefox ESR',
    'last 2 Opera versions',
    'not dead'
];
const createBuildContext = async ({ cwd, logger, tsconfig, strapi, options = {} })=>{
    /**
   * If you make a new strapi instance when one already exists,
   * you will overwrite the global and the app will _most likely_
   * crash and die.
   */ const strapiInstance = strapi ?? core.createStrapi({
        // Directories
        appDir: cwd,
        distDir: tsconfig?.config.options.outDir ?? '',
        // Options
        autoReload: true,
        serveAdminPanel: false
    });
    const serverAbsoluteUrl = strapiInstance.config.get('server.absoluteUrl');
    const adminAbsoluteUrl = strapiInstance.config.get('admin.absoluteUrl');
    const adminPath = strapiInstance.config.get('admin.path');
    // NOTE: Checks that both the server and admin will be served from the same origin (protocol, host, port)
    const sameOrigin = new URL(adminAbsoluteUrl).origin === new URL(serverAbsoluteUrl).origin;
    const adminPublicPath = new URL(adminAbsoluteUrl).pathname;
    const serverPublicPath = new URL(serverAbsoluteUrl).pathname;
    const appDir = strapiInstance.dirs.app.root;
    await loadEnv(cwd);
    const env = getStrapiAdminEnvVars({
        ADMIN_PATH: adminPublicPath,
        STRAPI_ADMIN_BACKEND_URL: sameOrigin ? serverPublicPath : serverAbsoluteUrl,
        STRAPI_TELEMETRY_DISABLED: String(strapiInstance.telemetry.isDisabled)
    });
    const envKeys = Object.keys(env);
    if (envKeys.length > 0) {
        logger.info([
            'Including the following ENV variables as part of the JS bundle:',
            ...envKeys.map((key)=>`    - ${key}`)
        ].join(os.EOL));
    }
    const distPath = path$1.join(strapiInstance.dirs.dist.root, 'build');
    const distDir = path$1.relative(cwd, distPath);
    /**
   * If the distPath already exists, clean it
   */ try {
        logger.debug(`Cleaning dist folder: ${distPath}`);
        await fs$1.rm(distPath, {
            recursive: true,
            force: true
        });
        logger.debug('Cleaned dist folder');
    } catch  {
        // do nothing, it will fail if the folder does not exist
        logger.debug('There was no dist folder to clean');
    }
    const runtimeDir = path$1.join(cwd, '.strapi', 'client');
    const entry = path$1.relative(cwd, path$1.join(runtimeDir, 'app.js'));
    const plugins = await getEnabledPlugins({
        cwd,
        logger,
        runtimeDir,
        strapi: strapiInstance
    });
    logger.debug('Enabled plugins', os.EOL, plugins);
    const pluginsWithFront = getMapOfPluginsWithAdmin(plugins);
    logger.debug('Enabled plugins with FE', os.EOL, pluginsWithFront);
    const target = browserslist.loadConfig({
        path: cwd
    }) ?? DEFAULT_BROWSERSLIST;
    const customisations = await loadUserAppFile({
        appDir,
        runtimeDir
    });
    const features = strapiInstance.config.get('features', undefined);
    const { bundler = 'vite', ...restOptions } = options;
    const buildContext = {
        appDir,
        adminPath,
        basePath: adminPublicPath,
        bundler,
        customisations,
        cwd,
        distDir,
        distPath,
        entry,
        env,
        features,
        logger,
        options: restOptions,
        plugins: pluginsWithFront,
        runtimeDir,
        strapi: strapiInstance,
        target,
        tsconfig
    };
    return buildContext;
};

const getEntryModule = (ctx)=>{
    const pluginsObject = ctx.plugins.map(({ name, importName })=>`'${name}': ${importName}`).join(',\n');
    const pluginsImport = ctx.plugins.map(({ importName, modulePath })=>`import ${importName} from '${modulePath}';`).join('\n');
    return outdent`
        /**
         * This file was automatically generated by Strapi.
         * Any modifications made will be discarded.
         */
        ${pluginsImport}
        import { renderAdmin } from "@strapi/strapi/admin"

        ${ctx.customisations?.modulePath ? `import customisations from '${ctx.customisations.modulePath}'` : ''}

        renderAdmin(
          document.getElementById("strapi"),
          {
            ${ctx.customisations?.modulePath ? 'customisations,' : ''}
            ${ctx.features ? `features: ${JSON.stringify(ctx.features)},` : ''}
            plugins: {
        ${pluginsObject}
            }
        })
      `;
};
/**
 * TODO: Here in the future we could add the ability
 * to load a user's Document component?
 */ const getDocumentHTML = ({ logger, props = {} })=>{
    const result = server.renderToStaticMarkup(react.createElement(_internal.DefaultDocument, props));
    logger.debug('Rendered the HTML');
    return outdent`<!DOCTYPE html>${result}`;
};
const AUTO_GENERATED_WARNING = `
This file was automatically generated by Strapi.
Any modifications made will be discarded.
`.trim();
/**
 * Because we now auto-generate the index.html file,
 * we should be clear that people _should not_ modify it.
 *
 * @internal
 */ const decorateHTMLWithAutoGeneratedWarning = (htmlTemplate)=>htmlTemplate.replace(/<head/, `\n<!--\n${AUTO_GENERATED_WARNING}\n-->\n<head`);
const writeStaticClientFiles = async (ctx)=>{
    const prettier = await import('prettier'); // ESM-only
    /**
   * For everything to work effectively we create a client folder in `.strapi` at the cwd level.
   * We then use the function we need to "createAdmin" as well as generate the Document index.html as well.
   *
   * All this links together an imaginary "src/index" that then allows vite to correctly build the admin panel.
   */ await fs$1.mkdir(ctx.runtimeDir, {
        recursive: true
    });
    ctx.logger.debug('Created the runtime directory');
    const indexHtml = decorateHTMLWithAutoGeneratedWarning(await getDocumentHTML({
        logger: ctx.logger,
        props: ctx.bundler === 'vite' ? {
            entryPath: `/${ctx.entry}`
        } : undefined
    }));
    await fs$1.writeFile(path$1.join(ctx.runtimeDir, 'index.html'), await prettier.format(indexHtml, {
        parser: 'html'
    }));
    ctx.logger.debug('Wrote the index.html file');
    await fs$1.writeFile(path$1.join(ctx.runtimeDir, 'app.js'), await prettier.format(getEntryModule(ctx), {
        parser: 'babel'
    }));
    ctx.logger.debug('Wrote the app.js file');
};

/**
 * @example `$ strapi build`
 *
 * @description Builds the admin panel of the strapi application.
 */ const build = async ({ logger, cwd, tsconfig, ...options })=>{
    const timer = getTimer();
    const { didInstall } = await checkRequiredDependencies({
        cwd,
        logger
    }).catch((err)=>{
        logger.error(err.message);
        process.exit(1);
    });
    if (didInstall) {
        return;
    }
    if (tsconfig?.config) {
        timer.start('compilingTS');
        const compilingTsSpinner = logger.spinner(`Compiling TS`).start();
        tsUtils__namespace.compile(cwd, {
            configOptions: {
                ignoreDiagnostics: false
            }
        });
        const compilingDuration = timer.end('compilingTS');
        compilingTsSpinner.text = `Compiling TS (${prettyTime(compilingDuration)})`;
        compilingTsSpinner.succeed();
    }
    timer.start('createBuildContext');
    const contextSpinner = logger.spinner(`Building build context`).start();
    console.log('');
    const ctx = await createBuildContext({
        cwd,
        logger,
        tsconfig,
        options
    });
    const contextDuration = timer.end('createBuildContext');
    contextSpinner.text = `Building build context (${prettyTime(contextDuration)})`;
    contextSpinner.succeed();
    timer.start('buildAdmin');
    const buildingSpinner = logger.spinner(`Building admin panel`).start();
    console.log('');
    try {
        await writeStaticClientFiles(ctx);
        if (ctx.bundler === 'webpack') {
            const { build: buildWebpack } = await Promise.resolve().then(function () { return require('./build-DFPOG3E7.js'); });
            await buildWebpack(ctx);
        } else if (ctx.bundler === 'vite') {
            const { build: buildVite } = await Promise.resolve().then(function () { return require('./build-e7nocMvN.js'); });
            await buildVite(ctx);
        }
        const buildDuration = timer.end('buildAdmin');
        buildingSpinner.text = `Building admin panel (${prettyTime(buildDuration)})`;
        buildingSpinner.succeed();
    } catch (err) {
        buildingSpinner.fail();
        throw err;
    }
};

const action$7 = async (options)=>{
    try {
        if (options.bundler === 'webpack') {
            options.logger.warn('[@strapi/strapi]: Using webpack as a bundler is deprecated. You should migrate to vite.');
        }
        await build(options);
    } catch (err) {
        handleUnexpectedError(err);
    }
};
/**
 * `$ strapi build`
 */ const command$9 = ({ ctx })=>{
    return commander.createCommand('build').option('--bundler [bundler]', 'Bundler to use (webpack or vite)', 'vite').option('-d, --debug', 'Enable debugging mode with verbose logs', false).option('--minify', 'Minify the output', true).option('--silent', "Don't log anything", false).option('--sourcemap', 'Produce sourcemaps', false).option('--stats', 'Print build statistics to the console', false).description('Build the strapi admin app').action(async (options)=>{
        return action$7({
            ...options,
            ...ctx
        });
    });
};

const action$6 = async ()=>{
    const appContext = await core.compileStrapi();
    const app = await core.createStrapi(appContext).load();
    app.start().then(()=>{
        const repl = REPL.start(app.config.info.name + ' > ' || 'strapi > '); // eslint-disable-line prefer-template
        repl.on('exit', (err)=>{
            if (err) {
                app.log.error(err);
                process.exit(1);
            }
            app.server.destroy();
            process.exit(0);
        });
    });
};
/**
 * `$ strapi console`
 */ const command$8 = ()=>{
    return commander.createCommand('console').description('Open the Strapi framework console').action(runAction('console', action$6));
};

// This method removes all non-admin build files from the dist directory
const cleanupDistDirectory = async ({ tsconfig, logger, timer })=>{
    const distDir = tsconfig?.config?.options?.outDir;
    if (!distDir || // we don't have a dist dir
    await fs$1.access(distDir).then(()=>false).catch(()=>true) // it doesn't exist -- if it does but no access, that will be caught later
    ) {
        return;
    }
    const timerName = `cleaningDist${Date.now()}`;
    timer.start(timerName);
    const cleaningSpinner = logger.spinner(`Cleaning dist dir ${distDir}`).start();
    try {
        const dirContent = await fs$1.readdir(distDir);
        const validFilenames = dirContent// Ignore the admin build folder
        .filter((filename)=>filename !== 'build');
        for (const filename of validFilenames){
            await fs$1.rm(path$1.resolve(distDir, filename), {
                recursive: true
            });
        }
    } catch (err) {
        const generatingDuration = timer.end(timerName);
        cleaningSpinner.text = `Error cleaning dist dir: ${err} (${prettyTime(generatingDuration)})`;
        cleaningSpinner?.fail();
        return;
    }
    const generatingDuration = timer.end(timerName);
    cleaningSpinner.text = `Cleaning dist dir (${prettyTime(generatingDuration)})`;
    cleaningSpinner?.succeed();
};
const develop = async ({ cwd, polling, logger, tsconfig, watchAdmin, ...options })=>{
    const timer = getTimer();
    if (cluster.isPrimary) {
        const { didInstall } = await checkRequiredDependencies({
            cwd,
            logger
        }).catch((err)=>{
            logger.error(err.message);
            process.exit(1);
        });
        if (didInstall) {
            return;
        }
        if (tsconfig?.config) {
            // Build without diagnostics in case schemas have changed
            await cleanupDistDirectory({
                tsconfig,
                logger,
                timer
            });
            await tsUtils__namespace.compile(cwd, {
                configOptions: {
                    ignoreDiagnostics: true
                }
            });
        }
        /**
     * IF we're not watching the admin we're going to build it, this makes
     * sure that at least the admin is built for users & they can interact
     * with the application.
     */ if (!watchAdmin) {
            timer.start('createBuildContext');
            const contextSpinner = logger.spinner(`Building build context`).start();
            console.log('');
            const ctx = await createBuildContext({
                cwd,
                logger,
                tsconfig,
                options
            });
            const contextDuration = timer.end('createBuildContext');
            contextSpinner.text = `Building build context (${prettyTime(contextDuration)})`;
            contextSpinner.succeed();
            timer.start('creatingAdmin');
            const adminSpinner = logger.spinner(`Creating admin`).start();
            await writeStaticClientFiles(ctx);
            if (ctx.bundler === 'webpack') {
                const { build: buildWebpack } = await Promise.resolve().then(function () { return require('./build-DFPOG3E7.js'); });
                await buildWebpack(ctx);
            } else if (ctx.bundler === 'vite') {
                const { build: buildVite } = await Promise.resolve().then(function () { return require('./build-e7nocMvN.js'); });
                await buildVite(ctx);
            }
            const adminDuration = timer.end('creatingAdmin');
            adminSpinner.text = `Creating admin (${prettyTime(adminDuration)})`;
            adminSpinner.succeed();
        }
        cluster.on('message', async (worker, message)=>{
            switch(message){
                case 'reload':
                    {
                        if (tsconfig?.config) {
                            // Build without diagnostics in case schemas have changed
                            await cleanupDistDirectory({
                                tsconfig,
                                logger,
                                timer
                            });
                            await tsUtils__namespace.compile(cwd, {
                                configOptions: {
                                    ignoreDiagnostics: true
                                }
                            });
                        }
                        logger.debug('cluster has the reload message, sending the worker kill message');
                        worker.send('kill');
                        break;
                    }
                case 'killed':
                    {
                        logger.debug('cluster has the killed message, forking the cluster');
                        cluster.fork();
                        break;
                    }
                case 'stop':
                    {
                        process.exit(1);
                        break;
                    }
            }
        });
        cluster.fork();
    }
    if (cluster.isWorker) {
        timer.start('loadStrapi');
        const loadStrapiSpinner = logger.spinner(`Loading Strapi`).start();
        const strapi = core.createStrapi({
            appDir: cwd,
            distDir: tsconfig?.config.options.outDir ?? '',
            autoReload: true,
            serveAdminPanel: !watchAdmin
        });
        /**
     * If we're watching the admin panel then we're going to attach the watcher
     * as a strapi middleware.
     */ let bundleWatcher;
        const strapiInstance = await strapi.load();
        if (watchAdmin) {
            timer.start('createBuildContext');
            const contextSpinner = logger.spinner(`Building build context`).start();
            console.log('');
            const ctx = await createBuildContext({
                cwd,
                logger,
                strapi,
                tsconfig,
                options
            });
            const contextDuration = timer.end('createBuildContext');
            contextSpinner.text = `Building build context (${prettyTime(contextDuration)})`;
            contextSpinner.succeed();
            timer.start('creatingAdmin');
            const adminSpinner = logger.spinner(`Creating admin`).start();
            await writeStaticClientFiles(ctx);
            if (ctx.bundler === 'webpack') {
                const { watch: watchWebpack } = await Promise.resolve().then(function () { return require('./watch-BTCIrOOP.js'); });
                bundleWatcher = await watchWebpack(ctx);
            } else if (ctx.bundler === 'vite') {
                const { watch: watchVite } = await Promise.resolve().then(function () { return require('./watch-C9i-YTFi.js'); });
                bundleWatcher = await watchVite(ctx);
            }
            const adminDuration = timer.end('creatingAdmin');
            adminSpinner.text = `Creating admin (${prettyTime(adminDuration)})`;
            adminSpinner.succeed();
        }
        const loadStrapiDuration = timer.end('loadStrapi');
        loadStrapiSpinner.text = `Loading Strapi (${prettyTime(loadStrapiDuration)})`;
        loadStrapiSpinner.succeed();
        // For TS projects, type generation is a requirement for the develop command so that the server can restart
        // For JS projects, we respect the experimental autogenerate setting
        if (tsconfig?.config || strapi.config.get('typescript.autogenerate') !== false) {
            timer.start('generatingTS');
            const generatingTsSpinner = logger.spinner(`Generating types`).start();
            await tsUtils__namespace.generators.generate({
                strapi: strapiInstance,
                pwd: cwd,
                rootDir: undefined,
                logger: {
                    silent: true,
                    debug: false
                },
                artifacts: {
                    contentTypes: true,
                    components: true
                }
            });
            const generatingDuration = timer.end('generatingTS');
            generatingTsSpinner.text = `Generating types (${prettyTime(generatingDuration)})`;
            generatingTsSpinner.succeed();
        }
        if (tsconfig?.config) {
            timer.start('compilingTS');
            const compilingTsSpinner = logger.spinner(`Compiling TS`).start();
            await cleanupDistDirectory({
                tsconfig,
                logger,
                timer
            });
            await tsUtils__namespace.compile(cwd, {
                configOptions: {
                    ignoreDiagnostics: false
                }
            });
            const compilingDuration = timer.end('compilingTS');
            compilingTsSpinner.text = `Compiling TS (${prettyTime(compilingDuration)})`;
            compilingTsSpinner.succeed();
        }
        const restart = async ()=>{
            if (strapiInstance.reload.isWatching && !strapiInstance.reload.isReloading) {
                strapiInstance.reload.isReloading = true;
                strapiInstance.reload();
            }
        };
        const watcher = chokidar.watch(cwd, {
            ignoreInitial: true,
            usePolling: polling,
            ignored: [
                /(^|[/\\])\../,
                /tmp/,
                '**/src/admin/**',
                '**/src/plugins/**/admin/**',
                '**/dist/src/plugins/test/admin/**',
                '**/documentation',
                '**/documentation/**',
                '**/node_modules',
                '**/node_modules/**',
                '**/plugins.json',
                '**/build',
                '**/build/**',
                '**/log',
                '**/log/**',
                '**/logs',
                '**/logs/**',
                '**/*.log',
                '**/index.html',
                '**/public',
                '**/public/**',
                strapiInstance.dirs.static.public,
                utils.strings.joinBy('/', strapiInstance.dirs.static.public, '**'),
                '**/*.db*',
                '**/exports/**',
                '**/dist/**',
                '**/*.d.ts',
                '**/.yalc/**',
                '**/yalc.lock',
                // TODO v6: watch only src folder by default, and flip this to watchIncludeFiles
                ...strapiInstance.config.get('admin.watchIgnoreFiles', [])
            ]
        }).on('add', (path)=>{
            strapiInstance.log.info(`File created: ${path}`);
            restart();
        }).on('change', (path)=>{
            strapiInstance.log.info(`File changed: ${path}`);
            restart();
        }).on('unlink', (path)=>{
            strapiInstance.log.info(`File deleted: ${path}`);
            restart();
        });
        process.on('message', async (message)=>{
            switch(message){
                case 'kill':
                    {
                        logger.debug('child process has the kill message, destroying the strapi instance and sending the killed process message');
                        await watcher.close();
                        await strapiInstance.destroy();
                        if (bundleWatcher) {
                            bundleWatcher.close();
                        }
                        process.send?.('killed');
                        break;
                    }
            }
        });
        strapiInstance.start();
    }
};

const action$5 = async (options)=>{
    try {
        if (cluster.isPrimary) {
            if (options.bundler === 'webpack') {
                options.logger.warn('[@strapi/strapi]: Using webpack as a bundler is deprecated. You should migrate to vite.');
            }
        }
        await develop(options);
    } catch (err) {
        handleUnexpectedError(err);
    }
};
/**
 * `$ strapi develop`
 */ const command$7 = ({ ctx })=>{
    return commander.createCommand('develop').alias('dev').option('--bundler [bundler]', 'Bundler to use (webpack or vite)', 'vite').option('-d, --debug', 'Enable debugging mode with verbose logs', false).option('--silent', "Don't log anything", false).option('--polling', 'Watch for file changes in network directories', false).option('--watch-admin', 'Watch the admin panel for hot changes', true).option('--no-watch-admin', 'Do not watch the admin panel for hot changes').option('--open', 'Open the admin in your browser', true).description('Start your Strapi application in development mode').action(async (options)=>{
        return action$5({
            ...options,
            ...ctx
        });
    });
};

/**
 * `$ strapi generate`
 */ const command$6 = ({ argv })=>{
    return commander.createCommand('generate').description('Launch the interactive API generator').action(()=>{
        assertCwdContainsStrapiProject('generate');
        argv.splice(2, 1);
        // NOTE: this needs to be lazy loaded in order for plop to work correctly
        import('@strapi/generators').then((gen)=>gen.runCLI());
    });
};

const action$4 = async ({ uuid, dependencies, all })=>{
    const config = {
        reportUUID: Boolean(all || uuid),
        reportDependencies: Boolean(all || dependencies)
    };
    const appContext = await core.compileStrapi();
    const app = await core.createStrapi(appContext).register();
    let debugInfo = `Launched In: ${Date.now() - app.config.launchedAt} ms
Environment: ${app.config.environment}
OS: ${process.platform}-${process.arch}
Strapi Version: ${app.config.info.strapi}
Node/Yarn Version: ${process.env.npm_config_user_agent}
Edition: ${app.EE ? 'Enterprise' : 'Community'}
Database: ${app?.config?.database?.connection?.client ?? 'unknown'}`;
    if (config.reportUUID) {
        debugInfo += `${os$1.EOL}UUID: ${app.config.uuid}`;
    }
    if (config.reportDependencies) {
        debugInfo += `${os$1.EOL}Dependencies: ${JSON.stringify(app.config.info.dependencies, null, 2)}
Dev Dependencies: ${JSON.stringify(app.config.info.devDependencies, null, 2)}`;
    }
    console.log(debugInfo);
    await app.destroy();
};
/**
 * `$ strapi report`
 */ const command$5 = ()=>{
    return commander.createCommand('report').description('Get system stats for debugging and submitting issues').option('-u, --uuid', 'Include Project UUID').option('-d, --dependencies', 'Include Project Dependencies').option('--all', 'Include All Information').action(runAction('report', action$4));
};

const action$3 = async ()=>{
    const appDir = process.cwd();
    const isTSProject = await tsUtils.isUsingTypeScript(appDir);
    const outDir = await tsUtils.resolveOutDir(appDir);
    const distDir = isTSProject ? outDir : appDir;
    const buildDirExists = fs.existsSync(outDir);
    if (isTSProject && !buildDirExists) throw new Error(`${outDir} directory not found. Please run the build command before starting your application`);
    core.createStrapi({
        appDir,
        distDir
    }).start();
};
/**
 * `$ strapi start`
 */ const command$4 = ()=>{
    return commander.createCommand('start').description('Start your Strapi application').action(runAction('start', action$3));
};

var version = "5.11.1";

/**
 * `$ strapi version`
 */ const command$3 = ()=>{
    // load the Strapi package.json to get version and other information
    return commander.createCommand('version').description('Output the version of Strapi').action(()=>{
        process.stdout.write(`${version}\n`);
        process.exit(0);
    });
};

/**
 * argParser: Parse a comma-delimited string as an array
 */ const parseList = (value)=>{
    try {
        return value.split(',').map((item)=>item.trim()); // trim shouldn't be necessary but might help catch unexpected whitespace characters
    } catch (e) {
        exitWith(1, `Unrecognized input: ${value}`);
    }
    return [];
};
/**
 * Returns an argParser that returns a list
 */ const getParseListWithChoices = (choices, errorMessage = 'Invalid options:')=>{
    return (value)=>{
        const list = parseList(value);
        const invalid = list.filter((item)=>{
            return !choices.includes(item);
        });
        if (invalid.length > 0) {
            exitWith(1, `${errorMessage}: ${invalid.join(',')}`);
        }
        return list;
    };
};
/**
 * argParser: Parse a string as an integer
 */ const parseInteger = (value)=>{
    // parseInt takes a string and a radix
    const parsedValue = parseInt(value, 10);
    if (fp.isNaN(parsedValue)) {
        throw new commander.InvalidOptionArgumentError(`Not an integer: ${value}`);
    }
    return parsedValue;
};
/**
 * argParser: Parse a string as a URL object
 */ const parseURL = (value)=>{
    try {
        const url = new URL(value);
        if (!url.host) {
            throw new commander.InvalidOptionArgumentError(`Could not parse url ${value}`);
        }
        return url;
    } catch (e) {
        throw new commander.InvalidOptionArgumentError(`Could not parse url ${value}`);
    }
};
/**
 * hook: if encrypt==true and key not provided, prompt for it
 */ const promptEncryptionKey = async (thisCommand)=>{
    const opts = thisCommand.opts();
    if (!opts.encrypt && opts.key) {
        return exitWith(1, 'Key may not be present unless encryption is used');
    }
    // if encrypt==true but we have no key, prompt for it
    if (opts.encrypt && !(opts.key && opts.key.length > 0)) {
        try {
            const answers = await inquirer.prompt([
                {
                    type: 'password',
                    message: 'Please enter an encryption key',
                    name: 'key',
                    validate (key) {
                        if (key.length > 0) return true;
                        return 'Key must be present when using the encrypt option';
                    }
                }
            ]);
            opts.key = answers.key;
        } catch (e) {
            return exitWith(1, 'Failed to get encryption key');
        }
        if (!opts.key) {
            return exitWith(1, 'Failed to get encryption key');
        }
    }
};
/**
 * hook: require a confirmation message to be accepted unless forceOption (-f,--force) is used
 */ const getCommanderConfirmMessage = (message, { failMessage } = {})=>{
    return async (command)=>{
        const confirmed = await confirmMessage(message, {
            force: command.opts().force
        });
        if (!confirmed) {
            exitWith(1, failMessage);
        }
    };
};
const confirmMessage = async (message, { force } = {})=>{
    // if we have a force option, respond yes
    if (force === true) {
        // attempt to mimic the inquirer prompt exactly
        console.log(`${chalk.green('?')} ${chalk.bold(message)} ${chalk.cyan('Yes')}`);
        return true;
    }
    const answers = await inquirer.prompt([
        {
            type: 'confirm',
            message,
            name: `confirm`,
            default: false
        }
    ]);
    return answers.confirm;
};
const forceOption = new commander.Option('--force', `Automatically answer "yes" to all prompts, including potentially destructive requests, and run non-interactively.`);

const { errors: { TransferEngineInitializationError } } = dataTransfer.engine;
const exitMessageText = (process1, error = false)=>{
    const processCapitalized = process1[0].toUpperCase() + process1.slice(1);
    if (!error) {
        return chalk.bold(chalk.green(`${processCapitalized} process has been completed successfully!`));
    }
    return chalk.bold(chalk.red(`${processCapitalized} process failed.`));
};
const pad = (n)=>{
    return (n < 10 ? '0' : '') + String(n);
};
const yyyymmddHHMMSS = ()=>{
    const date = new Date();
    return date.getFullYear() + pad(date.getMonth() + 1) + pad(date.getDate()) + pad(date.getHours()) + pad(date.getMinutes()) + pad(date.getSeconds());
};
const getDefaultExportName = ()=>{
    return `export_${yyyymmddHHMMSS()}`;
};
const buildTransferTable = (resultData)=>{
    if (!resultData) {
        return;
    }
    // Build pretty table
    const table = new CLITable({
        head: [
            'Type',
            'Count',
            'Size'
        ].map((text)=>chalk.bold.blue(text))
    });
    let totalBytes = 0;
    let totalItems = 0;
    Object.keys(resultData).forEach((stage)=>{
        const item = resultData[stage];
        if (!item) {
            return;
        }
        table.push([
            {
                hAlign: 'left',
                content: chalk.bold(stage)
            },
            {
                hAlign: 'right',
                content: item.count
            },
            {
                hAlign: 'right',
                content: `${readableBytes(item.bytes, 1, 11)} `
            }
        ]);
        totalBytes += item.bytes;
        totalItems += item.count;
        if (item.aggregates) {
            Object.keys(item.aggregates).sort().forEach((subkey)=>{
                if (!item.aggregates) {
                    return;
                }
                const subitem = item.aggregates[subkey];
                table.push([
                    {
                        hAlign: 'left',
                        content: `-- ${chalk.bold.grey(subkey)}`
                    },
                    {
                        hAlign: 'right',
                        content: chalk.grey(subitem.count)
                    },
                    {
                        hAlign: 'right',
                        content: chalk.grey(`(${readableBytes(subitem.bytes, 1, 11)})`)
                    }
                ]);
            });
        }
    });
    table.push([
        {
            hAlign: 'left',
            content: chalk.bold.green('Total')
        },
        {
            hAlign: 'right',
            content: chalk.bold.green(totalItems)
        },
        {
            hAlign: 'right',
            content: `${chalk.bold.green(readableBytes(totalBytes, 1, 11))} `
        }
    ]);
    return table;
};
const DEFAULT_IGNORED_CONTENT_TYPES = [
    'admin::permission',
    'admin::user',
    'admin::role',
    'admin::api-token',
    'admin::api-token-permission',
    'admin::transfer-token',
    'admin::transfer-token-permission',
    'admin::audit-log',
    'plugin::content-releases.release',
    'plugin::content-releases.release-action'
];
const abortTransfer = async ({ engine, strapi: strapi1 })=>{
    try {
        await engine.abortTransfer();
        await strapi1.destroy();
    } catch (e) {
        // ignore because there's not much else we can do
        return false;
    }
    return true;
};
const setSignalHandler = async (handler, signals = [
    'SIGINT',
    'SIGTERM',
    'SIGQUIT'
])=>{
    signals.forEach((signal)=>{
        // We specifically remove ALL listeners because we have to clear the one added in Strapi bootstrap that has a process.exit
        // TODO: Ideally Strapi bootstrap would not add that listener, and then this could be more flexible and add/remove only what it needs to
        process.removeAllListeners(signal);
        process.on(signal, handler);
    });
};
const createStrapiInstance = async (opts = {})=>{
    try {
        const appContext = await core.compileStrapi();
        const app = core.createStrapi({
            ...opts,
            ...appContext
        });
        app.log.level = opts.logLevel || 'error';
        return await app.load();
    } catch (error) {
        if (error instanceof Error && 'code' in error && error.code === 'ECONNREFUSED') {
            throw new Error('Process failed. Check the database connection with your Strapi project.');
        }
        throw error;
    }
};
const transferDataTypes = Object.keys(dataTransfer.engine.TransferGroupPresets);
const throttleOption = new commander.Option('--throttle <delay after each entity>', `Add a delay in milliseconds between each transferred entity`).argParser(parseInteger).hideHelp(); // This option is not publicly documented
const excludeOption = new commander.Option('--exclude <comma-separated data types>', `Exclude data using comma-separated types. Available types: ${transferDataTypes.join(',')}`).argParser(getParseListWithChoices(transferDataTypes, 'Invalid options for "exclude"'));
const onlyOption = new commander.Option('--only <command-separated data types>', `Include only these types of data (plus schemas). Available types: ${transferDataTypes.join(',')}`).argParser(getParseListWithChoices(transferDataTypes, 'Invalid options for "only"'));
const validateExcludeOnly = (command)=>{
    const { exclude, only } = command.opts();
    if (!only || !exclude) {
        return;
    }
    const choicesInBoth = only.filter((n)=>{
        return exclude.indexOf(n) !== -1;
    });
    if (choicesInBoth.length > 0) {
        exitWith(1, `Data types may not be used in both "exclude" and "only" in the same command. Found in both: ${choicesInBoth.join(',')}`);
    }
};
const errorColors = {
    fatal: chalk.red,
    error: chalk.red,
    silly: chalk.yellow
};
const formatDiagnostic = (operation, info)=>{
    // Create log file for all incoming diagnostics
    let logger$1;
    const getLogger = ()=>{
        if (!logger$1) {
            logger$1 = logger.createLogger(logger.configs.createOutputFileConfiguration(`${operation}_${Date.now()}.log`, {
                level: 'info',
                format: logger.formats?.detailedLogs
            }));
        }
        return logger$1;
    };
    // We don't want to write a log file until there is something to be logged
    return ({ details, kind })=>{
        try {
            if (kind === 'error') {
                const { message, severity = 'fatal' } = details;
                const colorizeError = errorColors[severity];
                const errorMessage = colorizeError(`[${severity.toUpperCase()}] ${message}`);
                getLogger().error(errorMessage);
            }
            if (kind === 'info' && info) {
                const { message, params, origin } = details;
                const msg = `[${origin ?? 'transfer'}] ${message}\n${params ? JSON.stringify(params, null, 2) : ''}`;
                getLogger().info(msg);
            }
            if (kind === 'warning') {
                const { origin, message } = details;
                getLogger().warn(`(${origin ?? 'transfer'}) ${message}`);
            }
        } catch (err) {
            getLogger().error(err);
        }
    };
};
const loadersFactory = (defaultLoaders = {})=>{
    const loaders = defaultLoaders;
    const updateLoader = (stage, data)=>{
        if (!(stage in loaders)) {
            createLoader(stage);
        }
        const stageData = data[stage];
        const elapsedTime = stageData?.startTime ? (stageData?.endTime || Date.now()) - stageData.startTime : 0;
        const size = `size: ${readableBytes(stageData?.bytes ?? 0)}`;
        const elapsed = `elapsed: ${elapsedTime} ms`;
        const speed = elapsedTime > 0 ? `(${readableBytes((stageData?.bytes ?? 0) * 1000 / elapsedTime)}/s)` : '';
        loaders[stage].text = `${stage}: ${stageData?.count ?? 0} transfered (${size}) (${elapsed}) ${!stageData?.endTime ? speed : ''}`;
        return loaders[stage];
    };
    const createLoader = (stage)=>{
        Object.assign(loaders, {
            [stage]: ora()
        });
        return loaders[stage];
    };
    const getLoader = (stage)=>{
        return loaders[stage];
    };
    return {
        updateLoader,
        createLoader,
        getLoader
    };
};
/**
 * Get the telemetry data to be sent for a didDEITSProcess* event from an initialized transfer engine object
 */ const getTransferTelemetryPayload = (engine)=>{
    return {
        eventProperties: {
            source: engine?.sourceProvider?.name,
            destination: engine?.destinationProvider?.name
        }
    };
};
/**
 * Get a transfer engine schema diff handler that confirms with the user before bypassing a schema check
 */ const getDiffHandler = (engine, { force, action })=>{
    return async (context, next)=>{
        // if we abort here, we need to actually exit the process because of conflict with inquirer prompt
        setSignalHandler(async ()=>{
            await abortTransfer({
                engine,
                strapi: strapi
            });
            exitWith(1, exitMessageText(action, true));
        });
        let workflowsStatus;
        const source = 'Schema Integrity';
        Object.entries(context.diffs).forEach(([uid, diffs])=>{
            for (const diff of diffs){
                const path = [
                    uid
                ].concat(diff.path).join('.');
                const endPath = diff.path[diff.path.length - 1];
                // Catch known features
                if (uid === 'plugin::review-workflows.workflow' || uid === 'plugin::review-workflows.workflow-stage' || endPath?.startsWith('strapi_stage') || endPath?.startsWith('strapi_assignee')) {
                    workflowsStatus = diff.kind;
                } else if (diff.kind === 'added') {
                    engine.reportWarning(chalk.red(`${chalk.bold(path)} does not exist on source`), source);
                } else if (diff.kind === 'deleted') {
                    engine.reportWarning(chalk.red(`${chalk.bold(path)} does not exist on destination`), source);
                } else if (diff.kind === 'modified') {
                    engine.reportWarning(chalk.red(`${chalk.bold(path)} has a different data type`), source);
                }
            }
        });
        // output the known feature warnings
        if (workflowsStatus === 'added') {
            engine.reportWarning(chalk.red(`Review workflows feature does not exist on source`), source);
        } else if (workflowsStatus === 'deleted') {
            engine.reportWarning(chalk.red(`Review workflows feature does not exist on destination`), source);
        } else if (workflowsStatus === 'modified') {
            engine.panic(new TransferEngineInitializationError('Unresolved differences in schema [review workflows]'));
        }
        const confirmed = await confirmMessage('There are differences in schema between the source and destination, and the data listed above will be lost. Are you sure you want to continue?', {
            force
        });
        // reset handler back to normal
        setSignalHandler(()=>abortTransfer({
                engine,
                strapi: strapi
            }));
        if (confirmed) {
            context.ignoredDiffs = fp.merge(context.diffs, context.ignoredDiffs);
        }
        return next(context);
    };
};
const getAssetsBackupHandler = (engine, { force, action })=>{
    return async (context, next)=>{
        // if we abort here, we need to actually exit the process because of conflict with inquirer prompt
        setSignalHandler(async ()=>{
            await abortTransfer({
                engine,
                strapi: strapi
            });
            exitWith(1, exitMessageText(action, true));
        });
        console.warn('The backup for the assets could not be created inside the public directory. Ensure Strapi has write permissions on the public directory.');
        const confirmed = await confirmMessage('Do you want to continue without backing up your public/uploads files?', {
            force
        });
        if (confirmed) {
            context.ignore = true;
        }
        // reset handler back to normal
        setSignalHandler(()=>abortTransfer({
                engine,
                strapi: strapi
            }));
        return next(context);
    };
};
const shouldSkipStage = (opts, dataKind)=>{
    if (opts.exclude?.includes(dataKind)) {
        return true;
    }
    if (opts.only) {
        return !opts.only.includes(dataKind);
    }
    return false;
};
// Based on exclude/only from options, create the restore object to match
const parseRestoreFromOptions = (opts)=>{
    const entitiesOptions = {
        exclude: DEFAULT_IGNORED_CONTENT_TYPES,
        include: undefined
    };
    // if content is not included, send an empty array for include
    if (opts.only && !opts.only.includes('content') || opts.exclude?.includes('content')) {
        entitiesOptions.include = [];
    }
    const restoreConfig = {
        entities: entitiesOptions,
        assets: !shouldSkipStage(opts, 'files'),
        configuration: {
            webhook: !shouldSkipStage(opts, 'config'),
            coreStore: !shouldSkipStage(opts, 'config')
        }
    };
    return restoreConfig;
};

const { providers: { createLocalFileDestinationProvider } } = dataTransfer.file;
const { providers: { createLocalStrapiSourceProvider: createLocalStrapiSourceProvider$1 } } = dataTransfer.strapi;
const BYTES_IN_MB = 1024 * 1024;
/**
 * Export command.
 *
 * It transfers data from a local Strapi instance to a file
 *
 * @param {ExportCommandOptions} opts
 */ var action$2 = (async (opts)=>{
    // Validate inputs from Commander
    if (!fp.isObject(opts)) {
        exitWith(1, 'Could not parse command arguments');
    }
    const strapi = await createStrapiInstance();
    const source = createSourceProvider(strapi);
    const destination = createDestinationProvider(opts);
    const engine = dataTransfer.engine.createTransferEngine(source, destination, {
        versionStrategy: 'ignore',
        schemaStrategy: 'ignore',
        exclude: opts.exclude,
        only: opts.only,
        throttle: opts.throttle,
        transforms: {
            links: [
                {
                    filter (link) {
                        return !DEFAULT_IGNORED_CONTENT_TYPES.includes(link.left.type) && !DEFAULT_IGNORED_CONTENT_TYPES.includes(link.right.type);
                    }
                }
            ],
            entities: [
                {
                    filter (entity) {
                        return !DEFAULT_IGNORED_CONTENT_TYPES.includes(entity.type);
                    }
                }
            ]
        }
    });
    engine.diagnostics.onDiagnostic(formatDiagnostic('export', opts.verbose));
    const progress = engine.progress.stream;
    const { updateLoader } = loadersFactory();
    progress.on(`stage::start`, ({ stage, data })=>{
        updateLoader(stage, data).start();
    });
    progress.on('stage::finish', ({ stage, data })=>{
        updateLoader(stage, data).succeed();
    });
    progress.on('stage::progress', ({ stage, data })=>{
        updateLoader(stage, data);
    });
    progress.on('transfer::start', async ()=>{
        console.log(`Starting export...`);
        await strapi.telemetry.send('didDEITSProcessStart', getTransferTelemetryPayload(engine));
    });
    let results;
    let outFile;
    try {
        // Abort transfer if user interrupts process
        setSignalHandler(()=>abortTransfer({
                engine,
                strapi
            }));
        results = await engine.transfer();
        outFile = results.destination?.file?.path ?? '';
        const outFileExists = await fse.pathExists(outFile);
        if (!outFileExists) {
            throw new dataTransfer.engine.errors.TransferEngineTransferError(`Export file not created "${outFile}"`);
        }
        // Note: we need to await telemetry or else the process ends before it is sent
        await strapi.telemetry.send('didDEITSProcessFinish', getTransferTelemetryPayload(engine));
        try {
            const table = buildTransferTable(results.engine);
            console.log(table?.toString());
        } catch (e) {
            console.error('There was an error displaying the results of the transfer.');
        }
        console.log(`Export archive is in ${chalk.green(outFile)}`);
        exitWith(0, exitMessageText('export'));
    } catch  {
        await strapi.telemetry.send('didDEITSProcessFail', getTransferTelemetryPayload(engine));
        exitWith(1, exitMessageText('export', true));
    }
});
/**
 * It creates a local strapi destination provider
 */ const createSourceProvider = (strapi)=>{
    return createLocalStrapiSourceProvider$1({
        async getStrapi () {
            return strapi;
        }
    });
};
/**
 * It creates a local file destination provider based on the given options
 */ const createDestinationProvider = (opts)=>{
    const { file, compress, encrypt, key, maxSizeJsonl } = opts;
    const filepath = fp.isString(file) && file.length > 0 ? file : getDefaultExportName();
    const maxSizeJsonlInMb = fp.isFinite(fp.toNumber(maxSizeJsonl)) ? fp.toNumber(maxSizeJsonl) * BYTES_IN_MB : undefined;
    return createLocalFileDestinationProvider({
        file: {
            path: filepath,
            maxSizeJsonl: maxSizeJsonlInMb
        },
        encryption: {
            enabled: encrypt ?? false,
            key: encrypt ? key : undefined
        },
        compression: {
            enabled: compress ?? false
        }
    });
};

/**
 * `$ strapi export`
 */ const command$2 = ()=>{
    return commander.createCommand('export').description('Export data from Strapi to file').allowExcessArguments(false).addOption(new commander.Option('--no-encrypt', `Disables 'aes-128-ecb' encryption of the output file`).default(true)).addOption(new commander.Option('--no-compress', 'Disables gzip compression of output file').default(true)).addOption(new commander.Option('--verbose', 'Enable verbose logs')).addOption(new commander.Option('-k, --key <string>', 'Provide encryption key in command instead of using the prompt')).addOption(new commander.Option('-f, --file <file>', 'name to use for exported file (without extensions)')).addOption(excludeOption).addOption(onlyOption).addOption(throttleOption).hook('preAction', validateExcludeOnly).hook('preAction', promptEncryptionKey).action(action$2);
};

const { providers: { createLocalFileSourceProvider } } = dataTransfer.file;
const { providers: { createLocalStrapiDestinationProvider: createLocalStrapiDestinationProvider$1, DEFAULT_CONFLICT_STRATEGY } } = dataTransfer.strapi;
const { createTransferEngine: createTransferEngine$1, DEFAULT_VERSION_STRATEGY, DEFAULT_SCHEMA_STRATEGY } = dataTransfer.engine;
/**
 * Import command.
 *
 * It transfers data from a file to a local Strapi instance
 */ var action$1 = (async (opts)=>{
    // validate inputs from Commander
    if (!fp.isObject(opts)) {
        exitWith(1, 'Could not parse arguments');
    }
    /**
   * From strapi backup file
   */ const sourceOptions = getLocalFileSourceOptions(opts);
    const source = createLocalFileSourceProvider(sourceOptions);
    /**
   * To local Strapi instance
   */ const strapiInstance = await createStrapiInstance();
    /**
   * Configure and run the transfer engine
   */ const engineOptions = {
        versionStrategy: DEFAULT_VERSION_STRATEGY,
        schemaStrategy: DEFAULT_SCHEMA_STRATEGY,
        exclude: opts.exclude,
        only: opts.only,
        throttle: opts.throttle,
        transforms: {
            links: [
                {
                    filter (link) {
                        return !DEFAULT_IGNORED_CONTENT_TYPES.includes(link.left.type) && !DEFAULT_IGNORED_CONTENT_TYPES.includes(link.right.type);
                    }
                }
            ],
            entities: [
                {
                    filter: (entity)=>!DEFAULT_IGNORED_CONTENT_TYPES.includes(entity.type)
                }
            ]
        }
    };
    const destinationOptions = {
        async getStrapi () {
            return strapiInstance;
        },
        autoDestroy: false,
        strategy: opts.conflictStrategy || DEFAULT_CONFLICT_STRATEGY,
        restore: parseRestoreFromOptions(engineOptions)
    };
    const destination = createLocalStrapiDestinationProvider$1(destinationOptions);
    destination.onWarning = (message)=>console.warn(`\n${chalk.yellow('warn')}: ${message}`);
    const engine = createTransferEngine$1(source, destination, engineOptions);
    engine.diagnostics.onDiagnostic(formatDiagnostic('import', opts.verbose));
    const progress = engine.progress.stream;
    const { updateLoader } = loadersFactory();
    engine.onSchemaDiff(getDiffHandler(engine, {
        force: opts.force,
        action: 'import'
    }));
    progress.on(`stage::start`, ({ stage, data })=>{
        updateLoader(stage, data).start();
    });
    progress.on('stage::finish', ({ stage, data })=>{
        updateLoader(stage, data).succeed();
    });
    progress.on('stage::progress', ({ stage, data })=>{
        updateLoader(stage, data);
    });
    progress.on('transfer::start', async ()=>{
        console.log('Starting import...');
        await strapiInstance.telemetry.send('didDEITSProcessStart', getTransferTelemetryPayload(engine));
    });
    let results;
    try {
        // Abort transfer if user interrupts process
        setSignalHandler(()=>abortTransfer({
                engine,
                strapi: strapi
            }));
        results = await engine.transfer();
        try {
            const table = buildTransferTable(results.engine);
            console.log(table?.toString());
        } catch (e) {
            console.error('There was an error displaying the results of the transfer.');
        }
        // Note: we need to await telemetry or else the process ends before it is sent
        await strapiInstance.telemetry.send('didDEITSProcessFinish', getTransferTelemetryPayload(engine));
        await strapiInstance.destroy();
        exitWith(0, exitMessageText('import'));
    } catch (e) {
        await strapiInstance.telemetry.send('didDEITSProcessFail', getTransferTelemetryPayload(engine));
        exitWith(1, exitMessageText('import', true));
    }
});
/**
 * Infer local file source provider options based on a given filename
 */ const getLocalFileSourceOptions = (opts)=>{
    const options = {
        file: {
            path: opts.file ?? ''
        },
        compression: {
            enabled: !!opts.decompress
        },
        encryption: {
            enabled: !!opts.decrypt,
            key: opts.key
        }
    };
    return options;
};

/**
 * `$ strapi import`
 */ const command$1 = ()=>{
    return commander.createCommand('import').description('Import data from file to Strapi').allowExcessArguments(false).requiredOption('-f, --file <file>', 'path and filename for the Strapi export file you want to import').addOption(new commander.Option('-k, --key <string>', 'Provide encryption key in command instead of using the prompt')).addOption(new commander.Option('--verbose', 'Enable verbose logs')).addOption(forceOption).addOption(excludeOption).addOption(onlyOption).addOption(throttleOption).hook('preAction', validateExcludeOnly).hook('preAction', async (thisCommand)=>{
        const opts = thisCommand.opts();
        const ext = path.extname(String(opts.file));
        // check extension to guess if we should prompt for key
        if (ext === '.enc') {
            if (!opts.key) {
                const answers = await inquirer.prompt([
                    {
                        type: 'password',
                        message: 'Please enter your decryption key',
                        name: 'key'
                    }
                ]);
                if (!answers.key?.length) {
                    exitWith(1, 'No key entered, aborting import.');
                }
                opts.key = answers.key;
            }
        }
    })// set decrypt and decompress options based on filename
    .hook('preAction', (thisCommand)=>{
        const opts = thisCommand.opts();
        const { extname, parse } = path;
        let file = opts.file;
        if (extname(file) === '.enc') {
            file = parse(file).name; // trim the .enc extension
            thisCommand.opts().decrypt = true;
        } else {
            thisCommand.opts().decrypt = false;
        }
        if (extname(file) === '.gz') {
            file = parse(file).name; // trim the .gz extension
            thisCommand.opts().decompress = true;
        } else {
            thisCommand.opts().decompress = false;
        }
        if (extname(file) !== '.tar') {
            exitWith(1, `The file '${opts.file}' does not appear to be a valid Strapi data file. It must have an extension ending in .tar[.gz][.enc]`);
        }
    }).hook('preAction', getCommanderConfirmMessage('The import will delete your existing data! Are you sure you want to proceed?', {
        failMessage: 'Import process aborted'
    })).action(action$1);
};

const { createTransferEngine } = dataTransfer.engine;
const { providers: { createRemoteStrapiDestinationProvider, createLocalStrapiSourceProvider, createLocalStrapiDestinationProvider, createRemoteStrapiSourceProvider } } = dataTransfer.strapi;
/**
 * Transfer command.
 *
 * Transfers data between local Strapi and remote Strapi instances
 */ var action = (async (opts)=>{
    // Validate inputs from Commander
    if (!fp.isObject(opts)) {
        exitWith(1, 'Could not parse command arguments');
    }
    if (!(opts.from || opts.to) || opts.from && opts.to) {
        exitWith(1, 'Exactly one source (from) or destination (to) option must be provided');
    }
    const strapi = await createStrapiInstance();
    let source;
    let destination;
    // if no URL provided, use local Strapi
    if (!opts.from) {
        source = createLocalStrapiSourceProvider({
            getStrapi: ()=>strapi
        });
    } else {
        if (!opts.fromToken) {
            exitWith(1, 'Missing token for remote destination');
        }
        source = createRemoteStrapiSourceProvider({
            getStrapi: ()=>strapi,
            url: opts.from,
            auth: {
                type: 'token',
                token: opts.fromToken
            }
        });
    }
    // if no URL provided, use local Strapi
    if (!opts.to) {
        destination = createLocalStrapiDestinationProvider({
            getStrapi: ()=>strapi,
            strategy: 'restore',
            restore: parseRestoreFromOptions(opts)
        });
    } else {
        if (!opts.toToken) {
            exitWith(1, 'Missing token for remote destination');
        }
        destination = createRemoteStrapiDestinationProvider({
            url: opts.to,
            auth: {
                type: 'token',
                token: opts.toToken
            },
            strategy: 'restore',
            restore: parseRestoreFromOptions(opts)
        });
    }
    if (!source || !destination) {
        exitWith(1, 'Could not create providers');
    }
    const engine = createTransferEngine(source, destination, {
        versionStrategy: 'exact',
        schemaStrategy: 'strict',
        exclude: opts.exclude,
        only: opts.only,
        throttle: opts.throttle,
        transforms: {
            links: [
                {
                    filter (link) {
                        return !DEFAULT_IGNORED_CONTENT_TYPES.includes(link.left.type) && !DEFAULT_IGNORED_CONTENT_TYPES.includes(link.right.type);
                    }
                }
            ],
            entities: [
                {
                    filter (entity) {
                        return !DEFAULT_IGNORED_CONTENT_TYPES.includes(entity.type);
                    }
                }
            ]
        }
    });
    engine.diagnostics.onDiagnostic(formatDiagnostic('transfer', opts.verbose));
    const progress = engine.progress.stream;
    const { updateLoader } = loadersFactory();
    engine.onSchemaDiff(getDiffHandler(engine, {
        force: opts.force,
        action: 'transfer'
    }));
    engine.addErrorHandler('ASSETS_DIRECTORY_ERR', getAssetsBackupHandler(engine, {
        force: opts.force,
        action: 'transfer'
    }));
    progress.on(`stage::start`, ({ stage, data })=>{
        updateLoader(stage, data).start();
    });
    progress.on('stage::finish', ({ stage, data })=>{
        updateLoader(stage, data).succeed();
    });
    progress.on('stage::progress', ({ stage, data })=>{
        updateLoader(stage, data);
    });
    progress.on('stage::error', ({ stage, data })=>{
        updateLoader(stage, data).fail();
    });
    progress.on('transfer::start', async ()=>{
        console.log(`Starting transfer...`);
        await strapi.telemetry.send('didDEITSProcessStart', getTransferTelemetryPayload(engine));
    });
    let results;
    try {
        // Abort transfer if user interrupts process
        setSignalHandler(()=>abortTransfer({
                engine,
                strapi
            }));
        results = await engine.transfer();
        // Note: we need to await telemetry or else the process ends before it is sent
        await strapi.telemetry.send('didDEITSProcessFinish', getTransferTelemetryPayload(engine));
        try {
            const table = buildTransferTable(results.engine);
            console.log(table?.toString());
        } catch (e) {
            console.error('There was an error displaying the results of the transfer.');
        }
        exitWith(0, exitMessageText('transfer'));
    } catch (e) {
        await strapi.telemetry.send('didDEITSProcessFail', getTransferTelemetryPayload(engine));
        exitWith(1, exitMessageText('transfer', true));
    }
});

/**
 * `$ strapi transfer`
 */ const command = ()=>{
    return commander.createCommand('transfer').description('Transfer data from one source to another').allowExcessArguments(false).addOption(new commander.Option('--from <sourceURL>', `URL of the remote Strapi instance to get data from`).argParser(parseURL)).addOption(new commander.Option('--from-token <token>', `Transfer token for the remote Strapi source`)).addOption(new commander.Option('--to <destinationURL>', `URL of the remote Strapi instance to send data to`).argParser(parseURL)).addOption(new commander.Option('--to-token <token>', `Transfer token for the remote Strapi destination`)).addOption(new commander.Option('--verbose', 'Enable verbose logs')).addOption(forceOption).addOption(excludeOption).addOption(onlyOption).addOption(throttleOption).hook('preAction', validateExcludeOnly).hook('preAction', ifOptions((opts)=>!(opts.from || opts.to) || opts.from && opts.to, async ()=>exitWith(1, 'Exactly one remote source (from) or destination (to) option must be provided')))// If --from is used, validate the URL and token
    .hook('preAction', ifOptions((opts)=>opts.from, async (thisCommand)=>{
        assertUrlHasProtocol(thisCommand.opts().from, [
            'https:',
            'http:'
        ]);
        if (!thisCommand.opts().fromToken) {
            const answers = await inquirer.prompt([
                {
                    type: 'password',
                    message: 'Please enter your transfer token for the remote Strapi source',
                    name: 'fromToken'
                }
            ]);
            if (!answers.fromToken?.length) {
                exitWith(1, 'No token provided for remote source, aborting transfer.');
            }
            thisCommand.opts().fromToken = answers.fromToken;
        }
        await getCommanderConfirmMessage('The transfer will delete all the local Strapi assets and its database. Are you sure you want to proceed?', {
            failMessage: 'Transfer process aborted'
        })(thisCommand);
    }))// If --to is used, validate the URL, token, and confirm restore
    .hook('preAction', ifOptions((opts)=>opts.to, async (thisCommand)=>{
        assertUrlHasProtocol(thisCommand.opts().to, [
            'https:',
            'http:'
        ]);
        if (!thisCommand.opts().toToken) {
            const answers = await inquirer.prompt([
                {
                    type: 'password',
                    message: 'Please enter your transfer token for the remote Strapi destination',
                    name: 'toToken'
                }
            ]);
            if (!answers.toToken?.length) {
                exitWith(1, 'No token provided for remote destination, aborting transfer.');
            }
            thisCommand.opts().toToken = answers.toToken;
        }
        await getCommanderConfirmMessage('The transfer will delete existing data from the remote Strapi! Are you sure you want to proceed?', {
            failMessage: 'Transfer process aborted'
        })(thisCommand);
    })).action(action);
};

const commands = [
    command$p,
    command$o,
    command$n,
    command$m,
    command$l,
    command$8,
    command$k,
    command$j,
    command$6,
    command$i,
    command$h,
    command$g,
    command$5,
    command$f,
    command$e,
    command$4,
    command$d,
    command$c,
    command$b,
    command$a,
    command$3,
    command$9,
    command$7,
    command$2,
    command$1,
    command,
    /**
   * Cloud
   */ cloudCli.buildStrapiCloudCommands
];

const silentSpinner = {
    succeed () {
        return this;
    },
    fail () {
        return this;
    },
    start () {
        return this;
    },
    text: '',
    isSpinning: false
};
const silentProgressBar = {
    start () {
        return this;
    },
    stop () {
        return this;
    },
    update () {
        return this;
    }
};
const createLogger = (options = {})=>{
    const { silent = false, debug = false, timestamp = true } = options;
    const state = {
        errors: 0,
        warning: 0
    };
    return {
        get warnings () {
            return state.warning;
        },
        get errors () {
            return state.errors;
        },
        debug (...args) {
            if (silent || !debug) {
                return;
            }
            console.log(chalk.cyan(`[DEBUG]${timestamp ? `\t[${new Date().toISOString()}]` : ''}`), ...args);
        },
        info (...args) {
            if (silent) {
                return;
            }
            console.info(chalk.blue(`[INFO]${timestamp ? `\t[${new Date().toISOString()}]` : ''}`), ...args);
        },
        log (...args) {
            if (silent) {
                return;
            }
            console.info(chalk.blue(`${timestamp ? `\t[${new Date().toISOString()}]` : ''}`), ...args);
        },
        success (...args) {
            if (silent) {
                return;
            }
            console.info(chalk.green(`[SUCCESS]${timestamp ? `\t[${new Date().toISOString()}]` : ''}`), ...args);
        },
        warn (...args) {
            state.warning += 1;
            if (silent) {
                return;
            }
            console.warn(chalk.yellow(`[WARN]${timestamp ? `\t[${new Date().toISOString()}]` : ''}`), ...args);
        },
        error (...args) {
            state.errors += 1;
            if (silent) {
                return;
            }
            console.error(chalk.red(`[ERROR]${timestamp ? `\t[${new Date().toISOString()}]` : ''}`), ...args);
        },
        spinner (text) {
            if (silent) {
                return silentSpinner;
            }
            return ora(text);
        },
        progressBar (totalSize, text) {
            if (silent) {
                return silentProgressBar;
            }
            const progressBar = new cliProgress__namespace.SingleBar({
                format: `${text ? `${text} |` : ''}${chalk.green('{bar}')}| {percentage}%`,
                barCompleteChar: '\u2588',
                barIncompleteChar: '\u2591',
                hideCursor: true,
                forceRedraw: true
            });
            progressBar.start(totalSize, 0);
            return progressBar;
        }
    };
};

/**
 * @description Load a tsconfig.json file and return the parsed config.
 *
 * @internal
 */ const loadTsConfig = ({ cwd, path, logger })=>{
    const configPath = ts.findConfigFile(cwd, ts.sys.fileExists, path);
    if (!configPath) {
        return undefined;
    }
    const configFile = ts.readConfigFile(configPath, ts.sys.readFile);
    const parsedConfig = ts.parseJsonConfigFileContent(configFile.config, ts.sys, cwd);
    logger.debug(`Loaded user TS config:`, os$1.EOL, parsedConfig);
    return {
        config: parsedConfig,
        path: configPath
    };
};

const createCLI = async (argv, command = new commander.Command())=>{
    // Initial program setup
    command.storeOptionsAsProperties(false).allowUnknownOption(true);
    // Help command
    command.helpOption('-h, --help', 'Display help for command');
    command.addHelpCommand('help [command]', 'Display help for command');
    command.version(version, '-v, --version', 'Output the version number');
    const cwd = process.cwd();
    const hasDebug = argv.includes('--debug');
    const hasSilent = argv.includes('--silent');
    const logger = createLogger({
        debug: hasDebug,
        silent: hasSilent,
        timestamp: false
    });
    const tsconfig = loadTsConfig({
        cwd,
        path: 'tsconfig.json',
        logger
    });
    const ctx = {
        cwd,
        logger,
        tsconfig
    };
    // Load all commands
    for (const commandFactory of commands){
        try {
            const subCommand = await commandFactory({
                command,
                argv,
                ctx
            });
            // Add this command to the Commander command object
            if (subCommand) {
                command.addCommand(subCommand);
            }
        } catch (e) {
            console.error(`Failed to load command`, e);
        }
    }
    // TODO v6: remove these deprecation notices
    const deprecatedCommands = [
        {
            name: 'plugin:init',
            message: 'Please use `npx @strapi/sdk-plugin init` instead.'
        },
        {
            name: 'plugin:verify',
            message: 'After migrating your plugin to v5, use `strapi-plugin verify`'
        },
        {
            name: 'plugin:watch',
            message: 'After migrating your plugin to v5, use `strapi-plugin watch`'
        },
        {
            name: 'plugin:watch:link',
            message: 'After migrating your plugin to v5, use `strapi-plugin watch:link`'
        },
        {
            name: 'plugin:build',
            message: 'After migrating your plugin to v5, use `strapi-plugin build`'
        }
    ];
    // Add hidden commands for deprecatedCommands that output a warning that the command has been removed.
    deprecatedCommands.forEach(({ name, message })=>{
        const deprecated = new commander.Command(name).command(name).description('(deprecated)').action(()=>{
            console.warn(`The command ${name} has been deprecated. See the Strapi 5 migration guide for more information.`);
            if (message) {
                console.warn(message);
            }
        });
        command.addCommand(deprecated, {
            hidden: true
        });
    });
    return command;
};
const runCLI = async (argv = process.argv, command = new commander.Command())=>{
    const commands = await createCLI(argv, command);
    await commands.parseAsync(argv);
};

exports.createCLI = createCLI;
exports.getDocumentHTML = getDocumentHTML;
exports.isError = isError;
exports.loadFile = loadFile;
exports.runCLI = runCLI;
//# sourceMappingURL=index-BISxmyok.js.map
