'use strict';

var get = require('lodash/get');
var yup = require('yup');
var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var designSystem = require('@strapi/design-system');
var icons = require('@strapi/icons');
var reactIntl = require('react-intl');
var styledComponents = require('styled-components');
var query = require('@reduxjs/toolkit/query');
var strapiAdmin = require('@strapi/admin/strapi-admin');
var strapiAdmin$1 = require('@strapi/content-manager/strapi-admin');
var reactRouterDom = require('react-router-dom');
var qs = require('qs');
var omit = require('lodash/omit');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var yup__namespace = /*#__PURE__*/_interopNamespaceDefault(yup);
var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);
var qs__namespace = /*#__PURE__*/_interopNamespaceDefault(qs);

const pluginId = 'i18n';

const getTranslation = (id)=>`${pluginId}.${id}`;

const TextAlignTypography = styledComponents.styled(designSystem.Typography)`
  text-align: center;
`;
const CheckboxConfirmation = ({ description, isCreating = false, intlLabel, name, onChange, value })=>{
    const { formatMessage } = reactIntl.useIntl();
    const [isOpen, setIsOpen] = React__namespace.useState(false);
    const handleChange = (value)=>{
        if (isCreating || value) {
            return onChange({
                target: {
                    name,
                    value,
                    type: 'checkbox'
                }
            });
        }
        if (!value) {
            return setIsOpen(true);
        }
        return null;
    };
    const handleConfirm = ()=>{
        onChange({
            target: {
                name,
                value: false,
                type: 'checkbox'
            }
        });
    };
    const label = intlLabel.id ? formatMessage({
        id: intlLabel.id,
        defaultMessage: intlLabel.defaultMessage
    }, {
        ...intlLabel.values
    }) : name;
    const hint = description ? formatMessage({
        id: description.id,
        defaultMessage: description.defaultMessage
    }, {
        ...description.values
    }) : '';
    return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Dialog.Root, {
        open: isOpen,
        onOpenChange: setIsOpen,
        children: [
            /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Field.Root, {
                hint: hint,
                name: name,
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Checkbox, {
                        onCheckedChange: handleChange,
                        checked: value,
                        children: label
                    }),
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Field.Hint, {})
                ]
            }),
            /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Dialog.Content, {
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Header, {
                        children: formatMessage({
                            id: getTranslation('CheckboxConfirmation.Modal.title'),
                            defaultMessage: 'Disable localization'
                        })
                    }),
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Body, {
                        icon: /*#__PURE__*/ jsxRuntime.jsx(icons.WarningCircle, {}),
                        children: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                            direction: "column",
                            alignItems: "stretch",
                            gap: 2,
                            children: [
                                /*#__PURE__*/ jsxRuntime.jsx(designSystem.Flex, {
                                    justifyContent: "center",
                                    children: /*#__PURE__*/ jsxRuntime.jsx(TextAlignTypography, {
                                        children: formatMessage({
                                            id: getTranslation('CheckboxConfirmation.Modal.content'),
                                            defaultMessage: 'Disabling localization will engender the deletion of all your content but the one associated to your default locale (if existing).'
                                        })
                                    })
                                }),
                                /*#__PURE__*/ jsxRuntime.jsx(designSystem.Flex, {
                                    justifyContent: "center",
                                    children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                                        fontWeight: "semiBold",
                                        children: formatMessage({
                                            id: getTranslation('CheckboxConfirmation.Modal.body'),
                                            defaultMessage: 'Do you want to disable it?'
                                        })
                                    })
                                })
                            ]
                        })
                    }),
                    /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Dialog.Footer, {
                        children: [
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Cancel, {
                                children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
                                    variant: "tertiary",
                                    children: formatMessage({
                                        id: 'components.popUpWarning.button.cancel',
                                        defaultMessage: 'No, cancel'
                                    })
                                })
                            }),
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Action, {
                                children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
                                    variant: "danger-light",
                                    onClick: handleConfirm,
                                    children: formatMessage({
                                        id: getTranslation('CheckboxConfirmation.Modal.button-confirm'),
                                        defaultMessage: 'Yes, disable'
                                    })
                                })
                            })
                        ]
                    })
                ]
            })
        ]
    });
};

const LOCALIZED_FIELDS = [
    'biginteger',
    'boolean',
    'component',
    'date',
    'datetime',
    'decimal',
    'dynamiczone',
    'email',
    'enumeration',
    'float',
    'integer',
    'json',
    'media',
    'number',
    'password',
    'richtext',
    'blocks',
    'string',
    'text',
    'time'
];
const doesPluginOptionsHaveI18nLocalized = (opts)=>typeof opts === 'object' && opts !== null && 'i18n' in opts && typeof opts.i18n === 'object' && opts.i18n !== null && 'localized' in opts.i18n && typeof opts.i18n.localized === 'boolean';

const capitalize = (str)=>str.charAt(0).toUpperCase() + str.slice(1);

/**
 * @alpha
 * @description This hook is used to get the i18n status of a content type.
 * Also returns the CRUDP permission locale properties for the content type
 * so we know which locales the user can perform actions on.
 */ const useI18n = ()=>{
    // Extract the params from the URL to pass to our useDocument hook
    const params = reactRouterDom.useParams();
    const userPermissions = strapiAdmin.useAuth('useI18n', (state)=>state.permissions);
    const actions = React__namespace.useMemo(()=>{
        const permissions = userPermissions.filter((permission)=>permission.subject === params.slug);
        return permissions.reduce((acc, permission)=>{
            const [actionShorthand] = permission.action.split('.').slice(-1);
            return {
                ...acc,
                [`can${capitalize(actionShorthand)}`]: permission.properties?.locales ?? []
            };
        }, {
            canCreate: [],
            canRead: [],
            canUpdate: [],
            canDelete: [],
            canPublish: []
        });
    }, [
        params.slug,
        userPermissions
    ]);
    // TODO: use specific hook to get schema only
    const { schema } = strapiAdmin$1.unstable_useDocument({
        // We can non-null assert these because below we skip the query if they are not present
        collectionType: params.collectionType,
        model: params.slug
    }, {
        skip: true
    });
    if (doesPluginOptionsHaveI18nLocalized(schema?.pluginOptions)) {
        return {
            hasI18n: schema.pluginOptions.i18n.localized,
            ...actions
        };
    }
    return {
        hasI18n: false,
        ...actions
    };
};

const i18nApi = strapiAdmin.adminApi.enhanceEndpoints({
    addTagTypes: [
        'Locale'
    ]
});

const localesApi = i18nApi.injectEndpoints({
    endpoints: (builder)=>({
            createLocale: builder.mutation({
                query: (data)=>({
                        url: '/i18n/locales',
                        method: 'POST',
                        data
                    }),
                invalidatesTags: [
                    {
                        type: 'Locale',
                        id: 'LIST'
                    }
                ]
            }),
            deleteLocale: builder.mutation({
                query: (id)=>({
                        url: `/i18n/locales/${id}`,
                        method: 'DELETE'
                    }),
                invalidatesTags: (result, error, id)=>[
                        {
                            type: 'Locale',
                            id
                        }
                    ]
            }),
            getLocales: builder.query({
                query: ()=>'/i18n/locales',
                providesTags: (res)=>[
                        {
                            type: 'Locale',
                            id: 'LIST'
                        },
                        ...Array.isArray(res) ? res.map((locale)=>({
                                type: 'Locale',
                                id: locale.id
                            })) : []
                    ]
            }),
            getDefaultLocales: builder.query({
                query: ()=>'/i18n/iso-locales'
            }),
            updateLocale: builder.mutation({
                query: ({ id, ...data })=>({
                        url: `/i18n/locales/${id}`,
                        method: 'PUT',
                        data
                    }),
                invalidatesTags: (result, error, { id })=>[
                        {
                            type: 'Locale',
                            id
                        }
                    ]
            })
        })
});
const { useCreateLocaleMutation, useDeleteLocaleMutation, useGetLocalesQuery, useGetDefaultLocalesQuery, useUpdateLocaleMutation } = localesApi;

const relationsApi = i18nApi.injectEndpoints({
    overrideExisting: true,
    endpoints: (builder)=>({
            getManyDraftRelationCount: builder.query({
                query: ({ model, ...params })=>({
                        url: `/content-manager/collection-types/${model}/actions/countManyEntriesDraftRelations`,
                        method: 'GET',
                        config: {
                            params
                        }
                    }),
                transformResponse: (response)=>response.data
            })
        })
});
const { useGetManyDraftRelationCountQuery } = relationsApi;

const cleanData = (data, schema, components)=>{
    const cleanedData = removeFields(data, [
        'createdAt',
        'createdBy',
        'updatedAt',
        'updatedBy',
        'id',
        'documentId',
        'publishedAt',
        'strapi_stage',
        'strapi_assignee',
        'locale',
        'status'
    ]);
    const cleanedDataWithoutPasswordAndRelation = recursiveRemoveFieldTypes(cleanedData, schema, components, [
        'relation',
        'password'
    ]);
    return cleanedDataWithoutPasswordAndRelation;
};
const removeFields = (data, fields)=>{
    return Object.keys(data).reduce((acc, current)=>{
        if (fields.includes(current)) {
            return acc;
        }
        acc[current] = data[current];
        return acc;
    }, {});
};
const recursiveRemoveFieldTypes = (data, schema, components, fields)=>{
    return Object.keys(data).reduce((acc, current)=>{
        const attribute = schema.attributes[current] ?? {
            type: undefined
        };
        if (fields.includes(attribute.type)) {
            return acc;
        }
        if (attribute.type === 'dynamiczone') {
            acc[current] = data[current].map((componentValue, index)=>{
                const { id: _, ...rest } = recursiveRemoveFieldTypes(componentValue, components[componentValue.__component], components, fields);
                return {
                    ...rest,
                    __temp_key__: index + 1
                };
            });
        } else if (attribute.type === 'component') {
            const { repeatable, component } = attribute;
            if (repeatable) {
                acc[current] = (data[current] ?? []).map((compoData, index)=>{
                    const { id: _, ...rest } = recursiveRemoveFieldTypes(compoData, components[component], components, fields);
                    return {
                        ...rest,
                        __temp_key__: index + 1
                    };
                });
            } else {
                const { id: _, ...rest } = recursiveRemoveFieldTypes(data[current] ?? {}, components[component], components, fields);
                acc[current] = rest;
            }
        } else {
            acc[current] = data[current];
        }
        return acc;
    }, {});
};

const isErrorMessageDescriptor = (object)=>{
    return typeof object === 'object' && object !== null && 'id' in object && 'defaultMessage' in object;
};
const EntryValidationText = ({ status = 'draft', validationErrors, action })=>{
    const { formatMessage } = reactIntl.useIntl();
    /**
   * TODO: Should this be extracted an made into a factory to recursively get
   * error messages??
   */ const getErrorStr = (key, value)=>{
        if (typeof value === 'string') {
            return `${key}: ${value}`;
        } else if (isErrorMessageDescriptor(value)) {
            return `${key}: ${formatMessage(value)}`;
        } else if (Array.isArray(value)) {
            return value.map((v)=>getErrorStr(key, v)).join(' ');
        } else if (typeof value === 'object' && !Array.isArray(value)) {
            return Object.entries(value).map(([k, v])=>getErrorStr(k, v)).join(' ');
        } else {
            /**
       * unlikely to happen, but we need to return something
       */ return '';
        }
    };
    if (validationErrors) {
        const validationErrorsMessages = Object.entries(validationErrors).map(([key, value])=>{
            return getErrorStr(key, value);
        }).join(' ');
        return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
            gap: 2,
            children: [
                /*#__PURE__*/ jsxRuntime.jsx(icons.CrossCircle, {
                    fill: "danger600"
                }),
                /*#__PURE__*/ jsxRuntime.jsx(designSystem.Tooltip, {
                    label: validationErrorsMessages,
                    children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                        maxWidth: '30rem',
                        textColor: "danger600",
                        variant: "omega",
                        fontWeight: "semiBold",
                        ellipsis: true,
                        children: validationErrorsMessages
                    })
                })
            ]
        });
    }
    const getStatusMessage = ()=>{
        if (action === 'bulk-publish') {
            if (status === 'published') {
                return {
                    icon: /*#__PURE__*/ jsxRuntime.jsx(icons.CheckCircle, {
                        fill: "success600"
                    }),
                    text: formatMessage({
                        id: 'content-manager.bulk-publish.already-published',
                        defaultMessage: 'Already Published'
                    }),
                    textColor: 'success600',
                    fontWeight: 'bold'
                };
            } else if (status === 'modified') {
                return {
                    icon: /*#__PURE__*/ jsxRuntime.jsx(icons.ArrowsCounterClockwise, {
                        fill: "alternative600"
                    }),
                    text: formatMessage({
                        id: 'app.utils.ready-to-publish-changes',
                        defaultMessage: 'Ready to publish changes'
                    })
                };
            } else {
                return {
                    icon: /*#__PURE__*/ jsxRuntime.jsx(icons.CheckCircle, {
                        fill: "success600"
                    }),
                    text: formatMessage({
                        id: 'app.utils.ready-to-publish',
                        defaultMessage: 'Ready to publish'
                    })
                };
            }
        } else {
            if (status === 'draft') {
                return {
                    icon: /*#__PURE__*/ jsxRuntime.jsx(icons.CheckCircle, {
                        fill: "success600"
                    }),
                    text: formatMessage({
                        id: 'content-manager.bulk-unpublish.already-unpublished',
                        defaultMessage: 'Already Unpublished'
                    }),
                    textColor: 'success600',
                    fontWeight: 'bold'
                };
            } else {
                return {
                    icon: /*#__PURE__*/ jsxRuntime.jsx(icons.CheckCircle, {
                        fill: "success600"
                    }),
                    text: formatMessage({
                        id: 'app.utils.ready-to-unpublish-changes',
                        defaultMessage: 'Ready to unpublish'
                    }),
                    textColor: 'success600',
                    fontWeight: 'bold'
                };
            }
        }
    };
    const { icon, text, textColor = 'success600', fontWeight = 'normal' } = getStatusMessage();
    return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
        gap: 2,
        children: [
            icon,
            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                textColor: textColor,
                fontWeight: fontWeight,
                children: text
            })
        ]
    });
};
/* -------------------------------------------------------------------------------------------------
 * BoldChunk
 * -----------------------------------------------------------------------------------------------*/ const BoldChunk = (chunks)=>/*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
        fontWeight: "bold",
        children: chunks
    });
const BulkLocaleActionModal = ({ headers, rows, localesMetadata, validationErrors = {}, action })=>{
    const { formatMessage } = reactIntl.useIntl();
    const selectedRows = strapiAdmin.useTable('BulkLocaleActionModal', (state)=>state.selectedRows);
    const getFormattedCountMessage = ()=>{
        const currentStatusByLocale = rows.reduce((acc, { locale, status })=>{
            acc[locale] = status;
            return acc;
        }, {});
        const localesWithErrors = Object.keys(validationErrors);
        const publishedCount = selectedRows.filter(({ locale })=>currentStatusByLocale[locale] === 'published').length;
        const draftCount = selectedRows.filter(({ locale })=>(currentStatusByLocale[locale] === 'draft' || currentStatusByLocale[locale] === 'modified') && !localesWithErrors.includes(locale)).length;
        const withErrorsCount = localesWithErrors.length;
        const messageId = action === 'bulk-publish' ? 'content-manager.containers.list.selectedEntriesModal.selectedCount.publish' : 'content-manager.containers.list.selectedEntriesModal.selectedCount.unpublish';
        const defaultMessage = action === 'bulk-publish' ? '<b>{publishedCount}</b> {publishedCount, plural, =0 {entries} one {entry} other {entries}} already published. <b>{draftCount}</b> {draftCount, plural, =0 {entries} one {entry} other {entries}} ready to publish. <b>{withErrorsCount}</b> {withErrorsCount, plural, =0 {entries} one {entry} other {entries}} waiting for action.' : '<b>{draftCount}</b> {draftCount, plural, =0 {entries} one {entry} other {entries}} already unpublished. <b>{publishedCount}</b> {publishedCount, plural, =0 {entries} one {entry} other {entries}} ready to unpublish.';
        return formatMessage({
            id: messageId,
            defaultMessage
        }, {
            withErrorsCount,
            draftCount,
            publishedCount,
            b: BoldChunk
        });
    };
    return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Modal.Body, {
        children: [
            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                children: getFormattedCountMessage()
            }),
            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Box, {
                marginTop: 5,
                children: /*#__PURE__*/ jsxRuntime.jsxs(strapiAdmin.Table.Content, {
                    children: [
                        /*#__PURE__*/ jsxRuntime.jsxs(strapiAdmin.Table.Head, {
                            children: [
                                /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.HeaderCheckboxCell, {}),
                                headers.map((head)=>/*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.HeaderCell, {
                                        ...head
                                    }, head.name))
                            ]
                        }),
                        /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.Body, {
                            children: rows.map(({ locale, status }, index)=>{
                                const error = validationErrors?.[locale] ?? null;
                                const statusVariant = status === 'draft' ? 'primary' : status === 'published' ? 'success' : 'alternative';
                                return /*#__PURE__*/ jsxRuntime.jsxs(strapiAdmin.Table.Row, {
                                    children: [
                                        /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.CheckboxCell, {
                                            id: locale,
                                            "aria-label": `Select ${locale}`
                                        }),
                                        /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.Cell, {
                                            children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                                                variant: "sigma",
                                                textColor: "neutral600",
                                                children: Array.isArray(localesMetadata) ? localesMetadata.find((localeEntry)=>localeEntry.code === locale)?.name : locale
                                            })
                                        }),
                                        /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.Cell, {
                                            children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Box, {
                                                display: "flex",
                                                children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Status, {
                                                    display: "flex",
                                                    paddingLeft: "6px",
                                                    paddingRight: "6px",
                                                    paddingTop: "2px",
                                                    paddingBottom: "2px",
                                                    size: 'S',
                                                    variant: statusVariant,
                                                    children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                                                        tag: "span",
                                                        variant: "pi",
                                                        fontWeight: "bold",
                                                        children: capitalize(status)
                                                    })
                                                })
                                            })
                                        }),
                                        /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.Cell, {
                                            children: /*#__PURE__*/ jsxRuntime.jsx(EntryValidationText, {
                                                validationErrors: error,
                                                status: status,
                                                action: action
                                            })
                                        }),
                                        /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.Cell, {
                                            children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.IconButton, {
                                                tag: reactRouterDom.Link,
                                                to: {
                                                    search: qs.stringify({
                                                        plugins: {
                                                            i18n: {
                                                                locale
                                                            }
                                                        }
                                                    })
                                                },
                                                label: formatMessage({
                                                    id: getTranslation('Settings.list.actions.edit'),
                                                    defaultMessage: 'Edit {name} locale'
                                                }, {
                                                    name: locale
                                                }),
                                                variant: "ghost",
                                                children: /*#__PURE__*/ jsxRuntime.jsx(icons.Pencil, {})
                                            })
                                        })
                                    ]
                                }, index);
                            })
                        })
                    ]
                })
            })
        ]
    });
};

const statusVariants = {
    draft: 'secondary',
    published: 'success',
    modified: 'alternative'
};
const LocaleOption = ({ isDraftAndPublishEnabled, locale, status, entryExists })=>{
    const { formatMessage } = reactIntl.useIntl();
    if (!entryExists) {
        return formatMessage({
            id: getTranslation('CMEditViewLocalePicker.locale.create'),
            defaultMessage: 'Create <bold>{locale}</bold> locale'
        }, {
            bold: (locale)=>/*#__PURE__*/ jsxRuntime.jsx("b", {
                    children: locale
                }),
            locale: locale.name
        });
    }
    return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
        width: "100%",
        gap: 1,
        justifyContent: "space-between",
        children: [
            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                children: locale.name
            }),
            isDraftAndPublishEnabled ? /*#__PURE__*/ jsxRuntime.jsx(designSystem.Status, {
                display: "flex",
                paddingLeft: "6px",
                paddingRight: "6px",
                paddingTop: "2px",
                paddingBottom: "2px",
                size: "S",
                variant: statusVariants[status],
                children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                    tag: "span",
                    variant: "pi",
                    fontWeight: "bold",
                    children: capitalize(status)
                })
            }) : null
        ]
    });
};
const LocalePickerAction = ({ document, meta, model, collectionType, documentId })=>{
    const { formatMessage } = reactIntl.useIntl();
    const [{ query }, setQuery] = strapiAdmin.useQueryParams();
    const { hasI18n, canCreate, canRead } = useI18n();
    const { data: locales = [] } = useGetLocalesQuery();
    const currentDesiredLocale = query.plugins?.i18n?.locale;
    const { schema } = strapiAdmin$1.unstable_useDocument({
        model,
        collectionType,
        documentId,
        params: {
            locale: currentDesiredLocale
        }
    });
    const handleSelect = React__namespace.useCallback((value)=>{
        setQuery({
            plugins: {
                ...query.plugins,
                i18n: {
                    locale: value
                }
            }
        });
    }, [
        query.plugins,
        setQuery
    ]);
    React__namespace.useEffect(()=>{
        if (!Array.isArray(locales) || !hasI18n) {
            return;
        }
        /**
     * Handle the case where the current locale query param doesn't exist
     * in the list of available locales, so we redirect to the default locale.
     */ const doesLocaleExist = locales.find((loc)=>loc.code === currentDesiredLocale);
        const defaultLocale = locales.find((locale)=>locale.isDefault);
        if (!doesLocaleExist && defaultLocale?.code) {
            handleSelect(defaultLocale.code);
        }
    }, [
        handleSelect,
        hasI18n,
        locales,
        currentDesiredLocale
    ]);
    const currentLocale = Array.isArray(locales) ? locales.find((locale)=>locale.code === currentDesiredLocale) : undefined;
    const allCurrentLocales = [
        {
            status: getDocumentStatus(document, meta),
            locale: currentLocale?.code
        },
        ...document?.localizations ?? []
    ];
    if (!hasI18n || !Array.isArray(locales) || locales.length === 0) {
        return null;
    }
    const displayedLocales = locales.filter((locale)=>{
        /**
     * If you can read we allow you to see the locale exists
     * otherwise the locale is hidden.
     */ return canRead.includes(locale.code);
    });
    return {
        label: formatMessage({
            id: getTranslation('Settings.locales.modal.locales.label'),
            defaultMessage: 'Locales'
        }),
        options: displayedLocales.map((locale)=>{
            const entryWithLocaleExists = allCurrentLocales.some((doc)=>doc.locale === locale.code);
            const currentLocaleDoc = allCurrentLocales.find((doc)=>'locale' in doc ? doc.locale === locale.code : false);
            const permissionsToCheck = currentLocaleDoc ? canRead : canCreate;
            return {
                disabled: !permissionsToCheck.includes(locale.code),
                value: locale.code,
                label: /*#__PURE__*/ jsxRuntime.jsx(LocaleOption, {
                    isDraftAndPublishEnabled: !!schema?.options?.draftAndPublish,
                    locale: locale,
                    status: currentLocaleDoc?.status,
                    entryExists: entryWithLocaleExists
                }),
                startIcon: !entryWithLocaleExists ? /*#__PURE__*/ jsxRuntime.jsx(icons.Plus, {}) : null
            };
        }),
        customizeContent: ()=>currentLocale?.name,
        onSelect: handleSelect,
        value: currentLocale
    };
};
const getDocumentStatus = (document, meta)=>{
    const docStatus = document?.status;
    const statuses = meta?.availableStatus ?? [];
    /**
   * Creating an entry
   */ if (!docStatus) {
        return 'draft';
    }
    /**
   * We're viewing a draft, but the document could have a published version
   */ if (docStatus === 'draft' && statuses.find((doc)=>doc.publishedAt !== null)) {
        return 'published';
    }
    return docStatus;
};
/* -------------------------------------------------------------------------------------------------
 * FillFromAnotherLocaleAction
 * -----------------------------------------------------------------------------------------------*/ const FillFromAnotherLocaleAction = ({ documentId, meta, model, collectionType })=>{
    const { formatMessage } = reactIntl.useIntl();
    const [{ query }] = strapiAdmin.useQueryParams();
    const { hasI18n } = useI18n();
    const currentDesiredLocale = query.plugins?.i18n?.locale;
    const [localeSelected, setLocaleSelected] = React__namespace.useState(null);
    const setValues = strapiAdmin.useForm('FillFromAnotherLocale', (state)=>state.setValues);
    const { getDocument } = strapiAdmin$1.unstable_useDocumentActions();
    const { schema, components } = strapiAdmin$1.unstable_useDocument({
        model,
        documentId,
        collectionType,
        params: {
            locale: currentDesiredLocale
        }
    });
    const { data: locales = [] } = useGetLocalesQuery();
    const availableLocales = Array.isArray(locales) ? locales.filter((locale)=>meta?.availableLocales.some((l)=>l.locale === locale.code)) : [];
    const fillFromLocale = (onClose)=>async ()=>{
            const response = await getDocument({
                collectionType,
                model,
                documentId,
                params: {
                    locale: localeSelected
                }
            });
            if (!response || !schema) {
                return;
            }
            const { data } = response;
            const cleanedData = cleanData(data, schema, components);
            setValues(cleanedData);
            onClose();
        };
    if (!hasI18n) {
        return null;
    }
    return {
        type: 'icon',
        icon: /*#__PURE__*/ jsxRuntime.jsx(icons.Earth, {}),
        disabled: availableLocales.length === 0,
        label: formatMessage({
            id: getTranslation('CMEditViewCopyLocale.copy-text'),
            defaultMessage: 'Fill in from another locale'
        }),
        dialog: {
            type: 'dialog',
            title: formatMessage({
                id: getTranslation('CMEditViewCopyLocale.dialog.title'),
                defaultMessage: 'Confirmation'
            }),
            content: ({ onClose })=>/*#__PURE__*/ jsxRuntime.jsxs(jsxRuntime.Fragment, {
                    children: [
                        /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Body, {
                            children: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                                direction: "column",
                                gap: 3,
                                children: [
                                    /*#__PURE__*/ jsxRuntime.jsx(icons.WarningCircle, {
                                        width: "24px",
                                        height: "24px",
                                        fill: "danger600"
                                    }),
                                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                                        textAlign: "center",
                                        children: formatMessage({
                                            id: getTranslation('CMEditViewCopyLocale.dialog.body'),
                                            defaultMessage: 'Your current content will be erased and filled by the content of the selected locale:'
                                        })
                                    }),
                                    /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Field.Root, {
                                        width: "100%",
                                        children: [
                                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Field.Label, {
                                                children: formatMessage({
                                                    id: getTranslation('CMEditViewCopyLocale.dialog.field.label'),
                                                    defaultMessage: 'Locale'
                                                })
                                            }),
                                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.SingleSelect, {
                                                value: localeSelected,
                                                placeholder: formatMessage({
                                                    id: getTranslation('CMEditViewCopyLocale.dialog.field.placeholder'),
                                                    defaultMessage: 'Select one locale...'
                                                }),
                                                // @ts-expect-error â€“ the DS will handle numbers, but we're not allowing the API.
                                                onChange: (value)=>setLocaleSelected(value),
                                                children: availableLocales.map((locale)=>/*#__PURE__*/ jsxRuntime.jsx(designSystem.SingleSelectOption, {
                                                        value: locale.code,
                                                        children: locale.name
                                                    }, locale.code))
                                            })
                                        ]
                                    })
                                ]
                            })
                        }),
                        /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Footer, {
                            children: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                                gap: 2,
                                width: "100%",
                                children: [
                                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
                                        flex: "auto",
                                        variant: "tertiary",
                                        onClick: onClose,
                                        children: formatMessage({
                                            id: getTranslation('CMEditViewCopyLocale.cancel-text'),
                                            defaultMessage: 'No, cancel'
                                        })
                                    }),
                                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
                                        flex: "auto",
                                        variant: "success",
                                        onClick: fillFromLocale(onClose),
                                        children: formatMessage({
                                            id: getTranslation('CMEditViewCopyLocale.submit-text'),
                                            defaultMessage: 'Yes, fill in'
                                        })
                                    })
                                ]
                            })
                        })
                    ]
                })
        }
    };
};
/* -------------------------------------------------------------------------------------------------
 * DeleteLocaleAction
 * -----------------------------------------------------------------------------------------------*/ const DeleteLocaleAction = ({ document, documentId, model, collectionType })=>{
    const { formatMessage } = reactIntl.useIntl();
    const navigate = reactRouterDom.useNavigate();
    const { toggleNotification } = strapiAdmin.useNotification();
    const { delete: deleteAction, isLoading } = strapiAdmin$1.unstable_useDocumentActions();
    const { hasI18n, canDelete } = useI18n();
    // Get the current locale object, using the URL instead of document so it works while creating
    const [{ query }] = strapiAdmin.useQueryParams();
    const { data: locales = [] } = useGetLocalesQuery();
    const currentDesiredLocale = query.plugins?.i18n?.locale;
    const locale = !('error' in locales) && locales.find((loc)=>loc.code === currentDesiredLocale);
    if (!hasI18n) {
        return null;
    }
    return {
        disabled: document?.locale && !canDelete.includes(document.locale) || !document || !document.id,
        position: [
            'header',
            'table-row'
        ],
        label: formatMessage({
            id: getTranslation('actions.delete.label'),
            defaultMessage: 'Delete entry ({locale})'
        }, {
            locale: locale && locale.name
        }),
        icon: /*#__PURE__*/ jsxRuntime.jsx(StyledTrash, {}),
        variant: 'danger',
        dialog: {
            type: 'dialog',
            title: formatMessage({
                id: getTranslation('actions.delete.dialog.title'),
                defaultMessage: 'Confirmation'
            }),
            content: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                direction: "column",
                gap: 2,
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx(icons.WarningCircle, {
                        width: "24px",
                        height: "24px",
                        fill: "danger600"
                    }),
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                        tag: "p",
                        variant: "omega",
                        textAlign: "center",
                        children: formatMessage({
                            id: getTranslation('actions.delete.dialog.body'),
                            defaultMessage: 'Are you sure?'
                        })
                    })
                ]
            }),
            loading: isLoading,
            onConfirm: async ()=>{
                const unableToDelete = // We are unable to delete a collection type without a document ID
                // & unable to delete generally if there is no document locale
                collectionType !== 'single-types' && !documentId || !document?.locale;
                if (unableToDelete) {
                    console.error("You're trying to delete a document without an id or locale, this is likely a bug with Strapi. Please open an issue.");
                    toggleNotification({
                        message: formatMessage({
                            id: getTranslation('actions.delete.error'),
                            defaultMessage: 'An error occurred while trying to delete the document locale.'
                        }),
                        type: 'danger'
                    });
                    return;
                }
                const res = await deleteAction({
                    documentId,
                    model,
                    collectionType,
                    params: {
                        locale: document.locale
                    }
                });
                if (!('error' in res)) {
                    navigate({
                        pathname: `../${collectionType}/${model}`
                    }, {
                        replace: true
                    });
                }
            }
        }
    };
};
/* -------------------------------------------------------------------------------------------------
 * BulkLocaleAction
 *
 * This component is used to handle bulk publish and unpublish actions on locales.
 * -----------------------------------------------------------------------------------------------*/ const BulkLocaleAction = ({ document, documentId, model, collectionType, action })=>{
    const locale = document?.locale ?? null;
    const [{ query: query$1 }] = strapiAdmin.useQueryParams();
    const params = React__namespace.useMemo(()=>strapiAdmin$1.buildValidParams(query$1), [
        query$1
    ]);
    const isOnPublishedTab = query$1.status === 'published';
    const { formatMessage } = reactIntl.useIntl();
    const { hasI18n, canPublish } = useI18n();
    const { toggleNotification } = strapiAdmin.useNotification();
    const { _unstableFormatAPIError: formatAPIError } = strapiAdmin.useAPIErrorHandler();
    const [selectedRows, setSelectedRows] = React__namespace.useState([]);
    const [isDraftRelationConfirmationOpen, setIsDraftRelationConfirmationOpen] = React__namespace.useState(false);
    const { publishMany: publishManyAction, unpublishMany: unpublishManyAction } = strapiAdmin$1.unstable_useDocumentActions();
    const { schema, validate } = strapiAdmin$1.unstable_useDocument({
        model,
        collectionType,
        documentId,
        params: {
            locale
        }
    }, {
        // No need to fetch the document, the data is already available in the `document` prop
        skip: true
    });
    const { data: localesMetadata = [] } = useGetLocalesQuery(hasI18n ? undefined : query.skipToken);
    const headers = [
        {
            label: formatMessage({
                id: 'global.name',
                defaultMessage: 'Name'
            }),
            name: 'name'
        },
        {
            label: formatMessage({
                id: getTranslation('CMEditViewBulkLocale.status'),
                defaultMessage: 'Status'
            }),
            name: 'status'
        },
        {
            label: formatMessage({
                id: getTranslation('CMEditViewBulkLocale.publication-status'),
                defaultMessage: 'Publication Status'
            }),
            name: 'publication-status'
        }
    ];
    // Extract the rows for the bulk locale publish modal and any validation
    // errors per locale
    const [rows, validationErrors] = React__namespace.useMemo(()=>{
        if (!document) {
            return [
                [],
                {}
            ];
        }
        const localizations = document.localizations ?? [];
        // Build the rows for the bulk locale publish modal by combining the current
        // document with all the available locales from the document meta
        const locales = localizations.map((doc)=>{
            const { locale, status } = doc;
            return {
                locale,
                status
            };
        });
        // Add the current document locale
        locales.unshift({
            locale: document.locale,
            status: document.status
        });
        // Build the validation errors for each locale.
        const allDocuments = [
            document,
            ...localizations
        ];
        const errors = allDocuments.reduce((errs, document)=>{
            if (!document) {
                return errs;
            }
            // Validate each locale entry via the useDocument validate function and store any errors in a dictionary
            const validation = validate(document);
            if (validation !== null) {
                errs[document.locale] = validation;
            }
            return errs;
        }, {});
        return [
            locales,
            errors
        ];
    }, [
        document,
        validate
    ]);
    const isBulkPublish = action === 'bulk-publish';
    const localesForAction = selectedRows.reduce((acc, selectedRow)=>{
        const isValidLocale = // Validation errors are irrelevant if we are trying to unpublish
        !isBulkPublish || !Object.keys(validationErrors).includes(selectedRow.locale);
        const shouldAddLocale = isBulkPublish ? selectedRow.status !== 'published' && isValidLocale : selectedRow.status !== 'draft' && isValidLocale;
        if (shouldAddLocale) {
            acc.push(selectedRow.locale);
        }
        return acc;
    }, []);
    // TODO skipping this for now as there is a bug with the draft relation count that will be worked on separately
    // see https://www.notion.so/strapi/Count-draft-relations-56901b492efb45ab90d42fe975b32bd8?pvs=4
    const enableDraftRelationsCount = false;
    const { data: draftRelationsCount = 0, isLoading: isDraftRelationsLoading, error: isDraftRelationsError } = useGetManyDraftRelationCountQuery({
        model,
        documentIds: [
            documentId
        ],
        locale: localesForAction
    }, {
        skip: !enableDraftRelationsCount
    });
    React__namespace.useEffect(()=>{
        if (isDraftRelationsError) {
            toggleNotification({
                type: 'danger',
                message: formatAPIError(isDraftRelationsError)
            });
        }
    }, [
        isDraftRelationsError,
        toggleNotification,
        formatAPIError
    ]);
    if (!schema?.options?.draftAndPublish) {
        return null;
    }
    if (!hasI18n) {
        return null;
    }
    if (!documentId) {
        return null;
    }
    // This document action can be enabled given that draft and publish and i18n are
    // enabled and we can publish the current locale.
    const publish = async ()=>{
        await publishManyAction({
            model,
            documentIds: [
                documentId
            ],
            params: {
                ...params,
                locale: localesForAction
            }
        });
        setSelectedRows([]);
    };
    const unpublish = async ()=>{
        await unpublishManyAction({
            model,
            documentIds: [
                documentId
            ],
            params: {
                ...params,
                locale: localesForAction
            }
        });
        setSelectedRows([]);
    };
    const handleAction = async ()=>{
        if (draftRelationsCount > 0) {
            setIsDraftRelationConfirmationOpen(true);
        } else if (isBulkPublish) {
            await publish();
        } else {
            await unpublish();
        }
    };
    if (isDraftRelationConfirmationOpen) {
        return {
            label: formatMessage({
                id: 'app.components.ConfirmDialog.title',
                defaultMessage: 'Confirmation'
            }),
            variant: 'danger',
            dialog: {
                onCancel: ()=>{
                    setIsDraftRelationConfirmationOpen(false);
                },
                onConfirm: async ()=>{
                    await publish();
                    setIsDraftRelationConfirmationOpen(false);
                },
                type: 'dialog',
                title: formatMessage({
                    id: getTranslation('actions.publish.dialog.title'),
                    defaultMessage: 'Confirmation'
                }),
                content: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                    direction: "column",
                    alignItems: "center",
                    gap: 2,
                    children: [
                        /*#__PURE__*/ jsxRuntime.jsx(icons.WarningCircle, {
                            width: "2.4rem",
                            height: "2.4rem",
                            fill: "danger600"
                        }),
                        /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                            textAlign: "center",
                            children: formatMessage({
                                id: getTranslation('CMEditViewBulkLocale.draft-relation-warning'),
                                defaultMessage: 'Some locales are related to draft entries. Publishing them could leave broken links in your app.'
                            })
                        }),
                        /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                            textAlign: "center",
                            children: formatMessage({
                                id: getTranslation('CMEditViewBulkLocale.continue-confirmation'),
                                defaultMessage: 'Are you sure you want to continue?'
                            })
                        })
                    ]
                })
            }
        };
    }
    const hasPermission = selectedRows.map(({ locale })=>locale).every((locale)=>canPublish.includes(locale));
    return {
        label: formatMessage({
            id: getTranslation(`CMEditViewBulkLocale.${isBulkPublish ? 'publish' : 'unpublish'}-title`),
            defaultMessage: `${isBulkPublish ? 'Publish' : 'Unpublish'} Multiple Locales`
        }),
        variant: isBulkPublish ? 'secondary' : 'danger',
        icon: isBulkPublish ? /*#__PURE__*/ jsxRuntime.jsx(icons.ListPlus, {}) : /*#__PURE__*/ jsxRuntime.jsx(icons.Cross, {}),
        disabled: isOnPublishedTab || canPublish.length === 0,
        position: [
            'panel'
        ],
        dialog: {
            type: 'modal',
            title: formatMessage({
                id: getTranslation(`CMEditViewBulkLocale.${isBulkPublish ? 'publish' : 'unpublish'}-title`),
                defaultMessage: `${isBulkPublish ? 'Publish' : 'Unpublish'} Multiple Locales`
            }),
            content: ()=>{
                return /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.Root, {
                    headers: headers,
                    rows: rows.map((row)=>({
                            ...row,
                            id: row.locale
                        })),
                    selectedRows: selectedRows,
                    onSelectedRowsChange: (tableSelectedRows)=>setSelectedRows(tableSelectedRows),
                    children: /*#__PURE__*/ jsxRuntime.jsx(BulkLocaleActionModal, {
                        validationErrors: validationErrors,
                        headers: headers,
                        rows: rows,
                        localesMetadata: localesMetadata,
                        action: action ?? 'bulk-publish'
                    })
                });
            },
            footer: ()=>/*#__PURE__*/ jsxRuntime.jsx(designSystem.Modal.Footer, {
                    justifyContent: "flex-end",
                    children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
                        loading: isDraftRelationsLoading,
                        disabled: !hasPermission || localesForAction.length === 0,
                        variant: "default",
                        onClick: handleAction,
                        children: formatMessage({
                            id: isBulkPublish ? 'app.utils.publish' : 'app.utils.unpublish',
                            defaultMessage: isBulkPublish ? 'Publish' : 'Unpublish'
                        })
                    })
                })
        }
    };
};
/* -------------------------------------------------------------------------------------------------
 * BulkLocalePublishAction
 * -----------------------------------------------------------------------------------------------*/ const BulkLocalePublishAction = (props)=>{
    return BulkLocaleAction({
        action: 'bulk-publish',
        ...props
    });
};
/* -------------------------------------------------------------------------------------------------
 * BulkLocaleUnpublishAction
 * -----------------------------------------------------------------------------------------------*/ const BulkLocaleUnpublishAction = (props)=>{
    return BulkLocaleAction({
        action: 'bulk-unpublish',
        ...props
    });
};
/**
 * Because the icon system is completely broken, we have to do
 * this to remove the fill from the cog.
 */ const StyledTrash = styledComponents.styled(icons.Trash)`
  path {
    fill: currentColor;
  }
`;

const Emphasis = (chunks)=>{
    return /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
        fontWeight: "semiBold",
        textColor: "danger500",
        children: chunks
    });
};
const DeleteModalAdditionalInfo = ()=>{
    const { hasI18n } = useI18n();
    const { formatMessage } = reactIntl.useIntl();
    if (!hasI18n) {
        return null;
    }
    return /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
        textColor: "danger500",
        children: formatMessage({
            id: getTranslation('Settings.list.actions.deleteAdditionalInfos'),
            defaultMessage: 'This will delete the active locale versions <em>(from Internationalization)</em>'
        }, {
            em: Emphasis
        })
    });
};
const PublishModalAdditionalInfo = ()=>{
    const { hasI18n } = useI18n();
    const { formatMessage } = reactIntl.useIntl();
    if (!hasI18n) {
        return null;
    }
    return /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
        textColor: "danger500",
        children: formatMessage({
            id: getTranslation('Settings.list.actions.publishAdditionalInfos'),
            defaultMessage: 'This will publish the active locale versions <em>(from Internationalization)</em>'
        }, {
            em: Emphasis
        })
    });
};
const UnpublishModalAdditionalInfo = ()=>{
    const { hasI18n } = useI18n();
    const { formatMessage } = reactIntl.useIntl();
    if (!hasI18n) {
        return null;
    }
    return /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
        textColor: "danger500",
        children: formatMessage({
            id: getTranslation('Settings.list.actions.unpublishAdditionalInfos'),
            defaultMessage: 'This will unpublish the active locale versions <em>(from Internationalization)</em>'
        }, {
            em: Emphasis
        })
    });
};

const LocalePicker = ()=>{
    const { formatMessage } = reactIntl.useIntl();
    const [{ query }, setQuery] = strapiAdmin.useQueryParams();
    const { hasI18n, canRead, canCreate } = useI18n();
    const { data: locales = [] } = useGetLocalesQuery(undefined, {
        skip: !hasI18n
    });
    const handleChange = React__namespace.useCallback((code, replace = false)=>{
        setQuery({
            page: 1,
            plugins: {
                ...query.plugins,
                i18n: {
                    locale: code
                }
            }
        }, 'push', replace);
    }, [
        query.plugins,
        setQuery
    ]);
    React__namespace.useEffect(()=>{
        if (!Array.isArray(locales) || !hasI18n) {
            return;
        }
        /**
     * Handle the case where the current locale query param doesn't exist
     * in the list of available locales, so we redirect to the default locale.
     */ const currentDesiredLocale = query.plugins?.i18n?.locale;
        const doesLocaleExist = locales.find((loc)=>loc.code === currentDesiredLocale);
        const defaultLocale = locales.find((locale)=>locale.isDefault);
        if (!doesLocaleExist && defaultLocale?.code) {
            handleChange(defaultLocale.code, true);
        }
    }, [
        hasI18n,
        handleChange,
        locales,
        query.plugins?.i18n?.locale
    ]);
    if (!hasI18n || !Array.isArray(locales) || locales.length === 0) {
        return null;
    }
    const displayedLocales = locales.filter((locale)=>{
        /**
     * If you can create or read we allow you to see the locale exists
     * this is because in the ListView, you may be able to create a new entry
     * in a locale you can't read.
     */ return canCreate.includes(locale.code) || canRead.includes(locale.code);
    });
    return /*#__PURE__*/ jsxRuntime.jsx(designSystem.SingleSelect, {
        size: "S",
        "aria-label": formatMessage({
            id: getTranslation('actions.select-locale'),
            defaultMessage: 'Select locale'
        }),
        value: query.plugins?.i18n?.locale || locales.find((locale)=>locale.isDefault)?.code,
        // @ts-expect-error â€“ This can be removed in V2 of the DS.
        onChange: handleChange,
        children: displayedLocales.map((locale)=>/*#__PURE__*/ jsxRuntime.jsx(designSystem.SingleSelectOption, {
                value: locale.code,
                children: locale.name
            }, locale.id))
    });
};

const PERMISSIONS = {
    accessMain: [
        {
            action: 'plugin::i18n.locale.read',
            subject: null
        }
    ],
    create: [
        {
            action: 'plugin::i18n.locale.create',
            subject: null
        }
    ],
    delete: [
        {
            action: 'plugin::i18n.locale.delete',
            subject: null
        }
    ],
    update: [
        {
            action: 'plugin::i18n.locale.update',
            subject: null
        }
    ],
    read: [
        {
            action: 'plugin::i18n.locale.read',
            subject: null
        }
    ]
};

const mutateEditViewHook = ({ layout })=>{
    // If i18n isn't explicitly enabled on the content type, then no field can be localized
    if (!('i18n' in layout.options) || typeof layout.options.i18n === 'object' && layout.options.i18n !== null && 'localized' in layout.options.i18n && !layout.options.i18n.localized) {
        return {
            layout
        };
    }
    const components = Object.entries(layout.components).reduce((acc, [key, componentLayout])=>{
        return {
            ...acc,
            [key]: {
                ...componentLayout,
                layout: componentLayout.layout.map((row)=>row.map(addLabelActionToField))
            }
        };
    }, {});
    return {
        layout: {
            ...layout,
            components,
            layout: layout.layout.map((panel)=>panel.map((row)=>row.map(addLabelActionToField)))
        }
    };
};
const addLabelActionToField = (field)=>{
    const isFieldLocalized = doesFieldHaveI18nPluginOpt(field.attribute.pluginOptions) ? field.attribute.pluginOptions.i18n.localized : true;
    const labelActionProps = {
        title: {
            id: isFieldLocalized ? getTranslation('Field.localized') : getTranslation('Field.not-localized'),
            defaultMessage: isFieldLocalized ? 'This value is unique for the selected locale' : 'This value is the same across all locales'
        },
        icon: isFieldLocalized ? /*#__PURE__*/ jsxRuntime.jsx(icons.Earth, {}) : null
    };
    return {
        ...field,
        labelAction: isFieldLocalized ? /*#__PURE__*/ jsxRuntime.jsx(LabelAction, {
            ...labelActionProps
        }) : null
    };
};
const doesFieldHaveI18nPluginOpt = (pluginOpts)=>{
    if (!pluginOpts) {
        return false;
    }
    return 'i18n' in pluginOpts && typeof pluginOpts.i18n === 'object' && pluginOpts.i18n !== null && 'localized' in pluginOpts.i18n;
};
const LabelAction = ({ title, icon })=>{
    const { formatMessage } = reactIntl.useIntl();
    return /*#__PURE__*/ jsxRuntime.jsxs(Span, {
        tag: "span",
        children: [
            /*#__PURE__*/ jsxRuntime.jsx(designSystem.VisuallyHidden, {
                tag: "span",
                children: formatMessage(title)
            }),
            /*#__PURE__*/ React__namespace.cloneElement(icon, {
                'aria-hidden': true,
                focusable: false
            })
        ]
    });
};
const Span = styledComponents.styled(designSystem.Flex)`
  svg {
    width: 12px;
    height: 12px;

    fill: ${({ theme })=>theme.colors.neutral500};

    path {
      fill: ${({ theme })=>theme.colors.neutral500};
    }
  }
`;

const LocaleListCell = ({ locale: currentLocale, localizations })=>{
    const { locale: language } = reactIntl.useIntl();
    const { data: locales = [] } = useGetLocalesQuery();
    const formatter = designSystem.useCollator(language, {
        sensitivity: 'base'
    });
    if (!Array.isArray(locales) || !localizations) {
        return null;
    }
    const availableLocales = localizations.map((loc)=>loc.locale);
    const localesForDocument = locales.reduce((acc, locale)=>{
        const createdLocale = [
            currentLocale,
            ...availableLocales
        ].find((loc)=>{
            return loc === locale.code;
        });
        if (createdLocale) {
            acc.push(locale);
        }
        return acc;
    }, []).map((locale)=>{
        if (locale.isDefault) {
            return `${locale.name} (default)`;
        }
        return locale.name;
    }).toSorted((a, b)=>formatter.compare(a, b));
    return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Popover.Root, {
        children: [
            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Popover.Trigger, {
                children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
                    variant: "ghost",
                    type: "button",
                    onClick: (e)=>e.stopPropagation(),
                    children: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                        minWidth: "100%",
                        alignItems: "center",
                        justifyContent: "center",
                        fontWeight: "regular",
                        children: [
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                                textColor: "neutral800",
                                ellipsis: true,
                                marginRight: 2,
                                children: localesForDocument.join(', ')
                            }),
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Flex, {
                                children: /*#__PURE__*/ jsxRuntime.jsx(icons.CaretDown, {
                                    width: "1.2rem",
                                    height: "1.2rem"
                                })
                            })
                        ]
                    })
                })
            }),
            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Popover.Content, {
                sideOffset: 16,
                children: /*#__PURE__*/ jsxRuntime.jsx("ul", {
                    children: localesForDocument.map((name)=>/*#__PURE__*/ jsxRuntime.jsx(designSystem.Box, {
                            padding: 3,
                            tag: "li",
                            children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                                children: name
                            })
                        }, name))
                })
            })
        ]
    });
};

const addColumnToTableHook = ({ displayedHeaders, layout })=>{
    const { options } = layout;
    const isFieldLocalized = doesPluginOptionsHaveI18nLocalized(options) ? options.i18n.localized : false;
    if (!isFieldLocalized) {
        return {
            displayedHeaders,
            layout
        };
    }
    return {
        displayedHeaders: [
            ...displayedHeaders,
            {
                attribute: {
                    type: 'string'
                },
                label: {
                    id: getTranslation('list-view.table.header.label'),
                    defaultMessage: 'Available in'
                },
                searchable: false,
                sortable: false,
                name: 'locales',
                // @ts-expect-error â€“ ID is seen as number | string; this will change when we move the type over.
                cellFormatter: (props, _header, meta)=>/*#__PURE__*/ jsxRuntime.jsx(LocaleListCell, {
                        ...props,
                        ...meta
                    })
            }
        ],
        layout
    };
};

const addLocaleToReleasesHook = ({ displayedHeaders = [] })=>{
    return {
        displayedHeaders: [
            ...displayedHeaders,
            {
                label: {
                    id: 'content-releases.page.ReleaseDetails.table.header.label.locale',
                    defaultMessage: 'locale'
                },
                name: 'locale'
            }
        ],
        hasI18nEnabled: true
    };
};

const extendCTBAttributeInitialDataMiddleware = ()=>{
    return ({ getState })=>(next)=>(action)=>{
                const enhanceAction = ()=>{
                    // the block here is to catch the error when trying to access the state
                    // of the ctb when the plugin is not mounted
                    try {
                        const store = getState();
                        const hasi18nEnabled = get(store, [
                            'content-type-builder_dataManagerProvider',
                            'modifiedData',
                            'contentType',
                            'schema',
                            'pluginOptions',
                            'i18n',
                            'localized'
                        ], false);
                        if (hasi18nEnabled) {
                            const pluginOptions = action.options ? {
                                ...action.options.pluginOptions,
                                i18n: {
                                    localized: true
                                }
                            } : {
                                i18n: {
                                    localized: true
                                }
                            };
                            return next({
                                ...action,
                                options: {
                                    pluginOptions
                                }
                            });
                        }
                        return next(action);
                    } catch (err) {
                        return next(action);
                    }
                };
                if (action.type === 'ContentTypeBuilder/FormModal/SET_ATTRIBUTE_DATA_SCHEMA' && action.forTarget === 'contentType' && ![
                    'relation',
                    'component'
                ].includes(action.attributeType) && !action.isEditing) {
                    return enhanceAction();
                }
                if (action.type === 'ContentTypeBuilder/FormModal/SET_CUSTOM_FIELD_DATA_SCHEMA' && action.forTarget === 'contentType' && !action.isEditing) {
                    return enhanceAction();
                }
                if ((action.type === 'ContentTypeBuilder/FormModal/RESET_PROPS_AND_SET_FORM_FOR_ADDING_AN_EXISTING_COMPO' || action.type === 'ContentTypeBuilder/FormModal/RESET_PROPS_AND_SAVE_CURRENT_DATA') && action.forTarget === 'contentType') {
                    return enhanceAction();
                }
                return next(action);
            };
};

const extendCTBInitialDataMiddleware = ()=>{
    return ()=>(next)=>(action)=>{
                if (action.type === 'ContentTypeBuilder/FormModal/SET_DATA_TO_EDIT' && action.modalType === 'contentType') {
                    const i18n = {
                        localized: false
                    };
                    const pluginOptions = action.data.pluginOptions ? {
                        ...action.data.pluginOptions,
                        i18n
                    } : {
                        i18n
                    };
                    const data = {
                        ...action.data,
                        pluginOptions
                    };
                    if (action.actionType === 'create') {
                        return next({
                            ...action,
                            data
                        });
                    }
                    // Override the action if the pluginOption config does not contain i18n
                    // In this case we need to set the proper initialData shape
                    if (!action.data.pluginOptions?.i18n?.localized) {
                        return next({
                            ...action,
                            data
                        });
                    }
                }
                // action is not the one we want to override
                return next(action);
            };
};

const localeMiddleware = (ctx)=>(next)=>(permissions)=>{
            const match = reactRouterDom.matchPath('/content-manager/:collectionType/:model?/:id', ctx.pathname);
            if (!match) {
                return next(permissions);
            }
            const search = qs__namespace.parse(ctx.search);
            if (typeof search !== 'object') {
                return next(permissions);
            }
            if (!('plugins' in search && typeof search.plugins === 'object')) {
                return next(permissions);
            }
            if (!('i18n' in search.plugins && typeof search.plugins.i18n === 'object' && !Array.isArray(search.plugins.i18n))) {
                return next(permissions);
            }
            const { locale } = search.plugins.i18n;
            if (typeof locale !== 'string') {
                return next(permissions);
            }
            const revisedPermissions = permissions.filter((permission)=>!permission.properties?.locales || permission.properties.locales.includes(locale));
            return next(revisedPermissions);
        };

const prefixPluginTranslations = (trad, pluginId)=>{
    return Object.keys(trad).reduce((acc, current)=>{
        acc[`${pluginId}.${current}`] = trad[current];
        return acc;
    }, {});
};

/* -------------------------------------------------------------------------------------------------
 * mutateCTBContentTypeSchema
 * -----------------------------------------------------------------------------------------------*/ const mutateCTBContentTypeSchema = (nextSchema, prevSchema)=>{
    // Don't perform mutations components
    if (!doesPluginOptionsHaveI18nLocalized(nextSchema.pluginOptions)) {
        return nextSchema;
    }
    const isNextSchemaLocalized = nextSchema.pluginOptions.i18n.localized;
    const isPrevSchemaLocalized = doesPluginOptionsHaveI18nLocalized(prevSchema?.schema?.pluginOptions) ? prevSchema?.schema?.pluginOptions.i18n.localized : false;
    // No need to perform modification on the schema, if the i18n feature was not changed
    // at the ct level
    if (isNextSchemaLocalized && isPrevSchemaLocalized) {
        return nextSchema;
    }
    if (isNextSchemaLocalized) {
        const attributes = addLocalisationToFields(nextSchema.attributes);
        return {
            ...nextSchema,
            attributes
        };
    }
    // Remove the i18n object from the pluginOptions
    if (!isNextSchemaLocalized) {
        const pluginOptions = omit(nextSchema.pluginOptions, 'i18n');
        const attributes = disableAttributesLocalisation(nextSchema.attributes);
        return {
            ...nextSchema,
            pluginOptions,
            attributes
        };
    }
    return nextSchema;
};
/* -------------------------------------------------------------------------------------------------
 * addLocalisationToFields
 * -----------------------------------------------------------------------------------------------*/ const addLocalisationToFields = (attributes)=>Object.keys(attributes).reduce((acc, current)=>{
        const currentAttribute = attributes[current];
        if (LOCALIZED_FIELDS.includes(currentAttribute.type)) {
            const i18n = {
                localized: true
            };
            const pluginOptions = currentAttribute.pluginOptions ? {
                ...currentAttribute.pluginOptions,
                i18n
            } : {
                i18n
            };
            acc[current] = {
                ...currentAttribute,
                pluginOptions
            };
            return acc;
        }
        acc[current] = currentAttribute;
        return acc;
    }, {});
const disableAttributesLocalisation = (attributes)=>Object.keys(attributes).reduce((acc, current)=>{
        acc[current] = omit(attributes[current], 'pluginOptions.i18n');
        return acc;
    }, {});

function __variableDynamicImportRuntime1__(path) {
  switch (path) {
    case './translations/de.json': return Promise.resolve().then(function () { return require('./de-nEMWvIiY.js'); });
    case './translations/dk.json': return Promise.resolve().then(function () { return require('./dk-CYATLPVe.js'); });
    case './translations/en.json': return Promise.resolve().then(function () { return require('./en-CG5cUCbD.js'); });
    case './translations/es.json': return Promise.resolve().then(function () { return require('./es-CWsogTGm.js'); });
    case './translations/fr.json': return Promise.resolve().then(function () { return require('./fr-CC7UFcYd.js'); });
    case './translations/ko.json': return Promise.resolve().then(function () { return require('./ko-XwGmfhoq.js'); });
    case './translations/pl.json': return Promise.resolve().then(function () { return require('./pl-B_vzY_ZB.js'); });
    case './translations/ru.json': return Promise.resolve().then(function () { return require('./ru-WzHcJV1f.js'); });
    case './translations/tr.json': return Promise.resolve().then(function () { return require('./tr-CcWp6u3w.js'); });
    case './translations/uk.json': return Promise.resolve().then(function () { return require('./uk-CO6JHYRC.js'); });
    case './translations/zh-Hans.json': return Promise.resolve().then(function () { return require('./zh-Hans-DnU2bhri.js'); });
    case './translations/zh.json': return Promise.resolve().then(function () { return require('./zh-C9So4SGq.js'); });
    default: return new Promise(function(resolve, reject) {
      (typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
        reject.bind(null, new Error("Unknown variable dynamic import: " + path))
      );
    })
   }
 }
// eslint-disable-next-line import/no-default-export
var index = {
    register (app) {
        app.addMiddlewares([
            extendCTBAttributeInitialDataMiddleware,
            extendCTBInitialDataMiddleware
        ]);
        app.addMiddlewares([
            ()=>i18nApi.middleware
        ]);
        app.addReducers({
            [i18nApi.reducerPath]: i18nApi.reducer
        });
        app.addRBACMiddleware([
            localeMiddleware
        ]);
        app.registerPlugin({
            id: pluginId,
            name: pluginId
        });
    },
    bootstrap (app) {
        // // Hook that adds a column into the CM's LV table
        app.registerHook('Admin/CM/pages/ListView/inject-column-in-table', addColumnToTableHook);
        app.registerHook('Admin/CM/pages/EditView/mutate-edit-view-layout', mutateEditViewHook);
        // Hooks that checks if the locale is present in the release
        app.registerHook('ContentReleases/pages/ReleaseDetails/add-locale-in-releases', addLocaleToReleasesHook);
        // Add the settings link
        app.addSettingsLink('global', {
            intlLabel: {
                id: getTranslation('plugin.name'),
                defaultMessage: 'Internationalization'
            },
            id: 'internationalization',
            to: 'internationalization',
            Component: ()=>Promise.resolve().then(function () { return require('./SettingsPage-Mg2Ygywx.js'); }).then((mod)=>({
                        default: mod.ProtectedSettingsPage
                    })),
            permissions: PERMISSIONS.accessMain
        });
        const contentManager = app.getPlugin('content-manager');
        contentManager.apis.addDocumentHeaderAction([
            LocalePickerAction,
            FillFromAnotherLocaleAction
        ]);
        contentManager.apis.addDocumentAction((actions)=>{
            const indexOfDeleteAction = actions.findIndex((action)=>action.type === 'delete');
            actions.splice(indexOfDeleteAction, 0, DeleteLocaleAction);
            return actions;
        });
        contentManager.apis.addDocumentAction((actions)=>{
            // When enabled the bulk locale publish action should be the first action
            // in 'More Document Actions' and therefore the third action in the array
            actions.splice(2, 0, BulkLocalePublishAction);
            actions.splice(5, 0, BulkLocaleUnpublishAction);
            return actions;
        });
        contentManager.injectComponent('listView', 'actions', {
            name: 'i18n-locale-filter',
            Component: LocalePicker
        });
        contentManager.injectComponent('listView', 'publishModalAdditionalInfos', {
            name: 'i18n-publish-bullets-in-modal',
            Component: PublishModalAdditionalInfo
        });
        contentManager.injectComponent('listView', 'unpublishModalAdditionalInfos', {
            name: 'i18n-unpublish-bullets-in-modal',
            Component: UnpublishModalAdditionalInfo
        });
        contentManager.injectComponent('listView', 'deleteModalAdditionalInfos', {
            name: 'i18n-delete-bullets-in-modal',
            Component: DeleteModalAdditionalInfo
        });
        const ctbPlugin = app.getPlugin('content-type-builder');
        if (ctbPlugin) {
            const ctbFormsAPI = ctbPlugin.apis.forms;
            ctbFormsAPI.addContentTypeSchemaMutation(mutateCTBContentTypeSchema);
            ctbFormsAPI.components.add({
                id: 'checkboxConfirmation',
                component: CheckboxConfirmation
            });
            ctbFormsAPI.extendContentType({
                validator: ()=>({
                        i18n: yup__namespace.object().shape({
                            localized: yup__namespace.bool()
                        })
                    }),
                form: {
                    advanced () {
                        return [
                            {
                                name: 'pluginOptions.i18n.localized',
                                description: {
                                    id: getTranslation('plugin.schema.i18n.localized.description-content-type'),
                                    defaultMessage: 'Allows translating an entry into different languages'
                                },
                                type: 'checkboxConfirmation',
                                intlLabel: {
                                    id: getTranslation('plugin.schema.i18n.localized.label-content-type'),
                                    defaultMessage: 'Localization'
                                }
                            }
                        ];
                    }
                }
            });
            ctbFormsAPI.extendFields(LOCALIZED_FIELDS, {
                form: {
                    advanced ({ contentTypeSchema, forTarget, type, step }) {
                        if (forTarget !== 'contentType') {
                            return [];
                        }
                        const hasI18nEnabled = get(contentTypeSchema, [
                            'schema',
                            'pluginOptions',
                            'i18n',
                            'localized'
                        ], false);
                        if (!hasI18nEnabled) {
                            return [];
                        }
                        if (type === 'component' && step === '1') {
                            return [];
                        }
                        return [
                            {
                                name: 'pluginOptions.i18n.localized',
                                description: {
                                    id: getTranslation('plugin.schema.i18n.localized.description-field'),
                                    defaultMessage: 'The field can have different values in each locale'
                                },
                                type: 'checkbox',
                                intlLabel: {
                                    id: getTranslation('plugin.schema.i18n.localized.label-field'),
                                    defaultMessage: 'Enable localization for this field'
                                }
                            }
                        ];
                    }
                }
            });
        }
    },
    async registerTrads ({ locales }) {
        const importedTrads = await Promise.all(locales.map((locale)=>{
            return __variableDynamicImportRuntime1__(`./translations/${locale}.json`).then(({ default: data })=>{
                return {
                    data: prefixPluginTranslations(data, pluginId),
                    locale
                };
            }).catch(()=>{
                return {
                    data: {},
                    locale
                };
            });
        }));
        return Promise.resolve(importedTrads);
    }
};

exports.PERMISSIONS = PERMISSIONS;
exports.getTranslation = getTranslation;
exports.index = index;
exports.useCreateLocaleMutation = useCreateLocaleMutation;
exports.useDeleteLocaleMutation = useDeleteLocaleMutation;
exports.useGetDefaultLocalesQuery = useGetDefaultLocalesQuery;
exports.useGetLocalesQuery = useGetLocalesQuery;
exports.useUpdateLocaleMutation = useUpdateLocaleMutation;
//# sourceMappingURL=index-hJ67XV0K.js.map
