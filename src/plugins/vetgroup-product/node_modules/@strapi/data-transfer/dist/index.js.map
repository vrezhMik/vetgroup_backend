{"version":3,"file":"index.js","sources":["../src/utils/encryption/encrypt.ts","../src/utils/encryption/decrypt.ts","../src/utils/stream.ts","../src/utils/json.ts","../src/utils/schema.ts","../src/utils/transaction.ts","../src/utils/middleware.ts","../src/utils/diagnostic.ts","../src/engine/validation/schemas/index.ts","../src/errors/constants.ts","../src/errors/base.ts","../src/engine/errors.ts","../src/engine/validation/provider.ts","../src/errors/providers.ts","../src/engine/index.ts","../src/utils/components.ts","../src/strapi/queries/entity.ts","../src/strapi/queries/link.ts","../src/strapi/providers/local-destination/strategies/restore/entities.ts","../src/strapi/providers/local-destination/strategies/restore/configuration.ts","../src/strapi/providers/local-destination/strategies/restore/links.ts","../src/strapi/providers/local-destination/strategies/restore/index.ts","../src/utils/providers.ts","../src/strapi/providers/local-destination/index.ts","../src/strapi/providers/local-source/entities.ts","../src/strapi/providers/local-source/links.ts","../src/strapi/providers/local-source/configuration.ts","../src/strapi/providers/local-source/assets.ts","../src/strapi/providers/local-source/index.ts","../src/strapi/providers/utils.ts","../src/strapi/remote/constants.ts","../src/strapi/providers/remote-destination/index.ts","../src/strapi/providers/remote-source/index.ts","../src/strapi/providers/index.ts","../src/strapi/remote/flows/default.ts","../src/strapi/remote/flows/index.ts","../src/strapi/remote/handlers/constants.ts","../src/strapi/remote/handlers/utils.ts","../src/strapi/remote/handlers/push.ts","../src/strapi/remote/handlers/pull.ts","../src/file/providers/source/utils.ts","../src/file/providers/source/index.ts","../src/file/providers/destination/utils.ts","../src/file/providers/destination/index.ts"],"sourcesContent":["import { createCipheriv, Cipher, scryptSync, CipherKey, BinaryLike } from 'crypto';\nimport { EncryptionStrategy, Strategies, Algorithm } from '../../../types';\n\n// different key values depending on algorithm chosen\nconst getEncryptionStrategy = (algorithm: Algorithm): EncryptionStrategy => {\n  const strategies: Strategies = {\n    'aes-128-ecb'(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 16);\n      const initVector: BinaryLike | null = null;\n      const securityKey: CipherKey = hashedKey;\n      return createCipheriv(algorithm, securityKey, initVector);\n    },\n    aes128(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 32);\n      const initVector: BinaryLike | null = hashedKey.slice(16);\n      const securityKey: CipherKey = hashedKey.slice(0, 16);\n      return createCipheriv(algorithm, securityKey, initVector);\n    },\n    aes192(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 40);\n      const initVector: BinaryLike | null = hashedKey.slice(24);\n      const securityKey: CipherKey = hashedKey.slice(0, 24);\n      return createCipheriv(algorithm, securityKey, initVector);\n    },\n    aes256(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 48);\n      const initVector: BinaryLike | null = hashedKey.slice(32);\n      const securityKey: CipherKey = hashedKey.slice(0, 32);\n      return createCipheriv(algorithm, securityKey, initVector);\n    },\n  };\n\n  return strategies[algorithm];\n};\n\n/**\n * It creates a cipher instance used for encryption\n *\n * @param key - The encryption key\n * @param algorithm - The algorithm to use to create the Cipher\n *\n * @returns A {@link Cipher} instance created with the given key & algorithm\n */\nexport const createEncryptionCipher = (\n  key: string,\n  algorithm: Algorithm = 'aes-128-ecb'\n): Cipher => {\n  return getEncryptionStrategy(algorithm)(key);\n};\n","import { Cipher, scryptSync, CipherKey, BinaryLike, createDecipheriv } from 'crypto';\nimport { EncryptionStrategy, Strategies, Algorithm } from '../../../types';\n\n// different key values depending on algorithm chosen\nconst getDecryptionStrategy = (algorithm: Algorithm): EncryptionStrategy => {\n  const strategies: Strategies = {\n    'aes-128-ecb'(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 16);\n      const initVector: BinaryLike | null = null;\n      const securityKey: CipherKey = hashedKey;\n      return createDecipheriv(algorithm, securityKey, initVector);\n    },\n    aes128(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 32);\n      const initVector: BinaryLike | null = hashedKey.slice(16);\n      const securityKey: CipherKey = hashedKey.slice(0, 16);\n      return createDecipheriv(algorithm, securityKey, initVector);\n    },\n    aes192(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 40);\n      const initVector: BinaryLike | null = hashedKey.slice(24);\n      const securityKey: CipherKey = hashedKey.slice(0, 24);\n      return createDecipheriv(algorithm, securityKey, initVector);\n    },\n    aes256(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 48);\n      const initVector: BinaryLike | null = hashedKey.slice(32);\n      const securityKey: CipherKey = hashedKey.slice(0, 32);\n      return createDecipheriv(algorithm, securityKey, initVector);\n    },\n  };\n\n  return strategies[algorithm];\n};\n\n/**\n * It creates a cipher instance used for decryption\n *\n * @param key - The decryption key\n * @param algorithm - The algorithm to use to create the Cipher\n *\n * @returns A {@link Cipher} instance created with the given key & algorithm\n */\nexport const createDecryptionCipher = (\n  key: string,\n  algorithm: Algorithm = 'aes-128-ecb'\n): Cipher => {\n  return getDecryptionStrategy(algorithm)(key);\n};\n","import { Transform, Readable } from 'stream';\n\ntype TransformOptions = ConstructorParameters<typeof Transform>[0];\n\n/**\n * Create a filter stream that discard chunks which doesn't satisfies the given predicate\n *\n * @param predicate - A filter predicate, takes a stream data chunk as parameter and returns a boolean value\n * @param options - Transform stream options\n */\nexport const filter = <T>(\n  predicate: (value: T) => boolean | Promise<boolean>,\n  options: TransformOptions = { objectMode: true }\n): Transform => {\n  return new Transform({\n    ...options,\n\n    async transform(chunk, _encoding, callback) {\n      const keep = await predicate(chunk);\n\n      callback(null, keep ? chunk : undefined);\n    },\n  });\n};\n\n/**\n * Create a map stream that transform chunks using the given predicate\n *\n * @param predicate - A map predicate, takes a stream data chunk as parameter and returns a mapped value\n * @param options - Transform stream options\n */\nexport const map = <T, U = T>(\n  predicate: (value: T) => U | Promise<U>,\n  options: TransformOptions = { objectMode: true }\n): Transform => {\n  return new Transform({\n    ...options,\n\n    async transform(chunk, _encoding, callback) {\n      const mappedValue = await predicate(chunk);\n\n      callback(null, mappedValue);\n    },\n  });\n};\n\n/**\n * Collect every chunks from a Readable stream.\n *\n * @param stream - The redable stream to collect data from\n * @param options.destroy - If set to true, it automatically calls `destroy()` on the given stream upon receiving the 'end' event\n */\nexport const collect = <T = unknown>(\n  stream: Readable,\n  options: { destroy: boolean } = { destroy: true }\n): Promise<T[]> => {\n  const chunks: T[] = [];\n\n  return new Promise((resolve, reject) => {\n    stream\n      .on('close', () => resolve(chunks))\n      .on('error', reject)\n      .on('data', (chunk) => chunks.push(chunk))\n      .on('end', () => {\n        if (options.destroy) {\n          stream.destroy();\n        }\n\n        resolve(chunks);\n      });\n  });\n};\n","import { isArray, isObject, zip, isEqual, uniq } from 'lodash/fp';\n\nconst createContext = (): Context => ({ path: [] });\n\n/**\n * Compute differences between two JSON objects and returns them\n *\n * @param a - First object\n * @param b - Second object\n * @param ctx - Context used to keep track of the current path during recursion\n */\nexport const diff = (a: unknown, b: unknown, ctx: Context = createContext()): Diff[] => {\n  const diffs: Diff[] = [];\n  const { path } = ctx;\n\n  const aType = typeof a;\n  const bType = typeof b;\n\n  // Define helpers\n\n  const added = () => {\n    diffs.push({ kind: 'added', path, type: bType, value: b });\n    return diffs;\n  };\n\n  const deleted = () => {\n    diffs.push({ kind: 'deleted', path, type: aType, value: a });\n    return diffs;\n  };\n\n  const modified = () => {\n    diffs.push({\n      kind: 'modified',\n      path,\n      types: [aType, bType],\n      values: [a, b],\n    });\n    return diffs;\n  };\n\n  if (isArray(a) && isArray(b)) {\n    let k = 0;\n\n    for (const [aItem, bItem] of zip(a, b)) {\n      const kCtx: Context = { path: [...path, k.toString()] };\n      const kDiffs = diff(aItem, bItem, kCtx);\n\n      diffs.push(...kDiffs);\n\n      k += 1;\n    }\n\n    return diffs;\n  }\n\n  if (isObject(a) && isObject(b)) {\n    const keys = uniq(Object.keys(a).concat(Object.keys(b)));\n\n    for (const key of keys) {\n      const aValue = (a as Record<string, unknown>)[key];\n      const bValue = (b as Record<string, unknown>)[key];\n\n      const nestedDiffs = diff(aValue, bValue, { path: [...path, key] });\n\n      diffs.push(...nestedDiffs);\n    }\n\n    return diffs;\n  }\n\n  if (!isEqual(a, b)) {\n    if (aType === 'undefined') {\n      return added();\n    }\n\n    if (bType === 'undefined') {\n      return deleted();\n    }\n\n    return modified();\n  }\n\n  return diffs;\n};\n\nexport interface AddedDiff<T = unknown> {\n  kind: 'added';\n  path: string[];\n  type: string;\n  value: T;\n}\n\nexport interface ModifiedDiff<T = unknown, P = unknown> {\n  kind: 'modified';\n  path: string[];\n  types: [string, string];\n  values: [T, P];\n}\n\nexport interface DeletedDiff<T = unknown> {\n  kind: 'deleted';\n  path: string[];\n  type: string;\n  value: T;\n}\n\nexport type Diff<T = unknown> = AddedDiff<T> | ModifiedDiff<T> | DeletedDiff<T>;\n\nexport interface Context {\n  path: string[];\n}\n","import type { Struct, Utils } from '@strapi/types';\nimport { mapValues, pick } from 'lodash/fp';\n\n/**\n * List of schema properties that should be kept when sanitizing schemas\n */\nconst VALID_SCHEMA_PROPERTIES = [\n  'collectionName',\n  'info',\n  'options',\n  'pluginOptions',\n  'attributes',\n  'kind',\n  'modelType',\n  'modelName',\n  'uid',\n  'plugin',\n  'globalId',\n];\n\n/**\n * Sanitize a schemas dictionary by omitting unwanted properties\n * The list of allowed properties can be found here: {@link VALID_SCHEMA_PROPERTIES}\n */\nexport const mapSchemasValues = (schemas: Utils.String.Dict<Struct.Schema>) => {\n  return mapValues(pick(VALID_SCHEMA_PROPERTIES), schemas) as Utils.String.Dict<Struct.Schema>;\n};\n\nexport const schemasToValidJSON = (schemas: Utils.String.Dict<Struct.Schema>) => {\n  return JSON.parse(JSON.stringify(schemas));\n};\n","import { EventEmitter } from 'events';\nimport { randomUUID } from 'crypto';\nimport type { Core } from '@strapi/types';\n\nimport { Transaction, TransactionCallback } from '../../types/utils';\n\nexport const createTransaction = (strapi: Core.Strapi): Transaction => {\n  const fns: { fn: TransactionCallback; uuid: string }[] = [];\n\n  let done = false;\n  let resume: null | (() => void) = null;\n\n  const e = new EventEmitter();\n  e.on('spawn', (uuid, cb) => {\n    fns.push({ fn: cb, uuid });\n    resume?.();\n  });\n\n  e.on('close', () => {\n    e.removeAllListeners('rollback');\n    e.removeAllListeners('spawn');\n\n    done = true;\n    resume?.();\n  });\n\n  strapi.db.transaction(async ({ trx, rollback }) => {\n    e.once('rollback', async () => {\n      e.removeAllListeners('close');\n      e.removeAllListeners('spawn');\n\n      try {\n        await rollback();\n        e.emit('rollback_completed');\n      } catch {\n        e.emit('rollback_failed');\n      } finally {\n        done = true;\n        resume?.();\n      }\n    });\n\n    while (!done) {\n      while (fns.length) {\n        const item = fns.shift();\n\n        if (item) {\n          const { fn, uuid } = item;\n\n          try {\n            const res = await fn(trx);\n            e.emit(uuid, { data: res });\n          } catch (error) {\n            e.emit(uuid, { error });\n          }\n        }\n      }\n      if (!done && !fns.length) {\n        // eslint-disable-next-line @typescript-eslint/no-loop-func\n        await new Promise<void>((resolve) => {\n          resume = resolve;\n        });\n      }\n    }\n  });\n\n  return {\n    async attach<T = undefined>(callback: TransactionCallback): Promise<T | undefined> {\n      const uuid = randomUUID();\n      e.emit('spawn', uuid, callback);\n      return new Promise<T | undefined>((resolve, reject) => {\n        e.on(uuid, ({ data, error }) => {\n          if (data) {\n            resolve(data);\n          }\n\n          if (error) {\n            reject(error);\n          }\n          resolve(undefined);\n        });\n      });\n    },\n\n    end() {\n      return e.emit('close');\n    },\n\n    rollback() {\n      return new Promise<boolean>((resolve) => {\n        e.emit('rollback');\n\n        e.once('rollback_failed', () => resolve(false));\n        e.once('rollback_completed', () => resolve(true));\n      });\n    },\n  };\n};\n","import { Middleware } from '../../types';\n\nexport const runMiddleware = async <T>(context: T, middlewares: Middleware<T>[]): Promise<void> => {\n  if (!middlewares.length) {\n    return;\n  }\n  const cb = middlewares[0];\n  await cb(context, async (newContext: T) => {\n    await runMiddleware(newContext, middlewares.slice(1));\n  });\n};\n","import { EventEmitter } from 'events';\n\nexport interface IDiagnosticReporterOptions {\n  stackSize?: number;\n}\n\nexport type GenericDiagnostic<K extends DiagnosticKind, T = unknown> = {\n  kind: K;\n  details: {\n    message: string;\n    createdAt: Date;\n  } & T;\n};\n\nexport type DiagnosticKind = 'error' | 'warning' | 'info';\n\nexport type DiagnosticListener<T extends DiagnosticKind = DiagnosticKind> = (\n  diagnostic: { kind: T } & Diagnostic extends infer U ? U : never\n) => void | Promise<void>;\n\nexport type DiagnosticEvent = 'diagnostic' | `diagnostic.${DiagnosticKind}`;\n\nexport type GetEventListener<E extends DiagnosticEvent> = E extends 'diagnostic'\n  ? DiagnosticListener\n  : E extends `diagnostic.${infer K}`\n    ? K extends DiagnosticKind\n      ? DiagnosticListener<K>\n      : never\n    : never;\n\nexport type Diagnostic = ErrorDiagnostic | WarningDiagnostic | InfoDiagnostic;\n\nexport type ErrorDiagnosticSeverity = 'fatal' | 'error' | 'silly';\n\nexport type ErrorDiagnostic = GenericDiagnostic<\n  'error',\n  {\n    name: string;\n    severity: ErrorDiagnosticSeverity;\n    error: Error;\n  }\n>;\n\nexport type WarningDiagnostic = GenericDiagnostic<\n  'warning',\n  {\n    origin?: string;\n  }\n>;\n\nexport type InfoDiagnostic<T = unknown> = GenericDiagnostic<\n  'info',\n  {\n    origin?: string;\n    params?: T;\n  }\n>;\n\nexport interface IDiagnosticReporter {\n  stack: {\n    readonly size: number;\n    readonly items: Diagnostic[];\n  };\n\n  report(diagnostic: Diagnostic): IDiagnosticReporter;\n  onDiagnostic(listener: DiagnosticListener): IDiagnosticReporter;\n  on<T extends DiagnosticKind>(kind: T, listener: DiagnosticListener<T>): IDiagnosticReporter;\n}\n\nconst createDiagnosticReporter = (\n  options: IDiagnosticReporterOptions = {}\n): IDiagnosticReporter => {\n  const { stackSize = -1 } = options;\n\n  const emitter = new EventEmitter();\n  const stack: Diagnostic[] = [];\n\n  const addListener = <T extends DiagnosticEvent>(event: T, listener: GetEventListener<T>) => {\n    emitter.on(event, listener);\n  };\n\n  const isDiagnosticValid = (diagnostic: Diagnostic) => {\n    if (!diagnostic.kind || !diagnostic.details || !diagnostic.details.message) {\n      return false;\n    }\n    return true;\n  };\n\n  return {\n    stack: {\n      get size() {\n        return stack.length;\n      },\n\n      get items() {\n        return stack;\n      },\n    },\n\n    report(diagnostic: Diagnostic) {\n      if (!isDiagnosticValid(diagnostic)) {\n        return this;\n      }\n\n      emitter.emit('diagnostic', diagnostic);\n      emitter.emit(`diagnostic.${diagnostic.kind}`, diagnostic);\n\n      if (stackSize !== -1 && stack.length >= stackSize) {\n        stack.shift();\n      }\n\n      stack.push(diagnostic);\n\n      return this;\n    },\n\n    onDiagnostic(listener: DiagnosticListener) {\n      addListener('diagnostic', listener);\n\n      return this;\n    },\n\n    on<T extends DiagnosticKind>(kind: T, listener: DiagnosticListener<T>) {\n      addListener(`diagnostic.${kind}`, listener as never);\n\n      return this;\n    },\n  };\n};\n\nexport { createDiagnosticReporter };\n","import type { Struct } from '@strapi/types';\nimport { isArray, isObject, reject } from 'lodash/fp';\nimport type { Diff } from '../../../utils/json';\nimport * as utils from '../../../utils';\n\nconst OPTIONAL_CONTENT_TYPES = ['audit-log'] as const;\n\nconst isAttributeIgnorable = (diff: Diff) => {\n  return (\n    diff.path.length === 3 &&\n    // Root property must be attributes\n    diff.path[0] === 'attributes' &&\n    // Need a valid string attribute name\n    typeof diff.path[1] === 'string' &&\n    // The diff must be on ignorable attribute properties\n    ['private', 'required', 'configurable', 'default'].includes(diff.path[2])\n  );\n};\n\n// TODO: clean up the type checking, which will require cleaning up the typings in utils/json.ts\n// exclude admin tables that are not transferable and are optionally available (such as audit logs which are only available in EE)\nconst isOptionalAdminType = (diff: Diff) => {\n  // added/deleted\n  if ('value' in diff && isObject(diff.value)) {\n    const name = (diff?.value as Struct.ContentTypeSchema)?.info?.singularName;\n    return (OPTIONAL_CONTENT_TYPES as ReadonlyArray<string | undefined>).includes(name);\n  }\n\n  // modified\n  if ('values' in diff && isArray(diff.values) && isObject(diff.values[0])) {\n    const name = (diff?.values[0] as Struct.ContentTypeSchema)?.info?.singularName;\n    return (OPTIONAL_CONTENT_TYPES as ReadonlyArray<string | undefined>).includes(name);\n  }\n\n  return false;\n};\n\nconst isIgnorableStrict = (diff: Diff) => isAttributeIgnorable(diff) || isOptionalAdminType(diff);\n\nconst strategies = {\n  // No diffs\n  exact(diffs: Diff[]) {\n    return diffs;\n  },\n\n  // Strict: all content types must match except:\n  // - the property within a content type is an ignorable one\n  // - those that are (not transferrable and optionally available), for example EE features such as audit logs\n  strict(diffs: Diff[]) {\n    return reject(isIgnorableStrict, diffs);\n  },\n};\n\nconst compareSchemas = <T, P>(a: T, b: P, strategy: keyof typeof strategies) => {\n  const diffs = utils.json.diff(a, b);\n  return strategies[strategy](diffs);\n};\n\nexport { compareSchemas };\n","import { ErrorDiagnosticSeverity } from '../utils/diagnostic';\n\nexport const SeverityKind: Record<string, ErrorDiagnosticSeverity> = {\n  FATAL: 'fatal',\n  ERROR: 'error',\n  SILLY: 'silly',\n} as const;\nexport type Severity = (typeof SeverityKind)[keyof typeof SeverityKind];\n","import { Severity } from './constants';\n\nclass DataTransferError<T = unknown> extends Error {\n  origin: string;\n\n  severity: Severity;\n\n  details: T | null;\n\n  constructor(origin: string, severity: Severity, message?: string, details?: T | null) {\n    super(message);\n\n    this.origin = origin;\n    this.severity = severity;\n    this.details = details ?? null;\n  }\n}\n\nexport { DataTransferError };\n","import { DataTransferError, Severity, SeverityKind } from '../errors';\n\ntype TransferEngineStep = 'initialization' | 'validation' | 'transfer';\n\ntype TransferEngineErrorDetails<P extends TransferEngineStep = TransferEngineStep, U = never> = {\n  step: P;\n} & ([U] extends [never] ? unknown : { details?: U });\n\nclass TransferEngineError<\n  P extends TransferEngineStep = TransferEngineStep,\n  U = never,\n  T extends TransferEngineErrorDetails<P, U> = TransferEngineErrorDetails<P, U>,\n> extends DataTransferError<T> {\n  constructor(severity: Severity, message?: string, details?: T | null) {\n    super('engine', severity, message, details);\n  }\n}\n\nclass TransferEngineInitializationError extends TransferEngineError<'initialization'> {\n  constructor(message?: string) {\n    super(SeverityKind.FATAL, message, { step: 'initialization' });\n  }\n}\n\nclass TransferEngineValidationError<\n  T extends { check: string } = { check: string },\n> extends TransferEngineError<'validation', T> {\n  constructor(message?: string, details?: T) {\n    super(SeverityKind.FATAL, message, { step: 'validation', details });\n  }\n}\n\nclass TransferEngineTransferError<\n  T extends { check: string } = { check: string },\n> extends TransferEngineError<'transfer', T> {\n  constructor(message?: string, details?: T) {\n    super(SeverityKind.FATAL, message, { step: 'transfer', details });\n  }\n}\n\nexport {\n  TransferEngineError,\n  TransferEngineInitializationError,\n  TransferEngineValidationError,\n  TransferEngineTransferError,\n};\n","import { capitalize } from 'lodash/fp';\n\nimport type { IDestinationProvider, ISourceProvider, ProviderType } from '../../../types';\nimport { TransferEngineValidationError } from '../errors';\n\nconst reject = (reason: string): never => {\n  throw new TransferEngineValidationError(`Invalid provider supplied. ${reason}`);\n};\n\nconst validateProvider = <T extends ProviderType>(\n  type: ProviderType,\n  provider?: ([T] extends ['source'] ? ISourceProvider : IDestinationProvider) | null\n) => {\n  if (!provider) {\n    return reject(\n      `Expected an instance of \"${capitalize(type)}Provider\", but got \"${typeof provider}\" instead.`\n    );\n  }\n\n  if (provider.type !== type) {\n    return reject(\n      `Expected the provider to be of type \"${type}\" but got \"${provider.type}\" instead.`\n    );\n  }\n};\n\nexport { validateProvider };\n","import { ErrorCode } from '../../types';\nimport { DataTransferError } from './base';\nimport { Severity, SeverityKind } from './constants';\n\ntype ProviderStep = 'initialization' | 'validation' | 'transfer';\n\nexport type ProviderErrorDetails<P extends ProviderStep = ProviderStep, U = never> = {\n  step: P;\n  code?: ErrorCode;\n} & ([U] extends [never] ? unknown : { details?: U });\n\nexport class ProviderError<\n  P extends ProviderStep = ProviderStep,\n  U = never,\n  T extends ProviderErrorDetails<P, U> = ProviderErrorDetails<P, U>,\n> extends DataTransferError<T> {\n  constructor(severity: Severity, message?: string, details?: T | null) {\n    super('provider', severity, message, details);\n  }\n}\n\nexport class ProviderInitializationError extends ProviderError<'initialization'> {\n  constructor(message?: string) {\n    super(SeverityKind.FATAL, message, { step: 'initialization' });\n  }\n}\n\n// TODO: these types are not working correctly, ProviderTransferError() is accepting any details object rather than requiring T\nexport class ProviderValidationError<T = ProviderErrorDetails> extends ProviderError<\n  'validation',\n  T\n> {\n  constructor(message?: string, details?: T) {\n    super(SeverityKind.SILLY, message, { step: 'validation', details });\n  }\n}\n// TODO: these types are not working correctly, ProviderTransferError() is accepting any details object rather than requiring T\nexport class ProviderTransferError<T = ProviderErrorDetails> extends ProviderError<'transfer', T> {\n  constructor(message?: string, details?: T) {\n    super(SeverityKind.FATAL, message, { step: 'transfer', details });\n  }\n}\n","import { PassThrough, Transform, Readable, Writable } from 'stream';\nimport { pipeline } from 'stream/promises';\nimport { extname } from 'path';\nimport { EOL } from 'os';\nimport type Chain from 'stream-chain';\nimport { chain } from 'stream-chain';\nimport { isEmpty, uniq, last, isNumber, set, pick } from 'lodash/fp';\nimport { diff as semverDiff } from 'semver';\n\nimport type { Struct, Utils } from '@strapi/types';\n\nimport type {\n  IAsset,\n  IDestinationProvider,\n  IEntity,\n  ILink,\n  IMetadata,\n  ISourceProvider,\n  ITransferEngine,\n  ITransferEngineOptions,\n  TransferProgress,\n  ITransferResults,\n  TransferStage,\n  TransferTransform,\n  IProvider,\n  TransferFilters,\n  TransferFilterPreset,\n  StreamItem,\n  SchemaDiffHandler,\n  SchemaDiffHandlerContext,\n  ErrorHandler,\n  ErrorHandlerContext,\n  ErrorHandlers,\n  ErrorCode,\n} from '../../types';\nimport type { Diff } from '../utils/json';\n\nimport { compareSchemas, validateProvider } from './validation';\n\nimport { TransferEngineError, TransferEngineValidationError } from './errors';\nimport {\n  createDiagnosticReporter,\n  IDiagnosticReporter,\n  ErrorDiagnosticSeverity,\n} from '../utils/diagnostic';\nimport { DataTransferError } from '../errors';\nimport * as utils from '../utils';\nimport { ProviderTransferError } from '../errors/providers';\n\nexport const TRANSFER_STAGES: ReadonlyArray<TransferStage> = Object.freeze([\n  'entities',\n  'links',\n  'assets',\n  'schemas',\n  'configuration',\n]);\n\nexport type TransferGroupFilter = Record<TransferFilterPreset, TransferFilters>;\n\n/**\n * Preset filters for only/exclude options\n * */\nexport const TransferGroupPresets: TransferGroupFilter = {\n  content: {\n    links: true, // Example: content includes the entire links stage\n    entities: true,\n    // TODO: If we need to implement filtering on a running stage, it would be done like this, but we still need to implement it\n    // [\n    //   // Example: content processes the entities stage, but filters individual entities\n    //   {\n    //     filter(data) {\n    //       return shouldIncludeThisData(data);\n    //     },\n    //   },\n    // ],\n  },\n  files: {\n    assets: true,\n  },\n  config: {\n    configuration: true,\n  },\n};\n\nexport const DEFAULT_VERSION_STRATEGY = 'ignore';\nexport const DEFAULT_SCHEMA_STRATEGY = 'strict';\n\ntype SchemaMap = Utils.String.Dict<Struct.Schema>;\n\nclass TransferEngine<\n  S extends ISourceProvider = ISourceProvider,\n  D extends IDestinationProvider = IDestinationProvider,\n> implements ITransferEngine\n{\n  sourceProvider: ISourceProvider;\n\n  destinationProvider: IDestinationProvider;\n\n  options: ITransferEngineOptions;\n\n  #metadata: { source?: IMetadata; destination?: IMetadata } = {};\n\n  #schema: { source?: SchemaMap; destination?: SchemaMap } = {};\n\n  // Progress of the current stage\n  progress: {\n    // metrics on the progress such as size and record count\n    data: TransferProgress;\n    // stream that emits events\n    stream: PassThrough;\n  };\n\n  diagnostics: IDiagnosticReporter;\n\n  #handlers: {\n    schemaDiff: SchemaDiffHandler[];\n    errors: Partial<ErrorHandlers>;\n  } = {\n    schemaDiff: [],\n    errors: {},\n  };\n\n  #currentStreamController?: AbortController;\n\n  #aborted: boolean = false;\n\n  onSchemaDiff(handler: SchemaDiffHandler) {\n    this.#handlers?.schemaDiff?.push(handler);\n  }\n\n  addErrorHandler(handlerName: ErrorCode, handler: ErrorHandler) {\n    if (!this.#handlers.errors[handlerName]) {\n      this.#handlers.errors[handlerName] = [];\n    }\n    this.#handlers.errors[handlerName]?.push(handler);\n  }\n\n  async attemptResolveError(error: Error) {\n    const context: ErrorHandlerContext = {};\n    if (error instanceof ProviderTransferError && error.details?.details.code) {\n      const errorCode = error.details?.details.code as ErrorCode;\n      if (!this.#handlers.errors[errorCode]) {\n        this.#handlers.errors[errorCode] = [];\n      }\n      await utils.middleware.runMiddleware(context ?? {}, this.#handlers.errors[errorCode] ?? []);\n    }\n\n    return !!context.ignore;\n  }\n\n  constructor(sourceProvider: S, destinationProvider: D, options: ITransferEngineOptions) {\n    this.diagnostics = createDiagnosticReporter();\n\n    validateProvider('source', sourceProvider);\n    validateProvider('destination', destinationProvider);\n\n    this.sourceProvider = sourceProvider;\n    this.destinationProvider = destinationProvider;\n    this.options = options;\n\n    this.progress = { data: {}, stream: new PassThrough({ objectMode: true }) };\n  }\n\n  /**\n   * Report a fatal error and throw it\n   */\n  panic(error: Error) {\n    this.reportError(error, 'fatal');\n\n    throw error;\n  }\n\n  /**\n   * Report an error diagnostic\n   */\n  reportError(error: Error, severity: ErrorDiagnosticSeverity) {\n    this.diagnostics.report({\n      kind: 'error',\n      details: {\n        severity,\n        createdAt: new Date(),\n        name: error.name,\n        message: error.message,\n        error,\n      },\n    });\n  }\n\n  /**\n   * Report a warning diagnostic\n   */\n  reportWarning(message: string, origin?: string) {\n    this.diagnostics.report({\n      kind: 'warning',\n      details: { createdAt: new Date(), message, origin },\n    });\n  }\n\n  /**\n   * Report an info diagnostic\n   */\n  reportInfo(message: string, params?: unknown) {\n    this.diagnostics.report({\n      kind: 'info',\n      details: { createdAt: new Date(), message, params, origin: 'engine' },\n    });\n  }\n\n  /**\n   * Create and return a transform stream based on the given stage and options.\n   *\n   * Allowed transformations includes 'filter' and 'map'.\n   */\n  #createStageTransformStream<T extends TransferStage>(\n    key: T,\n    options: { includeGlobal?: boolean } = {}\n  ): PassThrough | Transform {\n    const { includeGlobal = true } = options;\n    const { throttle } = this.options;\n    const { global: globalTransforms, [key]: stageTransforms } = this.options?.transforms ?? {};\n\n    let stream: PassThrough | Chain = new PassThrough({ objectMode: true });\n\n    const applyTransforms = <U>(transforms: TransferTransform<U>[] = []) => {\n      const chainTransforms: StreamItem[] = [];\n      for (const transform of transforms) {\n        if ('filter' in transform) {\n          chainTransforms.push(utils.stream.filter(transform.filter));\n        }\n\n        if ('map' in transform) {\n          chainTransforms.push(utils.stream.map(transform.map));\n        }\n      }\n      if (chainTransforms.length) {\n        stream = stream.pipe(chain(chainTransforms));\n      }\n    };\n\n    if (includeGlobal) {\n      applyTransforms(globalTransforms);\n    }\n\n    if (isNumber(throttle) && throttle > 0) {\n      stream = stream.pipe(\n        new PassThrough({\n          objectMode: true,\n          async transform(data, _encoding, callback) {\n            await new Promise((resolve) => {\n              setTimeout(resolve, throttle);\n            });\n            callback(null, data);\n          },\n        })\n      );\n    }\n\n    applyTransforms(stageTransforms as TransferTransform<unknown>[]);\n\n    return stream;\n  }\n\n  /**\n   * Update the Engine's transfer progress data for a given stage.\n   *\n   * Providing aggregate options enable custom computation to get the size (bytes) or the aggregate key associated with the data\n   */\n  #updateTransferProgress<T = unknown>(\n    stage: TransferStage,\n    data: T,\n    aggregate?: {\n      size?: (value: T) => number;\n      key?: (value: T) => string;\n    }\n  ) {\n    if (!this.progress.data[stage]) {\n      this.progress.data[stage] = { count: 0, bytes: 0, startTime: Date.now() };\n    }\n\n    const stageProgress = this.progress.data[stage];\n\n    if (!stageProgress) {\n      return;\n    }\n\n    const size = aggregate?.size?.(data) ?? JSON.stringify(data).length;\n    const key = aggregate?.key?.(data);\n\n    stageProgress.count += 1;\n    stageProgress.bytes += size;\n\n    // Handle aggregate updates if necessary\n    if (key) {\n      if (!stageProgress.aggregates) {\n        stageProgress.aggregates = {};\n      }\n\n      const { aggregates } = stageProgress;\n\n      if (!aggregates[key]) {\n        aggregates[key] = { count: 0, bytes: 0 };\n      }\n\n      aggregates[key].count += 1;\n      aggregates[key].bytes += size;\n    }\n  }\n\n  /**\n   * Create and return a PassThrough stream.\n   *\n   * Upon writing data into it, it'll update the Engine's transfer progress data and trigger stage update events.\n   */\n  #progressTracker(\n    stage: TransferStage,\n    aggregate?: {\n      size?(value: unknown): number;\n      key?(value: unknown): string;\n    }\n  ) {\n    return new PassThrough({\n      objectMode: true,\n      transform: (data, _encoding, callback) => {\n        this.#updateTransferProgress(stage, data, aggregate);\n        this.#emitStageUpdate('progress', stage);\n        callback(null, data);\n      },\n    });\n  }\n\n  /**\n   * Shorthand method used to trigger transfer update events to every listeners\n   */\n  #emitTransferUpdate(type: 'init' | 'start' | 'finish' | 'error', payload?: object) {\n    this.progress.stream.emit(`transfer::${type}`, payload);\n  }\n\n  /**\n   * Shorthand method used to trigger stage update events to every listeners\n   */\n  #emitStageUpdate(\n    type: 'start' | 'finish' | 'progress' | 'skip' | 'error',\n    transferStage: TransferStage\n  ) {\n    this.progress.stream.emit(`stage::${type}`, {\n      data: this.progress.data,\n      stage: transferStage,\n    });\n  }\n\n  /**\n   * Run a version check between two strapi version (source and destination) using the strategy given to the engine during initialization.\n   *\n   * If there is a mismatch, throws a validation error.\n   */\n  #assertStrapiVersionIntegrity(sourceVersion?: string, destinationVersion?: string) {\n    const strategy = this.options.versionStrategy || DEFAULT_VERSION_STRATEGY;\n\n    const reject = () => {\n      throw new TransferEngineValidationError(\n        `The source and destination provide are targeting incompatible Strapi versions (using the \"${strategy}\" strategy). The source (${this.sourceProvider.name}) version is ${sourceVersion} and the destination (${this.destinationProvider.name}) version is ${destinationVersion}`,\n        {\n          check: 'strapi.version',\n          strategy,\n          versions: { source: sourceVersion, destination: destinationVersion },\n        }\n      );\n    };\n\n    if (\n      !sourceVersion ||\n      !destinationVersion ||\n      strategy === 'ignore' ||\n      destinationVersion === sourceVersion\n    ) {\n      return;\n    }\n\n    let diff;\n    try {\n      diff = semverDiff(sourceVersion, destinationVersion);\n    } catch {\n      reject();\n    }\n\n    if (!diff) {\n      return;\n    }\n\n    const validPatch = ['prelease', 'build'];\n    const validMinor = [...validPatch, 'patch', 'prepatch'];\n    const validMajor = [...validMinor, 'minor', 'preminor'];\n    if (strategy === 'patch' && validPatch.includes(diff)) {\n      return;\n    }\n    if (strategy === 'minor' && validMinor.includes(diff)) {\n      return;\n    }\n    if (strategy === 'major' && validMajor.includes(diff)) {\n      return;\n    }\n\n    reject();\n  }\n\n  /**\n   * Run a check between two set of schemas (source and destination) using the strategy given to the engine during initialization.\n   *\n   * If there are differences and/or incompatibilities between source and destination schemas, then throw a validation error.\n   */\n  #assertSchemasMatching(sourceSchemas: SchemaMap, destinationSchemas: SchemaMap) {\n    const strategy = this.options.schemaStrategy || DEFAULT_SCHEMA_STRATEGY;\n\n    if (strategy === 'ignore') {\n      return;\n    }\n\n    const keys = uniq(Object.keys(sourceSchemas).concat(Object.keys(destinationSchemas)));\n    const diffs: { [key: string]: Diff[] } = {};\n\n    keys.forEach((key) => {\n      const sourceSchema = sourceSchemas[key];\n      const destinationSchema = destinationSchemas[key];\n      const schemaDiffs = compareSchemas(sourceSchema, destinationSchema, strategy);\n\n      if (schemaDiffs.length) {\n        diffs[key] = schemaDiffs as Diff<Struct.Schema>[];\n      }\n    });\n\n    if (!isEmpty(diffs)) {\n      const formattedDiffs = Object.entries(diffs)\n        .map(([uid, ctDiffs]) => {\n          let msg = `- ${uid}:${EOL}`;\n\n          msg += ctDiffs\n            .sort((a, b) => (a.kind > b.kind ? -1 : 1))\n            .map((diff) => {\n              const path = diff.path.join('.');\n\n              if (diff.kind === 'added') {\n                return `${path} exists in destination schema but not in source schema and the data will not be transferred.`;\n              }\n\n              if (diff.kind === 'deleted') {\n                return `${path} exists in source schema but not in destination schema and the data will not be transferred.`;\n              }\n\n              if (diff.kind === 'modified') {\n                if (diff.types[0] === diff.types[1]) {\n                  return `Schema value changed at \"${path}\": \"${diff.values[0]}\" (${diff.types[0]}) => \"${diff.values[1]}\" (${diff.types[1]})`;\n                }\n\n                return `Schema has differing data types at \"${path}\": \"${diff.values[0]}\" (${diff.types[0]}) => \"${diff.values[1]}\" (${diff.types[1]})`;\n              }\n\n              throw new TransferEngineValidationError(`Invalid diff found for \"${uid}\"`, {\n                check: `schema on ${uid}`,\n              });\n            })\n            .map((line) => `  - ${line}`)\n            .join(EOL);\n\n          return msg;\n        })\n        .join(EOL);\n\n      throw new TransferEngineValidationError(\n        `Invalid schema changes detected during integrity checks (using the ${strategy} strategy). Please find a summary of the changes below:\\n${formattedDiffs}`,\n        {\n          check: 'schema.changes',\n          strategy,\n          diffs,\n        }\n      );\n    }\n  }\n\n  shouldSkipStage(stage: TransferStage) {\n    const { exclude, only } = this.options;\n\n    // schemas must always be included\n    if (stage === 'schemas') {\n      return false;\n    }\n\n    // everything is included by default unless 'only' has been set\n    let included = isEmpty(only);\n    if (only && only.length > 0) {\n      included = only.some((transferGroup) => {\n        return TransferGroupPresets[transferGroup][stage];\n      });\n    }\n\n    if (exclude && exclude.length > 0) {\n      if (included) {\n        included = !exclude.some((transferGroup) => {\n          return TransferGroupPresets[transferGroup][stage];\n        });\n      }\n    }\n\n    return !included;\n  }\n\n  async #transferStage(options: {\n    stage: TransferStage;\n    source?: Readable;\n    destination?: Writable;\n    transform?: PassThrough | Chain;\n    tracker?: PassThrough;\n  }) {\n    if (this.#aborted) {\n      throw new TransferEngineError('fatal', 'Transfer aborted.');\n    }\n\n    const { stage, source, destination, transform, tracker } = options;\n\n    const updateEndTime = () => {\n      const stageData = this.progress.data[stage];\n\n      if (stageData) {\n        stageData.endTime = Date.now();\n      }\n    };\n\n    if (!source || !destination || this.shouldSkipStage(stage)) {\n      // Wait until source and destination are closed\n      const results = await Promise.allSettled(\n        [source, destination].map((stream) => {\n          // if stream is undefined or already closed, resolve immediately\n          if (!stream || stream.destroyed) {\n            return Promise.resolve();\n          }\n\n          // Wait until the close event is produced and then destroy the stream and resolve\n          return new Promise((resolve, reject) => {\n            stream.on('close', resolve).on('error', reject).destroy();\n          });\n        })\n      );\n\n      results.forEach((state) => {\n        if (state.status === 'rejected') {\n          this.reportWarning(state.reason, `transfer(${stage})`);\n        }\n      });\n\n      this.#emitStageUpdate('skip', stage);\n\n      return;\n    }\n\n    this.#emitStageUpdate('start', stage);\n\n    try {\n      const streams: (Readable | Writable)[] = [source];\n\n      if (transform) {\n        streams.push(transform);\n      }\n      if (tracker) {\n        streams.push(tracker);\n      }\n\n      streams.push(destination);\n\n      // NOTE: to debug/confirm backpressure issues from misbehaving stream, uncomment the following lines\n      // source.on('pause', () => console.log(`[${stage}] Source paused due to backpressure`));\n      // source.on('resume', () => console.log(`[${stage}] Source resumed`));\n      // destination.on('drain', () =>\n      //   console.log(`[${stage}] Destination drained, resuming data flow`)\n      // );\n      // destination.on('error', (err) => console.error(`[${stage}] Destination error:`, err));\n\n      const controller = new AbortController();\n      const { signal } = controller;\n\n      // Store the controller so you can cancel later\n      this.#currentStreamController = controller;\n\n      await pipeline(streams, { signal });\n\n      this.#emitStageUpdate('finish', stage);\n    } catch (e) {\n      updateEndTime();\n      this.#emitStageUpdate('error', stage);\n      this.reportError(e as Error, 'error');\n      if (!destination.destroyed) {\n        destination.destroy(e as Error);\n      }\n    } finally {\n      updateEndTime();\n    }\n  }\n\n  // Cause an ongoing transfer to abort gracefully\n  async abortTransfer(): Promise<void> {\n    this.#aborted = true;\n    this.#currentStreamController?.abort();\n    throw new TransferEngineError('fatal', 'Transfer aborted.');\n  }\n\n  async init(): Promise<void> {\n    // Resolve providers' resource and store\n    // them in the engine's internal state\n    await this.#resolveProviderResource();\n\n    // Update the destination provider's source metadata\n    const { source: sourceMetadata } = this.#metadata;\n\n    if (sourceMetadata) {\n      this.destinationProvider.setMetadata?.('source', sourceMetadata);\n    }\n  }\n\n  /**\n   * Run the bootstrap method in both source and destination providers\n   */\n  async bootstrap(): Promise<void> {\n    const results = await Promise.allSettled([\n      this.sourceProvider.bootstrap?.(this.diagnostics),\n      this.destinationProvider.bootstrap?.(this.diagnostics),\n    ]);\n\n    results.forEach((result) => {\n      if (result.status === 'rejected') {\n        this.panic(result.reason);\n      }\n    });\n  }\n\n  /**\n   * Run the close method in both source and destination providers\n   */\n  async close(): Promise<void> {\n    const results = await Promise.allSettled([\n      this.sourceProvider.close?.(),\n      this.destinationProvider.close?.(),\n    ]);\n\n    results.forEach((result) => {\n      if (result.status === 'rejected') {\n        this.panic(result.reason);\n      }\n    });\n  }\n\n  async #resolveProviderResource() {\n    const sourceMetadata = await this.sourceProvider.getMetadata();\n    const destinationMetadata = await this.destinationProvider.getMetadata();\n\n    if (sourceMetadata) {\n      this.#metadata.source = sourceMetadata;\n    }\n\n    if (destinationMetadata) {\n      this.#metadata.destination = destinationMetadata;\n    }\n  }\n\n  async #getSchemas() {\n    if (!this.#schema.source) {\n      this.#schema.source = (await this.sourceProvider.getSchemas?.()) as SchemaMap;\n    }\n\n    if (!this.#schema.destination) {\n      this.#schema.destination = (await this.destinationProvider.getSchemas?.()) as SchemaMap;\n    }\n\n    return {\n      sourceSchemas: this.#schema.source,\n      destinationSchemas: this.#schema.destination,\n    };\n  }\n\n  async integrityCheck() {\n    const sourceMetadata = await this.sourceProvider.getMetadata();\n    const destinationMetadata = await this.destinationProvider.getMetadata();\n\n    if (sourceMetadata && destinationMetadata) {\n      this.#assertStrapiVersionIntegrity(\n        sourceMetadata?.strapi?.version,\n        destinationMetadata?.strapi?.version\n      );\n    }\n\n    const { sourceSchemas, destinationSchemas } = await this.#getSchemas();\n\n    try {\n      if (sourceSchemas && destinationSchemas) {\n        this.#assertSchemasMatching(sourceSchemas, destinationSchemas);\n      }\n    } catch (error) {\n      // if this is a schema matching error, allow handlers to resolve it\n      if (error instanceof TransferEngineValidationError && error.details?.details?.diffs) {\n        const schemaDiffs = error.details?.details?.diffs as Record<string, Diff[]>;\n\n        const context: SchemaDiffHandlerContext = {\n          ignoredDiffs: {},\n          diffs: schemaDiffs,\n          source: this.sourceProvider,\n          destination: this.destinationProvider,\n        };\n\n        // if we don't have any handlers, throw the original error\n        if (isEmpty(this.#handlers.schemaDiff)) {\n          throw error;\n        }\n\n        await utils.middleware.runMiddleware<SchemaDiffHandlerContext>(\n          context,\n          this.#handlers.schemaDiff\n        );\n\n        // if there are any remaining diffs that weren't ignored\n        const unresolvedDiffs = utils.json.diff(context.diffs, context.ignoredDiffs);\n        if (unresolvedDiffs.length) {\n          this.panic(\n            new TransferEngineValidationError('Unresolved differences in schema', {\n              check: 'schema.changes',\n              unresolvedDiffs,\n            })\n          );\n        }\n\n        return;\n      }\n\n      throw error;\n    }\n  }\n\n  async transfer(): Promise<ITransferResults<S, D>> {\n    // reset data between transfers\n    this.progress.data = {};\n\n    try {\n      this.#emitTransferUpdate('init');\n      await this.bootstrap();\n      await this.init();\n\n      await this.integrityCheck();\n\n      this.#emitTransferUpdate('start');\n\n      await this.beforeTransfer();\n\n      // Run the transfer stages\n      await this.transferSchemas();\n      await this.transferEntities();\n      await this.transferAssets();\n      await this.transferLinks();\n      await this.transferConfiguration();\n      // Gracefully close the providers\n      await this.close();\n\n      this.#emitTransferUpdate('finish');\n    } catch (e: unknown) {\n      this.#emitTransferUpdate('error', { error: e });\n\n      const lastDiagnostic = last(this.diagnostics.stack.items);\n      // Do not report an error diagnostic if the last one reported the same error\n      if (\n        e instanceof Error &&\n        (!lastDiagnostic || lastDiagnostic.kind !== 'error' || lastDiagnostic.details.error !== e)\n      ) {\n        this.reportError(e, (e as DataTransferError).severity || 'fatal');\n      }\n\n      // Rollback the destination provider if an exception is thrown during the transfer\n      // Note: This will be configurable in the future\n      await this.destinationProvider.rollback?.(e as Error);\n\n      throw e;\n    }\n\n    return {\n      source: this.sourceProvider.results,\n      destination: this.destinationProvider.results,\n      engine: this.progress.data,\n    };\n  }\n\n  async beforeTransfer(): Promise<void> {\n    const runWithDiagnostic = async (provider: IProvider) => {\n      try {\n        await provider.beforeTransfer?.();\n      } catch (error) {\n        if (error instanceof Error) {\n          const resolved = await this.attemptResolveError(error);\n\n          if (resolved) {\n            return;\n          }\n          this.panic(error);\n        } else {\n          this.panic(\n            new Error(`Unknwon error when executing \"beforeTransfer\" on the ${origin} provider`)\n          );\n        }\n      }\n    };\n\n    await runWithDiagnostic(this.sourceProvider);\n    await runWithDiagnostic(this.destinationProvider);\n  }\n\n  async transferSchemas(): Promise<void> {\n    const stage: TransferStage = 'schemas';\n    if (this.shouldSkipStage(stage)) {\n      return;\n    }\n\n    const source = await this.sourceProvider.createSchemasReadStream?.();\n    const destination = await this.destinationProvider.createSchemasWriteStream?.();\n\n    const transform = this.#createStageTransformStream(stage);\n    const tracker = this.#progressTracker(stage, {\n      key: (value: Struct.Schema) => value.modelType,\n    });\n\n    await this.#transferStage({ stage, source, destination, transform, tracker });\n  }\n\n  async transferEntities(): Promise<void> {\n    const stage: TransferStage = 'entities';\n    if (this.shouldSkipStage(stage)) {\n      return;\n    }\n\n    const source = await this.sourceProvider.createEntitiesReadStream?.();\n    const destination = await this.destinationProvider.createEntitiesWriteStream?.();\n\n    const transform = chain([\n      this.#createStageTransformStream(stage),\n      new Transform({\n        objectMode: true,\n        transform: async (entity: IEntity, _encoding, callback) => {\n          const { destinationSchemas: schemas } = await this.#getSchemas();\n\n          if (!schemas) {\n            return callback(null, entity);\n          }\n\n          // TODO: this would be safer if we only ignored things in ignoredDiffs, otherwise continue and let an error be thrown\n          const availableContentTypes = Object.entries(schemas)\n            .filter(([, schema]) => schema.modelType === 'contentType')\n            .map(([uid]) => uid);\n\n          // If the type of the transferred entity doesn't exist in the destination, then discard it\n          if (!availableContentTypes.includes(entity.type)) {\n            return callback(null, undefined);\n          }\n\n          const { type, data } = entity;\n          const attributes = schemas[type].attributes;\n          const attributesToKeep = Object.keys(attributes).concat('documentId');\n          const updatedEntity = set('data', pick(attributesToKeep, data), entity);\n\n          callback(null, updatedEntity);\n        },\n      }),\n    ]);\n\n    const tracker = this.#progressTracker(stage, { key: (value: IEntity) => value.type });\n\n    await this.#transferStage({ stage, source, destination, transform, tracker });\n  }\n\n  async transferLinks(): Promise<void> {\n    const stage: TransferStage = 'links';\n    if (this.shouldSkipStage(stage)) {\n      return;\n    }\n\n    const source = await this.sourceProvider.createLinksReadStream?.();\n    const destination = await this.destinationProvider.createLinksWriteStream?.();\n\n    const transform = chain([\n      this.#createStageTransformStream(stage),\n      new Transform({\n        objectMode: true,\n        transform: async (link: ILink, _encoding, callback) => {\n          const { destinationSchemas: schemas } = await this.#getSchemas();\n          if (!schemas) {\n            return callback(null, link);\n          }\n\n          // TODO: this would be safer if we only ignored things in ignoredDiffs, otherwise continue and let an error be thrown\n          const availableContentTypes = Object.keys(schemas);\n\n          const isValidType = (uid: string) => availableContentTypes.includes(uid);\n\n          if (!isValidType(link.left.type) || !isValidType(link.right.type)) {\n            return callback(null, undefined); // ignore the link\n          }\n\n          callback(null, link);\n        },\n      }),\n    ]);\n\n    const tracker = this.#progressTracker(stage);\n\n    await this.#transferStage({ stage, source, destination, transform, tracker });\n  }\n\n  async transferAssets(): Promise<void> {\n    const stage: TransferStage = 'assets';\n    if (this.shouldSkipStage(stage)) {\n      return;\n    }\n\n    const source = await this.sourceProvider.createAssetsReadStream?.();\n    const destination = await this.destinationProvider.createAssetsWriteStream?.();\n\n    const transform = this.#createStageTransformStream(stage);\n    const tracker = this.#progressTracker(stage, {\n      size: (value: IAsset) => value.stats.size,\n      key: (value: IAsset) => extname(value.filename) || 'No extension',\n    });\n\n    await this.#transferStage({ stage, source, destination, transform, tracker });\n  }\n\n  async transferConfiguration(): Promise<void> {\n    const stage: TransferStage = 'configuration';\n    if (this.shouldSkipStage(stage)) {\n      return;\n    }\n\n    const source = await this.sourceProvider.createConfigurationReadStream?.();\n    const destination = await this.destinationProvider.createConfigurationWriteStream?.();\n\n    const transform = this.#createStageTransformStream(stage);\n    const tracker = this.#progressTracker(stage);\n\n    await this.#transferStage({ stage, source, destination, transform, tracker });\n  }\n}\n\nexport const createTransferEngine = <S extends ISourceProvider, D extends IDestinationProvider>(\n  sourceProvider: S,\n  destinationProvider: D,\n  options: ITransferEngineOptions\n): TransferEngine<S, D> => {\n  return new TransferEngine<S, D>(sourceProvider, destinationProvider, options);\n};\n\nexport type {\n  TransferEngine,\n  ITransferEngine,\n  ITransferEngineOptions,\n  ISourceProvider,\n  IDestinationProvider,\n  TransferStage,\n  TransferFilterPreset,\n  ErrorHandlerContext,\n  SchemaDiffHandlerContext,\n  ITransferResults,\n};\n\nexport * as errors from './errors';\n","import _ from 'lodash';\nimport { get, has, omit, pipe, assign } from 'lodash/fp';\n\nimport { contentTypes as contentTypesUtils, async, errors } from '@strapi/utils';\nimport type { Modules, UID, Data, Utils, Schema, Core } from '@strapi/types';\n\ntype LoadedComponents<TUID extends UID.Schema> = Data.Entity<\n  TUID,\n  Schema.AttributeNamesByType<TUID, 'component' | 'dynamiczone'>\n>;\n\ntype ComponentValue = Schema.Attribute.Value<\n  Schema.Attribute.Component<UID.Component, false> | Schema.Attribute.Component<UID.Component, true>\n>;\n\ntype ComponentBody = {\n  [key: string]: Schema.Attribute.Value<\n    | Schema.Attribute.Component<UID.Component, false>\n    | Schema.Attribute.Component<UID.Component, true>\n    | Schema.Attribute.DynamicZone\n  >;\n};\n\nconst isDialectMySQL = () => strapi.db?.dialect.client === 'mysql';\n\nfunction omitComponentData(\n  contentType: Schema.ContentType,\n  data: Modules.EntityService.Params.Data.Input<Schema.ContentType['uid']>\n): Partial<Modules.EntityService.Params.Data.Input<Schema.ContentType['uid']>>;\nfunction omitComponentData(\n  contentType: Schema.Component,\n  data: Modules.EntityService.Params.Data.Input<Schema.Component['uid']>\n): Partial<Modules.EntityService.Params.Data.Input<Schema.Component['uid']>>;\nfunction omitComponentData(\n  contentType: Schema.ContentType | Schema.Component,\n  data: Modules.EntityService.Params.Data.Input<Schema.ContentType['uid'] | Schema.Component['uid']>\n): Partial<\n  Modules.EntityService.Params.Data.Input<Schema.ContentType['uid'] | Schema.Component['uid']>\n> {\n  const { attributes } = contentType;\n  const componentAttributes = Object.keys(attributes).filter((attributeName) =>\n    contentTypesUtils.isComponentAttribute(attributes[attributeName])\n  );\n\n  return omit(componentAttributes, data);\n}\n\n// NOTE: we could generalize the logic to allow CRUD of relation directly in the DB layer\nconst createComponents = async <\n  TUID extends UID.Schema,\n  TData extends Modules.EntityService.Params.Data.Input<TUID>,\n>(\n  uid: TUID,\n  data: TData\n) => {\n  const { attributes = {} } = strapi.getModel(uid);\n\n  const componentBody: ComponentBody = {};\n\n  const attributeNames = Object.keys(attributes);\n\n  for (const attributeName of attributeNames) {\n    const attribute = attributes[attributeName];\n\n    if (!has(attributeName, data) || !contentTypesUtils.isComponentAttribute(attribute)) {\n      continue;\n    }\n\n    if (attribute.type === 'component') {\n      const { component: componentUID, repeatable = false } = attribute;\n\n      const componentValue = data[attributeName as keyof TData];\n\n      if (componentValue === null) {\n        continue;\n      }\n\n      if (repeatable === true) {\n        if (!Array.isArray(componentValue)) {\n          throw new Error('Expected an array to create repeatable component');\n        }\n\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n        const components = (await async.map(\n          componentValue,\n          (value: any) => createComponent(componentUID, value),\n          { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\n        )) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, true>>;\n\n        componentBody[attributeName] = components.map(({ id }) => {\n          return {\n            id,\n            __pivot: {\n              field: attributeName,\n              component_type: componentUID,\n            },\n          };\n        });\n      } else {\n        const component = await createComponent(\n          componentUID,\n          componentValue as Modules.EntityService.Params.Data.Input<UID.Component>\n        );\n        componentBody[attributeName] = {\n          id: component.id,\n          __pivot: {\n            field: attributeName,\n            component_type: componentUID,\n          },\n        };\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'dynamiczone') {\n      const dynamiczoneValues = data[\n        attributeName as keyof TData\n      ] as Modules.EntityService.Params.Attribute.GetValue<Schema.Attribute.DynamicZone>;\n\n      if (!Array.isArray(dynamiczoneValues)) {\n        throw new Error('Expected an array to create repeatable component');\n      }\n\n      const createDynamicZoneComponents = async (\n        value: Utils.Array.Values<typeof dynamiczoneValues>\n      ) => {\n        const { id } = await createComponent(value.__component, value);\n        return {\n          id,\n          __component: value.__component,\n          __pivot: {\n            field: attributeName,\n          },\n        };\n      };\n\n      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n      componentBody[attributeName] = await async.map(\n        dynamiczoneValues,\n        createDynamicZoneComponents,\n        { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\n      );\n\n      continue;\n    }\n  }\n\n  return componentBody;\n};\n\nconst getComponents = async <TUID extends UID.Schema>(\n  uid: TUID,\n  entity: { id: Modules.EntityService.Params.Attribute.ID }\n): Promise<LoadedComponents<TUID>> => {\n  const componentAttributes = contentTypesUtils.getComponentAttributes(strapi.getModel(uid));\n\n  if (_.isEmpty(componentAttributes)) {\n    return {} as LoadedComponents<TUID>;\n  }\n\n  return strapi.db.query(uid).load(entity, componentAttributes) as Promise<LoadedComponents<TUID>>;\n};\n\n/*\n  delete old components\n  create or update\n*/\nconst updateComponents = async <\n  TUID extends UID.Schema,\n  TData extends Partial<Modules.EntityService.Params.Data.Input<TUID>>,\n>(\n  uid: TUID,\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  data: TData\n) => {\n  const { attributes = {} } = strapi.getModel(uid);\n\n  const componentBody: ComponentBody = {};\n\n  for (const attributeName of Object.keys(attributes)) {\n    const attribute = attributes[attributeName];\n\n    if (!has(attributeName, data)) {\n      continue;\n    }\n\n    if (attribute.type === 'component') {\n      const { component: componentUID, repeatable = false } = attribute;\n\n      const componentValue = data[\n        attributeName as keyof TData\n      ] as Schema.Attribute.Value<Schema.Attribute.Component>;\n\n      await deleteOldComponents(uid, componentUID, entityToUpdate, attributeName, componentValue);\n\n      if (repeatable === true) {\n        if (!Array.isArray(componentValue)) {\n          throw new Error('Expected an array to create repeatable component');\n        }\n\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n        const components = (await async.map(\n          componentValue,\n          (value: any) => updateOrCreateComponent(componentUID, value),\n          { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\n        )) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, true>>;\n\n        componentBody[attributeName] = components.filter(_.negate(_.isNil)).map(({ id }) => {\n          return {\n            id,\n            __pivot: {\n              field: attributeName,\n              component_type: componentUID,\n            },\n          };\n        });\n      } else {\n        const component = await updateOrCreateComponent(componentUID, componentValue);\n        componentBody[attributeName] = component && {\n          id: component.id,\n          __pivot: {\n            field: attributeName,\n            component_type: componentUID,\n          },\n        };\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'dynamiczone') {\n      const dynamiczoneValues = data[\n        attributeName as keyof TData\n      ] as Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n\n      await deleteOldDZComponents(uid, entityToUpdate, attributeName, dynamiczoneValues);\n\n      if (!Array.isArray(dynamiczoneValues)) {\n        throw new Error('Expected an array to create repeatable component');\n      }\n\n      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n      componentBody[attributeName] = await async.map(\n        dynamiczoneValues,\n        async (value: any) => {\n          const { id } = await updateOrCreateComponent(value.__component, value);\n\n          return {\n            id,\n            __component: value.__component,\n            __pivot: {\n              field: attributeName,\n            },\n          };\n        },\n        { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\n      );\n\n      continue;\n    }\n  }\n\n  return componentBody;\n};\n\nconst pickStringifiedId = ({\n  id,\n}: {\n  id: Modules.EntityService.Params.Attribute.ID;\n}): Modules.EntityService.Params.Attribute.ID & string => {\n  if (typeof id === 'string') {\n    return id;\n  }\n\n  return `${id}`;\n};\n\nconst deleteOldComponents = async <TUID extends UID.Schema>(\n  uid: TUID,\n  componentUID: UID.Component,\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  attributeName: string,\n  componentValue: Schema.Attribute.Value<Schema.Attribute.Component>\n) => {\n  const previousValue = (await strapi.db\n    .query(uid)\n    .load(entityToUpdate, attributeName)) as ComponentValue;\n\n  const idsToKeep = _.castArray(componentValue).filter(has('id')).map(pickStringifiedId);\n  const allIds = _.castArray(previousValue).filter(has('id')).map(pickStringifiedId);\n\n  idsToKeep.forEach((id) => {\n    if (!allIds.includes(id)) {\n      throw new errors.ApplicationError(\n        `Some of the provided components in ${attributeName} are not related to the entity`\n      );\n    }\n  });\n\n  const idsToDelete = _.difference(allIds, idsToKeep);\n\n  if (idsToDelete.length > 0) {\n    for (const idToDelete of idsToDelete) {\n      await deleteComponent(componentUID, { id: idToDelete });\n    }\n  }\n};\n\nconst deleteOldDZComponents = async <TUID extends UID.Schema>(\n  uid: TUID,\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  attributeName: string,\n  dynamiczoneValues: Schema.Attribute.Value<Schema.Attribute.DynamicZone>\n) => {\n  const previousValue = (await strapi.db\n    .query(uid)\n    .load(entityToUpdate, attributeName)) as Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n\n  const idsToKeep = _.castArray(dynamiczoneValues)\n    .filter(has('id'))\n    .map((v) => ({\n      id: pickStringifiedId(v),\n      __component: v.__component,\n    }));\n\n  const allIds = _.castArray(previousValue)\n    .filter(has('id'))\n    .map((v) => ({\n      id: pickStringifiedId(v),\n      __component: v.__component,\n    }));\n\n  idsToKeep.forEach(({ id, __component }) => {\n    if (!allIds.find((el) => el.id === id && el.__component === __component)) {\n      const err = new Error(\n        `Some of the provided components in ${attributeName} are not related to the entity`\n      );\n\n      Object.assign(err, { status: 400 });\n      throw err;\n    }\n  });\n\n  type IdsToDelete = Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n\n  const idsToDelete = allIds.reduce((acc, { id, __component }) => {\n    if (!idsToKeep.find((el) => el.id === id && el.__component === __component)) {\n      acc.push({ id, __component });\n    }\n\n    return acc;\n  }, [] as IdsToDelete);\n\n  if (idsToDelete.length > 0) {\n    for (const idToDelete of idsToDelete) {\n      const { id, __component } = idToDelete;\n      await deleteComponent(__component, { id });\n    }\n  }\n};\n\nconst deleteComponents = async <TUID extends UID.Schema, TEntity extends Data.Entity<TUID>>(\n  uid: TUID,\n  entityToDelete: TEntity,\n  { loadComponents = true } = {}\n) => {\n  const { attributes = {} } = strapi.getModel(uid);\n\n  const attributeNames = Object.keys(attributes);\n\n  for (const attributeName of attributeNames) {\n    const attribute = attributes[attributeName];\n\n    if (attribute.type === 'component' || attribute.type === 'dynamiczone') {\n      let value;\n      if (loadComponents) {\n        value = await strapi.db.query(uid).load(entityToDelete, attributeName);\n      } else {\n        value = entityToDelete[attributeName as keyof TEntity];\n      }\n\n      if (!value) {\n        continue;\n      }\n\n      if (attribute.type === 'component') {\n        const { component: componentUID } = attribute;\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n        await async.map(\n          _.castArray(value),\n          (subValue: any) => deleteComponent(componentUID, subValue),\n          {\n            concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity,\n          }\n        );\n      } else {\n        // delete dynamic zone components\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n        await async.map(\n          _.castArray(value),\n          (subValue: any) => deleteComponent(subValue.__component, subValue),\n          { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\n        );\n      }\n\n      continue;\n    }\n  }\n};\n\n/** *************************\n    Component queries\n************************** */\n\n// components can have nested compos so this must be recursive\nconst createComponent = async <TUID extends UID.Component = UID.Component>(\n  uid: TUID,\n  data: Modules.EntityService.Params.Data.Input<TUID>\n) => {\n  const model = strapi.getModel(uid) as Schema.Component;\n\n  const componentData = await createComponents(uid, data);\n  const transform = pipe(\n    // Make sure we don't save the component with a pre-defined ID\n    omit('id'),\n    // Remove the component data from the original data object ...\n    (payload) => omitComponentData(model, payload),\n    // ... and assign the newly created component instead\n    assign(componentData)\n  );\n\n  return strapi.db.query(uid).create({ data: transform(data) });\n};\n\n// components can have nested compos so this must be recursive\nconst updateComponent = async <TUID extends UID.Component>(\n  uid: TUID,\n  componentToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  data: Modules.EntityService.Params.Data.Input<TUID>\n) => {\n  const model = strapi.getModel(uid) as Schema.Component;\n\n  const componentData = await updateComponents(uid, componentToUpdate, data);\n\n  return strapi.db.query(uid).update({\n    where: {\n      id: componentToUpdate.id,\n    },\n    data: Object.assign(omitComponentData(model, data), componentData),\n  });\n};\n\nconst updateOrCreateComponent = <TUID extends UID.Component>(\n  componentUID: TUID,\n  value: Modules.EntityService.Params.Data.Input<TUID>\n) => {\n  if (value === null) {\n    return null;\n  }\n\n  // update\n  if ('id' in value && typeof value.id !== 'undefined') {\n    // TODO: verify the compo is associated with the entity\n    return updateComponent(componentUID, { id: value.id }, value);\n  }\n\n  // create\n  return createComponent(componentUID, value);\n};\n\nconst deleteComponent = async <TUID extends UID.Component>(\n  uid: TUID,\n  componentToDelete: Data.Component<TUID>\n) => {\n  await deleteComponents(uid, componentToDelete);\n  await strapi.db.query(uid).delete({ where: { id: componentToDelete.id } });\n};\n\n/**\n * Resolve the component UID of an entity's attribute based\n * on a given path (components & dynamic zones only)\n */\nconst resolveComponentUID = ({\n  paths,\n  strapi,\n  data,\n  contentType,\n}: {\n  paths: string[];\n  strapi: Core.Strapi;\n  data: any;\n  contentType: Schema.ContentType;\n}): UID.Schema | undefined => {\n  let value: unknown = data;\n  let cType:\n    | Schema.ContentType\n    | Schema.Component\n    | ((...opts: any[]) => Schema.ContentType | Schema.Component) = contentType;\n  for (const path of paths) {\n    value = get(path, value);\n\n    // Needed when the value of cType should be computed\n    // based on the next value (eg: dynamic zones)\n    if (typeof cType === 'function') {\n      cType = cType(value);\n    }\n\n    if (path in cType.attributes) {\n      const attribute: Schema.Attribute.AnyAttribute = cType.attributes[path];\n\n      if (attribute.type === 'component') {\n        cType = strapi.getModel(attribute.component);\n      }\n\n      if (attribute.type === 'dynamiczone') {\n        cType = ({ __component }: { __component: UID.Component }) => strapi.getModel(__component);\n      }\n    }\n  }\n\n  if ('uid' in cType) {\n    return cType.uid;\n  }\n\n  return undefined;\n};\n\nexport {\n  omitComponentData,\n  getComponents,\n  createComponents,\n  updateComponents,\n  deleteComponents,\n  deleteComponent,\n  resolveComponentUID,\n};\n","import { assign, isArray, isEmpty, isObject, map, omit, size } from 'lodash/fp';\n\nimport type { Core, UID, Data, Struct } from '@strapi/types';\nimport * as componentsService from '../../utils/components';\n\nconst sanitizeComponentLikeAttributes = <T extends Struct.Schema>(\n  model: T,\n  data: Data.Entity<T['uid']>\n) => {\n  const { attributes } = model;\n\n  const componentLikeAttributesKey = Object.entries(attributes)\n    .filter(([, attribute]) => attribute.type === 'component' || attribute.type === 'dynamiczone')\n    .map(([key]) => key);\n\n  return omit(componentLikeAttributesKey, data);\n};\n\nconst omitInvalidCreationAttributes = omit(['id']);\n\nconst createEntityQuery = (strapi: Core.Strapi): any => {\n  const components = {\n    async assignToEntity(uid: UID.Schema, data: any) {\n      const model = strapi.getModel(uid);\n\n      const entityComponents = await componentsService.createComponents(uid, data);\n      const dataWithoutComponents = sanitizeComponentLikeAttributes(model, data);\n\n      return assign(entityComponents, dataWithoutComponents);\n    },\n\n    async get<T extends object>(uid: string, entity: T) {\n      return componentsService.getComponents(uid as UID.Schema, entity as any);\n    },\n\n    delete<T extends object>(uid: string, componentsToDelete: T) {\n      return componentsService.deleteComponents(uid as UID.Schema, componentsToDelete as any, {\n        loadComponents: false,\n      });\n    },\n  };\n\n  const query = (uid: UID.Schema) => {\n    const create = async <T extends { data: U }, U extends object>(params: T) => {\n      const dataWithComponents = await components.assignToEntity(uid, params.data);\n      const sanitizedData = omitInvalidCreationAttributes(dataWithComponents);\n\n      return strapi.db.query(uid).create({ ...params, data: sanitizedData });\n    };\n\n    const createMany = async <T extends { data: U[] }, U extends object>(params: T) => {\n      return (\n        Promise.resolve(params.data)\n          // Create components for each entity\n          .then(map((data) => components.assignToEntity(uid, data)))\n          // Remove unwanted attributes\n          .then(map(omitInvalidCreationAttributes))\n          // Execute a strapi db createMany query with all the entities + their created components\n          .then((data) => strapi.db.query(uid).createMany({ ...params, data }))\n      );\n    };\n\n    const deleteMany = async <T extends object>(params?: T) => {\n      const entitiesToDelete = await strapi.db.query(uid).findMany(params ?? {});\n\n      if (!entitiesToDelete.length) {\n        return null;\n      }\n\n      const componentsToDelete = await Promise.all(\n        entitiesToDelete.map((entityToDelete) => components.get(uid, entityToDelete))\n      );\n\n      const deletedEntities = await strapi.db.query(uid).deleteMany(params);\n      await Promise.all(componentsToDelete.map((compos) => components.delete(uid, compos)));\n\n      return deletedEntities;\n    };\n\n    const getDeepPopulateComponentLikeQuery = (\n      contentType: Struct.Schema,\n      params = { select: '*' }\n    ) => {\n      const { attributes } = contentType;\n\n      const populate: any = {};\n\n      const entries: [string, any][] = Object.entries(attributes);\n\n      for (const [key, attribute] of entries) {\n        if (attribute.type === 'component') {\n          const component = strapi.getModel(attribute.component);\n          const subPopulate = getDeepPopulateComponentLikeQuery(component, params);\n\n          if ((isArray(subPopulate) || isObject(subPopulate)) && size(subPopulate) > 0) {\n            populate[key] = { ...params, populate: subPopulate };\n          }\n\n          if (isArray(subPopulate) && isEmpty(subPopulate)) {\n            populate[key] = { ...params };\n          }\n        }\n\n        if (attribute.type === 'dynamiczone') {\n          const { components: componentsUID } = attribute;\n\n          const on: any = {};\n\n          for (const componentUID of componentsUID) {\n            const component = strapi.getModel(componentUID);\n            const subPopulate = getDeepPopulateComponentLikeQuery(component, params);\n\n            if ((isArray(subPopulate) || isObject(subPopulate)) && size(subPopulate) > 0) {\n              on[componentUID] = { ...params, populate: subPopulate };\n            }\n\n            if (isArray(subPopulate) && isEmpty(subPopulate)) {\n              on[componentUID] = { ...params };\n            }\n          }\n\n          populate[key] = size(on) > 0 ? { on } : true;\n        }\n      }\n\n      const values = Object.values(populate);\n\n      if (values.every((value) => value === true)) {\n        return Object.keys(populate);\n      }\n\n      return populate;\n    };\n\n    return {\n      create,\n      createMany,\n      deleteMany,\n      getDeepPopulateComponentLikeQuery,\n\n      get deepPopulateComponentLikeQuery() {\n        const contentType = strapi.getModel(uid);\n\n        return getDeepPopulateComponentLikeQuery(contentType);\n      },\n    };\n  };\n\n  return query;\n};\n\nexport { createEntityQuery };\n","import type { Knex } from 'knex';\nimport { clone, isNil } from 'lodash/fp';\nimport type { Core } from '@strapi/types';\n\nimport { ILink } from '../../../types';\n\n// TODO: Remove any types when we'll have types for DB metadata\n\nexport const createLinkQuery = (strapi: Core.Strapi, trx?: Knex.Transaction) => {\n  const query = () => {\n    const { connection } = strapi.db;\n\n    // TODO: Export utils from database and use the addSchema that is already written\n    const addSchema = (tableName: string) => {\n      const schemaName = connection.client.connectionSettings.schema;\n      return schemaName ? `${schemaName}.${tableName}` : tableName;\n    };\n\n    async function* generateAllForAttribute(uid: string, fieldName: string): AsyncGenerator<ILink> {\n      const metadata = strapi.db.metadata.get(uid);\n\n      if (!metadata) {\n        throw new Error(`No metadata found for ${uid}`);\n      }\n\n      const attributes = filterValidRelationalAttributes(metadata.attributes);\n\n      if (!(fieldName in attributes)) {\n        throw new Error(`${fieldName} is not a valid relational attribute name`);\n      }\n\n      const attribute = attributes[fieldName];\n\n      const kind = getLinkKind(attribute, uid);\n      const { relation, target } = attribute;\n\n      // The relation is stored in the same table\n      // TODO: handle manyToOne joinColumn\n      if (attribute.joinColumn) {\n        const joinColumnName: string = attribute.joinColumn.name;\n\n        const qb = connection\n          .queryBuilder()\n          .select('id', joinColumnName)\n          .from(addSchema(metadata.tableName));\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        // TODO: stream the query to improve performances\n        const entries = await qb;\n\n        for (const entry of entries) {\n          const ref = entry[joinColumnName];\n\n          if (ref !== null) {\n            yield {\n              kind,\n              relation,\n              left: { type: uid, ref: entry.id, field: fieldName },\n              right: { type: target, ref },\n            };\n          }\n        }\n      }\n\n      // The relation uses a join table\n      if (attribute.joinTable) {\n        const {\n          name,\n          joinColumn,\n          inverseJoinColumn,\n          orderColumnName,\n          morphColumn,\n          inverseOrderColumnName,\n        } = attribute.joinTable;\n\n        const qb = connection.queryBuilder().from(addSchema(name));\n\n        type Columns = {\n          left: { ref: string | null; order?: string };\n          right: { ref: string | null; order?: string; type?: string; field?: string };\n        };\n\n        const columns: Columns = {\n          left: { ref: null },\n          right: { ref: null },\n        };\n\n        const left: Partial<ILink['left']> = { type: uid, field: fieldName };\n        const right: Partial<ILink['right']> = {};\n\n        if (kind === 'relation.basic' || kind === 'relation.circular') {\n          right.type = attribute.target;\n          right.field = attribute.inversedBy;\n\n          columns.left.ref = joinColumn.name;\n          columns.right.ref = inverseJoinColumn.name;\n\n          if (orderColumnName) {\n            columns.left.order = orderColumnName as string;\n          }\n\n          if (inverseOrderColumnName) {\n            columns.right.order = inverseOrderColumnName as string;\n          }\n        }\n\n        if (kind === 'relation.morph') {\n          columns.left.ref = joinColumn.name;\n\n          columns.right.ref = morphColumn.idColumn.name;\n          columns.right.type = morphColumn.typeColumn.name;\n          columns.right.field = 'field';\n          columns.right.order = 'order';\n        }\n\n        const validColumns = [\n          // Left\n          columns.left.ref,\n          columns.left.order,\n          // Right\n          columns.right.ref,\n          columns.right.type,\n          columns.right.field,\n          columns.right.order,\n        ].filter((column: string | null | undefined) => !isNil(column));\n\n        qb.select(validColumns);\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        // TODO: stream the query to improve performances\n        const entries = await qb;\n\n        for (const entry of entries) {\n          if (columns.left.ref) {\n            left.ref = entry[columns.left.ref];\n          }\n\n          if (columns.right.ref) {\n            right.ref = entry[columns.right.ref];\n          }\n\n          if (columns.left.order) {\n            left.pos = entry[columns.left.order as string];\n          }\n\n          if (columns.right.order) {\n            right.pos = entry[columns.right.order as string];\n          }\n\n          if (columns.right.type) {\n            right.type = entry[columns.right.type as string];\n          }\n\n          if (columns.right.field) {\n            right.field = entry[columns.right.field as string];\n          }\n\n          const link: ILink = {\n            kind,\n            relation,\n            left: clone(left as ILink['left']),\n            right: clone(right as ILink['right']),\n          };\n\n          yield link;\n        }\n      }\n\n      if (attribute.morphColumn) {\n        const { typeColumn, idColumn } = attribute.morphColumn;\n\n        const qb = connection\n          .queryBuilder()\n          .select('id', typeColumn.name, idColumn.name)\n          .from(addSchema(metadata.tableName))\n          .whereNotNull(typeColumn.name)\n          .whereNotNull(idColumn.name);\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        const entries = await qb;\n\n        for (const entry of entries) {\n          const ref = entry[idColumn.name];\n\n          yield {\n            kind,\n            relation,\n            left: { type: uid, ref: entry.id, field: fieldName },\n            right: { type: entry[typeColumn.name], ref },\n          };\n        }\n      }\n    }\n\n    async function* generateAll(uid: string): AsyncGenerator<ILink> {\n      const metadata = strapi.db.metadata.get(uid);\n\n      if (!metadata) {\n        throw new Error(`No metadata found for ${uid}`);\n      }\n\n      const attributes = filterValidRelationalAttributes(metadata.attributes);\n\n      for (const fieldName of Object.keys(attributes)) {\n        for await (const link of generateAllForAttribute(uid, fieldName)) {\n          yield link;\n        }\n      }\n    }\n\n    const insert = async (link: ILink) => {\n      const { kind, left, right } = link;\n\n      const metadata = strapi.db.metadata.get(left.type);\n      const attribute = metadata.attributes[left.field];\n\n      const payload = {};\n\n      /**\n       * This _should_ only happen for attributes that are added dynamically e.g. review-workflow stages\n       * and a user is importing EE data into a CE project.\n       */\n      if (!attribute) {\n        return;\n      }\n\n      if (attribute.type !== 'relation') {\n        throw new Error(`Attribute ${left.field} is not a relation`);\n      }\n\n      if ('joinColumn' in attribute && attribute.joinColumn) {\n        const joinColumnName = attribute.joinColumn.name;\n\n        // Note: this addSchema may not be necessary, but is added for safety\n        const qb = connection(addSchema(metadata.tableName))\n          .where('id', left.ref)\n          .update({ [joinColumnName]: right.ref });\n        if (trx) {\n          qb.transacting(trx);\n        }\n        await qb;\n      }\n\n      if ('joinTable' in attribute && attribute.joinTable) {\n        const { joinTable } = attribute;\n\n        if (joinTable.joinColumn) {\n          Object.assign(payload, { [joinTable.joinColumn.name]: left.ref });\n        }\n\n        const assignInverseColumn = () => {\n          if ('inverseJoinColumn' in joinTable && joinTable.inverseJoinColumn) {\n            Object.assign(payload, {\n              [joinTable.inverseJoinColumn.name]: right.ref,\n            });\n          }\n        };\n\n        const assignOrderColumns = () => {\n          if ('orderColumnName' in joinTable && joinTable.orderColumnName) {\n            Object.assign(payload, { [joinTable.orderColumnName]: left.pos ?? null });\n          }\n\n          if ('inverseOrderColumnName' in joinTable && joinTable.inverseOrderColumnName) {\n            Object.assign(payload, { [joinTable.inverseOrderColumnName]: right.pos ?? null });\n          }\n        };\n\n        const assignMorphColumns = () => {\n          if ('morphColumn' in joinTable && joinTable.morphColumn) {\n            const { idColumn, typeColumn } = joinTable.morphColumn ?? {};\n\n            if (idColumn) {\n              Object.assign(payload, { [idColumn.name]: right.ref });\n            }\n\n            if (typeColumn) {\n              Object.assign(payload, { [typeColumn.name]: right.type });\n            }\n\n            Object.assign(payload, { order: right.pos ?? null, field: right.field ?? null });\n          }\n        };\n\n        if (kind === 'relation.basic' || kind === 'relation.circular') {\n          assignInverseColumn();\n        }\n\n        if (kind === 'relation.morph') {\n          assignMorphColumns();\n        }\n\n        assignOrderColumns();\n        const qb = connection.insert(payload).into(addSchema(joinTable.name));\n        if (trx) {\n          await qb.transacting(trx);\n        }\n      }\n\n      if ('morphColumn' in attribute && attribute.morphColumn) {\n        const { morphColumn } = attribute;\n\n        const qb = connection(addSchema(metadata.tableName))\n          .where('id', left.ref)\n          .update({\n            [morphColumn.idColumn.name]: right.ref,\n            [morphColumn.typeColumn.name]: right.type,\n          });\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        await qb;\n      }\n    };\n\n    return { generateAll, generateAllForAttribute, insert };\n  };\n\n  return query;\n};\n\nexport const filterValidRelationalAttributes = (attributes: Record<string, any>) => {\n  const isOwner = (attribute: any) => {\n    return attribute.owner || (!attribute.mappedBy && !attribute.morphBy);\n  };\n\n  const isComponentLike = (attribute: any) => attribute.joinTable?.name.endsWith('_cmps');\n\n  return Object.entries(attributes)\n    .filter(([, attribute]) => {\n      return attribute.type === 'relation' && isOwner(attribute) && !isComponentLike(attribute);\n    })\n    .reduce<Record<string, any>>((acc, [key, attribute]) => ({ ...acc, [key]: attribute }), {});\n};\n\nconst getLinkKind = (attribute: any, uid: string): ILink['kind'] => {\n  if (attribute.relation.startsWith('morph')) {\n    return 'relation.morph';\n  }\n\n  if (attribute.target === uid) {\n    return 'relation.circular';\n  }\n\n  return 'relation.basic';\n};\n","import { Writable } from 'stream';\nimport type { Core, UID } from '@strapi/types';\n\nimport { last } from 'lodash/fp';\n\nimport { ProviderTransferError } from '../../../../../errors/providers';\nimport type { IEntity, Transaction } from '../../../../../../types';\nimport { json } from '../../../../../utils';\nimport * as queries from '../../../../queries';\nimport { resolveComponentUID } from '../../../../../utils/components';\n\ninterface IEntitiesRestoreStreamOptions {\n  strapi: Core.Strapi;\n  updateMappingTable<TSchemaUID extends UID.Schema>(\n    type: TSchemaUID,\n    oldID: number,\n    newID: number\n  ): void;\n  transaction?: Transaction;\n}\n\nexport const createEntitiesWriteStream = (options: IEntitiesRestoreStreamOptions) => {\n  const { strapi, updateMappingTable, transaction } = options;\n  const query = queries.entity.createEntityQuery(strapi);\n\n  return new Writable({\n    objectMode: true,\n\n    async write(entity: IEntity, _encoding, callback) {\n      await transaction?.attach(async () => {\n        const { type, id, data } = entity;\n        const { create, getDeepPopulateComponentLikeQuery } = query(type);\n        const contentType = strapi.getModel(type);\n\n        try {\n          const created = await create({\n            data,\n            populate: getDeepPopulateComponentLikeQuery(contentType, { select: 'id' }),\n            select: 'id',\n          });\n\n          // Compute differences between original & new entities\n          const diffs = json.diff(data, created);\n\n          updateMappingTable(type, id, created.id);\n\n          // For each difference found on an ID attribute,\n          // update the mapping the table accordingly\n          diffs.forEach((diff) => {\n            if (diff.kind === 'modified' && last(diff.path) === 'id' && 'kind' in contentType) {\n              const target = resolveComponentUID({ paths: diff.path, data, contentType, strapi });\n\n              // If no type is found for the given path, then ignore the diff\n              if (!target) {\n                return;\n              }\n\n              const [oldID, newID] = diff.values as [number, number];\n\n              updateMappingTable(target, oldID, newID);\n            }\n          });\n        } catch (e) {\n          if (e instanceof Error) {\n            return callback(e);\n          }\n\n          return callback(new ProviderTransferError(`Failed to create \"${type}\" (${id})`));\n        }\n\n        return callback(null);\n      });\n    },\n  });\n};\n","import { Writable } from 'stream';\nimport { omit } from 'lodash/fp';\nimport chalk from 'chalk';\nimport type { Core } from '@strapi/types';\nimport { ProviderTransferError } from '../../../../../errors/providers';\nimport { IConfiguration, Transaction } from '../../../../../../types';\n\nconst omitInvalidCreationAttributes = omit(['id']);\n\nconst restoreCoreStore = async <T extends { value: unknown }>(strapi: Core.Strapi, values: T) => {\n  const data = omitInvalidCreationAttributes(values);\n  return strapi.db.query('strapi::core-store').create({\n    data: {\n      ...data,\n      value: JSON.stringify(data.value),\n    },\n  });\n};\n\nconst restoreWebhooks = async <T extends { value: unknown }>(strapi: Core.Strapi, values: T) => {\n  const data = omitInvalidCreationAttributes(values);\n  return strapi.db.query('strapi::webhook').create({ data });\n};\n\nexport const restoreConfigs = async (strapi: Core.Strapi, config: IConfiguration) => {\n  if (config.type === 'core-store') {\n    return restoreCoreStore(strapi, config.value as { value: unknown });\n  }\n\n  if (config.type === 'webhook') {\n    return restoreWebhooks(strapi, config.value as { value: unknown });\n  }\n};\n\nexport const createConfigurationWriteStream = async (\n  strapi: Core.Strapi,\n  transaction?: Transaction\n) => {\n  return new Writable({\n    objectMode: true,\n    async write<T extends { id: number }>(\n      config: IConfiguration<T>,\n      _encoding: BufferEncoding,\n      callback: (error?: Error | null) => void\n    ) {\n      await transaction?.attach(async () => {\n        try {\n          await restoreConfigs(strapi, config);\n        } catch (error) {\n          return callback(\n            new ProviderTransferError(\n              `Failed to import ${chalk.yellowBright(config.type)} (${chalk.greenBright(\n                config.value.id\n              )}`\n            )\n          );\n        }\n        callback();\n      });\n    },\n  });\n};\n","import { Writable } from 'stream';\nimport type { Core } from '@strapi/types';\nimport { ProviderTransferError } from '../../../../../errors/providers';\nimport { ILink, Transaction } from '../../../../../../types';\nimport { createLinkQuery } from '../../../../queries/link';\n\ninterface ErrorWithCode extends Error {\n  code: string;\n}\n\nconst isErrorWithCode = (error: any): error is ErrorWithCode => {\n  return error && typeof error.code === 'string';\n};\n\nconst isForeignKeyConstraintError = (e: Error) => {\n  const MYSQL_FK_ERROR_CODES = ['1452', '1557', '1216', '1217', '1451'];\n  const POSTGRES_FK_ERROR_CODE = '23503';\n  const SQLITE_FK_ERROR_CODE = 'SQLITE_CONSTRAINT_FOREIGNKEY';\n\n  if (isErrorWithCode(e) && e.code) {\n    return [SQLITE_FK_ERROR_CODE, POSTGRES_FK_ERROR_CODE, ...MYSQL_FK_ERROR_CODES].includes(e.code);\n  }\n\n  return e.message.toLowerCase().includes('foreign key constraint');\n};\n\nexport const createLinksWriteStream = (\n  mapID: (uid: string, id: number) => number | undefined,\n  strapi: Core.Strapi,\n  transaction?: Transaction,\n  onWarning?: (message: string) => void\n) => {\n  return new Writable({\n    objectMode: true,\n    async write(link: ILink, _encoding, callback) {\n      await transaction?.attach(async (trx) => {\n        const { left, right } = link;\n        const query = createLinkQuery(strapi, trx);\n\n        const originalLeftRef = left.ref;\n        const originalRightRef = right.ref;\n\n        // Map IDs if needed\n        left.ref = mapID(left.type, originalLeftRef) ?? originalLeftRef;\n        right.ref = mapID(right.type, originalRightRef) ?? originalRightRef;\n\n        try {\n          await query().insert(link);\n        } catch (e) {\n          if (e instanceof Error) {\n            if (isForeignKeyConstraintError(e)) {\n              onWarning?.(\n                `Skipping link ${left.type}:${originalLeftRef} -> ${right.type}:${originalRightRef} due to a foreign key constraint.`\n              );\n              return callback(null);\n            }\n            return callback(e);\n          }\n\n          return callback(\n            new ProviderTransferError(\n              `An error happened while trying to import a ${left.type} link.`\n            )\n          );\n        }\n\n        callback(null);\n      });\n    },\n  });\n};\n","import type { Core, UID, Struct } from '@strapi/types';\nimport type { Model } from '@strapi/database';\nimport { ProviderTransferError } from '../../../../../errors/providers';\nimport * as queries from '../../../../queries';\n\nexport interface IRestoreOptions {\n  assets?: boolean; // delete media library files before transfer\n  configuration?: {\n    webhook?: boolean; // delete webhooks before transfer\n    coreStore?: boolean; // delete core store before transfer\n  };\n  entities?: {\n    include?: string[]; // only delete these stage entities before transfer\n    exclude?: string[]; // exclude these stage entities from deletion\n    filters?: ((contentType: Struct.ContentTypeSchema) => boolean)[]; // custom filters to exclude a content type from deletion\n    params?: { [uid: string]: unknown }; // params object passed to deleteMany before transfer for custom deletions\n  };\n}\n\ninterface IDeleteResults {\n  count: number;\n  aggregate: { [uid: string]: { count: number } };\n}\n\nexport const deleteRecords = async (strapi: Core.Strapi, options: IRestoreOptions) => {\n  const entities = await deleteEntitiesRecords(strapi, options);\n  const configuration = await deleteConfigurationRecords(strapi, options);\n\n  return {\n    count: entities.count + configuration.count,\n    entities,\n    configuration,\n  };\n};\n\nconst deleteEntitiesRecords = async (\n  strapi: Core.Strapi,\n  options: IRestoreOptions = {}\n): Promise<IDeleteResults> => {\n  const { entities } = options;\n\n  const models = strapi.get('models').get() as Model[];\n  const contentTypes = Object.values(strapi.contentTypes) as Struct.ContentTypeSchema[];\n\n  const contentTypesToClear = contentTypes\n    .filter((contentType) => {\n      let removeThisContentType = true;\n\n      // include means \"only include these types\" so if it's not in here, it's not being included\n      if (entities?.include) {\n        removeThisContentType = entities.include.includes(contentType.uid);\n      }\n\n      // if something is excluded, remove it. But lack of being excluded doesn't mean it's kept\n      if (entities?.exclude && entities.exclude.includes(contentType.uid)) {\n        removeThisContentType = false;\n      }\n\n      if (entities?.filters) {\n        removeThisContentType = entities.filters.every((filter) => filter(contentType));\n      }\n\n      return removeThisContentType;\n    })\n    .map((contentType) => contentType.uid);\n\n  const modelsToClear = models\n    .filter((model) => {\n      if (contentTypesToClear.includes(model.uid as UID.ContentType)) {\n        return false;\n      }\n\n      let removeThisModel = true;\n\n      // include means \"only include these types\" so if it's not in here, it's not being included\n      if (entities?.include) {\n        removeThisModel = entities.include.includes(model.uid);\n      }\n\n      // if something is excluded, remove it. But lack of being excluded doesn't mean it's kept\n      if (entities?.exclude && entities.exclude.includes(model.uid)) {\n        removeThisModel = false;\n      }\n\n      return removeThisModel;\n    })\n    .map((model) => model.uid);\n\n  const [results, updateResults] = useResults([...contentTypesToClear, ...modelsToClear]);\n\n  const contentTypeQuery = queries.entity.createEntityQuery(strapi);\n\n  const contentTypePromises = contentTypesToClear.map(async (uid) => {\n    const result = await contentTypeQuery(uid).deleteMany(entities?.params);\n\n    if (result) {\n      updateResults(result.count || 0, uid);\n    }\n  });\n\n  const modelsPromises = modelsToClear.map(async (uid) => {\n    const result = await strapi.db.query(uid).deleteMany({});\n\n    if (result) {\n      updateResults(result.count || 0, uid);\n    }\n  });\n\n  await Promise.all([...contentTypePromises, ...modelsPromises]);\n\n  return results;\n};\n\nconst deleteConfigurationRecords = async (\n  strapi: Core.Strapi,\n  options: IRestoreOptions = {}\n): Promise<IDeleteResults> => {\n  const { coreStore = true, webhook = true } = options?.configuration ?? {};\n\n  const models: string[] = [];\n\n  if (coreStore) {\n    models.push('strapi::core-store');\n  }\n\n  if (webhook) {\n    models.push('strapi::webhook');\n  }\n\n  const [results, updateResults] = useResults(models);\n\n  const deletePromises = models.map(async (uid) => {\n    const result = await strapi.db.query(uid).deleteMany({});\n\n    if (result) {\n      updateResults(result.count, uid);\n    }\n  });\n\n  await Promise.all(deletePromises);\n\n  return results;\n};\n\nconst useResults = (\n  keys: string[]\n): [IDeleteResults, (count: number, key?: string) => void | never] => {\n  const results: IDeleteResults = {\n    count: 0,\n    aggregate: keys.reduce((acc, key) => ({ ...acc, [key]: { count: 0 } }), {}),\n  };\n\n  const update = (count: number, key?: string) => {\n    if (key) {\n      if (!(key in results.aggregate)) {\n        throw new ProviderTransferError(`Unknown key \"${key}\" provided in results update`);\n      }\n\n      results.aggregate[key].count += count;\n    }\n\n    results.count += count;\n  };\n\n  return [results, update];\n};\n\nexport * from './entities';\nexport * from './configuration';\nexport * from './links';\n","import type { Core } from '@strapi/types';\n\nimport { ProviderInitializationError } from '../errors/providers';\n\nexport type ValidStrapiAssertion = (strapi: unknown, msg?: string) => asserts strapi is Core.Strapi;\n\nexport const assertValidStrapi: ValidStrapiAssertion = (strapi?: unknown, msg = '') => {\n  if (!strapi) {\n    throw new ProviderInitializationError(`${msg}. Strapi instance not found.`);\n  }\n};\n","import { Writable, Readable } from 'stream';\nimport path from 'path';\nimport * as fse from 'fs-extra';\nimport type { Knex } from 'knex';\nimport type { Core, Struct } from '@strapi/types';\nimport type {\n  IAsset,\n  IDestinationProvider,\n  IFile,\n  IMetadata,\n  ProviderType,\n  Transaction,\n} from '../../../../types';\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\n\nimport { restore } from './strategies';\nimport * as utils from '../../../utils';\nimport {\n  ProviderInitializationError,\n  ProviderTransferError,\n  ProviderValidationError,\n} from '../../../errors/providers';\nimport { assertValidStrapi } from '../../../utils/providers';\n\nexport const VALID_CONFLICT_STRATEGIES = ['restore'];\nexport const DEFAULT_CONFLICT_STRATEGY = 'restore';\n\nexport interface ILocalStrapiDestinationProviderOptions {\n  getStrapi(): Core.Strapi | Promise<Core.Strapi>; // return an initialized instance of Strapi\n\n  autoDestroy?: boolean; // shut down the instance returned by getStrapi() at the end of the transfer\n  restore?: restore.IRestoreOptions; // erase data in strapi database before transfer; required if strategy is 'restore'\n  strategy: 'restore'; // conflict management strategy; only the restore strategy is available at this time\n}\n\nclass LocalStrapiDestinationProvider implements IDestinationProvider {\n  name = 'destination::local-strapi';\n\n  type: ProviderType = 'destination';\n\n  options: ILocalStrapiDestinationProviderOptions;\n\n  strapi?: Core.Strapi;\n\n  transaction?: Transaction;\n\n  uploadsBackupDirectoryName: string;\n\n  onWarning?: ((message: string) => void) | undefined;\n\n  #diagnostics?: IDiagnosticReporter;\n\n  /**\n   * The entities mapper is used to map old entities to their new IDs\n   */\n  #entitiesMapper: { [type: string]: { [id: number]: number } };\n\n  constructor(options: ILocalStrapiDestinationProviderOptions) {\n    this.options = options;\n    this.#entitiesMapper = {};\n    this.uploadsBackupDirectoryName = `uploads_backup_${Date.now()}`;\n  }\n\n  async bootstrap(diagnostics?: IDiagnosticReporter): Promise<void> {\n    this.#diagnostics = diagnostics;\n    this.#validateOptions();\n    this.strapi = await this.options.getStrapi();\n    if (!this.strapi) {\n      throw new ProviderInitializationError('Could not access local strapi');\n    }\n    this.strapi.db.lifecycles.disable();\n    this.transaction = utils.transaction.createTransaction(this.strapi);\n  }\n\n  // TODO: either move this to restore strategy, or restore strategy should given access to these instead of repeating the logic possibly in a different way\n  #areAssetsIncluded = () => {\n    return this.options.restore?.assets;\n  };\n\n  #isContentTypeIncluded = (type: string) => {\n    const notIncluded =\n      this.options.restore?.entities?.include &&\n      !this.options.restore?.entities?.include?.includes(type);\n    const excluded =\n      this.options.restore?.entities?.exclude &&\n      this.options.restore?.entities.exclude.includes(type);\n\n    return !excluded && !notIncluded;\n  };\n\n  #reportInfo(message: string) {\n    this.#diagnostics?.report({\n      details: {\n        createdAt: new Date(),\n        message,\n        origin: 'local-destination-provider',\n      },\n      kind: 'info',\n    });\n  }\n\n  async close(): Promise<void> {\n    const { autoDestroy } = this.options;\n    assertValidStrapi(this.strapi);\n    this.transaction?.end();\n    this.strapi.db.lifecycles.enable();\n    // Basically `!== false` but more deterministic\n    if (autoDestroy === undefined || autoDestroy === true) {\n      await this.strapi?.destroy();\n    }\n  }\n\n  #validateOptions() {\n    this.#reportInfo('validating options');\n    if (!VALID_CONFLICT_STRATEGIES.includes(this.options.strategy)) {\n      throw new ProviderValidationError(`Invalid strategy ${this.options.strategy}`, {\n        check: 'strategy',\n        strategy: this.options.strategy,\n        validStrategies: VALID_CONFLICT_STRATEGIES,\n      });\n    }\n\n    // require restore options when using restore\n    if (this.options.strategy === 'restore' && !this.options.restore) {\n      throw new ProviderValidationError('Missing restore options');\n    }\n  }\n\n  async #deleteFromRestoreOptions() {\n    assertValidStrapi(this.strapi);\n    if (!this.options.restore) {\n      throw new ProviderValidationError('Missing restore options');\n    }\n    this.#reportInfo('deleting record ');\n    return restore.deleteRecords(this.strapi, this.options.restore);\n  }\n\n  async #deleteAllAssets(trx?: Knex.Transaction) {\n    assertValidStrapi(this.strapi);\n    this.#reportInfo('deleting all assets');\n    // if we're not restoring files, don't touch the files\n    if (!this.#areAssetsIncluded()) {\n      return;\n    }\n\n    const stream: Readable = this.strapi.db\n      // Create a query builder instance (default type is 'select')\n      .queryBuilder('plugin::upload.file')\n      // Fetch all columns\n      .select('*')\n      // Attach the transaction\n      .transacting(trx)\n      // Get a readable stream\n      .stream();\n\n    // TODO use bulk delete when exists in providers\n    for await (const file of stream) {\n      await this.strapi.plugin('upload').provider.delete(file);\n      if (file.formats) {\n        for (const fileFormat of Object.values(file.formats)) {\n          await this.strapi.plugin('upload').provider.delete(fileFormat);\n        }\n      }\n    }\n\n    this.#reportInfo('deleted all assets');\n  }\n\n  async rollback() {\n    this.#reportInfo('Rolling back transaction');\n    await this.transaction?.rollback();\n    this.#reportInfo('Rolled back transaction');\n  }\n\n  async beforeTransfer() {\n    if (!this.strapi) {\n      throw new Error('Strapi instance not found');\n    }\n\n    await this.transaction?.attach(async (trx) => {\n      try {\n        if (this.options.strategy === 'restore') {\n          await this.#handleAssetsBackup();\n          await this.#deleteAllAssets(trx);\n          await this.#deleteFromRestoreOptions();\n        }\n      } catch (error) {\n        throw new Error(`restore failed ${error}`);\n      }\n    });\n  }\n\n  getMetadata(): IMetadata {\n    this.#reportInfo('getting metadata');\n    assertValidStrapi(this.strapi, 'Not able to get Schemas');\n    const strapiVersion = this.strapi.config.get<string>('info.strapi');\n    const createdAt = new Date().toISOString();\n\n    return {\n      createdAt,\n      strapi: {\n        version: strapiVersion,\n      },\n    };\n  }\n\n  getSchemas(): Record<string, Struct.Schema> {\n    this.#reportInfo('getting schema');\n    assertValidStrapi(this.strapi, 'Not able to get Schemas');\n\n    const schemas = utils.schema.schemasToValidJSON({\n      ...this.strapi.contentTypes,\n      ...this.strapi.components,\n    });\n\n    return utils.schema.mapSchemasValues(schemas);\n  }\n\n  createEntitiesWriteStream(): Writable {\n    assertValidStrapi(this.strapi, 'Not able to import entities');\n    this.#reportInfo('creating entities stream');\n    const { strategy } = this.options;\n\n    const updateMappingTable = (type: string, oldID: number, newID: number) => {\n      if (!this.#entitiesMapper[type]) {\n        this.#entitiesMapper[type] = {};\n      }\n\n      Object.assign(this.#entitiesMapper[type], { [oldID]: newID });\n    };\n\n    if (strategy === 'restore') {\n      return restore.createEntitiesWriteStream({\n        strapi: this.strapi,\n        updateMappingTable,\n        transaction: this.transaction,\n      });\n    }\n\n    throw new ProviderValidationError(`Invalid strategy ${this.options.strategy}`, {\n      check: 'strategy',\n      strategy: this.options.strategy,\n      validStrategies: VALID_CONFLICT_STRATEGIES,\n    });\n  }\n\n  async #handleAssetsBackup() {\n    assertValidStrapi(this.strapi, 'Not able to create the assets backup');\n\n    // if we're not restoring assets, don't back them up because they won't be touched\n    if (!this.#areAssetsIncluded()) {\n      return;\n    }\n\n    if (this.strapi.config.get<{ provider: string }>('plugin::upload').provider === 'local') {\n      this.#reportInfo('creating assets backup directory');\n      const assetsDirectory = path.join(this.strapi.dirs.static.public, 'uploads');\n      const backupDirectory = path.join(\n        this.strapi.dirs.static.public,\n        this.uploadsBackupDirectoryName\n      );\n\n      try {\n        // Check access before attempting to do anything\n        await fse.access(\n          assetsDirectory,\n          // eslint-disable-next-line no-bitwise\n          fse.constants.W_OK | fse.constants.R_OK | fse.constants.F_OK\n        );\n        // eslint-disable-next-line no-bitwise\n        await fse.access(path.join(assetsDirectory, '..'), fse.constants.W_OK | fse.constants.R_OK);\n\n        await fse.move(assetsDirectory, backupDirectory);\n        await fse.mkdir(assetsDirectory);\n        // Create a .gitkeep file to ensure the directory is not empty\n        await fse.outputFile(path.join(assetsDirectory, '.gitkeep'), '');\n        this.#reportInfo(`created assets backup directory ${backupDirectory}`);\n      } catch (err) {\n        throw new ProviderTransferError(\n          'The backup folder for the assets could not be created inside the public folder. Please ensure Strapi has write permissions on the public directory',\n          {\n            code: 'ASSETS_DIRECTORY_ERR',\n          }\n        );\n      }\n      return backupDirectory;\n    }\n  }\n\n  async #removeAssetsBackup() {\n    assertValidStrapi(this.strapi, 'Not able to remove Assets');\n    // if we're not restoring assets, don't back them up because they won't be touched\n    if (!this.#areAssetsIncluded()) {\n      return;\n    }\n    // TODO: this should catch all thrown errors and bubble it up to engine so it can be reported as a non-fatal diagnostic message telling the user they may need to manually delete assets\n    if (this.strapi.config.get<{ provider: string }>('plugin::upload').provider === 'local') {\n      this.#reportInfo('removing assets backup');\n      assertValidStrapi(this.strapi);\n      const backupDirectory = path.join(\n        this.strapi.dirs.static.public,\n        this.uploadsBackupDirectoryName\n      );\n      await fse.rm(backupDirectory, { recursive: true, force: true });\n      this.#reportInfo('successfully removed assets backup');\n    }\n  }\n\n  // TODO: Move this logic to the restore strategy\n  async createAssetsWriteStream(): Promise<Writable> {\n    assertValidStrapi(this.strapi, 'Not able to stream Assets');\n    this.#reportInfo('creating assets write stream');\n    if (!this.#areAssetsIncluded()) {\n      throw new ProviderTransferError(\n        'Attempting to transfer assets when `assets` is not set in restore options'\n      );\n    }\n\n    const removeAssetsBackup = this.#removeAssetsBackup.bind(this);\n    const strapi = this.strapi;\n    const transaction = this.transaction;\n    const fileEntitiesMapper = this.#entitiesMapper['plugin::upload.file'];\n\n    const restoreMediaEntitiesContent = this.#isContentTypeIncluded('plugin::upload.file');\n\n    return new Writable({\n      objectMode: true,\n      async final(next) {\n        // Delete the backup folder\n        await removeAssetsBackup();\n        next();\n      },\n      async write(chunk: IAsset, _encoding, callback) {\n        await transaction?.attach(async () => {\n          const uploadData = {\n            ...chunk.metadata,\n            stream: Readable.from(chunk.stream),\n            buffer: chunk?.buffer,\n          };\n\n          const provider = strapi.config.get<{ provider: string }>('plugin::upload').provider;\n\n          const fileId = fileEntitiesMapper?.[uploadData.id];\n          if (!fileId) {\n            return callback(new Error(`File ID not found for ID: ${uploadData.id}`));\n          }\n\n          try {\n            await strapi.plugin('upload').provider.uploadStream(uploadData);\n\n            // if we're not supposed to transfer the associated entities, stop here\n            if (!restoreMediaEntitiesContent) {\n              return callback();\n            }\n\n            // Files formats are stored within the parent file entity\n            if (uploadData?.type) {\n              const entry: IFile = await strapi.db.query('plugin::upload.file').findOne({\n                where: { id: fileId },\n              });\n              if (!entry) {\n                throw new Error('file not found');\n              }\n              const specificFormat = entry?.formats?.[uploadData.type];\n              if (specificFormat) {\n                specificFormat.url = uploadData.url;\n              }\n              await strapi.db.query('plugin::upload.file').update({\n                where: { id: entry.id },\n                data: {\n                  formats: entry.formats,\n                  provider,\n                },\n              });\n              return callback();\n            }\n\n            const entry: IFile = await strapi.db.query('plugin::upload.file').findOne({\n              where: { id: fileId },\n            });\n            if (!entry) {\n              throw new Error('file not found');\n            }\n            entry.url = uploadData.url;\n            await strapi.db.query('plugin::upload.file').update({\n              where: { id: entry.id },\n              data: {\n                url: entry.url,\n                provider,\n              },\n            });\n            return callback();\n          } catch (error) {\n            return callback(new Error(`Error while uploading asset ${chunk.filename} ${error}`));\n          }\n        });\n      },\n    });\n  }\n\n  async createConfigurationWriteStream(): Promise<Writable> {\n    assertValidStrapi(this.strapi, 'Not able to stream Configurations');\n    this.#reportInfo('creating configuration write stream');\n    const { strategy } = this.options;\n\n    if (strategy === 'restore') {\n      return restore.createConfigurationWriteStream(this.strapi, this.transaction);\n    }\n\n    throw new ProviderValidationError(`Invalid strategy ${strategy}`, {\n      check: 'strategy',\n      strategy,\n      validStrategies: VALID_CONFLICT_STRATEGIES,\n    });\n  }\n\n  async createLinksWriteStream(): Promise<Writable> {\n    this.#reportInfo('creating links write stream');\n    if (!this.strapi) {\n      throw new Error('Not able to stream links. Strapi instance not found');\n    }\n\n    const { strategy } = this.options;\n    const mapID = (uid: string, id: number): number | undefined => this.#entitiesMapper[uid]?.[id];\n\n    if (strategy === 'restore') {\n      return restore.createLinksWriteStream(mapID, this.strapi, this.transaction, this.onWarning);\n    }\n\n    throw new ProviderValidationError(`Invalid strategy ${strategy}`, {\n      check: 'strategy',\n      strategy,\n      validStrategies: VALID_CONFLICT_STRATEGIES,\n    });\n  }\n}\n\nexport const createLocalStrapiDestinationProvider = (\n  options: ILocalStrapiDestinationProviderOptions\n) => {\n  return new LocalStrapiDestinationProvider(options);\n};\n","import { Readable, Transform } from 'stream';\nimport type { Core, Struct } from '@strapi/types';\n\nimport * as shared from '../../queries';\nimport { IEntity } from '../../../../types';\n\n/**\n * Generate and consume content-types streams in order to stream each entity individually\n */\nexport const createEntitiesStream = (strapi: Core.Strapi): Readable => {\n  const contentTypes: Struct.ContentTypeSchema[] = Object.values(strapi.contentTypes);\n\n  async function* contentTypeStreamGenerator() {\n    for (const contentType of contentTypes) {\n      const query = shared.entity.createEntityQuery(strapi).call(null, contentType.uid);\n\n      const stream: Readable = strapi.db\n        // Create a query builder instance (default type is 'select')\n        .queryBuilder(contentType.uid)\n        // Fetch all columns\n        .select('*')\n        // Apply the populate\n        .populate(query.deepPopulateComponentLikeQuery)\n        // Get a readable stream\n        .stream();\n\n      yield { contentType, stream };\n    }\n  }\n\n  return Readable.from(\n    (async function* entitiesGenerator(): AsyncGenerator<{\n      entity: IEntity;\n      contentType: Struct.ContentTypeSchema;\n    }> {\n      for await (const { stream, contentType } of contentTypeStreamGenerator()) {\n        try {\n          for await (const entity of stream) {\n            yield { entity, contentType };\n          }\n        } catch {\n          // ignore\n        } finally {\n          stream.destroy();\n        }\n      }\n    })()\n  );\n};\n\n/**\n * Create an entity transform stream which convert the output of\n * the multi-content-types stream to the transfer entity format\n */\nexport const createEntitiesTransformStream = (): Transform => {\n  return new Transform({\n    objectMode: true,\n    transform(data, _encoding, callback) {\n      const { entity, contentType } = data;\n      const { id, ...attributes } = entity;\n\n      callback(null, {\n        type: contentType.uid,\n        id,\n        data: attributes,\n      });\n    },\n  });\n};\n","import { Readable } from 'stream';\nimport type { Core } from '@strapi/types';\n\nimport type { ILink } from '../../../../types';\nimport { createLinkQuery } from '../../queries/link';\n\n/**\n * Create a Readable which will stream all the links from a Strapi instance\n */\nexport const createLinksStream = (strapi: Core.Strapi): Readable => {\n  const uids = [...Object.keys(strapi.contentTypes), ...Object.keys(strapi.components)] as string[];\n\n  // Async generator stream that returns every link from a Strapi instance\n  return Readable.from(\n    (async function* linkGenerator(): AsyncGenerator<ILink> {\n      const query = createLinkQuery(strapi);\n\n      for (const uid of uids) {\n        const generator = query().generateAll(uid);\n\n        for await (const link of generator) {\n          yield link;\n        }\n      }\n    })()\n  );\n};\n","import { Readable } from 'stream';\nimport { chain } from 'stream-chain';\nimport { set } from 'lodash/fp';\nimport type { Core } from '@strapi/types';\n\nimport type { IConfiguration } from '../../../../types';\n\n/**\n * Create a readable stream that export the Strapi app configuration\n */\nexport const createConfigurationStream = (strapi: Core.Strapi): Readable => {\n  return Readable.from(\n    (async function* configurationGenerator(): AsyncGenerator<IConfiguration> {\n      // Core Store\n      const coreStoreStream = chain([\n        strapi.db.queryBuilder('strapi::core-store').stream(),\n        (data) => set('value', JSON.parse(data.value), data),\n        wrapConfigurationItem('core-store'),\n      ]);\n\n      // Webhook\n      const webhooksStream = chain([\n        strapi.db.queryBuilder('strapi::webhook').stream(),\n        wrapConfigurationItem('webhook'),\n      ]);\n\n      const streams = [coreStoreStream, webhooksStream];\n\n      for (const stream of streams) {\n        for await (const item of stream) {\n          yield item;\n        }\n      }\n    })()\n  );\n};\n\nconst wrapConfigurationItem = (type: 'core-store' | 'webhook') => (value: unknown) => ({\n  type,\n  value,\n});\n","import { join } from 'path';\nimport { Duplex, PassThrough, Readable } from 'stream';\nimport * as webStream from 'stream/web';\nimport { stat, createReadStream, ReadStream } from 'fs-extra';\nimport type { Core } from '@strapi/types';\n\nimport type { IAsset, IFile } from '../../../../types';\n\nfunction getFileStream(\n  filepath: string,\n  strapi: Core.Strapi,\n  isLocal = false\n): PassThrough | ReadStream {\n  if (isLocal) {\n    // Todo: handle errors\n    return createReadStream(filepath);\n  }\n\n  const readableStream = new PassThrough();\n\n  // fetch the image from remote url and stream it\n  strapi\n    .fetch(filepath)\n    .then((res: Response) => {\n      if (res.status !== 200) {\n        readableStream.emit('error', new Error(`Request failed with status code ${res.status}`));\n        return;\n      }\n\n      if (res.body) {\n        // pipe the image data\n        Readable.fromWeb(new webStream.ReadableStream(res.body)).pipe(readableStream);\n      } else {\n        readableStream.emit('error', new Error('Empty data found for file'));\n      }\n    })\n    .catch((error: unknown) => {\n      readableStream.emit('error', error);\n    });\n\n  return readableStream;\n}\n\nfunction getFileStats(\n  filepath: string,\n  strapi: Core.Strapi,\n  isLocal = false\n): Promise<{ size: number }> {\n  if (isLocal) {\n    return stat(filepath);\n  }\n  return new Promise((resolve, reject) => {\n    strapi\n      .fetch(filepath)\n      .then((res: Response) => {\n        if (res.status !== 200) {\n          reject(new Error(`Request failed with status code ${res.status}`));\n          return;\n        }\n\n        const contentLength = res.headers.get('content-length');\n        const stats = {\n          size: contentLength ? parseInt(contentLength, 10) : 0,\n        };\n\n        resolve(stats);\n      })\n      .catch((error: unknown) => {\n        reject(error);\n      });\n  });\n}\n\nasync function signFile(file: IFile) {\n  const { provider } = strapi.plugins.upload;\n  const { provider: providerName } = strapi.config.get('plugin.upload') as { provider: string };\n  const isPrivate = await provider.isPrivate();\n  if (file?.provider === providerName && isPrivate) {\n    const signUrl = async (file: IFile) => {\n      const signedUrl = await provider.getSignedUrl(file);\n      file.url = signedUrl.url;\n    };\n\n    // Sign the original file\n    await signUrl(file);\n    // Sign each file format\n    if (file.formats) {\n      for (const format of Object.keys(file.formats)) {\n        await signUrl(file.formats[format]);\n      }\n    }\n  }\n}\n\n/**\n * Generate and consume assets streams in order to stream each file individually\n */\nexport const createAssetsStream = (strapi: Core.Strapi): Duplex => {\n  const generator: () => AsyncGenerator<IAsset, void> = async function* () {\n    const stream: Readable = strapi.db\n      .queryBuilder('plugin::upload.file')\n      // Create a query builder instance (default type is 'select')\n      // Fetch all columns\n      .select('*')\n      // Get a readable stream\n      .stream();\n\n    for await (const file of stream) {\n      const isLocalProvider = file.provider === 'local';\n      if (!isLocalProvider) {\n        await signFile(file);\n      }\n      const filepath = isLocalProvider ? join(strapi.dirs.static.public, file.url) : file.url;\n      const stats = await getFileStats(filepath, strapi, isLocalProvider);\n      const stream = getFileStream(filepath, strapi, isLocalProvider);\n\n      yield {\n        metadata: file,\n        filepath,\n        filename: file.hash + file.ext,\n        stream,\n        stats: { size: stats.size },\n      };\n\n      if (file.formats) {\n        for (const format of Object.keys(file.formats)) {\n          const fileFormat = file.formats[format];\n          const fileFormatFilepath = isLocalProvider\n            ? join(strapi.dirs.static.public, fileFormat.url)\n            : fileFormat.url;\n          const fileFormatStats = await getFileStats(fileFormatFilepath, strapi, isLocalProvider);\n          const fileFormatStream = getFileStream(fileFormatFilepath, strapi, isLocalProvider);\n          const metadata = { ...fileFormat, type: format, id: file.id, mainHash: file.hash };\n          yield {\n            metadata,\n            filepath: fileFormatFilepath,\n            filename: fileFormat.hash + fileFormat.ext,\n            stream: fileFormatStream,\n            stats: { size: fileFormatStats.size },\n          };\n        }\n      }\n    }\n  };\n\n  return Duplex.from(generator());\n};\n","import { Readable } from 'stream';\nimport { chain } from 'stream-chain';\nimport type { Core, Struct } from '@strapi/types';\n\nimport type { IMetadata, ISourceProvider, ProviderType } from '../../../../types';\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\nimport { createEntitiesStream, createEntitiesTransformStream } from './entities';\nimport { createLinksStream } from './links';\nimport { createConfigurationStream } from './configuration';\nimport { createAssetsStream } from './assets';\nimport * as utils from '../../../utils';\nimport { assertValidStrapi } from '../../../utils/providers';\n\nexport interface ILocalStrapiSourceProviderOptions {\n  getStrapi(): Core.Strapi | Promise<Core.Strapi>; // return an initialized instance of Strapi\n\n  autoDestroy?: boolean; // shut down the instance returned by getStrapi() at the end of the transfer\n}\n\nexport const createLocalStrapiSourceProvider = (options: ILocalStrapiSourceProviderOptions) => {\n  return new LocalStrapiSourceProvider(options);\n};\n\nclass LocalStrapiSourceProvider implements ISourceProvider {\n  name = 'source::local-strapi';\n\n  type: ProviderType = 'source';\n\n  options: ILocalStrapiSourceProviderOptions;\n\n  strapi?: Core.Strapi;\n\n  #diagnostics?: IDiagnosticReporter;\n\n  constructor(options: ILocalStrapiSourceProviderOptions) {\n    this.options = options;\n  }\n\n  async bootstrap(diagnostics?: IDiagnosticReporter): Promise<void> {\n    this.#diagnostics = diagnostics;\n    this.strapi = await this.options.getStrapi();\n    this.strapi.db.lifecycles.disable();\n  }\n\n  #reportInfo(message: string) {\n    this.#diagnostics?.report({\n      details: {\n        createdAt: new Date(),\n        message,\n        origin: 'local-source-provider',\n      },\n      kind: 'info',\n    });\n  }\n\n  /**\n   * Reports an error to the diagnostic reporter.\n   */\n  #reportError(message: string, error: Error) {\n    this.#diagnostics?.report({\n      details: {\n        createdAt: new Date(),\n        message,\n        error,\n        severity: 'fatal',\n        name: error.name,\n      },\n      kind: 'error',\n    });\n  }\n\n  /**\n   * Handles errors that occur in read streams.\n   */\n  #handleStreamError(streamType: string, err: Error) {\n    const { message, stack } = err;\n    const errorMessage = `[Data transfer] Error in ${streamType} read stream: ${message}`;\n    const formattedError = {\n      message: errorMessage,\n      stack,\n      timestamp: new Date().toISOString(),\n    };\n\n    this.strapi?.log.error(formattedError);\n    this.#reportError(formattedError.message, err);\n  }\n\n  async close(): Promise<void> {\n    const { autoDestroy } = this.options;\n    assertValidStrapi(this.strapi);\n    this.strapi.db.lifecycles.enable();\n    // Basically `!== false` but more deterministic\n    if (autoDestroy === undefined || autoDestroy === true) {\n      await this.strapi?.destroy();\n    }\n  }\n\n  getMetadata(): IMetadata {\n    this.#reportInfo('getting metadata');\n    const strapiVersion = strapi.config.get<string>('info.strapi');\n    const createdAt = new Date().toISOString();\n\n    return {\n      createdAt,\n      strapi: {\n        version: strapiVersion,\n      },\n    };\n  }\n\n  async createEntitiesReadStream(): Promise<Readable> {\n    assertValidStrapi(this.strapi, 'Not able to stream entities');\n    this.#reportInfo('creating entities read stream');\n    return chain([\n      // Entities stream\n      createEntitiesStream(this.strapi),\n\n      // Transform stream\n      createEntitiesTransformStream(),\n    ]);\n  }\n\n  createLinksReadStream(): Readable {\n    assertValidStrapi(this.strapi, 'Not able to stream links');\n    this.#reportInfo('creating links read stream');\n\n    return createLinksStream(this.strapi);\n  }\n\n  createConfigurationReadStream(): Readable {\n    assertValidStrapi(this.strapi, 'Not able to stream configuration');\n    this.#reportInfo('creating configuration read stream');\n    return createConfigurationStream(this.strapi);\n  }\n\n  getSchemas(): Record<string, Struct.Schema> {\n    assertValidStrapi(this.strapi, 'Not able to get Schemas');\n    this.#reportInfo('getting schemas');\n    const schemas = utils.schema.schemasToValidJSON({\n      ...this.strapi.contentTypes,\n      ...this.strapi.components,\n    });\n\n    return utils.schema.mapSchemasValues(schemas);\n  }\n\n  createSchemasReadStream(): Readable {\n    return Readable.from(Object.values(this.getSchemas()));\n  }\n\n  createAssetsReadStream(): Readable {\n    assertValidStrapi(this.strapi, 'Not able to stream assets');\n    this.#reportInfo('creating assets read stream');\n\n    const stream = createAssetsStream(this.strapi);\n    stream.on('error', (err) => {\n      this.#handleStreamError('assets', err);\n    });\n\n    return stream;\n  }\n}\n\nexport type ILocalStrapiSourceProvider = InstanceType<typeof LocalStrapiSourceProvider>;\n","import { randomUUID } from 'crypto';\nimport { RawData, WebSocket } from 'ws';\n\nimport type { Client, Server } from '../../../types/remote/protocol';\n\nimport {\n  ProviderError,\n  ProviderTransferError,\n  ProviderInitializationError,\n  ProviderValidationError,\n  ProviderErrorDetails,\n} from '../../errors/providers';\nimport { IDiagnosticReporter } from '../../utils/diagnostic';\n\ninterface IDispatcherState {\n  transfer?: { kind: Client.TransferKind; id: string };\n}\n\ninterface IDispatchOptions {\n  attachTransfer?: boolean;\n}\n\ntype Dispatch<T> = Omit<T, 'transferID' | 'uuid'>;\n\nexport const createDispatcher = (\n  ws: WebSocket,\n  retryMessageOptions = {\n    retryMessageMaxRetries: 5,\n    retryMessageTimeout: 30000,\n  },\n  reportInfo?: (message: string) => void\n) => {\n  const state: IDispatcherState = {};\n\n  type DispatchMessage = Dispatch<Client.Message>;\n\n  const dispatch = async <U = null>(\n    message: DispatchMessage,\n    options: IDispatchOptions = {}\n  ): Promise<U | null> => {\n    if (!ws) {\n      throw new Error('No websocket connection found');\n    }\n\n    return new Promise<U | null>((resolve, reject) => {\n      const uuid = randomUUID();\n      const payload = { ...message, uuid };\n      let numberOfTimesMessageWasSent = 0;\n\n      if (options.attachTransfer) {\n        Object.assign(payload, { transferID: state.transfer?.id });\n      }\n\n      if (message.type === 'command') {\n        reportInfo?.(\n          `dispatching message command:${(message as Client.CommandMessage).command} uuid:${uuid} sent:${numberOfTimesMessageWasSent}`\n        );\n      } else if (message.type === 'transfer') {\n        const messageToSend = message as Client.TransferMessage;\n        reportInfo?.(\n          `dispatching message action:${messageToSend.action} ${messageToSend.kind === 'step' ? `step:${messageToSend.step}` : ''} uuid:${uuid} sent:${numberOfTimesMessageWasSent}`\n        );\n      }\n      const stringifiedPayload = JSON.stringify(payload);\n      ws.send(stringifiedPayload, (error) => {\n        if (error) {\n          reject(error);\n        }\n      });\n      const { retryMessageMaxRetries, retryMessageTimeout } = retryMessageOptions;\n      const sendPeriodically = () => {\n        if (numberOfTimesMessageWasSent <= retryMessageMaxRetries) {\n          numberOfTimesMessageWasSent += 1;\n          ws.send(stringifiedPayload, (error) => {\n            if (error) {\n              reject(error);\n            }\n          });\n        } else {\n          reject(new ProviderError('error', 'Request timed out'));\n        }\n      };\n      const interval = setInterval(sendPeriodically, retryMessageTimeout);\n\n      const onResponse = (raw: RawData) => {\n        const response: Server.Message<U> = JSON.parse(raw.toString());\n        if (message.type === 'command') {\n          reportInfo?.(\n            `received response to message command: ${(message as Client.CommandMessage).command} uuid: ${uuid} sent: ${numberOfTimesMessageWasSent}`\n          );\n        } else if (message.type === 'transfer') {\n          const messageToSend = message as Client.TransferMessage;\n          reportInfo?.(\n            `received response to message action:${messageToSend.action} ${messageToSend.kind === 'step' ? `step:${messageToSend.step}` : ''} uuid:${uuid} sent:${numberOfTimesMessageWasSent}`\n          );\n        }\n        if (response.uuid === uuid) {\n          clearInterval(interval);\n          if (response.error) {\n            const message = response.error.message;\n            const details = response.error.details?.details as ProviderErrorDetails;\n            const step = response.error.details?.step;\n            let error = new ProviderError('error', message, details);\n            if (step === 'transfer') {\n              error = new ProviderTransferError(message, details);\n            } else if (step === 'validation') {\n              error = new ProviderValidationError(message, details);\n            } else if (step === 'initialization') {\n              error = new ProviderInitializationError(message);\n            }\n            return reject(error);\n          }\n          resolve(response.data ?? null);\n        } else {\n          ws.once('message', onResponse);\n        }\n      };\n\n      ws.once('message', onResponse);\n    });\n  };\n\n  const dispatchCommand = <U extends Client.Command>(\n    payload: {\n      command: U;\n    } & ([Client.GetCommandParams<U>] extends [never]\n      ? unknown\n      : { params?: Client.GetCommandParams<U> })\n  ) => {\n    return dispatch({ type: 'command', ...payload } as Client.CommandMessage);\n  };\n\n  const dispatchTransferAction = async <T>(action: Client.Action['action']) => {\n    const payload: Dispatch<Client.Action> = { type: 'transfer', kind: 'action', action };\n\n    return dispatch<T>(payload, { attachTransfer: true }) ?? Promise.resolve(null);\n  };\n\n  const dispatchTransferStep = async <\n    T,\n    A extends Client.TransferPushMessage['action'] = Client.TransferPushMessage['action'],\n    S extends Client.TransferPushStep = Client.TransferPushStep,\n  >(\n    payload: {\n      step: S;\n      action: A;\n    } & (A extends 'stream' ? { data: Client.GetTransferPushStreamData<S> } : unknown)\n  ) => {\n    const message: Dispatch<Client.TransferPushMessage> = {\n      type: 'transfer',\n      kind: 'step',\n      ...payload,\n    };\n\n    return dispatch<T>(message, { attachTransfer: true }) ?? Promise.resolve(null);\n  };\n\n  const setTransferProperties = (\n    properties: Exclude<IDispatcherState['transfer'], undefined>\n  ): void => {\n    state.transfer = { ...properties };\n  };\n\n  return {\n    get transferID() {\n      return state.transfer?.id;\n    },\n\n    get transferKind() {\n      return state.transfer?.kind;\n    },\n\n    setTransferProperties,\n\n    dispatch,\n    dispatchCommand,\n    dispatchTransferAction,\n    dispatchTransferStep,\n  };\n};\n\ntype WebsocketParams = ConstructorParameters<typeof WebSocket>;\ntype Address = WebsocketParams[0];\ntype Options = WebsocketParams[2];\n\nexport const connectToWebsocket = (\n  address: Address,\n  options?: Options,\n  diagnostics?: IDiagnosticReporter\n): Promise<WebSocket> => {\n  return new Promise((resolve, reject) => {\n    const server = new WebSocket(address, options);\n    server.once('open', () => {\n      resolve(server);\n    });\n\n    server.on('unexpected-response', (_req, res) => {\n      if (res.statusCode === 401) {\n        return reject(\n          new ProviderInitializationError(\n            'Failed to initialize the connection: Authentication Error'\n          )\n        );\n      }\n\n      if (res.statusCode === 403) {\n        return reject(\n          new ProviderInitializationError(\n            'Failed to initialize the connection: Authorization Error'\n          )\n        );\n      }\n\n      if (res.statusCode === 404) {\n        return reject(\n          new ProviderInitializationError(\n            'Failed to initialize the connection: Data transfer is not enabled on the remote host'\n          )\n        );\n      }\n\n      return reject(\n        new ProviderInitializationError(\n          `Failed to initialize the connection: Unexpected server response ${res.statusCode}`\n        )\n      );\n    });\n\n    server.on('message', (raw: RawData) => {\n      const response: Server.Message = JSON.parse(raw.toString());\n      if (response.diagnostic) {\n        diagnostics?.report({\n          ...response.diagnostic,\n        });\n      }\n    });\n\n    server.once('error', (err) => {\n      reject(\n        new ProviderTransferError(err.message, {\n          details: {\n            error: err.message,\n          },\n        })\n      );\n    });\n  });\n};\n\nexport const trimTrailingSlash = (input: string): string => {\n  return input.replace(/\\/$/, '');\n};\n\nexport const wait = (ms: number) => {\n  return new Promise<void>((resolve) => {\n    setTimeout(resolve, ms);\n  });\n};\n\nexport const waitUntil = async (test: () => boolean, interval: number): Promise<void> => {\n  while (!test()) {\n    await wait(interval);\n  }\n\n  return Promise.resolve();\n};\n","export const TRANSFER_PATH = '/transfer/runner' as const;\nexport const TRANSFER_METHODS = ['push', 'pull'] as const;\n\nexport type TransferPath = typeof TRANSFER_PATH;\nexport type TransferMethod = (typeof TRANSFER_METHODS)[number];\n","import { randomUUID } from 'crypto';\nimport { Writable } from 'stream';\nimport { WebSocket } from 'ws';\nimport { once } from 'lodash/fp';\nimport type { Struct, Utils } from '@strapi/types';\n\nimport { createDispatcher, connectToWebsocket, trimTrailingSlash } from '../utils';\n\nimport type {\n  IDestinationProvider,\n  IMetadata,\n  ProviderType,\n  IAsset,\n  TransferStage,\n  Protocol,\n} from '../../../../types';\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\nimport type { Client, Server, Auth } from '../../../../types/remote/protocol';\nimport type { ILocalStrapiDestinationProviderOptions } from '../local-destination';\nimport { TRANSFER_PATH } from '../../remote/constants';\nimport { ProviderTransferError, ProviderValidationError } from '../../../errors/providers';\n\nexport interface IRemoteStrapiDestinationProviderOptions\n  extends Pick<ILocalStrapiDestinationProviderOptions, 'restore' | 'strategy'> {\n  url: URL; // the url of the remote Strapi admin\n  auth?: Auth.ITransferTokenAuth;\n  retryMessageOptions?: {\n    retryMessageTimeout: number; // milliseconds to wait for a response from a message\n    retryMessageMaxRetries: number; // max number of retries for a message before aborting transfer\n  };\n}\n\nconst jsonLength = (obj: object) => Buffer.byteLength(JSON.stringify(obj));\n\nclass RemoteStrapiDestinationProvider implements IDestinationProvider {\n  name = 'destination::remote-strapi';\n\n  type: ProviderType = 'destination';\n\n  options: IRemoteStrapiDestinationProviderOptions;\n\n  ws: WebSocket | null;\n\n  dispatcher: ReturnType<typeof createDispatcher> | null;\n\n  transferID: string | null;\n\n  stats!: { [TStage in Exclude<TransferStage, 'schemas'>]: { count: number } };\n\n  #diagnostics?: IDiagnosticReporter;\n\n  constructor(options: IRemoteStrapiDestinationProviderOptions) {\n    this.options = options;\n    this.ws = null;\n    this.dispatcher = null;\n    this.transferID = null;\n\n    this.resetStats();\n  }\n\n  private resetStats() {\n    this.stats = {\n      assets: { count: 0 },\n      entities: { count: 0 },\n      links: { count: 0 },\n      configuration: { count: 0 },\n    };\n  }\n\n  async initTransfer(): Promise<string> {\n    const { strategy, restore } = this.options;\n\n    const query = this.dispatcher?.dispatchCommand({\n      command: 'init',\n      params: { options: { strategy, restore }, transfer: 'push' },\n    });\n\n    const res = (await query) as Server.Payload<Server.InitMessage>;\n    if (!res?.transferID) {\n      throw new ProviderTransferError('Init failed, invalid response from the server');\n    }\n\n    this.resetStats();\n\n    return res.transferID;\n  }\n\n  #startStepOnce(stage: Client.TransferPushStep) {\n    return once(() => this.#startStep(stage));\n  }\n\n  async #startStep<T extends Client.TransferPushStep>(step: T) {\n    try {\n      await this.dispatcher?.dispatchTransferStep({ action: 'start', step });\n    } catch (e) {\n      if (e instanceof Error) {\n        return e;\n      }\n\n      if (typeof e === 'string') {\n        return new ProviderTransferError(e);\n      }\n\n      return new ProviderTransferError('Unexpected error');\n    }\n\n    this.stats[step] = { count: 0 };\n\n    return null;\n  }\n\n  async #endStep<T extends Client.TransferPushStep>(step: T) {\n    try {\n      const res = await this.dispatcher?.dispatchTransferStep<{\n        ok: boolean;\n        stats: Protocol.Client.Stats;\n      }>({\n        action: 'end',\n        step,\n      });\n\n      return { stats: res?.stats ?? null, error: null };\n    } catch (e) {\n      if (e instanceof Error) {\n        return { stats: null, error: e };\n      }\n\n      if (typeof e === 'string') {\n        return { stats: null, error: new ProviderTransferError(e) };\n      }\n\n      return { stats: null, error: new ProviderTransferError('Unexpected error') };\n    }\n  }\n\n  async #streamStep<T extends Client.TransferPushStep>(\n    step: T,\n    message: Client.GetTransferPushStreamData<T>\n  ) {\n    try {\n      if (step === 'assets') {\n        const assetMessage = message as Protocol.Client.TransferAssetFlow[];\n        this.stats[step].count += assetMessage.filter((data) => data.action === 'start').length;\n      } else {\n        this.stats[step].count += message.length;\n      }\n\n      await this.dispatcher?.dispatchTransferStep({ action: 'stream', step, data: message });\n    } catch (e) {\n      if (e instanceof Error) {\n        return e;\n      }\n\n      if (typeof e === 'string') {\n        return new ProviderTransferError(e);\n      }\n\n      return new ProviderTransferError('Unexpected error');\n    }\n\n    return null;\n  }\n\n  #writeStream(step: Exclude<Client.TransferPushStep, 'assets'>): Writable {\n    type Step = typeof step;\n\n    const batchSize = 1024 * 1024; // 1MB;\n    const startTransferOnce = this.#startStepOnce(step);\n\n    let batch = [] as Client.GetTransferPushStreamData<Step>;\n\n    const batchLength = () => jsonLength(batch);\n\n    return new Writable({\n      objectMode: true,\n\n      final: async (callback) => {\n        if (batch.length > 0) {\n          const streamError = await this.#streamStep(step, batch);\n\n          batch = [];\n\n          if (streamError) {\n            return callback(streamError);\n          }\n        }\n        const { error, stats } = await this.#endStep(step);\n\n        const { count } = this.stats[step];\n\n        if (stats && (stats.started !== count || stats.finished !== count)) {\n          callback(\n            new Error(\n              `Data missing: sent ${this.stats[step].count} ${step}, recieved ${stats.started} and saved ${stats.finished} ${step}`\n            )\n          );\n        }\n\n        callback(error);\n      },\n\n      write: async (chunk, _encoding, callback) => {\n        const startError = await startTransferOnce();\n        if (startError) {\n          return callback(startError);\n        }\n\n        batch.push(chunk);\n\n        if (batchLength() >= batchSize) {\n          const streamError = await this.#streamStep(step, batch);\n\n          batch = [];\n\n          if (streamError) {\n            return callback(streamError);\n          }\n        }\n\n        callback();\n      },\n    });\n  }\n\n  #reportInfo(message: string) {\n    this.#diagnostics?.report({\n      details: {\n        createdAt: new Date(),\n        message,\n        origin: 'remote-destination-provider',\n      },\n      kind: 'info',\n    });\n  }\n\n  async bootstrap(diagnostics?: IDiagnosticReporter): Promise<void> {\n    this.#diagnostics = diagnostics;\n    const { url, auth } = this.options;\n    const validProtocols = ['https:', 'http:'];\n\n    let ws: WebSocket;\n\n    if (!validProtocols.includes(url.protocol)) {\n      throw new ProviderValidationError(`Invalid protocol \"${url.protocol}\"`, {\n        check: 'url',\n        details: {\n          protocol: url.protocol,\n          validProtocols,\n        },\n      });\n    }\n    const wsProtocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\n    const wsUrl = `${wsProtocol}//${url.host}${trimTrailingSlash(\n      url.pathname\n    )}${TRANSFER_PATH}/push`;\n\n    this.#reportInfo('establishing websocket connection');\n    // No auth defined, trying public access for transfer\n    if (!auth) {\n      ws = await connectToWebsocket(wsUrl, undefined, this.#diagnostics);\n    }\n\n    // Common token auth, this should be the main auth method\n    else if (auth.type === 'token') {\n      const headers = { Authorization: `Bearer ${auth.token}` };\n      ws = await connectToWebsocket(wsUrl, { headers }, this.#diagnostics);\n    }\n\n    // Invalid auth method provided\n    else {\n      throw new ProviderValidationError('Auth method not available', {\n        check: 'auth.type',\n        details: {\n          auth: auth.type,\n        },\n      });\n    }\n\n    this.#reportInfo('established websocket connection');\n\n    this.ws = ws;\n    const { retryMessageOptions } = this.options;\n\n    this.#reportInfo('creating dispatcher');\n    this.dispatcher = createDispatcher(this.ws, retryMessageOptions, (message: string) =>\n      this.#reportInfo(message)\n    );\n    this.#reportInfo('created dispatcher');\n\n    this.#reportInfo('initialize transfer');\n    this.transferID = await this.initTransfer();\n    this.#reportInfo(`initialized transfer ${this.transferID}`);\n\n    this.dispatcher.setTransferProperties({ id: this.transferID, kind: 'push' });\n\n    await this.dispatcher.dispatchTransferAction('bootstrap');\n  }\n\n  async close() {\n    // Gracefully close the remote transfer process\n    if (this.transferID && this.dispatcher) {\n      await this.dispatcher.dispatchTransferAction('close');\n\n      await this.dispatcher.dispatchCommand({\n        command: 'end',\n        params: { transferID: this.transferID },\n      });\n    }\n\n    await new Promise<void>((resolve) => {\n      const { ws } = this;\n\n      if (!ws || ws.CLOSED) {\n        resolve();\n        return;\n      }\n\n      ws.on('close', () => resolve()).close();\n    });\n  }\n\n  getMetadata() {\n    return this.dispatcher?.dispatchTransferAction<IMetadata>('getMetadata') ?? null;\n  }\n\n  async beforeTransfer() {\n    await this.dispatcher?.dispatchTransferAction('beforeTransfer');\n  }\n\n  async rollback() {\n    await this.dispatcher?.dispatchTransferAction('rollback');\n  }\n\n  getSchemas() {\n    if (!this.dispatcher) {\n      return Promise.resolve(null);\n    }\n\n    return this.dispatcher.dispatchTransferAction<Utils.String.Dict<Struct.Schema>>('getSchemas');\n  }\n\n  createEntitiesWriteStream(): Writable {\n    return this.#writeStream('entities');\n  }\n\n  createLinksWriteStream(): Writable {\n    return this.#writeStream('links');\n  }\n\n  createConfigurationWriteStream(): Writable {\n    return this.#writeStream('configuration');\n  }\n\n  createAssetsWriteStream(): Writable | Promise<Writable> {\n    let batch: Client.TransferAssetFlow[] = [];\n    let hasStarted = false;\n\n    const batchSize = 1024 * 1024; // 1MB;\n    const batchLength = () => {\n      return batch.reduce(\n        (acc, chunk) => (chunk.action === 'stream' ? acc + chunk.data.byteLength : acc),\n        0\n      );\n    };\n    const startAssetsTransferOnce = this.#startStepOnce('assets');\n\n    const flush = async () => {\n      const streamError = await this.#streamStep('assets', batch);\n      batch = [];\n      return streamError;\n    };\n\n    const safePush = async (chunk: Client.TransferAssetFlow) => {\n      batch.push(chunk);\n\n      if (batchLength() >= batchSize) {\n        const streamError = await flush();\n        if (streamError) {\n          throw streamError;\n        }\n      }\n    };\n\n    return new Writable({\n      objectMode: true,\n      final: async (callback) => {\n        if (batch.length > 0) {\n          await flush();\n        }\n\n        if (hasStarted) {\n          const { error: endStepError } = await this.#endStep('assets');\n\n          if (endStepError) {\n            return callback(endStepError);\n          }\n        }\n\n        return callback(null);\n      },\n\n      async write(asset: IAsset, _encoding, callback) {\n        const startError = await startAssetsTransferOnce();\n        if (startError) {\n          return callback(startError);\n        }\n\n        hasStarted = true;\n\n        const assetID = randomUUID();\n        const { filename, filepath, stats, stream, metadata } = asset;\n\n        try {\n          await safePush({\n            action: 'start',\n            assetID,\n            data: { filename, filepath, stats, metadata },\n          });\n\n          for await (const chunk of stream) {\n            await safePush({ action: 'stream', assetID, data: chunk });\n          }\n\n          await safePush({ action: 'end', assetID });\n\n          callback();\n        } catch (error) {\n          if (error instanceof Error) {\n            callback(error);\n          }\n        }\n      },\n    });\n  }\n}\n\nexport const createRemoteStrapiDestinationProvider = (\n  options: IRemoteStrapiDestinationProviderOptions\n) => {\n  return new RemoteStrapiDestinationProvider(options);\n};\n","import { PassThrough, Readable, Writable } from 'stream';\nimport type { Struct, Utils } from '@strapi/types';\nimport { WebSocket } from 'ws';\nimport { castArray } from 'lodash/fp';\n\nimport type {\n  IAsset,\n  IMetadata,\n  ISourceProvider,\n  ISourceProviderTransferResults,\n  MaybePromise,\n  Protocol,\n  ProviderType,\n  TransferStage,\n} from '../../../../types';\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\nimport { Client, Server, Auth } from '../../../../types/remote/protocol';\nimport { ProviderTransferError, ProviderValidationError } from '../../../errors/providers';\nimport { TRANSFER_PATH } from '../../remote/constants';\nimport { ILocalStrapiSourceProviderOptions } from '../local-source';\nimport { createDispatcher, connectToWebsocket, trimTrailingSlash } from '../utils';\n\nexport interface IRemoteStrapiSourceProviderOptions extends ILocalStrapiSourceProviderOptions {\n  url: URL; // the url of the remote Strapi admin\n  auth?: Auth.ITransferTokenAuth;\n  retryMessageOptions?: {\n    retryMessageTimeout: number; // milliseconds to wait for a response from a message\n    retryMessageMaxRetries: number; // max number of retries for a message before aborting transfer\n  };\n  streamTimeout?: number; // milliseconds to wait between chunks of an asset before aborting the transfer\n}\n\ntype QueueableAction = Protocol.Client.TransferAssetFlow &\n  ({ action: 'stream' } | { action: 'end' });\n\nclass RemoteStrapiSourceProvider implements ISourceProvider {\n  name = 'source::remote-strapi';\n\n  type: ProviderType = 'source';\n\n  options: IRemoteStrapiSourceProviderOptions;\n\n  ws: WebSocket | null;\n\n  dispatcher: ReturnType<typeof createDispatcher> | null;\n\n  defaultOptions: Partial<IRemoteStrapiSourceProviderOptions> = {\n    streamTimeout: 15000,\n  };\n\n  constructor(options: IRemoteStrapiSourceProviderOptions) {\n    this.options = {\n      ...this.defaultOptions,\n      ...options,\n    };\n\n    this.ws = null;\n    this.dispatcher = null;\n  }\n\n  results?: ISourceProviderTransferResults | undefined;\n\n  #diagnostics?: IDiagnosticReporter;\n\n  async #createStageReadStream(stage: Exclude<TransferStage, 'schemas'>) {\n    const startResult = await this.#startStep(stage);\n\n    if (startResult instanceof Error) {\n      throw startResult;\n    }\n\n    const { id: processID } = startResult as { id: string };\n\n    const stream = new PassThrough({ objectMode: true });\n\n    const listener = async (raw: Buffer) => {\n      const parsed = JSON.parse(raw.toString());\n      // If not a message related to our transfer process, ignore it\n      if (!parsed.uuid || parsed?.data?.type !== 'transfer' || parsed?.data?.id !== processID) {\n        this.ws?.once('message', listener);\n        return;\n      }\n\n      const { uuid, data: message } = parsed;\n      const { ended, error, data } = message;\n\n      if (error) {\n        await this.#respond(uuid);\n        stream.destroy(error);\n        return;\n      }\n\n      if (ended) {\n        await this.#respond(uuid);\n        await this.#endStep(stage);\n\n        stream.end();\n        return;\n      }\n\n      // if we get a single items instead of a batch\n      for (const item of castArray(data)) {\n        stream.push(item);\n      }\n\n      this.ws?.once('message', listener);\n\n      await this.#respond(uuid);\n    };\n\n    this.ws?.once('message', listener);\n\n    return stream;\n  }\n\n  createEntitiesReadStream(): MaybePromise<Readable> {\n    return this.#createStageReadStream('entities');\n  }\n\n  createLinksReadStream(): MaybePromise<Readable> {\n    return this.#createStageReadStream('links');\n  }\n\n  writeAsync = <T>(stream: Writable, data: T) => {\n    return new Promise<void>((resolve, reject) => {\n      stream.write(data, (error) => {\n        if (error) {\n          reject(error);\n        }\n\n        resolve();\n      });\n    });\n  };\n\n  async createAssetsReadStream(): Promise<Readable> {\n    // Create the streams used to transfer the assets\n    const stream = await this.#createStageReadStream('assets');\n    const pass = new PassThrough({ objectMode: true });\n\n    // Init the asset map\n    const assets: {\n      // TODO: could we include filename in this for improved logging?\n      [assetID: string]: IAsset & {\n        stream: PassThrough;\n        queue: Array<QueueableAction>;\n        status: 'ok' | 'closed' | 'errored';\n        timeout?: NodeJS.Timeout;\n      };\n    } = {};\n\n    // Watch for stalled assets; if we don't receive a chunk within timeout, abort transfer\n    const resetTimeout = (assetID: string) => {\n      if (assets[assetID].timeout) {\n        clearTimeout(assets[assetID].timeout);\n      }\n      assets[assetID].timeout = setTimeout(() => {\n        this.#reportInfo(`Asset ${assetID} transfer stalled, aborting.`);\n        assets[assetID].status = 'errored';\n        assets[assetID].stream.destroy(new Error(`Asset ${assetID} transfer timed out`));\n      }, this.options.streamTimeout);\n    };\n\n    stream\n      /**\n       * Process a payload of many transfer assets and performs the following tasks:\n       * - Start: creates a stream for new assets.\n       * - Stream: writes asset chunks to the asset's stream.\n       * - End: closes the stream after the asset s transferred and cleanup related resources.\n       */\n      .on('data', async (payload: Protocol.Client.TransferAssetFlow[]) => {\n        for (const item of payload) {\n          const { action, assetID } = item;\n\n          // Creates the stream to send the incoming asset through\n          if (action === 'start') {\n            // if a transfer has already been started for the same asset ID, something is wrong\n            if (assets[assetID]) {\n              throw new Error(`Asset ${assetID} already started`);\n            }\n\n            this.#reportInfo(`Asset ${assetID} starting`);\n            // Register the asset\n            assets[assetID] = {\n              ...item.data,\n              stream: new PassThrough(),\n              status: 'ok',\n              queue: [],\n            };\n\n            resetTimeout(assetID);\n\n            // Connect the individual asset stream to the main asset stage stream\n            // Note: nothing is transferred until data chunks are fed to the asset stream\n            await this.writeAsync(pass, assets[assetID]);\n          }\n\n          // Writes the asset's data chunks to their corresponding stream\n          // \"end\" is considered a chunk, but it's not a data chunk, it's a control message\n          // That is done so that we don't complicate the already complicated async processing of the queue\n          else if (action === 'stream' || action === 'end') {\n            // If the asset hasn't been registered, or if it's been closed already, something is wrong\n            if (!assets[assetID]) {\n              throw new Error(`No id matching ${assetID} for stream action`);\n            }\n\n            // On every action, reset the timeout timer\n            if (action === 'stream') {\n              resetTimeout(assetID);\n            } else {\n              clearTimeout(assets[assetID].timeout);\n            }\n\n            if (assets[assetID].status === 'closed') {\n              throw new Error(`Asset ${assetID} is closed`);\n            }\n\n            assets[assetID].queue.push(item);\n          }\n        }\n\n        // each new payload will start new processQueue calls, which may cause some extra calls\n        // it's essentially saying \"start processing this asset again, I added more data to the queue\"\n        for (const assetID in assets) {\n          if (Object.prototype.hasOwnProperty.call(assets, assetID)) {\n            const asset = assets[assetID];\n            if (asset.queue?.length > 0) {\n              await processQueue(assetID);\n            }\n          }\n        }\n      })\n      .on('close', () => {\n        pass.end();\n      });\n\n    /**\n     * Start processing the queue for a given assetID\n     *\n     * Even though this is a loop that attempts to process the entire queue, it is safe to call this more than once\n     * for the same asset id because the queue is shared globally, the items are shifted off, and immediately written\n     */\n    const processQueue = async (id: string) => {\n      if (!assets[id]) {\n        throw new Error(`Failed to write asset chunk for \"${id}\". Asset not found.`);\n      }\n\n      const asset = assets[id];\n      const { status: currentStatus } = asset;\n\n      if (['closed', 'errored'].includes(currentStatus)) {\n        throw new Error(\n          `Failed to write asset chunk for \"${id}\". The asset is currently \"${currentStatus}\"`\n        );\n      }\n\n      while (asset.queue.length > 0) {\n        const data = asset.queue.shift();\n\n        if (!data) {\n          throw new Error(`Invalid chunk found for ${id}`);\n        }\n\n        try {\n          // if this is an end chunk, close the asset stream\n          if (data.action === 'end') {\n            this.#reportInfo(`Ending asset stream for ${id}`);\n            await closeAssetStream(id);\n            break; // Exit the loop after closing the stream\n          }\n\n          // Save the current chunk\n          await writeChunkToStream(id, data);\n        } catch {\n          if (!assets[id]) {\n            throw new Error(`No id matching ${id} for writeAssetChunk`);\n          }\n        }\n      }\n    };\n\n    /**\n     * Writes a chunk of data to the asset's stream.\n     *\n     * Only check if the targeted asset exists, no other validation is done.\n     */\n    const writeChunkToStream = async (id: string, data: unknown) => {\n      const asset = assets[id];\n\n      if (!asset) {\n        throw new Error(`Failed to write asset chunk for \"${id}\". Asset not found.`);\n      }\n\n      const rawBuffer = data as { type: 'Buffer'; data: Uint8Array };\n      const chunk = Buffer.from(rawBuffer.data);\n\n      await this.writeAsync(asset.stream, chunk);\n    };\n\n    /**\n     * Closes the asset stream associated with the given ID.\n     *\n     * It deletes the stream for the asset upon successful closure.\n     */\n    const closeAssetStream = async (id: string) => {\n      if (!assets[id]) {\n        throw new Error(`Failed to close asset \"${id}\". Asset not found.`);\n      }\n\n      assets[id].status = 'closed';\n\n      await new Promise<void>((resolve, reject) => {\n        const { stream } = assets[id];\n\n        stream\n          .on('close', () => {\n            resolve();\n          })\n          .on('error', (e) => {\n            assets[id].status = 'errored';\n            reject(new Error(`Failed to close asset \"${id}\". Asset stream error: ${e.toString()}`));\n          })\n          .end();\n      });\n    };\n\n    return pass;\n  }\n\n  createConfigurationReadStream(): MaybePromise<Readable> {\n    return this.#createStageReadStream('configuration');\n  }\n\n  async getMetadata(): Promise<IMetadata | null> {\n    const metadata = await this.dispatcher?.dispatchTransferAction<IMetadata>('getMetadata');\n\n    return metadata ?? null;\n  }\n\n  assertValidProtocol(url: URL) {\n    const validProtocols = ['https:', 'http:'];\n\n    if (!validProtocols.includes(url.protocol)) {\n      throw new ProviderValidationError(`Invalid protocol \"${url.protocol}\"`, {\n        check: 'url',\n        details: {\n          protocol: url.protocol,\n          validProtocols,\n        },\n      });\n    }\n  }\n\n  async initTransfer(): Promise<string> {\n    const query = this.dispatcher?.dispatchCommand({\n      command: 'init',\n    });\n\n    const res = (await query) as Server.Payload<Server.InitMessage>;\n\n    if (!res?.transferID) {\n      throw new ProviderTransferError('Init failed, invalid response from the server');\n    }\n\n    return res.transferID;\n  }\n\n  #reportInfo(message: string) {\n    this.#diagnostics?.report({\n      details: {\n        createdAt: new Date(),\n        message,\n        origin: 'remote-source-provider',\n      },\n      kind: 'info',\n    });\n  }\n\n  async bootstrap(diagnostics?: IDiagnosticReporter): Promise<void> {\n    this.#diagnostics = diagnostics;\n    const { url, auth } = this.options;\n    let ws: WebSocket;\n    this.assertValidProtocol(url);\n    const wsProtocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\n    const wsUrl = `${wsProtocol}//${url.host}${trimTrailingSlash(\n      url.pathname\n    )}${TRANSFER_PATH}/pull`;\n\n    this.#reportInfo('establishing websocket connection');\n    // No auth defined, trying public access for transfer\n    if (!auth) {\n      ws = await connectToWebsocket(wsUrl, undefined, this.#diagnostics);\n    }\n\n    // Common token auth, this should be the main auth method\n    else if (auth.type === 'token') {\n      const headers = { Authorization: `Bearer ${auth.token}` };\n      ws = await connectToWebsocket(wsUrl, { headers }, this.#diagnostics);\n    }\n\n    // Invalid auth method provided\n    else {\n      throw new ProviderValidationError('Auth method not available', {\n        check: 'auth.type',\n        details: {\n          auth: auth.type,\n        },\n      });\n    }\n\n    this.#reportInfo('established websocket connection');\n    this.ws = ws;\n    const { retryMessageOptions } = this.options;\n\n    this.#reportInfo('creating dispatcher');\n    this.dispatcher = createDispatcher(this.ws, retryMessageOptions, (message: string) =>\n      this.#reportInfo(message)\n    );\n    this.#reportInfo('creating dispatcher');\n\n    this.#reportInfo('initialize transfer');\n    const transferID = await this.initTransfer();\n    this.#reportInfo(`initialized transfer ${transferID}`);\n\n    this.dispatcher.setTransferProperties({ id: transferID, kind: 'pull' });\n    await this.dispatcher.dispatchTransferAction('bootstrap');\n  }\n\n  async close() {\n    await this.dispatcher?.dispatchTransferAction('close');\n\n    await new Promise<void>((resolve) => {\n      const { ws } = this;\n\n      if (!ws || ws.CLOSED) {\n        resolve();\n        return;\n      }\n\n      ws.on('close', () => resolve()).close();\n    });\n  }\n\n  async getSchemas() {\n    const schemas =\n      await this.dispatcher?.dispatchTransferAction<Utils.String.Dict<Struct.Schema>>('getSchemas');\n\n    return schemas ?? null;\n  }\n\n  async #startStep<T extends Client.TransferPullStep>(step: T) {\n    try {\n      return await this.dispatcher?.dispatchTransferStep({ action: 'start', step });\n    } catch (e) {\n      if (e instanceof Error) {\n        return e;\n      }\n\n      if (typeof e === 'string') {\n        return new ProviderTransferError(e);\n      }\n\n      return new ProviderTransferError('Unexpected error');\n    }\n  }\n\n  async #respond(uuid: string) {\n    return new Promise((resolve, reject) => {\n      this.ws?.send(JSON.stringify({ uuid }), (e) => {\n        if (e) {\n          reject(e);\n        } else {\n          resolve(e);\n        }\n      });\n    });\n  }\n\n  async #endStep<T extends Client.TransferPullStep>(step: T) {\n    try {\n      await this.dispatcher?.dispatchTransferStep({ action: 'end', step });\n    } catch (e) {\n      if (e instanceof Error) {\n        return e;\n      }\n\n      if (typeof e === 'string') {\n        return new ProviderTransferError(e);\n      }\n\n      return new ProviderTransferError('Unexpected error');\n    }\n\n    return null;\n  }\n}\n\nexport const createRemoteStrapiSourceProvider = (options: IRemoteStrapiSourceProviderOptions) => {\n  return new RemoteStrapiSourceProvider(options);\n};\n","// Local\nexport * from './local-destination';\nexport * from './local-source';\n\n// Remote\nexport * from './remote-destination';\nexport * from './remote-source';\n","import type { Step } from '.';\n\nexport default [\n  {\n    kind: 'action',\n    action: 'bootstrap',\n  },\n  {\n    kind: 'action',\n    action: 'init',\n  },\n  {\n    kind: 'action',\n    action: 'beforeTransfer',\n  },\n  {\n    kind: 'transfer',\n    stage: 'schemas',\n  },\n  {\n    kind: 'transfer',\n    stage: 'entities',\n  },\n  {\n    kind: 'transfer',\n    stage: 'assets',\n  },\n  {\n    kind: 'transfer',\n    stage: 'links',\n  },\n  {\n    kind: 'transfer',\n    stage: 'configuration',\n  },\n  {\n    kind: 'action',\n    action: 'close',\n  },\n] as readonly Step[];\n","import type { TransferStage } from '../../../../types';\n\nexport type Step =\n  | { kind: 'action'; action: string }\n  | { kind: 'transfer'; stage: TransferStage; locked?: boolean };\n\nexport { default as DEFAULT_TRANSFER_FLOW } from './default';\n\ninterface IState {\n  step: Step | null;\n}\n\nexport interface TransferFlow {\n  has(step: Step): boolean;\n  can(step: Step): boolean;\n  cannot(step: Step): boolean;\n  set(step: Step): this;\n  get(): Step | null;\n}\n\nexport const createFlow = (flow: readonly Step[]): TransferFlow => {\n  const state: IState = { step: null };\n\n  /**\n   * Equality check between two steps\n   */\n  const stepEqual = (stepA: Step, stepB: Step): boolean => {\n    if (stepA.kind === 'action' && stepB.kind === 'action') {\n      return stepA.action === stepB.action;\n    }\n\n    if (stepA.kind === 'transfer' && stepB.kind === 'transfer') {\n      return stepA.stage === stepB.stage;\n    }\n\n    return false;\n  };\n\n  /**\n   * Find the index for a given step\n   */\n  const findStepIndex = (step: Step) => flow.findIndex((flowStep) => stepEqual(step, flowStep));\n\n  return {\n    has(step: Step) {\n      return findStepIndex(step) !== -1;\n    },\n\n    can(step: Step) {\n      if (state.step === null) {\n        return true;\n      }\n\n      const indexesDifference = findStepIndex(step) - findStepIndex(state.step);\n\n      // It's possible to send multiple time the same transfer step in a row\n      if (indexesDifference === 0 && step.kind === 'transfer') {\n        return true;\n      }\n\n      return indexesDifference > 0;\n    },\n\n    cannot(step: Step) {\n      return !this.can(step);\n    },\n\n    set(step: Step) {\n      const canSwitch = this.can(step);\n\n      if (!canSwitch) {\n        throw new Error('Impossible to proceed to the given step');\n      }\n\n      state.step = step;\n\n      return this;\n    },\n\n    get() {\n      return state.step;\n    },\n  };\n};\n","export const VALID_TRANSFER_COMMANDS = ['init', 'end', 'status'] as const;\nexport type ValidTransferCommand = (typeof VALID_TRANSFER_COMMANDS)[number];\n","import type { IncomingMessage } from 'node:http';\nimport { randomUUID } from 'crypto';\nimport type { Context } from 'koa';\nimport type { RawData, ServerOptions } from 'ws';\nimport { WebSocket, WebSocketServer } from 'ws';\n\nimport type { Handler, TransferState } from './abstract';\nimport type { Protocol } from '../../../../types';\nimport { ProviderError, ProviderTransferError } from '../../../errors/providers';\nimport { VALID_TRANSFER_COMMANDS, ValidTransferCommand } from './constants';\nimport { TransferMethod } from '../constants';\nimport { createDiagnosticReporter } from '../../../utils/diagnostic';\n\ntype WSCallback = (client: WebSocket, request: IncomingMessage) => void;\n\nexport interface HandlerOptions {\n  verify: (ctx: Context, scope?: TransferMethod) => Promise<void>;\n  server?: ServerOptions;\n}\n\nexport const transformUpgradeHeader = (header = '') => {\n  return header.split(',').map((s) => s.trim().toLowerCase());\n};\n\nlet timeouts: Record<string, number> | undefined;\n\nconst hasHttpServer = () => {\n  // during server restarts, strapi may not have ever been defined at all, so we have to check it first\n  return typeof strapi !== 'undefined' && !!strapi?.server?.httpServer;\n};\n\n// temporarily disable server timeouts while transfer is running\nconst disableTimeouts = () => {\n  if (!hasHttpServer()) {\n    return;\n  }\n\n  const { httpServer } = strapi.server;\n\n  // save the original timeouts to restore after\n  if (!timeouts) {\n    timeouts = {\n      headersTimeout: httpServer.headersTimeout,\n      requestTimeout: httpServer.requestTimeout,\n    };\n  }\n\n  httpServer.headersTimeout = 0;\n  httpServer.requestTimeout = 0;\n\n  strapi.log.info('[Data transfer] Disabling http timeouts');\n};\nconst resetTimeouts = () => {\n  if (!hasHttpServer() || !timeouts) {\n    return;\n  }\n\n  const { httpServer } = strapi.server;\n\n  strapi.log.info('[Data transfer] Restoring http timeouts');\n  httpServer.headersTimeout = timeouts.headersTimeout;\n  httpServer.requestTimeout = timeouts.requestTimeout;\n};\n/**\n * Make sure that the upgrade header is a valid websocket one\n */\nexport const assertValidHeader = (ctx: Context) => {\n  // if it's exactly what we expect, it's fine\n  if (ctx.headers.upgrade === 'websocket') {\n    return;\n  }\n\n  // check if it could be an array that still includes websocket\n  const upgradeHeader = transformUpgradeHeader(ctx.headers.upgrade);\n\n  // Sanitize user input before writing it to our logs\n  const logSafeUpgradeHeader = JSON.stringify(ctx.headers.upgrade)\n    ?.replace(/[^a-z0-9\\s.,|]/gi, '')\n    .substring(0, 50);\n\n  if (!upgradeHeader.includes('websocket')) {\n    throw new Error(\n      `Transfer Upgrade header expected 'websocket', found '${logSafeUpgradeHeader}'. Please ensure that your server or proxy is not modifying the Upgrade header.`\n    );\n  }\n\n  /**\n   * If there's more than expected but it still includes websocket, in theory it could still work\n   * and could be necessary for their certain configurations, so we'll allow it to proceed but\n   * log the unexpected behaviour in case it helps debug an issue\n   * */\n  strapi.log.info(\n    `Transfer Upgrade header expected only 'websocket', found unexpected values: ${logSafeUpgradeHeader}`\n  );\n};\n\nexport const isDataTransferMessage = (message: unknown): message is Protocol.Client.Message => {\n  if (!message || typeof message !== 'object') {\n    return false;\n  }\n\n  const { uuid, type } = message as Record<string, unknown>;\n\n  if (typeof uuid !== 'string' || typeof type !== 'string') {\n    return false;\n  }\n\n  if (!['command', 'transfer'].includes(type)) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Handle the upgrade to ws connection\n */\nexport const handleWSUpgrade = (wss: WebSocketServer, ctx: Context, callback: WSCallback) => {\n  assertValidHeader(ctx);\n\n  wss.handleUpgrade(ctx.req, ctx.request.socket, Buffer.alloc(0), (client, request) => {\n    if (!client) {\n      // If the WebSocket upgrade failed, destroy the socket to avoid hanging\n      ctx.request.socket.destroy();\n      return;\n    }\n\n    disableTimeouts();\n    strapi.db.lifecycles.disable();\n    strapi.log.info('[Data transfer] Disabling lifecycle hooks');\n\n    // Create a connection between the client & the server\n    wss.emit('connection', client, ctx.req);\n\n    // Invoke the ws callback\n    callback(client, request);\n  });\n\n  ctx.respond = false;\n};\n\n// Protocol related functions\n\nexport const handlerControllerFactory =\n  <T extends Partial<Handler>>(implementation: (proto: Handler) => T) =>\n  (options: HandlerOptions) => {\n    const { verify, server: serverOptions } = options ?? {};\n\n    const wss = new WebSocket.Server({ ...serverOptions, noServer: true });\n\n    return async (ctx: Context) => {\n      const cb: WSCallback = (ws) => {\n        const state: TransferState = { id: undefined };\n        const messageUUIDs = new Set<string>();\n        const diagnostics = createDiagnosticReporter();\n\n        const cannotRespondHandler = (err: unknown) => {\n          strapi?.log?.error(\n            '[Data transfer] Cannot send error response to client, closing connection'\n          );\n          strapi?.log?.error(err);\n          try {\n            ws.terminate();\n            ctx.req.socket.destroy();\n          } catch (err) {\n            strapi?.log?.error('[Data transfer] Failed to close socket on error');\n          }\n        };\n\n        const prototype: Handler = {\n          // Transfer ID\n          get transferID() {\n            return state.id;\n          },\n\n          set transferID(id) {\n            state.id = id;\n          },\n\n          // Started at\n          get startedAt() {\n            return state.startedAt;\n          },\n\n          set startedAt(timestamp) {\n            state.startedAt = timestamp;\n          },\n\n          get response() {\n            return state.response;\n          },\n\n          set response(response) {\n            state.response = response;\n          },\n\n          get diagnostics() {\n            return diagnostics;\n          },\n\n          addUUID(uuid) {\n            messageUUIDs.add(uuid);\n          },\n\n          hasUUID(uuid) {\n            return messageUUIDs.has(uuid);\n          },\n\n          isTransferStarted() {\n            return this.transferID !== undefined && this.startedAt !== undefined;\n          },\n\n          assertValidTransfer() {\n            const isStarted = this.isTransferStarted();\n\n            if (!isStarted) {\n              throw new Error('Invalid Transfer Process');\n            }\n          },\n\n          assertValidTransferCommand(command: ValidTransferCommand) {\n            const isDefined = typeof this[command] === 'function';\n            const isValidTransferCommand = VALID_TRANSFER_COMMANDS.includes(command);\n\n            if (!isDefined || !isValidTransferCommand) {\n              throw new Error('Invalid transfer command');\n            }\n          },\n\n          async respond(uuid, e, data) {\n            let details = {};\n            return new Promise<void>((resolve, reject) => {\n              if (!uuid && !e) {\n                reject(new Error('Missing uuid for this message'));\n                return;\n              }\n\n              this.response = {\n                uuid,\n                data,\n                e,\n              };\n\n              if (e instanceof ProviderError) {\n                details = e.details;\n              }\n\n              const payload = JSON.stringify({\n                uuid,\n                data: data ?? null,\n                error: e\n                  ? {\n                      code: e?.name ?? 'ERR',\n                      message: e?.message,\n                      details,\n                    }\n                  : null,\n              });\n\n              this.send(payload, (error) => (error ? reject(error) : resolve()));\n            });\n          },\n\n          send(message, cb) {\n            ws.send(message, cb);\n          },\n          confirm(message) {\n            return new Promise((resolve, reject) => {\n              const uuid = randomUUID();\n\n              const payload = JSON.stringify({ uuid, data: message });\n\n              this.send(payload, (error) => {\n                if (error) {\n                  reject(error);\n                }\n              });\n\n              const onResponse = (raw: RawData) => {\n                const response = JSON.parse(raw.toString());\n\n                if (response.uuid === uuid) {\n                  resolve(response.data ?? null);\n                } else {\n                  ws.once('message', onResponse);\n                }\n              };\n\n              ws.once('message', onResponse);\n            });\n          },\n\n          async executeAndRespond(uuid, fn) {\n            try {\n              const response = await fn();\n              await this.respond(uuid, null, response);\n            } catch (e) {\n              if (e instanceof Error) {\n                await this.respond(uuid, e).catch(cannotRespondHandler);\n              } else if (typeof e === 'string') {\n                await this.respond(uuid, new ProviderTransferError(e)).catch(cannotRespondHandler);\n              } else {\n                await this.respond(\n                  uuid,\n                  new ProviderTransferError('Unexpected error', {\n                    error: e,\n                  })\n                ).catch(cannotRespondHandler);\n              }\n            }\n          },\n\n          cleanup() {\n            this.transferID = undefined;\n            this.startedAt = undefined;\n            this.response = undefined;\n          },\n\n          teardown() {\n            this.cleanup();\n          },\n\n          verifyAuth(scope?: TransferMethod) {\n            return verify(ctx, scope);\n          },\n\n          // Transfer commands\n          init() {},\n          end() {},\n          status() {},\n\n          // Default prototype implementation for events\n          onMessage() {},\n          onError() {},\n          onClose() {},\n          onInfo() {},\n          onWarning() {},\n        };\n\n        const handler: Handler = Object.assign(Object.create(prototype), implementation(prototype));\n\n        // Bind ws events to handler methods\n        ws.on('close', async (...args) => {\n          try {\n            await handler.onClose(...args);\n          } catch (err) {\n            strapi?.log?.error('[Data transfer] Uncaught error closing connection');\n            strapi?.log?.error(err);\n            cannotRespondHandler(err);\n          } finally {\n            resetTimeouts();\n            strapi.db.lifecycles.enable();\n            strapi.log.info('[Data transfer] Restoring lifecycle hooks');\n          }\n        });\n        ws.on('error', async (...args) => {\n          try {\n            await handler.onError(...args);\n          } catch (err) {\n            strapi?.log?.error('[Data transfer] Uncaught error in error handling');\n            strapi?.log?.error(err);\n            cannotRespondHandler(err);\n          }\n        });\n        ws.on('message', async (...args) => {\n          try {\n            await handler.onMessage(...args);\n          } catch (err) {\n            strapi?.log?.error('[Data transfer] Uncaught error in message handling');\n            strapi?.log?.error(err);\n            cannotRespondHandler(err);\n          }\n        });\n\n        diagnostics.onDiagnostic((diagnostic) => {\n          const uuid = randomUUID();\n          const payload = JSON.stringify({\n            diagnostic,\n            uuid,\n          });\n\n          handler.send(payload);\n        });\n      };\n\n      try {\n        handleWSUpgrade(wss, ctx, cb);\n      } catch (err) {\n        strapi?.log?.error('[Data transfer] Error in websocket upgrade request');\n        strapi?.log?.error(err);\n      }\n    };\n  };\n","import { randomUUID } from 'crypto';\nimport { Writable, PassThrough } from 'stream';\nimport type { Core } from '@strapi/types';\n\nimport type { TransferFlow, Step } from '../flows';\nimport type { TransferStage, IAsset, Protocol } from '../../../../types';\n\nimport { ProviderTransferError } from '../../../errors/providers';\nimport { createLocalStrapiDestinationProvider } from '../../providers';\nimport { createFlow, DEFAULT_TRANSFER_FLOW } from '../flows';\nimport { Handler } from './abstract';\nimport { handlerControllerFactory, isDataTransferMessage } from './utils';\n\nconst VALID_TRANSFER_ACTIONS = [\n  'bootstrap',\n  'close',\n  'rollback',\n  'beforeTransfer',\n  'getMetadata',\n  'getSchemas',\n] as const;\n\ntype PushTransferAction = (typeof VALID_TRANSFER_ACTIONS)[number];\n\nconst TRANSFER_KIND = 'push';\n\nexport interface PushHandler extends Handler {\n  /**\n   * Local Strapi Destination Provider used to write data to the current Strapi instance\n   */\n  provider?: ReturnType<typeof createLocalStrapiDestinationProvider>;\n\n  /**\n   * Holds all the stages' stream for the current transfer handler (one registry per connection)\n   */\n  streams?: { [stage in TransferStage]?: Writable };\n\n  stats: {\n    [stage in Exclude<TransferStage, 'schemas'>]: Protocol.Client.Stats;\n  };\n\n  /**\n   * Holds all the transferred assets for the current transfer handler (one registry per connection)\n   */\n  assets: { [filepath: string]: IAsset & { stream: PassThrough } };\n\n  /**\n   * Ochestrate and manage the transfer messages' ordering\n   */\n  flow?: TransferFlow;\n\n  /**\n   * Checks that the given action is a valid push transfer action\n   */\n  assertValidTransferAction(action: string): asserts action is PushTransferAction;\n\n  /**\n   * Create a new writable stream for the given step in the handler's stream registry\n   */\n  createWritableStreamForStep(step: TransferStage): Promise<void>;\n\n  /**\n   * Simple override of the auth verification\n   */\n  verifyAuth(): Promise<void>;\n\n  /**\n   * Callback when receiving a regular transfer message\n   */\n  onTransferMessage(msg: Protocol.Client.TransferMessage): Promise<unknown> | unknown;\n\n  /**\n   * Callback when receiving a transfer action message\n   */\n  onTransferAction(msg: Protocol.Client.Action): Promise<unknown> | unknown;\n\n  /**\n   * Callback when receiving a transfer step message\n   */\n  onTransferStep(msg: Protocol.Client.TransferPushMessage): Promise<unknown> | unknown;\n\n  /**\n   * Start streaming an asset\n   */\n  streamAsset(\n    this: PushHandler,\n    payload: Protocol.Client.GetTransferPushStreamData<'assets'>\n  ): Promise<void>;\n\n  // Transfer Flow\n\n  /**\n   * Try to move to a specific transfer stage & lock the step\n   */\n  lockTransferStep(stage: TransferStage): void;\n\n  /**\n   * Try to move to unlock the current step\n   */\n  unlockTransferStep(stage: TransferStage): void;\n\n  /**\n   * Checks whether it's possible to stream a chunk for the given stage\n   */\n  assertValidStreamTransferStep(stage: TransferStage): void;\n}\n\nconst writeAsync = <T>(stream: Writable, data: T) => {\n  return new Promise<void>((resolve, reject) => {\n    stream.write(data, (error) => {\n      if (error) {\n        reject(error);\n      }\n\n      resolve();\n    });\n  });\n};\n\nexport const createPushController = handlerControllerFactory<Partial<PushHandler>>((proto) => ({\n  isTransferStarted(this: PushHandler) {\n    return proto.isTransferStarted.call(this) && this.provider !== undefined;\n  },\n\n  verifyAuth(this: PushHandler) {\n    return proto.verifyAuth.call(this, TRANSFER_KIND);\n  },\n  onInfo(message) {\n    this.diagnostics?.report({\n      details: {\n        message,\n        origin: 'push-handler',\n        createdAt: new Date(),\n      },\n      kind: 'info',\n    });\n  },\n  onWarning(message) {\n    this.diagnostics?.report({\n      details: {\n        message,\n        createdAt: new Date(),\n        origin: 'push-handler',\n      },\n      kind: 'warning',\n    });\n  },\n  cleanup(this: PushHandler) {\n    proto.cleanup.call(this);\n\n    this.streams = {};\n    this.assets = {};\n\n    delete this.flow;\n    delete this.provider;\n  },\n\n  teardown(this: PushHandler) {\n    if (this.provider) {\n      this.provider.rollback();\n    }\n\n    proto.teardown.call(this);\n  },\n\n  assertValidTransfer(this: PushHandler) {\n    proto.assertValidTransfer.call(this);\n\n    if (this.provider === undefined) {\n      throw new Error('Invalid Transfer Process');\n    }\n  },\n\n  assertValidTransferAction(this: PushHandler, action: PushTransferAction) {\n    if (VALID_TRANSFER_ACTIONS.includes(action)) {\n      return;\n    }\n\n    throw new ProviderTransferError(`Invalid action provided: \"${action}\"`, {\n      action,\n      validActions: Object.keys(VALID_TRANSFER_ACTIONS),\n    });\n  },\n\n  assertValidStreamTransferStep(this: PushHandler, stage) {\n    const currentStep = this.flow?.get();\n    const nextStep: Step = { kind: 'transfer', stage };\n\n    if (currentStep?.kind === 'transfer' && !currentStep.locked) {\n      throw new ProviderTransferError(\n        `You need to initialize the transfer stage (${nextStep}) before starting to stream data`\n      );\n    }\n\n    if (this.flow?.cannot(nextStep)) {\n      throw new ProviderTransferError(`Invalid stage (${nextStep}) provided for the current flow`, {\n        step: nextStep,\n      });\n    }\n  },\n\n  async createWritableStreamForStep(this: PushHandler, step: Exclude<TransferStage, 'schemas'>) {\n    const mapper = {\n      entities: () => this.provider?.createEntitiesWriteStream(),\n      links: () => this.provider?.createLinksWriteStream(),\n      configuration: () => this.provider?.createConfigurationWriteStream(),\n      assets: () => this.provider?.createAssetsWriteStream(),\n    };\n\n    if (!(step in mapper)) {\n      throw new Error('Invalid transfer step, impossible to create a stream');\n    }\n\n    if (!this.streams) {\n      throw new Error('Invalid transfer state');\n    }\n\n    this.streams[step] = await mapper[step]();\n  },\n\n  async onMessage(this: PushHandler, raw) {\n    const msg = JSON.parse(raw.toString());\n\n    if (!isDataTransferMessage(msg)) {\n      return;\n    }\n\n    if (!msg.uuid) {\n      await this.respond(undefined, new Error('Missing uuid in message'));\n    }\n\n    if (proto.hasUUID(msg.uuid)) {\n      const previousResponse = proto.response;\n      if (previousResponse?.uuid === msg.uuid) {\n        await this.respond(previousResponse?.uuid, previousResponse.e, previousResponse.data);\n      }\n      return;\n    }\n\n    const { uuid, type } = msg;\n    proto.addUUID(uuid);\n    // Regular command message (init, end, status)\n    if (type === 'command') {\n      const { command } = msg;\n      this.onInfo(`received command:${command} uuid:${uuid}`);\n      await this.executeAndRespond(uuid, () => {\n        this.assertValidTransferCommand(command);\n\n        // The status command don't have params\n        if (command === 'status') {\n          return this.status();\n        }\n        return this[command](msg.params);\n      });\n    }\n\n    // Transfer message (the transfer must be init first)\n    else if (type === 'transfer') {\n      this.onInfo(`received transfer action:${msg.action} step:${msg.kind} uuid:${uuid}`);\n      await this.executeAndRespond(uuid, async () => {\n        await this.verifyAuth();\n\n        this.assertValidTransfer();\n\n        return this.onTransferMessage(msg);\n      });\n    }\n\n    // Invalid messages\n    else {\n      await this.respond(uuid, new Error('Bad Request'));\n    }\n  },\n\n  async onTransferMessage(this: PushHandler, msg) {\n    const { kind } = msg;\n\n    if (kind === 'action') {\n      return this.onTransferAction(msg);\n    }\n\n    if (kind === 'step') {\n      return this.onTransferStep(msg as Protocol.Client.TransferPushMessage);\n    }\n  },\n\n  lockTransferStep(stage: TransferStage) {\n    const currentStep = this.flow?.get();\n    const nextStep: Step = { kind: 'transfer', stage };\n\n    if (currentStep?.kind === 'transfer' && currentStep.locked) {\n      throw new ProviderTransferError(\n        `It's not possible to start a new transfer stage (${stage}) while another one is in progress (${currentStep.stage})`\n      );\n    }\n\n    if (this.flow?.cannot(nextStep)) {\n      throw new ProviderTransferError(`Invalid stage (${stage}) provided for the current flow`, {\n        step: nextStep,\n      });\n    }\n\n    this.flow?.set({ ...nextStep, locked: true });\n  },\n\n  unlockTransferStep(stage: TransferStage) {\n    const currentStep = this.flow?.get();\n    const nextStep: Step = { kind: 'transfer', stage };\n\n    // Cannot unlock if not locked (aka: started)\n    if (currentStep?.kind === 'transfer' && !currentStep.locked) {\n      throw new ProviderTransferError(\n        `You need to initialize the transfer stage (${stage}) before ending it`\n      );\n    }\n\n    // Cannot unlock if invalid step provided\n    if (this.flow?.cannot(nextStep)) {\n      throw new ProviderTransferError(`Invalid stage (${stage}) provided for the current flow`, {\n        step: nextStep,\n      });\n    }\n\n    this.flow?.set({ ...nextStep, locked: false });\n  },\n\n  async onTransferStep(this: PushHandler, msg) {\n    const { step: stage } = msg;\n\n    if (msg.action === 'start') {\n      this.lockTransferStep(stage);\n\n      if (this.streams?.[stage] instanceof Writable) {\n        throw new Error('Stream already created, something went wrong');\n      }\n\n      await this.createWritableStreamForStep(stage);\n\n      this.stats[stage] = { started: 0, finished: 0 };\n\n      return { ok: true };\n    }\n\n    if (msg.action === 'stream') {\n      this.assertValidStreamTransferStep(stage);\n\n      // Stream operation on the current transfer stage\n      const stream = this.streams?.[stage];\n\n      if (!stream) {\n        throw new Error('You need to init first');\n      }\n\n      // Assets are nested streams\n      if (stage === 'assets') {\n        return this.streamAsset(msg.data);\n      }\n\n      // For all other steps\n      await Promise.all(\n        msg.data.map(async (item) => {\n          this.stats[stage].started += 1;\n          await writeAsync(stream, item);\n          this.stats[stage].finished += 1;\n        })\n      );\n    }\n\n    if (msg.action === 'end') {\n      this.unlockTransferStep(stage);\n      const stream = this.streams?.[stage];\n\n      if (stream && !stream.closed) {\n        await new Promise((resolve, reject) => {\n          stream.on('close', resolve).on('error', reject).end();\n        });\n      }\n\n      delete this.streams?.[stage];\n\n      return { ok: true, stats: this.stats[stage] };\n    }\n  },\n\n  async onTransferAction(this: PushHandler, msg) {\n    const { action } = msg;\n\n    this.assertValidTransferAction(action);\n\n    const step: Step = { kind: 'action', action };\n    const isStepRegistered = this.flow?.has(step);\n\n    if (isStepRegistered) {\n      if (this.flow?.cannot(step)) {\n        throw new ProviderTransferError(`Invalid action \"${action}\" found for the current flow `, {\n          action,\n        });\n      }\n\n      this.flow?.set(step);\n    }\n    if (action === 'bootstrap') {\n      return this.provider?.[action](this.diagnostics);\n    }\n    return this.provider?.[action]();\n  },\n\n  async streamAsset(this: PushHandler, payload) {\n    const assetsStream = this.streams?.assets;\n\n    // TODO: close the stream upon receiving an 'end' event instead\n    if (payload === null) {\n      this.streams?.assets?.end();\n      return;\n    }\n\n    for (const item of payload) {\n      const { action, assetID } = item;\n\n      if (!assetsStream) {\n        throw new Error('Stream not defined');\n      }\n\n      if (action === 'start') {\n        this.stats.assets.started += 1;\n        this.assets[assetID] = { ...item.data, stream: new PassThrough() };\n        writeAsync(assetsStream, this.assets[assetID]);\n      }\n\n      if (action === 'stream') {\n        // The buffer has gone through JSON operations and is now of shape { type: \"Buffer\"; data: UInt8Array }\n        // We need to transform it back into a Buffer instance\n        const rawBuffer = item.data as unknown as { type: 'Buffer'; data: Uint8Array };\n        const chunk = Buffer.from(rawBuffer.data);\n        await writeAsync(this.assets[assetID].stream, chunk);\n      }\n\n      if (action === 'end') {\n        await new Promise<void>((resolve, reject) => {\n          const { stream: assetStream } = this.assets[assetID];\n          assetStream\n            .on('close', () => {\n              this.stats.assets.finished += 1;\n              delete this.assets[assetID];\n              resolve();\n            })\n            .on('error', reject)\n            .end();\n        });\n      }\n    }\n  },\n\n  onClose(this: Handler) {\n    this.teardown();\n  },\n\n  onError(this: Handler, err) {\n    this.teardown();\n    strapi.log.error(err);\n  },\n\n  // Commands\n\n  async init(\n    this: PushHandler,\n    params: Protocol.Client.GetCommandParams<'init'>\n  ): Promise<Protocol.Server.Payload<Protocol.Server.InitMessage>> {\n    if (this.transferID || this.provider) {\n      throw new Error('Transfer already in progress');\n    }\n\n    await this.verifyAuth();\n\n    this.transferID = randomUUID();\n    this.startedAt = Date.now();\n\n    this.assets = {};\n    this.streams = {};\n    this.stats = {\n      assets: { started: 0, finished: 0 },\n      configuration: { started: 0, finished: 0 },\n      entities: { started: 0, finished: 0 },\n      links: { started: 0, finished: 0 },\n    };\n\n    this.flow = createFlow(DEFAULT_TRANSFER_FLOW);\n\n    this.provider = createLocalStrapiDestinationProvider({\n      ...params.options,\n      autoDestroy: false,\n      getStrapi: () => strapi as Core.Strapi,\n    });\n\n    this.provider.onWarning = (message) => {\n      this.onWarning(message);\n      strapi.log.warn(message);\n    };\n\n    return { transferID: this.transferID };\n  },\n\n  async status(this: PushHandler) {\n    const isStarted = this.isTransferStarted();\n\n    if (isStarted) {\n      const startedAt = this.startedAt as number;\n\n      return {\n        active: true,\n        kind: TRANSFER_KIND,\n        startedAt,\n        elapsed: Date.now() - startedAt,\n      };\n    }\n\n    return { active: false, kind: null, elapsed: null, startedAt: null };\n  },\n\n  async end(\n    this: PushHandler,\n    params: Protocol.Client.GetCommandParams<'end'>\n  ): Promise<Protocol.Server.Payload<Protocol.Server.EndMessage>> {\n    await this.verifyAuth();\n\n    if (this.transferID !== params?.transferID) {\n      throw new ProviderTransferError('Bad transfer ID provided');\n    }\n\n    this.cleanup();\n\n    return { ok: true };\n  },\n}));\n","import { Readable } from 'stream';\nimport { randomUUID } from 'crypto';\nimport type { Core } from '@strapi/types';\n\nimport { Handler } from './abstract';\nimport { handlerControllerFactory, isDataTransferMessage } from './utils';\nimport { createLocalStrapiSourceProvider, ILocalStrapiSourceProvider } from '../../providers';\nimport { ProviderTransferError } from '../../../errors/providers';\nimport type { IAsset, TransferStage, Protocol } from '../../../../types';\nimport { Client } from '../../../../types/remote/protocol';\n\nconst TRANSFER_KIND = 'pull';\nconst VALID_TRANSFER_ACTIONS = ['bootstrap', 'close', 'getMetadata', 'getSchemas'] as const;\n\ntype PullTransferAction = (typeof VALID_TRANSFER_ACTIONS)[number];\n\nexport interface PullHandler extends Handler {\n  provider?: ILocalStrapiSourceProvider;\n\n  streams?: { [stage in TransferStage]?: Readable };\n\n  assertValidTransferAction(action: string): asserts action is PullTransferAction;\n\n  onTransferMessage(msg: Protocol.Client.TransferMessage): Promise<unknown> | unknown;\n  onTransferAction(msg: Protocol.Client.Action): Promise<unknown> | unknown;\n  onTransferStep(msg: Protocol.Client.TransferPullMessage): Promise<unknown> | unknown;\n\n  createReadableStreamForStep(step: TransferStage): Promise<void>;\n\n  flush(stage: TransferStage, id: string): Promise<void> | void;\n}\n\nexport const createPullController = handlerControllerFactory<Partial<PullHandler>>((proto) => ({\n  isTransferStarted(this: PullHandler) {\n    return proto.isTransferStarted.call(this) && this.provider !== undefined;\n  },\n\n  verifyAuth(this: PullHandler) {\n    return proto.verifyAuth.call(this, TRANSFER_KIND);\n  },\n\n  cleanup(this: PullHandler) {\n    proto.cleanup.call(this);\n\n    this.streams = {};\n\n    delete this.provider;\n  },\n\n  onInfo(message) {\n    this.diagnostics?.report({\n      details: {\n        message,\n        origin: 'pull-handler',\n        createdAt: new Date(),\n      },\n      kind: 'info',\n    });\n  },\n  onWarning(message) {\n    this.diagnostics?.report({\n      details: {\n        message,\n        createdAt: new Date(),\n        origin: 'pull-handler',\n      },\n      kind: 'warning',\n    });\n  },\n\n  onError(error) {\n    this.diagnostics?.report({\n      details: {\n        message: error.message,\n        error,\n        createdAt: new Date(),\n        name: error.name,\n        severity: 'fatal',\n      },\n      kind: 'error',\n    });\n  },\n\n  assertValidTransferAction(this: PullHandler, action) {\n    // Abstract the constant to string[] to allow looser check on the given action\n    const validActions = VALID_TRANSFER_ACTIONS as unknown as string[];\n\n    if (validActions.includes(action)) {\n      return;\n    }\n\n    throw new ProviderTransferError(`Invalid action provided: \"${action}\"`, {\n      action,\n      validActions: Object.keys(VALID_TRANSFER_ACTIONS),\n    });\n  },\n\n  async onMessage(this: PullHandler, raw) {\n    const msg = JSON.parse(raw.toString());\n\n    if (!isDataTransferMessage(msg)) {\n      return;\n    }\n\n    if (!msg.uuid) {\n      await this.respond(undefined, new Error('Missing uuid in message'));\n    }\n\n    if (proto.hasUUID(msg.uuid)) {\n      const previousResponse = proto.response;\n      if (previousResponse?.uuid === msg.uuid) {\n        await this.respond(previousResponse?.uuid, previousResponse.e, previousResponse.data);\n      }\n      return;\n    }\n\n    const { uuid, type } = msg;\n    proto.addUUID(uuid);\n    // Regular command message (init, end, status)\n    if (type === 'command') {\n      const { command } = msg;\n      this.onInfo(`received command:${command} uuid:${uuid}`);\n      await this.executeAndRespond(uuid, () => {\n        this.assertValidTransferCommand(command);\n\n        // The status command don't have params\n        if (command === 'status') {\n          return this.status();\n        }\n\n        return this[command](msg.params);\n      });\n    }\n\n    // Transfer message (the transfer must be init first)\n    else if (type === 'transfer') {\n      this.onInfo(`received transfer action:${msg.action} step:${msg.kind} uuid:${uuid}`);\n      await this.executeAndRespond(uuid, async () => {\n        await this.verifyAuth();\n\n        this.assertValidTransfer();\n\n        return this.onTransferMessage(msg);\n      });\n    }\n\n    // Invalid messages\n    else {\n      await this.respond(uuid, new Error('Bad Request'));\n    }\n  },\n\n  async onTransferMessage(this: PullHandler, msg) {\n    const { kind } = msg;\n\n    if (kind === 'action') {\n      return this.onTransferAction(msg);\n    }\n\n    if (kind === 'step') {\n      return this.onTransferStep(msg as Protocol.Client.TransferPullMessage);\n    }\n  },\n\n  async onTransferAction(this: PullHandler, msg) {\n    const { action } = msg;\n\n    this.assertValidTransferAction(action);\n\n    if (action === 'bootstrap') {\n      return this.provider?.[action](this.diagnostics);\n    }\n    return this.provider?.[action]();\n  },\n\n  async flush(this: PullHandler, stage: Client.TransferPullStep, id) {\n    type Stage = typeof stage;\n    const batchSize = 1024 * 1024;\n    let batch = [] as Client.GetTransferPullStreamData<Stage>;\n    const stream = this.streams?.[stage];\n\n    const batchLength = () => Buffer.byteLength(JSON.stringify(batch));\n\n    const maybeConfirm = async (data: any) => {\n      try {\n        await this.confirm(data);\n      } catch (error) {\n        // Handle the error, log it, or take other appropriate actions\n\n        strapi?.log.error(\n          `[Data transfer] Message confirmation failed: ${(error as Error)?.message}`\n        );\n        this.onError(error as Error);\n      }\n    };\n\n    const sendBatch = async () => {\n      await this.confirm({\n        type: 'transfer',\n        data: batch,\n        ended: false,\n        error: null,\n        id,\n      });\n      batch = [];\n    };\n\n    if (!stream) {\n      throw new ProviderTransferError(`No available stream found for ${stage}`);\n    }\n\n    try {\n      for await (const chunk of stream) {\n        if (stage !== 'assets') {\n          batch.push(chunk);\n          if (batchLength() >= batchSize) {\n            await sendBatch();\n          }\n        } else {\n          await this.confirm({\n            type: 'transfer',\n            data: [chunk],\n            ended: false,\n            error: null,\n            id,\n          });\n        }\n      }\n\n      if (batch.length > 0 && stage !== 'assets') {\n        await sendBatch();\n      }\n      await this.confirm({ type: 'transfer', data: null, ended: true, error: null, id });\n    } catch (e) {\n      // TODO: if this confirm fails, can we abort the whole transfer?\n      await maybeConfirm({ type: 'transfer', data: null, ended: true, error: e, id });\n    }\n  },\n\n  async onTransferStep(this: PullHandler, msg) {\n    const { step, action } = msg;\n\n    if (action === 'start') {\n      if (this.streams?.[step] instanceof Readable) {\n        throw new Error('Stream already created, something went wrong');\n      }\n\n      const flushUUID = randomUUID();\n\n      await this.createReadableStreamForStep(step);\n      this.flush(step, flushUUID);\n\n      return { ok: true, id: flushUUID };\n    }\n\n    if (action === 'end') {\n      const stream = this.streams?.[step];\n\n      if (stream?.readableEnded === false) {\n        await new Promise((resolve) => {\n          stream?.on('close', resolve).destroy();\n        });\n      }\n\n      delete this.streams?.[step];\n\n      return { ok: true };\n    }\n  },\n\n  async createReadableStreamForStep(this: PullHandler, step: Exclude<TransferStage, 'schemas'>) {\n    const mapper = {\n      entities: () => this.provider?.createEntitiesReadStream(),\n      links: () => this.provider?.createLinksReadStream(),\n      configuration: () => this.provider?.createConfigurationReadStream(),\n      assets: () => {\n        const assets = this.provider?.createAssetsReadStream();\n        let batch: Protocol.Client.TransferAssetFlow[] = [];\n\n        const batchLength = () => {\n          return batch.reduce(\n            (acc, chunk) => (chunk.action === 'stream' ? acc + chunk.data.byteLength : acc),\n            0\n          );\n        };\n\n        const BATCH_MAX_SIZE = 1024 * 1024; // 1MB\n\n        if (!assets) {\n          throw new Error('Assets read stream could not be created');\n        }\n        /**\n         * Generates batches of 1MB of data from the assets stream to avoid\n         * sending too many small chunks\n         *\n         * @param stream Assets stream from the local source provider\n         */\n        async function* generator(stream: Readable) {\n          let hasStarted = false;\n          let assetID = '';\n\n          for await (const chunk of stream) {\n            const { stream: assetStream, ...assetData } = chunk as IAsset;\n            if (!hasStarted) {\n              assetID = randomUUID();\n              // Start the transfer of a new asset\n              batch.push({ action: 'start', assetID, data: assetData });\n              hasStarted = true;\n            }\n\n            for await (const assetChunk of assetStream) {\n              // Add the asset data to the batch\n              batch.push({ action: 'stream', assetID, data: assetChunk });\n\n              // if the batch size is bigger than BATCH_MAX_SIZE stream the batch\n              if (batchLength() >= BATCH_MAX_SIZE) {\n                yield batch;\n                batch = [];\n              }\n            }\n\n            // All the asset data has been streamed and gets ready for the next one\n            hasStarted = false;\n            batch.push({ action: 'end', assetID });\n            yield batch;\n            batch = [];\n          }\n        }\n\n        return Readable.from(generator(assets));\n      },\n    };\n\n    if (!(step in mapper)) {\n      throw new Error('Invalid transfer step, impossible to create a stream');\n    }\n\n    if (!this.streams) {\n      throw new Error('Invalid transfer state');\n    }\n\n    this.streams[step] = await mapper[step]();\n  },\n\n  // Commands\n  async init(this: PullHandler) {\n    if (this.transferID || this.provider) {\n      throw new Error('Transfer already in progress');\n    }\n    await this.verifyAuth();\n\n    this.transferID = randomUUID();\n    this.startedAt = Date.now();\n\n    this.streams = {};\n\n    this.provider = createLocalStrapiSourceProvider({\n      autoDestroy: false,\n      getStrapi: () => strapi as Core.Strapi,\n    });\n\n    return { transferID: this.transferID };\n  },\n\n  async end(\n    this: PullHandler,\n    params: Protocol.Client.GetCommandParams<'end'>\n  ): Promise<Protocol.Server.Payload<Protocol.Server.EndMessage>> {\n    await this.verifyAuth();\n\n    if (this.transferID !== params?.transferID) {\n      throw new ProviderTransferError('Bad transfer ID provided');\n    }\n\n    this.cleanup();\n\n    return { ok: true };\n  },\n\n  async status(this: PullHandler) {\n    const isStarted = this.isTransferStarted();\n\n    if (!isStarted) {\n      const startedAt = this.startedAt as number;\n      return {\n        active: true,\n        kind: TRANSFER_KIND,\n        startedAt,\n        elapsed: Date.now() - startedAt,\n      };\n    }\n    return { active: false, kind: null, elapsed: null, startedAt: null };\n  },\n}));\n","import path from 'path';\n\n/**\n * Note: in versions of the transfer engine <=4.9.0, exports were generated with windows paths\n * on Windows systems, and posix paths on posix systems.\n *\n * We now store all paths as posix, but need to leave a separator conversion for legacy purposes, and to\n * support manually-created tar files coming from Windows systems (ie, if a user creates a\n * backup file with a windows tar tool rather than using the `export` command)\n *\n * Because of this, export/import files may never contain files with a forward slash in the name, even escaped\n *\n * */\n\n/**\n * Check if the directory of a given filePath (which can be either posix or win32) resolves to the same as the given posix-format path posixDirName\n * We must be able to assume the first argument is a path to a directory and the second is a path to a file, otherwise path.dirname will interpret a path without any slashes as the filename\n *\n * @param {string} posixDirName A posix path pointing to a directory\n * @param {string} filePath an unknown filesystem path pointing to a file\n * @returns {boolean} is the file located in the given directory\n */\nexport const isFilePathInDirname = (posixDirName: string, filePath: string) => {\n  const normalizedDir = path.posix.dirname(unknownPathToPosix(filePath));\n  return isPathEquivalent(posixDirName, normalizedDir);\n};\n\n/**\n *  Check if two paths that can be either in posix or win32 format resolves to the same file\n *\n * @param {string} pathA a path that may be either win32 or posix\n * @param {string} pathB a path that may be either win32 or posix\n *\n * @returns {boolean} do paths point to the same place\n */\nexport const isPathEquivalent = (pathA: string, pathB: string) => {\n  // Check if paths appear to be win32 or posix, and if win32 convert to posix\n  const normalizedPathA = path.posix.normalize(unknownPathToPosix(pathA));\n  const normalizedPathB = path.posix.normalize(unknownPathToPosix(pathB));\n\n  return !path.posix.relative(normalizedPathB, normalizedPathA).length;\n};\n\n/**\n *  Convert an unknown format path (win32 or posix) to a posix path\n *\n * @param {string} filePath a path that may be either win32 or posix\n *\n * @returns {string} a posix path\n */\nexport const unknownPathToPosix = (filePath: string) => {\n  // if it includes a forward slash, it must be posix already -- we will not support win32 with mixed path separators\n  if (filePath.includes(path.posix.sep)) {\n    return filePath;\n  }\n\n  return path.normalize(filePath).split(path.win32.sep).join(path.posix.sep);\n};\n","import type { Readable } from 'stream';\n\nimport zip from 'zlib';\nimport path from 'path';\nimport { pipeline, PassThrough } from 'stream';\nimport fs from 'fs-extra';\nimport tar from 'tar';\nimport { isEmpty, keyBy } from 'lodash/fp';\nimport { chain } from 'stream-chain';\nimport { parser } from 'stream-json/jsonl/Parser';\nimport type { Struct } from '@strapi/types';\n\nimport type { IAsset, IMetadata, ISourceProvider, ProviderType, IFile } from '../../../../types';\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\n\nimport * as utils from '../../../utils';\nimport { ProviderInitializationError, ProviderTransferError } from '../../../errors/providers';\nimport { isFilePathInDirname, isPathEquivalent, unknownPathToPosix } from './utils';\n\ntype StreamItemArray = Parameters<typeof chain>[0];\n\n/**\n * Constant for the metadata file path\n */\nconst METADATA_FILE_PATH = 'metadata.json';\n\n/**\n * Provider options\n */\nexport interface ILocalFileSourceProviderOptions {\n  file: {\n    path: string; // the file to load\n  };\n\n  encryption: {\n    enabled: boolean; // if the file is encrypted (and should be decrypted)\n    key?: string; // the key to decrypt the file\n  };\n\n  compression: {\n    enabled: boolean; // if the file is compressed (and should be decompressed)\n  };\n}\n\nexport const createLocalFileSourceProvider = (options: ILocalFileSourceProviderOptions) => {\n  return new LocalFileSourceProvider(options);\n};\n\nclass LocalFileSourceProvider implements ISourceProvider {\n  type: ProviderType = 'source';\n\n  name = 'source::local-file';\n\n  options: ILocalFileSourceProviderOptions;\n\n  #metadata?: IMetadata;\n\n  #diagnostics?: IDiagnosticReporter;\n\n  constructor(options: ILocalFileSourceProviderOptions) {\n    this.options = options;\n\n    const { encryption } = this.options;\n\n    if (encryption.enabled && encryption.key === undefined) {\n      throw new Error('Missing encryption key');\n    }\n  }\n\n  #reportInfo(message: string) {\n    this.#diagnostics?.report({\n      details: {\n        createdAt: new Date(),\n        message,\n        origin: 'file-source-provider',\n      },\n      kind: 'info',\n    });\n  }\n\n  /**\n   * Pre flight checks regarding the provided options, making sure that the file can be opened (decrypted, decompressed), etc.\n   */\n  async bootstrap(diagnostics: IDiagnosticReporter) {\n    this.#diagnostics = diagnostics;\n    const { path: filePath } = this.options.file;\n\n    try {\n      // Read the metadata to ensure the file can be parsed\n      await this.#loadMetadata();\n      // TODO: we might also need to read the schema.jsonl files & implements a custom stream-check\n    } catch (e) {\n      if (this.options?.encryption?.enabled) {\n        throw new ProviderInitializationError(\n          `Key is incorrect or the file '${filePath}' is not a valid Strapi data file.`\n        );\n      }\n      throw new ProviderInitializationError(`File '${filePath}' is not a valid Strapi data file.`);\n    }\n\n    if (!this.#metadata) {\n      throw new ProviderInitializationError('Could not load metadata from Strapi data file.');\n    }\n  }\n\n  async #loadMetadata() {\n    const backupStream = this.#getBackupStream();\n    this.#metadata = await this.#parseJSONFile<IMetadata>(backupStream, METADATA_FILE_PATH);\n  }\n\n  async #loadAssetMetadata(path: string) {\n    const backupStream = this.#getBackupStream();\n    return this.#parseJSONFile<IFile>(backupStream, path);\n  }\n\n  async getMetadata() {\n    this.#reportInfo('getting metadata');\n    if (!this.#metadata) {\n      await this.#loadMetadata();\n    }\n\n    return this.#metadata ?? null;\n  }\n\n  async getSchemas() {\n    this.#reportInfo('getting schemas');\n    const schemaCollection = await utils.stream.collect<Struct.Schema>(\n      this.createSchemasReadStream()\n    );\n\n    if (isEmpty(schemaCollection)) {\n      throw new ProviderInitializationError('Could not load schemas from Strapi data file.');\n    }\n\n    // Group schema by UID\n    const schemas = keyBy('uid', schemaCollection);\n\n    // Transform to valid JSON\n    return utils.schema.schemasToValidJSON(schemas);\n  }\n\n  createEntitiesReadStream(): Readable {\n    this.#reportInfo('creating entities read stream');\n    return this.#streamJsonlDirectory('entities');\n  }\n\n  createSchemasReadStream(): Readable {\n    this.#reportInfo('creating schemas read stream');\n    return this.#streamJsonlDirectory('schemas');\n  }\n\n  createLinksReadStream(): Readable {\n    this.#reportInfo('creating links read stream');\n    return this.#streamJsonlDirectory('links');\n  }\n\n  createConfigurationReadStream(): Readable {\n    this.#reportInfo('creating configuration read stream');\n    // NOTE: TBD\n    return this.#streamJsonlDirectory('configuration');\n  }\n\n  createAssetsReadStream(): Readable | Promise<Readable> {\n    const inStream = this.#getBackupStream();\n    const outStream = new PassThrough({ objectMode: true });\n    const loadAssetMetadata = this.#loadAssetMetadata.bind(this);\n    this.#reportInfo('creating assets read stream');\n\n    pipeline(\n      [\n        inStream,\n        new tar.Parse({\n          // find only files in the assets/uploads folder\n          filter(filePath, entry) {\n            if (entry.type !== 'File') {\n              return false;\n            }\n            return isFilePathInDirname('assets/uploads', filePath);\n          },\n          async onentry(entry) {\n            const { path: filePath, size = 0 } = entry;\n            const normalizedPath = unknownPathToPosix(filePath);\n            const file = path.basename(normalizedPath);\n            let metadata;\n            try {\n              metadata = await loadAssetMetadata(`assets/metadata/${file}.json`);\n            } catch (error) {\n              throw new Error(`Failed to read metadata for ${file}`);\n            }\n            const asset: IAsset = {\n              metadata,\n              filename: file,\n              filepath: normalizedPath,\n              stats: { size },\n              stream: entry as unknown as Readable,\n            };\n            outStream.write(asset);\n          },\n        }),\n      ],\n      () => outStream.end()\n    );\n\n    return outStream;\n  }\n\n  #getBackupStream() {\n    const { file, encryption, compression } = this.options;\n\n    const streams: StreamItemArray = [];\n\n    try {\n      streams.push(fs.createReadStream(file.path));\n    } catch (e) {\n      throw new Error(`Could not read backup file path provided at \"${this.options.file.path}\"`);\n    }\n\n    if (encryption.enabled && encryption.key) {\n      streams.push(utils.encryption.createDecryptionCipher(encryption.key));\n    }\n\n    if (compression.enabled) {\n      streams.push(zip.createGunzip());\n    }\n\n    return chain(streams);\n  }\n\n  // `directory` must be posix formatted path\n  #streamJsonlDirectory(directory: string) {\n    const inStream = this.#getBackupStream();\n\n    const outStream = new PassThrough({ objectMode: true });\n\n    pipeline(\n      [\n        inStream,\n        new tar.Parse({\n          filter(filePath, entry) {\n            if (entry.type !== 'File') {\n              return false;\n            }\n\n            return isFilePathInDirname(directory, filePath);\n          },\n\n          async onentry(entry) {\n            const transforms = [\n              // JSONL parser to read the data chunks one by one (line by line)\n              parser({\n                checkErrors: true,\n              }),\n              // The JSONL parser returns each line as key/value\n              (line: { key: string; value: object }) => line.value,\n            ];\n\n            const stream = entry.pipe(chain(transforms));\n\n            try {\n              for await (const chunk of stream) {\n                outStream.write(chunk);\n              }\n            } catch (e: unknown) {\n              outStream.destroy(\n                new ProviderTransferError(\n                  `Error parsing backup files from backup file ${entry.path}: ${\n                    (e as Error).message\n                  }`,\n                  {\n                    details: {\n                      error: e,\n                    },\n                  }\n                )\n              );\n            }\n          },\n        }),\n      ],\n      async () => {\n        // Manually send the 'end' event to the out stream\n        // once every entry has finished streaming its content\n        outStream.end();\n      }\n    );\n\n    return outStream;\n  }\n\n  // For collecting an entire JSON file then parsing it, not for streaming JSONL\n  async #parseJSONFile<T extends object>(fileStream: Readable, filePath: string): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      pipeline(\n        [\n          fileStream,\n          // Custom backup archive parsing\n          new tar.Parse({\n            /**\n             * Filter the parsed entries to only keep the one that matches the given filepath\n             */\n            filter(entryPath, entry) {\n              if (entry.type !== 'File') {\n                return false;\n              }\n\n              return isPathEquivalent(entryPath, filePath);\n            },\n\n            async onentry(entry) {\n              // Collect all the content of the entry file\n              const content = await entry.collect();\n\n              try {\n                // Parse from buffer array to string to JSON\n                const parsedContent = JSON.parse(Buffer.concat(content).toString());\n\n                // Resolve the Promise with the parsed content\n                resolve(parsedContent);\n              } catch (e) {\n                reject(e);\n              } finally {\n                // Cleanup (close the stream associated to the entry)\n                entry.destroy();\n              }\n            },\n          }),\n        ],\n        () => {\n          // If the promise hasn't been resolved and we've parsed all\n          // the archive entries, then the file doesn't exist\n          reject(new Error(`File \"${filePath}\" not found`));\n        }\n      );\n    });\n  }\n}\n","import { Writable } from 'stream';\nimport { posix } from 'path';\nimport tar from 'tar-stream';\n\n/**\n * Create a file path factory for a given path & prefix.\n * Upon being called, the factory will return a file path for a given index\n */\nexport const createFilePathFactory =\n  (type: string) =>\n  (fileIndex = 0): string => {\n    // always write tar files with posix paths so we have a standard format for paths regardless of system\n    return posix.join(\n      // \"{type}\" directory\n      type,\n      // \"${type}_XXXXX.jsonl\" file\n      `${type}_${String(fileIndex).padStart(5, '0')}.jsonl`\n    );\n  };\n\nexport const createTarEntryStream = (\n  archive: tar.Pack,\n  pathFactory: (index?: number) => string,\n  maxSize = 2.56e8\n) => {\n  let fileIndex = 0;\n  let buffer = '';\n\n  const flush = async () => {\n    if (!buffer) {\n      return;\n    }\n\n    fileIndex += 1;\n    const name = pathFactory(fileIndex);\n    const size = buffer.length;\n\n    await new Promise<void>((resolve, reject) => {\n      archive.entry({ name, size }, buffer, (err) => {\n        if (err) {\n          reject(err);\n        }\n\n        resolve();\n      });\n    });\n\n    buffer = '';\n  };\n\n  const push = (chunk: string | Buffer) => {\n    buffer += chunk;\n  };\n\n  return new Writable({\n    async destroy(err, callback) {\n      await flush();\n      callback(err);\n    },\n\n    async write(chunk, _encoding, callback) {\n      const size = chunk.length;\n\n      if (chunk.length > maxSize) {\n        callback(new Error(`payload too large: ${chunk.length}>${maxSize}`));\n        return;\n      }\n\n      if (buffer.length + size > maxSize) {\n        await flush();\n      }\n\n      push(chunk);\n\n      callback(null);\n    },\n  });\n};\n","import path from 'path';\nimport zlib from 'zlib';\nimport { Readable, Writable } from 'stream';\nimport { rm, createWriteStream } from 'fs-extra';\nimport tar from 'tar-stream';\nimport { stringer } from 'stream-json/jsonl/Stringer';\nimport { chain } from 'stream-chain';\n\nimport { createEncryptionCipher } from '../../../utils/encryption';\nimport type {\n  IAsset,\n  IDestinationProvider,\n  IDestinationProviderTransferResults,\n  IMetadata,\n  ProviderType,\n  Stream,\n} from '../../../../types';\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\nimport { createFilePathFactory, createTarEntryStream } from './utils';\nimport { ProviderTransferError } from '../../../errors/providers';\n\nexport interface ILocalFileDestinationProviderOptions {\n  encryption: {\n    enabled: boolean; // if the file should be encrypted\n    key?: string; // the key to use when encryption.enabled is true\n  };\n\n  compression: {\n    enabled: boolean; // if the file should be compressed with gzip\n  };\n\n  file: {\n    path: string; // the filename to create\n    maxSize?: number; // the max size of a single backup file\n    maxSizeJsonl?: number; // the max lines of each jsonl file before creating the next file\n  };\n}\n\nexport interface ILocalFileDestinationProviderTransferResults\n  extends IDestinationProviderTransferResults {\n  file?: {\n    path?: string;\n  };\n}\n\nexport const createLocalFileDestinationProvider = (\n  options: ILocalFileDestinationProviderOptions\n) => {\n  return new LocalFileDestinationProvider(options);\n};\n\nclass LocalFileDestinationProvider implements IDestinationProvider {\n  name = 'destination::local-file';\n\n  type: ProviderType = 'destination';\n\n  options: ILocalFileDestinationProviderOptions;\n\n  results: ILocalFileDestinationProviderTransferResults = {};\n\n  #providersMetadata: { source?: IMetadata; destination?: IMetadata } = {};\n\n  #archive: { stream?: tar.Pack; pipeline?: Stream } = {};\n\n  #diagnostics?: IDiagnosticReporter;\n\n  constructor(options: ILocalFileDestinationProviderOptions) {\n    this.options = options;\n  }\n\n  #reportInfo(message: string) {\n    this.#diagnostics?.report({\n      details: {\n        createdAt: new Date(),\n        message,\n        origin: 'file-destination-provider',\n      },\n      kind: 'info',\n    });\n  }\n\n  get #archivePath() {\n    const { encryption, compression, file } = this.options;\n\n    let filePath = `${file.path}.tar`;\n\n    if (compression.enabled) {\n      filePath += '.gz';\n    }\n\n    if (encryption.enabled) {\n      filePath += '.enc';\n    }\n\n    return filePath;\n  }\n\n  setMetadata(target: ProviderType, metadata: IMetadata): IDestinationProvider {\n    this.#providersMetadata[target] = metadata;\n\n    return this;\n  }\n\n  createGzip(): zlib.Gzip {\n    this.#reportInfo('creating gzip');\n    return zlib.createGzip();\n  }\n\n  bootstrap(diagnostics: IDiagnosticReporter): void | Promise<void> {\n    this.#diagnostics = diagnostics;\n    const { compression, encryption } = this.options;\n\n    if (encryption.enabled && !encryption.key) {\n      throw new Error(\"Can't encrypt without a key\");\n    }\n\n    this.#archive.stream = tar.pack();\n\n    const outStream = createWriteStream(this.#archivePath);\n\n    outStream.on('error', (err: NodeJS.ErrnoException) => {\n      if (err.code === 'ENOSPC') {\n        throw new ProviderTransferError(\n          \"Your server doesn't have space to proceed with the import.\"\n        );\n      }\n      throw err;\n    });\n\n    const archiveTransforms: Stream[] = [];\n\n    if (compression.enabled) {\n      archiveTransforms.push(this.createGzip());\n    }\n\n    if (encryption.enabled && encryption.key) {\n      archiveTransforms.push(createEncryptionCipher(encryption.key));\n    }\n\n    this.#archive.pipeline = chain([this.#archive.stream, ...archiveTransforms, outStream]);\n\n    this.results.file = { path: this.#archivePath };\n  }\n\n  async close() {\n    const { stream, pipeline } = this.#archive;\n\n    if (!stream) {\n      return;\n    }\n\n    await this.#writeMetadata();\n    stream.finalize();\n\n    if (pipeline && !pipeline.closed) {\n      await new Promise<void>((resolve, reject) => {\n        pipeline.on('close', resolve).on('error', reject);\n      });\n    }\n  }\n\n  async rollback(): Promise<void> {\n    this.#reportInfo('rolling back');\n    await this.close();\n    await rm(this.#archivePath, { force: true });\n  }\n\n  getMetadata() {\n    return null;\n  }\n\n  async #writeMetadata(): Promise<void> {\n    this.#reportInfo('writing metadata');\n    const metadata = this.#providersMetadata.source;\n\n    if (metadata) {\n      await new Promise((resolve) => {\n        const outStream = this.#getMetadataStream();\n        const data = JSON.stringify(metadata, null, 2);\n\n        Readable.from(data).pipe(outStream).on('close', resolve);\n      });\n    }\n  }\n\n  #getMetadataStream() {\n    const { stream } = this.#archive;\n\n    if (!stream) {\n      throw new Error('Archive stream is unavailable');\n    }\n\n    return createTarEntryStream(stream, () => 'metadata.json');\n  }\n\n  createSchemasWriteStream() {\n    if (!this.#archive.stream) {\n      throw new Error('Archive stream is unavailable');\n    }\n    this.#reportInfo('creating schemas write stream');\n    const filePathFactory = createFilePathFactory('schemas');\n\n    const entryStream = createTarEntryStream(\n      this.#archive.stream,\n      filePathFactory,\n      this.options.file.maxSizeJsonl\n    );\n\n    return chain([stringer(), entryStream]);\n  }\n\n  createEntitiesWriteStream(): Writable {\n    if (!this.#archive.stream) {\n      throw new Error('Archive stream is unavailable');\n    }\n    this.#reportInfo('creating entities write stream');\n    const filePathFactory = createFilePathFactory('entities');\n\n    const entryStream = createTarEntryStream(\n      this.#archive.stream,\n      filePathFactory,\n      this.options.file.maxSizeJsonl\n    );\n\n    return chain([stringer(), entryStream]);\n  }\n\n  createLinksWriteStream(): Writable {\n    if (!this.#archive.stream) {\n      throw new Error('Archive stream is unavailable');\n    }\n    this.#reportInfo('creating links write stream');\n    const filePathFactory = createFilePathFactory('links');\n\n    const entryStream = createTarEntryStream(\n      this.#archive.stream,\n      filePathFactory,\n      this.options.file.maxSizeJsonl\n    );\n\n    return chain([stringer(), entryStream]);\n  }\n\n  createConfigurationWriteStream(): Writable {\n    if (!this.#archive.stream) {\n      throw new Error('Archive stream is unavailable');\n    }\n    this.#reportInfo('creating configuration write stream');\n    const filePathFactory = createFilePathFactory('configuration');\n\n    const entryStream = createTarEntryStream(\n      this.#archive.stream,\n      filePathFactory,\n      this.options.file.maxSizeJsonl\n    );\n\n    return chain([stringer(), entryStream]);\n  }\n\n  createAssetsWriteStream(): Writable {\n    const { stream: archiveStream } = this.#archive;\n\n    if (!archiveStream) {\n      throw new Error('Archive stream is unavailable');\n    }\n\n    this.#reportInfo('creating assets write stream');\n    return new Writable({\n      objectMode: true,\n      write(data: IAsset, _encoding, callback) {\n        // always write tar files with posix paths so we have a standard format for paths regardless of system\n        const entryPath = path.posix.join('assets', 'uploads', data.filename);\n\n        const entryMetadataPath = path.posix.join('assets', 'metadata', `${data.filename}.json`);\n        const stringifiedMetadata = JSON.stringify(data.metadata);\n        archiveStream.entry(\n          {\n            name: entryMetadataPath,\n            size: stringifiedMetadata.length,\n          },\n          stringifiedMetadata\n        );\n\n        const entry = archiveStream.entry({\n          name: entryPath,\n          size: data.stats.size,\n        });\n\n        if (!entry) {\n          callback(new Error(`Failed to created an asset tar entry for ${entryPath}`));\n          return;\n        }\n\n        data.stream.pipe(entry);\n\n        entry\n          .on('finish', () => {\n            callback(null);\n          })\n          .on('error', (error) => {\n            callback(error);\n          });\n      },\n    });\n  }\n}\n"],"names":["getEncryptionStrategy","algorithm","strategies","key","hashedKey","scryptSync","initVector","securityKey","createCipheriv","aes128","slice","aes192","aes256","createEncryptionCipher","getDecryptionStrategy","createDecipheriv","createDecryptionCipher","filter","predicate","options","objectMode","Transform","transform","chunk","_encoding","callback","keep","undefined","map","mappedValue","collect","stream","destroy","chunks","Promise","resolve","reject","on","push","createContext","path","diff","a","b","ctx","diffs","aType","bType","added","kind","type","value","deleted","modified","types","values","isArray","k","aItem","bItem","zip","kCtx","toString","kDiffs","isObject","keys","uniq","Object","concat","aValue","bValue","nestedDiffs","isEqual","VALID_SCHEMA_PROPERTIES","mapSchemasValues","schemas","mapValues","pick","schemasToValidJSON","JSON","parse","stringify","createTransaction","strapi","fns","done","resume","e","EventEmitter","uuid","cb","fn","removeAllListeners","db","transaction","trx","rollback","once","emit","length","item","shift","res","data","error","attach","randomUUID","end","runMiddleware","context","middlewares","newContext","createDiagnosticReporter","stackSize","emitter","stack","addListener","event","listener","isDiagnosticValid","diagnostic","details","message","size","items","report","onDiagnostic","OPTIONAL_CONTENT_TYPES","isAttributeIgnorable","includes","isOptionalAdminType","name","info","singularName","isIgnorableStrict","exact","strict","compareSchemas","strategy","utils","SeverityKind","FATAL","ERROR","SILLY","DataTransferError","Error","constructor","origin","severity","TransferEngineError","TransferEngineInitializationError","step","TransferEngineValidationError","TransferEngineTransferError","reason","validateProvider","provider","capitalize","ProviderError","ProviderInitializationError","ProviderValidationError","ProviderTransferError","TRANSFER_STAGES","freeze","TransferGroupPresets","content","links","entities","files","assets","config","configuration","DEFAULT_VERSION_STRATEGY","DEFAULT_SCHEMA_STRATEGY","_metadata","_class_private_field_loose_key","TransferEngine","onSchemaDiff","handler","_class_private_field_loose_base","handlers","schemaDiff","addErrorHandler","handlerName","errors","attemptResolveError","code","errorCode","ignore","panic","reportError","diagnostics","createdAt","Date","reportWarning","reportInfo","params","shouldSkipStage","stage","exclude","only","included","isEmpty","some","transferGroup","abortTransfer","aborted","currentStreamController","abort","init","resolveProviderResource","source","sourceMetadata","metadata","destinationProvider","setMetadata","bootstrap","results","allSettled","sourceProvider","forEach","result","status","close","integrityCheck","getMetadata","destinationMetadata","assertStrapiVersionIntegrity","version","sourceSchemas","destinationSchemas","getSchemas","assertSchemasMatching","schemaDiffs","ignoredDiffs","destination","unresolvedDiffs","check","transfer","progress","emitTransferUpdate","beforeTransfer","transferSchemas","transferEntities","transferAssets","transferLinks","transferConfiguration","lastDiagnostic","last","engine","runWithDiagnostic","resolved","createSchemasReadStream","createSchemasWriteStream","createStageTransformStream","tracker","progressTracker","modelType","transferStage","createEntitiesReadStream","createEntitiesWriteStream","chain","entity","availableContentTypes","entries","schema","uid","attributes","attributesToKeep","updatedEntity","set","createLinksReadStream","createLinksWriteStream","link","isValidType","left","right","createAssetsReadStream","createAssetsWriteStream","stats","extname","filename","createConfigurationReadStream","createConfigurationWriteStream","PassThrough","includeGlobal","throttle","global","globalTransforms","stageTransforms","transforms","applyTransforms","chainTransforms","pipe","isNumber","setTimeout","aggregate","count","bytes","startTime","now","stageProgress","aggregates","updateTransferProgress","emitStageUpdate","payload","sourceVersion","destinationVersion","versionStrategy","versions","semverDiff","validPatch","validMinor","validMajor","schemaStrategy","sourceSchema","destinationSchema","formattedDiffs","ctDiffs","msg","EOL","sort","join","line","updateEndTime","stageData","endTime","destroyed","state","streams","controller","AbortController","signal","pipeline","createTransferEngine","isDialectMySQL","dialect","client","omitComponentData","contentType","componentAttributes","attributeName","contentTypesUtils","isComponentAttribute","omit","createComponents","getModel","componentBody","attributeNames","attribute","has","component","componentUID","repeatable","componentValue","Array","components","async","createComponent","concurrency","inTransaction","Infinity","id","__pivot","field","component_type","dynamiczoneValues","createDynamicZoneComponents","__component","getComponents","getComponentAttributes","_","query","load","deleteComponents","entityToDelete","loadComponents","castArray","subValue","deleteComponent","model","componentData","assign","create","componentToDelete","delete","where","resolveComponentUID","paths","cType","get","sanitizeComponentLikeAttributes","componentLikeAttributesKey","omitInvalidCreationAttributes","createEntityQuery","assignToEntity","entityComponents","componentsService","dataWithoutComponents","componentsToDelete","dataWithComponents","sanitizedData","createMany","then","deleteMany","entitiesToDelete","findMany","all","deletedEntities","compos","getDeepPopulateComponentLikeQuery","select","populate","subPopulate","componentsUID","every","deepPopulateComponentLikeQuery","createLinkQuery","connection","addSchema","tableName","schemaName","connectionSettings","generateAllForAttribute","fieldName","filterValidRelationalAttributes","getLinkKind","relation","target","joinColumn","joinColumnName","qb","queryBuilder","from","transacting","entry","ref","joinTable","inverseJoinColumn","orderColumnName","morphColumn","inverseOrderColumnName","columns","inversedBy","order","idColumn","typeColumn","validColumns","column","isNil","pos","clone","whereNotNull","generateAll","insert","update","assignInverseColumn","assignOrderColumns","assignMorphColumns","into","isOwner","owner","mappedBy","morphBy","isComponentLike","endsWith","reduce","acc","startsWith","updateMappingTable","queries","Writable","write","created","json","oldID","newID","restoreCoreStore","restoreWebhooks","restoreConfigs","chalk","yellowBright","greenBright","isErrorWithCode","isForeignKeyConstraintError","MYSQL_FK_ERROR_CODES","POSTGRES_FK_ERROR_CODE","SQLITE_FK_ERROR_CODE","toLowerCase","mapID","onWarning","originalLeftRef","originalRightRef","deleteRecords","deleteEntitiesRecords","deleteConfigurationRecords","models","contentTypes","contentTypesToClear","removeThisContentType","include","filters","modelsToClear","removeThisModel","updateResults","useResults","contentTypeQuery","contentTypePromises","modelsPromises","coreStore","webhook","deletePromises","assertValidStrapi","VALID_CONFLICT_STRATEGIES","DEFAULT_CONFLICT_STRATEGY","_diagnostics","_reportInfo","LocalStrapiDestinationProvider","validateOptions","getStrapi","lifecycles","disable","autoDestroy","enable","handleAssetsBackup","deleteAllAssets","deleteFromRestoreOptions","strapiVersion","toISOString","entitiesMapper","restore","validStrategies","areAssetsIncluded","removeAssetsBackup","bind","fileEntitiesMapper","restoreMediaEntitiesContent","isContentTypeIncluded","final","next","uploadData","Readable","buffer","fileId","plugin","uploadStream","findOne","specificFormat","formats","url","notIncluded","excluded","uploadsBackupDirectoryName","file","fileFormat","assetsDirectory","dirs","static","public","backupDirectory","fse","access","constants","W_OK","R_OK","F_OK","move","mkdir","outputFile","err","rm","recursive","force","createLocalStrapiDestinationProvider","createEntitiesStream","contentTypeStreamGenerator","shared","call","entitiesGenerator","createEntitiesTransformStream","createLinksStream","uids","linkGenerator","generator","createConfigurationStream","configurationGenerator","coreStoreStream","wrapConfigurationItem","webhooksStream","getFileStream","filepath","isLocal","createReadStream","readableStream","fetch","body","fromWeb","webStream","ReadableStream","catch","getFileStats","stat","contentLength","headers","parseInt","signFile","plugins","upload","providerName","isPrivate","signUrl","signedUrl","getSignedUrl","format","createAssetsStream","isLocalProvider","hash","ext","fileFormatFilepath","fileFormatStats","fileFormatStream","mainHash","Duplex","createLocalStrapiSourceProvider","LocalStrapiSourceProvider","handleStreamError","streamType","errorMessage","formattedError","timestamp","log","createDispatcher","ws","retryMessageOptions","retryMessageMaxRetries","retryMessageTimeout","dispatch","numberOfTimesMessageWasSent","attachTransfer","transferID","command","messageToSend","action","stringifiedPayload","send","sendPeriodically","interval","setInterval","onResponse","raw","response","clearInterval","dispatchCommand","dispatchTransferAction","dispatchTransferStep","setTransferProperties","properties","transferKind","connectToWebsocket","address","server","WebSocket","_req","statusCode","trimTrailingSlash","input","replace","TRANSFER_PATH","TRANSFER_METHODS","jsonLength","obj","Buffer","byteLength","_startStep","_endStep","RemoteStrapiDestinationProvider","resetStats","initTransfer","dispatcher","auth","validProtocols","protocol","wsProtocol","wsUrl","host","pathname","Authorization","token","CLOSED","writeStream","batch","hasStarted","batchSize","batchLength","startAssetsTransferOnce","startStepOnce","flush","streamError","streamStep","safePush","endStepError","endStep","asset","startError","assetID","startStep","assetMessage","startTransferOnce","started","finished","createRemoteStrapiDestinationProvider","RemoteStrapiSourceProvider","createStageReadStream","pass","resetTimeout","timeout","clearTimeout","streamTimeout","queue","writeAsync","prototype","hasOwnProperty","processQueue","currentStatus","closeAssetStream","writeChunkToStream","rawBuffer","assertValidProtocol","defaultOptions","startResult","processID","parsed","ended","respond","createRemoteStrapiSourceProvider","createFlow","flow","stepEqual","stepA","stepB","findStepIndex","findIndex","flowStep","can","indexesDifference","cannot","canSwitch","VALID_TRANSFER_COMMANDS","transformUpgradeHeader","header","split","s","trim","timeouts","hasHttpServer","httpServer","disableTimeouts","headersTimeout","requestTimeout","resetTimeouts","assertValidHeader","upgrade","upgradeHeader","logSafeUpgradeHeader","substring","isDataTransferMessage","handleWSUpgrade","wss","handleUpgrade","req","request","socket","alloc","handlerControllerFactory","implementation","verify","serverOptions","Server","noServer","messageUUIDs","Set","cannotRespondHandler","terminate","startedAt","addUUID","add","hasUUID","isTransferStarted","assertValidTransfer","isStarted","assertValidTransferCommand","isDefined","isValidTransferCommand","confirm","executeAndRespond","cleanup","teardown","verifyAuth","scope","onMessage","onError","onClose","onInfo","args","VALID_TRANSFER_ACTIONS","TRANSFER_KIND","createPushController","proto","assertValidTransferAction","validActions","assertValidStreamTransferStep","currentStep","nextStep","locked","createWritableStreamForStep","mapper","previousResponse","onTransferMessage","onTransferAction","onTransferStep","lockTransferStep","unlockTransferStep","ok","streamAsset","closed","isStepRegistered","assetsStream","assetStream","DEFAULT_TRANSFER_FLOW","warn","active","elapsed","createPullController","maybeConfirm","sendBatch","flushUUID","createReadableStreamForStep","readableEnded","BATCH_MAX_SIZE","assetData","assetChunk","isFilePathInDirname","posixDirName","filePath","normalizedDir","posix","dirname","unknownPathToPosix","isPathEquivalent","pathA","pathB","normalizedPathA","normalize","normalizedPathB","relative","sep","win32","METADATA_FILE_PATH","createLocalFileSourceProvider","LocalFileSourceProvider","loadMetadata","encryption","enabled","schemaCollection","keyBy","streamJsonlDirectory","inStream","getBackupStream","outStream","loadAssetMetadata","tar","Parse","onentry","normalizedPath","basename","backupStream","parseJSONFile","compression","fs","createGunzip","directory","parser","checkErrors","fileStream","entryPath","parsedContent","createFilePathFactory","fileIndex","String","padStart","createTarEntryStream","archive","pathFactory","maxSize","createLocalFileDestinationProvider","LocalFileDestinationProvider","providersMetadata","createGzip","zlib","pack","createWriteStream","archivePath","archiveTransforms","writeMetadata","finalize","filePathFactory","entryStream","maxSizeJsonl","stringer","archiveStream","entryMetadataPath","stringifiedMetadata","getMetadataStream"],"mappings":"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"}