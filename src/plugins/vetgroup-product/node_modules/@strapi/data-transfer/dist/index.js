'use strict';

var stream$1 = require('stream');
var promises = require('stream/promises');
var path = require('path');
var os = require('os');
var streamChain = require('stream-chain');
var fp = require('lodash/fp');
var semver = require('semver');
var crypto = require('crypto');
var events = require('events');
var fse = require('fs-extra');
var _ = require('lodash');
var utils = require('@strapi/utils');
var chalk = require('chalk');
var webStream = require('stream/web');
var ws = require('ws');
var zip = require('zlib');
var tar = require('tar');
var Parser = require('stream-json/jsonl/Parser');
var tar$1 = require('tar-stream');
var Stringer = require('stream-json/jsonl/Stringer');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var fse__namespace = /*#__PURE__*/_interopNamespaceDefault(fse);
var webStream__namespace = /*#__PURE__*/_interopNamespaceDefault(webStream);

// different key values depending on algorithm chosen
const getEncryptionStrategy = (algorithm)=>{
    const strategies = {
        'aes-128-ecb' (key) {
            const hashedKey = crypto.scryptSync(key, '', 16);
            const initVector = null;
            const securityKey = hashedKey;
            return crypto.createCipheriv(algorithm, securityKey, initVector);
        },
        aes128 (key) {
            const hashedKey = crypto.scryptSync(key, '', 32);
            const initVector = hashedKey.slice(16);
            const securityKey = hashedKey.slice(0, 16);
            return crypto.createCipheriv(algorithm, securityKey, initVector);
        },
        aes192 (key) {
            const hashedKey = crypto.scryptSync(key, '', 40);
            const initVector = hashedKey.slice(24);
            const securityKey = hashedKey.slice(0, 24);
            return crypto.createCipheriv(algorithm, securityKey, initVector);
        },
        aes256 (key) {
            const hashedKey = crypto.scryptSync(key, '', 48);
            const initVector = hashedKey.slice(32);
            const securityKey = hashedKey.slice(0, 32);
            return crypto.createCipheriv(algorithm, securityKey, initVector);
        }
    };
    return strategies[algorithm];
};
/**
 * It creates a cipher instance used for encryption
 *
 * @param key - The encryption key
 * @param algorithm - The algorithm to use to create the Cipher
 *
 * @returns A {@link Cipher} instance created with the given key & algorithm
 */ const createEncryptionCipher = (key, algorithm = 'aes-128-ecb')=>{
    return getEncryptionStrategy(algorithm)(key);
};

// different key values depending on algorithm chosen
const getDecryptionStrategy = (algorithm)=>{
    const strategies = {
        'aes-128-ecb' (key) {
            const hashedKey = crypto.scryptSync(key, '', 16);
            const initVector = null;
            const securityKey = hashedKey;
            return crypto.createDecipheriv(algorithm, securityKey, initVector);
        },
        aes128 (key) {
            const hashedKey = crypto.scryptSync(key, '', 32);
            const initVector = hashedKey.slice(16);
            const securityKey = hashedKey.slice(0, 16);
            return crypto.createDecipheriv(algorithm, securityKey, initVector);
        },
        aes192 (key) {
            const hashedKey = crypto.scryptSync(key, '', 40);
            const initVector = hashedKey.slice(24);
            const securityKey = hashedKey.slice(0, 24);
            return crypto.createDecipheriv(algorithm, securityKey, initVector);
        },
        aes256 (key) {
            const hashedKey = crypto.scryptSync(key, '', 48);
            const initVector = hashedKey.slice(32);
            const securityKey = hashedKey.slice(0, 32);
            return crypto.createDecipheriv(algorithm, securityKey, initVector);
        }
    };
    return strategies[algorithm];
};
/**
 * It creates a cipher instance used for decryption
 *
 * @param key - The decryption key
 * @param algorithm - The algorithm to use to create the Cipher
 *
 * @returns A {@link Cipher} instance created with the given key & algorithm
 */ const createDecryptionCipher = (key, algorithm = 'aes-128-ecb')=>{
    return getDecryptionStrategy(algorithm)(key);
};

var index$9 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createDecryptionCipher: createDecryptionCipher,
  createEncryptionCipher: createEncryptionCipher
});

/**
 * Create a filter stream that discard chunks which doesn't satisfies the given predicate
 *
 * @param predicate - A filter predicate, takes a stream data chunk as parameter and returns a boolean value
 * @param options - Transform stream options
 */ const filter = (predicate, options = {
    objectMode: true
})=>{
    return new stream$1.Transform({
        ...options,
        async transform (chunk, _encoding, callback) {
            const keep = await predicate(chunk);
            callback(null, keep ? chunk : undefined);
        }
    });
};
/**
 * Create a map stream that transform chunks using the given predicate
 *
 * @param predicate - A map predicate, takes a stream data chunk as parameter and returns a mapped value
 * @param options - Transform stream options
 */ const map = (predicate, options = {
    objectMode: true
})=>{
    return new stream$1.Transform({
        ...options,
        async transform (chunk, _encoding, callback) {
            const mappedValue = await predicate(chunk);
            callback(null, mappedValue);
        }
    });
};
/**
 * Collect every chunks from a Readable stream.
 *
 * @param stream - The redable stream to collect data from
 * @param options.destroy - If set to true, it automatically calls `destroy()` on the given stream upon receiving the 'end' event
 */ const collect = (stream, options = {
    destroy: true
})=>{
    const chunks = [];
    return new Promise((resolve, reject)=>{
        stream.on('close', ()=>resolve(chunks)).on('error', reject).on('data', (chunk)=>chunks.push(chunk)).on('end', ()=>{
            if (options.destroy) {
                stream.destroy();
            }
            resolve(chunks);
        });
    });
};

var stream = /*#__PURE__*/Object.freeze({
  __proto__: null,
  collect: collect,
  filter: filter,
  map: map
});

const createContext = ()=>({
        path: []
    });
/**
 * Compute differences between two JSON objects and returns them
 *
 * @param a - First object
 * @param b - Second object
 * @param ctx - Context used to keep track of the current path during recursion
 */ const diff = (a, b, ctx = createContext())=>{
    const diffs = [];
    const { path } = ctx;
    const aType = typeof a;
    const bType = typeof b;
    // Define helpers
    const added = ()=>{
        diffs.push({
            kind: 'added',
            path,
            type: bType,
            value: b
        });
        return diffs;
    };
    const deleted = ()=>{
        diffs.push({
            kind: 'deleted',
            path,
            type: aType,
            value: a
        });
        return diffs;
    };
    const modified = ()=>{
        diffs.push({
            kind: 'modified',
            path,
            types: [
                aType,
                bType
            ],
            values: [
                a,
                b
            ]
        });
        return diffs;
    };
    if (fp.isArray(a) && fp.isArray(b)) {
        let k = 0;
        for (const [aItem, bItem] of fp.zip(a, b)){
            const kCtx = {
                path: [
                    ...path,
                    k.toString()
                ]
            };
            const kDiffs = diff(aItem, bItem, kCtx);
            diffs.push(...kDiffs);
            k += 1;
        }
        return diffs;
    }
    if (fp.isObject(a) && fp.isObject(b)) {
        const keys = fp.uniq(Object.keys(a).concat(Object.keys(b)));
        for (const key of keys){
            const aValue = a[key];
            const bValue = b[key];
            const nestedDiffs = diff(aValue, bValue, {
                path: [
                    ...path,
                    key
                ]
            });
            diffs.push(...nestedDiffs);
        }
        return diffs;
    }
    if (!fp.isEqual(a, b)) {
        if (aType === 'undefined') {
            return added();
        }
        if (bType === 'undefined') {
            return deleted();
        }
        return modified();
    }
    return diffs;
};

var json = /*#__PURE__*/Object.freeze({
  __proto__: null,
  diff: diff
});

/**
 * List of schema properties that should be kept when sanitizing schemas
 */ const VALID_SCHEMA_PROPERTIES = [
    'collectionName',
    'info',
    'options',
    'pluginOptions',
    'attributes',
    'kind',
    'modelType',
    'modelName',
    'uid',
    'plugin',
    'globalId'
];
/**
 * Sanitize a schemas dictionary by omitting unwanted properties
 * The list of allowed properties can be found here: {@link VALID_SCHEMA_PROPERTIES}
 */ const mapSchemasValues = (schemas)=>{
    return fp.mapValues(fp.pick(VALID_SCHEMA_PROPERTIES), schemas);
};
const schemasToValidJSON = (schemas)=>{
    return JSON.parse(JSON.stringify(schemas));
};

var schema = /*#__PURE__*/Object.freeze({
  __proto__: null,
  mapSchemasValues: mapSchemasValues,
  schemasToValidJSON: schemasToValidJSON
});

const createTransaction = (strapi)=>{
    const fns = [];
    let done = false;
    let resume = null;
    const e = new events.EventEmitter();
    e.on('spawn', (uuid, cb)=>{
        fns.push({
            fn: cb,
            uuid
        });
        resume?.();
    });
    e.on('close', ()=>{
        e.removeAllListeners('rollback');
        e.removeAllListeners('spawn');
        done = true;
        resume?.();
    });
    strapi.db.transaction(async ({ trx, rollback })=>{
        e.once('rollback', async ()=>{
            e.removeAllListeners('close');
            e.removeAllListeners('spawn');
            try {
                await rollback();
                e.emit('rollback_completed');
            } catch  {
                e.emit('rollback_failed');
            } finally{
                done = true;
                resume?.();
            }
        });
        while(!done){
            while(fns.length){
                const item = fns.shift();
                if (item) {
                    const { fn, uuid } = item;
                    try {
                        const res = await fn(trx);
                        e.emit(uuid, {
                            data: res
                        });
                    } catch (error) {
                        e.emit(uuid, {
                            error
                        });
                    }
                }
            }
            if (!done && !fns.length) {
                // eslint-disable-next-line @typescript-eslint/no-loop-func
                await new Promise((resolve)=>{
                    resume = resolve;
                });
            }
        }
    });
    return {
        async attach (callback) {
            const uuid = crypto.randomUUID();
            e.emit('spawn', uuid, callback);
            return new Promise((resolve, reject)=>{
                e.on(uuid, ({ data, error })=>{
                    if (data) {
                        resolve(data);
                    }
                    if (error) {
                        reject(error);
                    }
                    resolve(undefined);
                });
            });
        },
        end () {
            return e.emit('close');
        },
        rollback () {
            return new Promise((resolve)=>{
                e.emit('rollback');
                e.once('rollback_failed', ()=>resolve(false));
                e.once('rollback_completed', ()=>resolve(true));
            });
        }
    };
};

var transaction = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createTransaction: createTransaction
});

const runMiddleware = async (context, middlewares)=>{
    if (!middlewares.length) {
        return;
    }
    const cb = middlewares[0];
    await cb(context, async (newContext)=>{
        await runMiddleware(newContext, middlewares.slice(1));
    });
};

var middleware = /*#__PURE__*/Object.freeze({
  __proto__: null,
  runMiddleware: runMiddleware
});

const createDiagnosticReporter = (options = {})=>{
    const { stackSize = -1 } = options;
    const emitter = new events.EventEmitter();
    const stack = [];
    const addListener = (event, listener)=>{
        emitter.on(event, listener);
    };
    const isDiagnosticValid = (diagnostic)=>{
        if (!diagnostic.kind || !diagnostic.details || !diagnostic.details.message) {
            return false;
        }
        return true;
    };
    return {
        stack: {
            get size () {
                return stack.length;
            },
            get items () {
                return stack;
            }
        },
        report (diagnostic) {
            if (!isDiagnosticValid(diagnostic)) {
                return this;
            }
            emitter.emit('diagnostic', diagnostic);
            emitter.emit(`diagnostic.${diagnostic.kind}`, diagnostic);
            if (stackSize !== -1 && stack.length >= stackSize) {
                stack.shift();
            }
            stack.push(diagnostic);
            return this;
        },
        onDiagnostic (listener) {
            addListener('diagnostic', listener);
            return this;
        },
        on (kind, listener) {
            addListener(`diagnostic.${kind}`, listener);
            return this;
        }
    };
};

var diagnostic = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createDiagnosticReporter: createDiagnosticReporter
});

var index$8 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  diagnostics: diagnostic,
  encryption: index$9,
  json: json,
  middleware: middleware,
  schema: schema,
  stream: stream,
  transaction: transaction
});

const OPTIONAL_CONTENT_TYPES = [
    'audit-log'
];
const isAttributeIgnorable = (diff)=>{
    return diff.path.length === 3 && // Root property must be attributes
    diff.path[0] === 'attributes' && // Need a valid string attribute name
    typeof diff.path[1] === 'string' && // The diff must be on ignorable attribute properties
    [
        'private',
        'required',
        'configurable',
        'default'
    ].includes(diff.path[2]);
};
// TODO: clean up the type checking, which will require cleaning up the typings in utils/json.ts
// exclude admin tables that are not transferable and are optionally available (such as audit logs which are only available in EE)
const isOptionalAdminType = (diff)=>{
    // added/deleted
    if ('value' in diff && fp.isObject(diff.value)) {
        const name = diff?.value?.info?.singularName;
        return OPTIONAL_CONTENT_TYPES.includes(name);
    }
    // modified
    if ('values' in diff && fp.isArray(diff.values) && fp.isObject(diff.values[0])) {
        const name = diff?.values[0]?.info?.singularName;
        return OPTIONAL_CONTENT_TYPES.includes(name);
    }
    return false;
};
const isIgnorableStrict = (diff)=>isAttributeIgnorable(diff) || isOptionalAdminType(diff);
const strategies = {
    // No diffs
    exact (diffs) {
        return diffs;
    },
    // Strict: all content types must match except:
    // - the property within a content type is an ignorable one
    // - those that are (not transferrable and optionally available), for example EE features such as audit logs
    strict (diffs) {
        return fp.reject(isIgnorableStrict, diffs);
    }
};
const compareSchemas = (a, b, strategy)=>{
    const diffs = diff(a, b);
    return strategies[strategy](diffs);
};

const SeverityKind = {
    FATAL: 'fatal',
    ERROR: 'error',
    SILLY: 'silly'
};

class DataTransferError extends Error {
    constructor(origin, severity, message, details){
        super(message);
        this.origin = origin;
        this.severity = severity;
        this.details = details ?? null;
    }
}

class TransferEngineError extends DataTransferError {
    constructor(severity, message, details){
        super('engine', severity, message, details);
    }
}
class TransferEngineInitializationError extends TransferEngineError {
    constructor(message){
        super(SeverityKind.FATAL, message, {
            step: 'initialization'
        });
    }
}
class TransferEngineValidationError extends TransferEngineError {
    constructor(message, details){
        super(SeverityKind.FATAL, message, {
            step: 'validation',
            details
        });
    }
}
class TransferEngineTransferError extends TransferEngineError {
    constructor(message, details){
        super(SeverityKind.FATAL, message, {
            step: 'transfer',
            details
        });
    }
}

var errors = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TransferEngineError: TransferEngineError,
  TransferEngineInitializationError: TransferEngineInitializationError,
  TransferEngineTransferError: TransferEngineTransferError,
  TransferEngineValidationError: TransferEngineValidationError
});

const reject = (reason)=>{
    throw new TransferEngineValidationError(`Invalid provider supplied. ${reason}`);
};
const validateProvider = (type, provider)=>{
    if (!provider) {
        return reject(`Expected an instance of "${fp.capitalize(type)}Provider", but got "${typeof provider}" instead.`);
    }
    if (provider.type !== type) {
        return reject(`Expected the provider to be of type "${type}" but got "${provider.type}" instead.`);
    }
};

class ProviderError extends DataTransferError {
    constructor(severity, message, details){
        super('provider', severity, message, details);
    }
}
class ProviderInitializationError extends ProviderError {
    constructor(message){
        super(SeverityKind.FATAL, message, {
            step: 'initialization'
        });
    }
}
// TODO: these types are not working correctly, ProviderTransferError() is accepting any details object rather than requiring T
class ProviderValidationError extends ProviderError {
    constructor(message, details){
        super(SeverityKind.SILLY, message, {
            step: 'validation',
            details
        });
    }
}
// TODO: these types are not working correctly, ProviderTransferError() is accepting any details object rather than requiring T
class ProviderTransferError extends ProviderError {
    constructor(message, details){
        super(SeverityKind.FATAL, message, {
            step: 'transfer',
            details
        });
    }
}

function _class_private_field_loose_base$6(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
}
var id$6 = 0;
function _class_private_field_loose_key$6(name) {
    return "__private_" + id$6++ + "_" + name;
}
const TRANSFER_STAGES = Object.freeze([
    'entities',
    'links',
    'assets',
    'schemas',
    'configuration'
]);
/**
 * Preset filters for only/exclude options
 * */ const TransferGroupPresets = {
    content: {
        links: true,
        entities: true
    },
    files: {
        assets: true
    },
    config: {
        configuration: true
    }
};
const DEFAULT_VERSION_STRATEGY = 'ignore';
const DEFAULT_SCHEMA_STRATEGY = 'strict';
var _metadata$1 = /*#__PURE__*/ _class_private_field_loose_key$6("_metadata"), _schema = /*#__PURE__*/ _class_private_field_loose_key$6("_schema"), _handlers = /*#__PURE__*/ _class_private_field_loose_key$6("_handlers"), _currentStreamController = /*#__PURE__*/ _class_private_field_loose_key$6("_currentStreamController"), _aborted = /*#__PURE__*/ _class_private_field_loose_key$6("_aborted"), /**
   * Create and return a transform stream based on the given stage and options.
   *
   * Allowed transformations includes 'filter' and 'map'.
   */ _createStageTransformStream = /*#__PURE__*/ _class_private_field_loose_key$6("_createStageTransformStream"), /**
   * Update the Engine's transfer progress data for a given stage.
   *
   * Providing aggregate options enable custom computation to get the size (bytes) or the aggregate key associated with the data
   */ _updateTransferProgress = /*#__PURE__*/ _class_private_field_loose_key$6("_updateTransferProgress"), /**
   * Create and return a PassThrough stream.
   *
   * Upon writing data into it, it'll update the Engine's transfer progress data and trigger stage update events.
   */ _progressTracker = /*#__PURE__*/ _class_private_field_loose_key$6("_progressTracker"), /**
   * Shorthand method used to trigger transfer update events to every listeners
   */ _emitTransferUpdate = /*#__PURE__*/ _class_private_field_loose_key$6("_emitTransferUpdate"), /**
   * Shorthand method used to trigger stage update events to every listeners
   */ _emitStageUpdate = /*#__PURE__*/ _class_private_field_loose_key$6("_emitStageUpdate"), /**
   * Run a version check between two strapi version (source and destination) using the strategy given to the engine during initialization.
   *
   * If there is a mismatch, throws a validation error.
   */ _assertStrapiVersionIntegrity = /*#__PURE__*/ _class_private_field_loose_key$6("_assertStrapiVersionIntegrity"), /**
   * Run a check between two set of schemas (source and destination) using the strategy given to the engine during initialization.
   *
   * If there are differences and/or incompatibilities between source and destination schemas, then throw a validation error.
   */ _assertSchemasMatching = /*#__PURE__*/ _class_private_field_loose_key$6("_assertSchemasMatching"), _transferStage = /*#__PURE__*/ _class_private_field_loose_key$6("_transferStage"), _resolveProviderResource = /*#__PURE__*/ _class_private_field_loose_key$6("_resolveProviderResource"), _getSchemas = /*#__PURE__*/ _class_private_field_loose_key$6("_getSchemas");
class TransferEngine {
    onSchemaDiff(handler) {
        _class_private_field_loose_base$6(this, _handlers)[_handlers]?.schemaDiff?.push(handler);
    }
    addErrorHandler(handlerName, handler) {
        if (!_class_private_field_loose_base$6(this, _handlers)[_handlers].errors[handlerName]) {
            _class_private_field_loose_base$6(this, _handlers)[_handlers].errors[handlerName] = [];
        }
        _class_private_field_loose_base$6(this, _handlers)[_handlers].errors[handlerName]?.push(handler);
    }
    async attemptResolveError(error) {
        const context = {};
        if (error instanceof ProviderTransferError && error.details?.details.code) {
            const errorCode = error.details?.details.code;
            if (!_class_private_field_loose_base$6(this, _handlers)[_handlers].errors[errorCode]) {
                _class_private_field_loose_base$6(this, _handlers)[_handlers].errors[errorCode] = [];
            }
            await runMiddleware(context ?? {}, _class_private_field_loose_base$6(this, _handlers)[_handlers].errors[errorCode] ?? []);
        }
        return !!context.ignore;
    }
    /**
   * Report a fatal error and throw it
   */ panic(error) {
        this.reportError(error, 'fatal');
        throw error;
    }
    /**
   * Report an error diagnostic
   */ reportError(error, severity) {
        this.diagnostics.report({
            kind: 'error',
            details: {
                severity,
                createdAt: new Date(),
                name: error.name,
                message: error.message,
                error
            }
        });
    }
    /**
   * Report a warning diagnostic
   */ reportWarning(message, origin1) {
        this.diagnostics.report({
            kind: 'warning',
            details: {
                createdAt: new Date(),
                message,
                origin: origin1
            }
        });
    }
    /**
   * Report an info diagnostic
   */ reportInfo(message, params) {
        this.diagnostics.report({
            kind: 'info',
            details: {
                createdAt: new Date(),
                message,
                params,
                origin: 'engine'
            }
        });
    }
    shouldSkipStage(stage) {
        const { exclude, only } = this.options;
        // schemas must always be included
        if (stage === 'schemas') {
            return false;
        }
        // everything is included by default unless 'only' has been set
        let included = fp.isEmpty(only);
        if (only && only.length > 0) {
            included = only.some((transferGroup)=>{
                return TransferGroupPresets[transferGroup][stage];
            });
        }
        if (exclude && exclude.length > 0) {
            if (included) {
                included = !exclude.some((transferGroup)=>{
                    return TransferGroupPresets[transferGroup][stage];
                });
            }
        }
        return !included;
    }
    // Cause an ongoing transfer to abort gracefully
    async abortTransfer() {
        _class_private_field_loose_base$6(this, _aborted)[_aborted] = true;
        _class_private_field_loose_base$6(this, _currentStreamController)[_currentStreamController]?.abort();
        throw new TransferEngineError('fatal', 'Transfer aborted.');
    }
    async init() {
        // Resolve providers' resource and store
        // them in the engine's internal state
        await _class_private_field_loose_base$6(this, _resolveProviderResource)[_resolveProviderResource]();
        // Update the destination provider's source metadata
        const { source: sourceMetadata } = _class_private_field_loose_base$6(this, _metadata$1)[_metadata$1];
        if (sourceMetadata) {
            this.destinationProvider.setMetadata?.('source', sourceMetadata);
        }
    }
    /**
   * Run the bootstrap method in both source and destination providers
   */ async bootstrap() {
        const results = await Promise.allSettled([
            this.sourceProvider.bootstrap?.(this.diagnostics),
            this.destinationProvider.bootstrap?.(this.diagnostics)
        ]);
        results.forEach((result)=>{
            if (result.status === 'rejected') {
                this.panic(result.reason);
            }
        });
    }
    /**
   * Run the close method in both source and destination providers
   */ async close() {
        const results = await Promise.allSettled([
            this.sourceProvider.close?.(),
            this.destinationProvider.close?.()
        ]);
        results.forEach((result)=>{
            if (result.status === 'rejected') {
                this.panic(result.reason);
            }
        });
    }
    async integrityCheck() {
        const sourceMetadata = await this.sourceProvider.getMetadata();
        const destinationMetadata = await this.destinationProvider.getMetadata();
        if (sourceMetadata && destinationMetadata) {
            _class_private_field_loose_base$6(this, _assertStrapiVersionIntegrity)[_assertStrapiVersionIntegrity](sourceMetadata?.strapi?.version, destinationMetadata?.strapi?.version);
        }
        const { sourceSchemas, destinationSchemas } = await _class_private_field_loose_base$6(this, _getSchemas)[_getSchemas]();
        try {
            if (sourceSchemas && destinationSchemas) {
                _class_private_field_loose_base$6(this, _assertSchemasMatching)[_assertSchemasMatching](sourceSchemas, destinationSchemas);
            }
        } catch (error) {
            // if this is a schema matching error, allow handlers to resolve it
            if (error instanceof TransferEngineValidationError && error.details?.details?.diffs) {
                const schemaDiffs = error.details?.details?.diffs;
                const context = {
                    ignoredDiffs: {},
                    diffs: schemaDiffs,
                    source: this.sourceProvider,
                    destination: this.destinationProvider
                };
                // if we don't have any handlers, throw the original error
                if (fp.isEmpty(_class_private_field_loose_base$6(this, _handlers)[_handlers].schemaDiff)) {
                    throw error;
                }
                await runMiddleware(context, _class_private_field_loose_base$6(this, _handlers)[_handlers].schemaDiff);
                // if there are any remaining diffs that weren't ignored
                const unresolvedDiffs = diff(context.diffs, context.ignoredDiffs);
                if (unresolvedDiffs.length) {
                    this.panic(new TransferEngineValidationError('Unresolved differences in schema', {
                        check: 'schema.changes',
                        unresolvedDiffs
                    }));
                }
                return;
            }
            throw error;
        }
    }
    async transfer() {
        // reset data between transfers
        this.progress.data = {};
        try {
            _class_private_field_loose_base$6(this, _emitTransferUpdate)[_emitTransferUpdate]('init');
            await this.bootstrap();
            await this.init();
            await this.integrityCheck();
            _class_private_field_loose_base$6(this, _emitTransferUpdate)[_emitTransferUpdate]('start');
            await this.beforeTransfer();
            // Run the transfer stages
            await this.transferSchemas();
            await this.transferEntities();
            await this.transferAssets();
            await this.transferLinks();
            await this.transferConfiguration();
            // Gracefully close the providers
            await this.close();
            _class_private_field_loose_base$6(this, _emitTransferUpdate)[_emitTransferUpdate]('finish');
        } catch (e) {
            _class_private_field_loose_base$6(this, _emitTransferUpdate)[_emitTransferUpdate]('error', {
                error: e
            });
            const lastDiagnostic = fp.last(this.diagnostics.stack.items);
            // Do not report an error diagnostic if the last one reported the same error
            if (e instanceof Error && (!lastDiagnostic || lastDiagnostic.kind !== 'error' || lastDiagnostic.details.error !== e)) {
                this.reportError(e, e.severity || 'fatal');
            }
            // Rollback the destination provider if an exception is thrown during the transfer
            // Note: This will be configurable in the future
            await this.destinationProvider.rollback?.(e);
            throw e;
        }
        return {
            source: this.sourceProvider.results,
            destination: this.destinationProvider.results,
            engine: this.progress.data
        };
    }
    async beforeTransfer() {
        const runWithDiagnostic = async (provider)=>{
            try {
                await provider.beforeTransfer?.();
            } catch (error) {
                if (error instanceof Error) {
                    const resolved = await this.attemptResolveError(error);
                    if (resolved) {
                        return;
                    }
                    this.panic(error);
                } else {
                    this.panic(new Error(`Unknwon error when executing "beforeTransfer" on the ${origin} provider`));
                }
            }
        };
        await runWithDiagnostic(this.sourceProvider);
        await runWithDiagnostic(this.destinationProvider);
    }
    async transferSchemas() {
        const stage = 'schemas';
        if (this.shouldSkipStage(stage)) {
            return;
        }
        const source = await this.sourceProvider.createSchemasReadStream?.();
        const destination = await this.destinationProvider.createSchemasWriteStream?.();
        const transform = _class_private_field_loose_base$6(this, _createStageTransformStream)[_createStageTransformStream](stage);
        const tracker = _class_private_field_loose_base$6(this, _progressTracker)[_progressTracker](stage, {
            key: (value)=>value.modelType
        });
        await _class_private_field_loose_base$6(this, _transferStage)[_transferStage]({
            stage,
            source,
            destination,
            transform,
            tracker
        });
    }
    async transferEntities() {
        const stage = 'entities';
        if (this.shouldSkipStage(stage)) {
            return;
        }
        const source = await this.sourceProvider.createEntitiesReadStream?.();
        const destination = await this.destinationProvider.createEntitiesWriteStream?.();
        const transform = streamChain.chain([
            _class_private_field_loose_base$6(this, _createStageTransformStream)[_createStageTransformStream](stage),
            new stream$1.Transform({
                objectMode: true,
                transform: async (entity, _encoding, callback)=>{
                    const { destinationSchemas: schemas } = await _class_private_field_loose_base$6(this, _getSchemas)[_getSchemas]();
                    if (!schemas) {
                        return callback(null, entity);
                    }
                    // TODO: this would be safer if we only ignored things in ignoredDiffs, otherwise continue and let an error be thrown
                    const availableContentTypes = Object.entries(schemas).filter(([, schema])=>schema.modelType === 'contentType').map(([uid])=>uid);
                    // If the type of the transferred entity doesn't exist in the destination, then discard it
                    if (!availableContentTypes.includes(entity.type)) {
                        return callback(null, undefined);
                    }
                    const { type, data } = entity;
                    const attributes = schemas[type].attributes;
                    const attributesToKeep = Object.keys(attributes).concat('documentId');
                    const updatedEntity = fp.set('data', fp.pick(attributesToKeep, data), entity);
                    callback(null, updatedEntity);
                }
            })
        ]);
        const tracker = _class_private_field_loose_base$6(this, _progressTracker)[_progressTracker](stage, {
            key: (value)=>value.type
        });
        await _class_private_field_loose_base$6(this, _transferStage)[_transferStage]({
            stage,
            source,
            destination,
            transform,
            tracker
        });
    }
    async transferLinks() {
        const stage = 'links';
        if (this.shouldSkipStage(stage)) {
            return;
        }
        const source = await this.sourceProvider.createLinksReadStream?.();
        const destination = await this.destinationProvider.createLinksWriteStream?.();
        const transform = streamChain.chain([
            _class_private_field_loose_base$6(this, _createStageTransformStream)[_createStageTransformStream](stage),
            new stream$1.Transform({
                objectMode: true,
                transform: async (link, _encoding, callback)=>{
                    const { destinationSchemas: schemas } = await _class_private_field_loose_base$6(this, _getSchemas)[_getSchemas]();
                    if (!schemas) {
                        return callback(null, link);
                    }
                    // TODO: this would be safer if we only ignored things in ignoredDiffs, otherwise continue and let an error be thrown
                    const availableContentTypes = Object.keys(schemas);
                    const isValidType = (uid)=>availableContentTypes.includes(uid);
                    if (!isValidType(link.left.type) || !isValidType(link.right.type)) {
                        return callback(null, undefined); // ignore the link
                    }
                    callback(null, link);
                }
            })
        ]);
        const tracker = _class_private_field_loose_base$6(this, _progressTracker)[_progressTracker](stage);
        await _class_private_field_loose_base$6(this, _transferStage)[_transferStage]({
            stage,
            source,
            destination,
            transform,
            tracker
        });
    }
    async transferAssets() {
        const stage = 'assets';
        if (this.shouldSkipStage(stage)) {
            return;
        }
        const source = await this.sourceProvider.createAssetsReadStream?.();
        const destination = await this.destinationProvider.createAssetsWriteStream?.();
        const transform = _class_private_field_loose_base$6(this, _createStageTransformStream)[_createStageTransformStream](stage);
        const tracker = _class_private_field_loose_base$6(this, _progressTracker)[_progressTracker](stage, {
            size: (value)=>value.stats.size,
            key: (value)=>path.extname(value.filename) || 'No extension'
        });
        await _class_private_field_loose_base$6(this, _transferStage)[_transferStage]({
            stage,
            source,
            destination,
            transform,
            tracker
        });
    }
    async transferConfiguration() {
        const stage = 'configuration';
        if (this.shouldSkipStage(stage)) {
            return;
        }
        const source = await this.sourceProvider.createConfigurationReadStream?.();
        const destination = await this.destinationProvider.createConfigurationWriteStream?.();
        const transform = _class_private_field_loose_base$6(this, _createStageTransformStream)[_createStageTransformStream](stage);
        const tracker = _class_private_field_loose_base$6(this, _progressTracker)[_progressTracker](stage);
        await _class_private_field_loose_base$6(this, _transferStage)[_transferStage]({
            stage,
            source,
            destination,
            transform,
            tracker
        });
    }
    constructor(sourceProvider, destinationProvider, options){
        Object.defineProperty(this, _createStageTransformStream, {
            value: createStageTransformStream
        });
        Object.defineProperty(this, _updateTransferProgress, {
            value: updateTransferProgress
        });
        Object.defineProperty(this, _progressTracker, {
            value: progressTracker
        });
        Object.defineProperty(this, _emitTransferUpdate, {
            value: emitTransferUpdate
        });
        Object.defineProperty(this, _emitStageUpdate, {
            value: emitStageUpdate
        });
        Object.defineProperty(this, _assertStrapiVersionIntegrity, {
            value: assertStrapiVersionIntegrity
        });
        Object.defineProperty(this, _assertSchemasMatching, {
            value: assertSchemasMatching
        });
        Object.defineProperty(this, _transferStage, {
            value: transferStage
        });
        Object.defineProperty(this, _resolveProviderResource, {
            value: resolveProviderResource
        });
        Object.defineProperty(this, _getSchemas, {
            value: getSchemas
        });
        Object.defineProperty(this, _metadata$1, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _schema, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _handlers, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _currentStreamController, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _aborted, {
            writable: true,
            value: void 0
        });
        _class_private_field_loose_base$6(this, _metadata$1)[_metadata$1] = {};
        _class_private_field_loose_base$6(this, _schema)[_schema] = {};
        _class_private_field_loose_base$6(this, _handlers)[_handlers] = {
            schemaDiff: [],
            errors: {}
        };
        _class_private_field_loose_base$6(this, _aborted)[_aborted] = false;
        this.diagnostics = createDiagnosticReporter();
        validateProvider('source', sourceProvider);
        validateProvider('destination', destinationProvider);
        this.sourceProvider = sourceProvider;
        this.destinationProvider = destinationProvider;
        this.options = options;
        this.progress = {
            data: {},
            stream: new stream$1.PassThrough({
                objectMode: true
            })
        };
    }
}
function createStageTransformStream(key, options = {}) {
    const { includeGlobal = true } = options;
    const { throttle } = this.options;
    const { global: globalTransforms, [key]: stageTransforms } = this.options?.transforms ?? {};
    let stream = new stream$1.PassThrough({
        objectMode: true
    });
    const applyTransforms = (transforms = [])=>{
        const chainTransforms = [];
        for (const transform of transforms){
            if ('filter' in transform) {
                chainTransforms.push(filter(transform.filter));
            }
            if ('map' in transform) {
                chainTransforms.push(map(transform.map));
            }
        }
        if (chainTransforms.length) {
            stream = stream.pipe(streamChain.chain(chainTransforms));
        }
    };
    if (includeGlobal) {
        applyTransforms(globalTransforms);
    }
    if (fp.isNumber(throttle) && throttle > 0) {
        stream = stream.pipe(new stream$1.PassThrough({
            objectMode: true,
            async transform (data, _encoding, callback) {
                await new Promise((resolve)=>{
                    setTimeout(resolve, throttle);
                });
                callback(null, data);
            }
        }));
    }
    applyTransforms(stageTransforms);
    return stream;
}
function updateTransferProgress(stage, data, aggregate) {
    if (!this.progress.data[stage]) {
        this.progress.data[stage] = {
            count: 0,
            bytes: 0,
            startTime: Date.now()
        };
    }
    const stageProgress = this.progress.data[stage];
    if (!stageProgress) {
        return;
    }
    const size = aggregate?.size?.(data) ?? JSON.stringify(data).length;
    const key = aggregate?.key?.(data);
    stageProgress.count += 1;
    stageProgress.bytes += size;
    // Handle aggregate updates if necessary
    if (key) {
        if (!stageProgress.aggregates) {
            stageProgress.aggregates = {};
        }
        const { aggregates } = stageProgress;
        if (!aggregates[key]) {
            aggregates[key] = {
                count: 0,
                bytes: 0
            };
        }
        aggregates[key].count += 1;
        aggregates[key].bytes += size;
    }
}
function progressTracker(stage, aggregate) {
    return new stream$1.PassThrough({
        objectMode: true,
        transform: (data, _encoding, callback)=>{
            _class_private_field_loose_base$6(this, _updateTransferProgress)[_updateTransferProgress](stage, data, aggregate);
            _class_private_field_loose_base$6(this, _emitStageUpdate)[_emitStageUpdate]('progress', stage);
            callback(null, data);
        }
    });
}
function emitTransferUpdate(type, payload) {
    this.progress.stream.emit(`transfer::${type}`, payload);
}
function emitStageUpdate(type, transferStage) {
    this.progress.stream.emit(`stage::${type}`, {
        data: this.progress.data,
        stage: transferStage
    });
}
function assertStrapiVersionIntegrity(sourceVersion, destinationVersion) {
    const strategy = this.options.versionStrategy || DEFAULT_VERSION_STRATEGY;
    const reject = ()=>{
        throw new TransferEngineValidationError(`The source and destination provide are targeting incompatible Strapi versions (using the "${strategy}" strategy). The source (${this.sourceProvider.name}) version is ${sourceVersion} and the destination (${this.destinationProvider.name}) version is ${destinationVersion}`, {
            check: 'strapi.version',
            strategy,
            versions: {
                source: sourceVersion,
                destination: destinationVersion
            }
        });
    };
    if (!sourceVersion || !destinationVersion || strategy === 'ignore' || destinationVersion === sourceVersion) {
        return;
    }
    let diff;
    try {
        diff = semver.diff(sourceVersion, destinationVersion);
    } catch  {
        reject();
    }
    if (!diff) {
        return;
    }
    const validPatch = [
        'prelease',
        'build'
    ];
    const validMinor = [
        ...validPatch,
        'patch',
        'prepatch'
    ];
    const validMajor = [
        ...validMinor,
        'minor',
        'preminor'
    ];
    if (strategy === 'patch' && validPatch.includes(diff)) {
        return;
    }
    if (strategy === 'minor' && validMinor.includes(diff)) {
        return;
    }
    if (strategy === 'major' && validMajor.includes(diff)) {
        return;
    }
    reject();
}
function assertSchemasMatching(sourceSchemas, destinationSchemas) {
    const strategy = this.options.schemaStrategy || DEFAULT_SCHEMA_STRATEGY;
    if (strategy === 'ignore') {
        return;
    }
    const keys = fp.uniq(Object.keys(sourceSchemas).concat(Object.keys(destinationSchemas)));
    const diffs = {};
    keys.forEach((key)=>{
        const sourceSchema = sourceSchemas[key];
        const destinationSchema = destinationSchemas[key];
        const schemaDiffs = compareSchemas(sourceSchema, destinationSchema, strategy);
        if (schemaDiffs.length) {
            diffs[key] = schemaDiffs;
        }
    });
    if (!fp.isEmpty(diffs)) {
        const formattedDiffs = Object.entries(diffs).map(([uid, ctDiffs])=>{
            let msg = `- ${uid}:${os.EOL}`;
            msg += ctDiffs.sort((a, b)=>a.kind > b.kind ? -1 : 1).map((diff)=>{
                const path = diff.path.join('.');
                if (diff.kind === 'added') {
                    return `${path} exists in destination schema but not in source schema and the data will not be transferred.`;
                }
                if (diff.kind === 'deleted') {
                    return `${path} exists in source schema but not in destination schema and the data will not be transferred.`;
                }
                if (diff.kind === 'modified') {
                    if (diff.types[0] === diff.types[1]) {
                        return `Schema value changed at "${path}": "${diff.values[0]}" (${diff.types[0]}) => "${diff.values[1]}" (${diff.types[1]})`;
                    }
                    return `Schema has differing data types at "${path}": "${diff.values[0]}" (${diff.types[0]}) => "${diff.values[1]}" (${diff.types[1]})`;
                }
                throw new TransferEngineValidationError(`Invalid diff found for "${uid}"`, {
                    check: `schema on ${uid}`
                });
            }).map((line)=>`  - ${line}`).join(os.EOL);
            return msg;
        }).join(os.EOL);
        throw new TransferEngineValidationError(`Invalid schema changes detected during integrity checks (using the ${strategy} strategy). Please find a summary of the changes below:\n${formattedDiffs}`, {
            check: 'schema.changes',
            strategy,
            diffs
        });
    }
}
async function transferStage(options) {
    if (_class_private_field_loose_base$6(this, _aborted)[_aborted]) {
        throw new TransferEngineError('fatal', 'Transfer aborted.');
    }
    const { stage, source, destination, transform, tracker } = options;
    const updateEndTime = ()=>{
        const stageData = this.progress.data[stage];
        if (stageData) {
            stageData.endTime = Date.now();
        }
    };
    if (!source || !destination || this.shouldSkipStage(stage)) {
        // Wait until source and destination are closed
        const results = await Promise.allSettled([
            source,
            destination
        ].map((stream)=>{
            // if stream is undefined or already closed, resolve immediately
            if (!stream || stream.destroyed) {
                return Promise.resolve();
            }
            // Wait until the close event is produced and then destroy the stream and resolve
            return new Promise((resolve, reject)=>{
                stream.on('close', resolve).on('error', reject).destroy();
            });
        }));
        results.forEach((state)=>{
            if (state.status === 'rejected') {
                this.reportWarning(state.reason, `transfer(${stage})`);
            }
        });
        _class_private_field_loose_base$6(this, _emitStageUpdate)[_emitStageUpdate]('skip', stage);
        return;
    }
    _class_private_field_loose_base$6(this, _emitStageUpdate)[_emitStageUpdate]('start', stage);
    try {
        const streams = [
            source
        ];
        if (transform) {
            streams.push(transform);
        }
        if (tracker) {
            streams.push(tracker);
        }
        streams.push(destination);
        // NOTE: to debug/confirm backpressure issues from misbehaving stream, uncomment the following lines
        // source.on('pause', () => console.log(`[${stage}] Source paused due to backpressure`));
        // source.on('resume', () => console.log(`[${stage}] Source resumed`));
        // destination.on('drain', () =>
        //   console.log(`[${stage}] Destination drained, resuming data flow`)
        // );
        // destination.on('error', (err) => console.error(`[${stage}] Destination error:`, err));
        const controller = new AbortController();
        const { signal } = controller;
        // Store the controller so you can cancel later
        _class_private_field_loose_base$6(this, _currentStreamController)[_currentStreamController] = controller;
        await promises.pipeline(streams, {
            signal
        });
        _class_private_field_loose_base$6(this, _emitStageUpdate)[_emitStageUpdate]('finish', stage);
    } catch (e) {
        updateEndTime();
        _class_private_field_loose_base$6(this, _emitStageUpdate)[_emitStageUpdate]('error', stage);
        this.reportError(e, 'error');
        if (!destination.destroyed) {
            destination.destroy(e);
        }
    } finally{
        updateEndTime();
    }
}
async function resolveProviderResource() {
    const sourceMetadata = await this.sourceProvider.getMetadata();
    const destinationMetadata = await this.destinationProvider.getMetadata();
    if (sourceMetadata) {
        _class_private_field_loose_base$6(this, _metadata$1)[_metadata$1].source = sourceMetadata;
    }
    if (destinationMetadata) {
        _class_private_field_loose_base$6(this, _metadata$1)[_metadata$1].destination = destinationMetadata;
    }
}
async function getSchemas() {
    if (!_class_private_field_loose_base$6(this, _schema)[_schema].source) {
        _class_private_field_loose_base$6(this, _schema)[_schema].source = await this.sourceProvider.getSchemas?.();
    }
    if (!_class_private_field_loose_base$6(this, _schema)[_schema].destination) {
        _class_private_field_loose_base$6(this, _schema)[_schema].destination = await this.destinationProvider.getSchemas?.();
    }
    return {
        sourceSchemas: _class_private_field_loose_base$6(this, _schema)[_schema].source,
        destinationSchemas: _class_private_field_loose_base$6(this, _schema)[_schema].destination
    };
}
const createTransferEngine = (sourceProvider, destinationProvider, options)=>{
    return new TransferEngine(sourceProvider, destinationProvider, options);
};

var index$7 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DEFAULT_SCHEMA_STRATEGY: DEFAULT_SCHEMA_STRATEGY,
  DEFAULT_VERSION_STRATEGY: DEFAULT_VERSION_STRATEGY,
  TRANSFER_STAGES: TRANSFER_STAGES,
  TransferGroupPresets: TransferGroupPresets,
  createTransferEngine: createTransferEngine,
  errors: errors
});

const isDialectMySQL = ()=>strapi.db?.dialect.client === 'mysql';
function omitComponentData(contentType, data) {
    const { attributes } = contentType;
    const componentAttributes = Object.keys(attributes).filter((attributeName)=>utils.contentTypes.isComponentAttribute(attributes[attributeName]));
    return fp.omit(componentAttributes, data);
}
// NOTE: we could generalize the logic to allow CRUD of relation directly in the DB layer
const createComponents = async (uid, data)=>{
    const { attributes = {} } = strapi.getModel(uid);
    const componentBody = {};
    const attributeNames = Object.keys(attributes);
    for (const attributeName of attributeNames){
        const attribute = attributes[attributeName];
        if (!fp.has(attributeName, data) || !utils.contentTypes.isComponentAttribute(attribute)) {
            continue;
        }
        if (attribute.type === 'component') {
            const { component: componentUID, repeatable = false } = attribute;
            const componentValue = data[attributeName];
            if (componentValue === null) {
                continue;
            }
            if (repeatable === true) {
                if (!Array.isArray(componentValue)) {
                    throw new Error('Expected an array to create repeatable component');
                }
                // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1
                const components = await utils.async.map(componentValue, (value)=>createComponent(componentUID, value), {
                    concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity
                });
                componentBody[attributeName] = components.map(({ id })=>{
                    return {
                        id,
                        __pivot: {
                            field: attributeName,
                            component_type: componentUID
                        }
                    };
                });
            } else {
                const component = await createComponent(componentUID, componentValue);
                componentBody[attributeName] = {
                    id: component.id,
                    __pivot: {
                        field: attributeName,
                        component_type: componentUID
                    }
                };
            }
            continue;
        }
        if (attribute.type === 'dynamiczone') {
            const dynamiczoneValues = data[attributeName];
            if (!Array.isArray(dynamiczoneValues)) {
                throw new Error('Expected an array to create repeatable component');
            }
            const createDynamicZoneComponents = async (value)=>{
                const { id } = await createComponent(value.__component, value);
                return {
                    id,
                    __component: value.__component,
                    __pivot: {
                        field: attributeName
                    }
                };
            };
            // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1
            componentBody[attributeName] = await utils.async.map(dynamiczoneValues, createDynamicZoneComponents, {
                concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity
            });
            continue;
        }
    }
    return componentBody;
};
const getComponents = async (uid, entity)=>{
    const componentAttributes = utils.contentTypes.getComponentAttributes(strapi.getModel(uid));
    if (_.isEmpty(componentAttributes)) {
        return {};
    }
    return strapi.db.query(uid).load(entity, componentAttributes);
};
const deleteComponents = async (uid, entityToDelete, { loadComponents = true } = {})=>{
    const { attributes = {} } = strapi.getModel(uid);
    const attributeNames = Object.keys(attributes);
    for (const attributeName of attributeNames){
        const attribute = attributes[attributeName];
        if (attribute.type === 'component' || attribute.type === 'dynamiczone') {
            let value;
            if (loadComponents) {
                value = await strapi.db.query(uid).load(entityToDelete, attributeName);
            } else {
                value = entityToDelete[attributeName];
            }
            if (!value) {
                continue;
            }
            if (attribute.type === 'component') {
                const { component: componentUID } = attribute;
                // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1
                await utils.async.map(_.castArray(value), (subValue)=>deleteComponent(componentUID, subValue), {
                    concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity
                });
            } else {
                // delete dynamic zone components
                // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1
                await utils.async.map(_.castArray(value), (subValue)=>deleteComponent(subValue.__component, subValue), {
                    concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity
                });
            }
            continue;
        }
    }
};
/** *************************
    Component queries
************************** */ // components can have nested compos so this must be recursive
const createComponent = async (uid, data)=>{
    const model = strapi.getModel(uid);
    const componentData = await createComponents(uid, data);
    const transform = fp.pipe(// Make sure we don't save the component with a pre-defined ID
    fp.omit('id'), // Remove the component data from the original data object ...
    (payload)=>omitComponentData(model, payload), // ... and assign the newly created component instead
    fp.assign(componentData));
    return strapi.db.query(uid).create({
        data: transform(data)
    });
};
const deleteComponent = async (uid, componentToDelete)=>{
    await deleteComponents(uid, componentToDelete);
    await strapi.db.query(uid).delete({
        where: {
            id: componentToDelete.id
        }
    });
};
/**
 * Resolve the component UID of an entity's attribute based
 * on a given path (components & dynamic zones only)
 */ const resolveComponentUID = ({ paths, strapi: strapi1, data, contentType })=>{
    let value = data;
    let cType = contentType;
    for (const path of paths){
        value = fp.get(path, value);
        // Needed when the value of cType should be computed
        // based on the next value (eg: dynamic zones)
        if (typeof cType === 'function') {
            cType = cType(value);
        }
        if (path in cType.attributes) {
            const attribute = cType.attributes[path];
            if (attribute.type === 'component') {
                cType = strapi1.getModel(attribute.component);
            }
            if (attribute.type === 'dynamiczone') {
                cType = ({ __component })=>strapi1.getModel(__component);
            }
        }
    }
    if ('uid' in cType) {
        return cType.uid;
    }
    return undefined;
};

const sanitizeComponentLikeAttributes = (model, data)=>{
    const { attributes } = model;
    const componentLikeAttributesKey = Object.entries(attributes).filter(([, attribute])=>attribute.type === 'component' || attribute.type === 'dynamiczone').map(([key])=>key);
    return fp.omit(componentLikeAttributesKey, data);
};
const omitInvalidCreationAttributes$1 = fp.omit([
    'id'
]);
const createEntityQuery = (strapi)=>{
    const components = {
        async assignToEntity (uid, data) {
            const model = strapi.getModel(uid);
            const entityComponents = await createComponents(uid, data);
            const dataWithoutComponents = sanitizeComponentLikeAttributes(model, data);
            return fp.assign(entityComponents, dataWithoutComponents);
        },
        async get (uid, entity) {
            return getComponents(uid, entity);
        },
        delete (uid, componentsToDelete) {
            return deleteComponents(uid, componentsToDelete, {
                loadComponents: false
            });
        }
    };
    const query = (uid)=>{
        const create = async (params)=>{
            const dataWithComponents = await components.assignToEntity(uid, params.data);
            const sanitizedData = omitInvalidCreationAttributes$1(dataWithComponents);
            return strapi.db.query(uid).create({
                ...params,
                data: sanitizedData
            });
        };
        const createMany = async (params)=>{
            return Promise.resolve(params.data)// Create components for each entity
            .then(fp.map((data)=>components.assignToEntity(uid, data)))// Remove unwanted attributes
            .then(fp.map(omitInvalidCreationAttributes$1))// Execute a strapi db createMany query with all the entities + their created components
            .then((data)=>strapi.db.query(uid).createMany({
                    ...params,
                    data
                }));
        };
        const deleteMany = async (params)=>{
            const entitiesToDelete = await strapi.db.query(uid).findMany(params ?? {});
            if (!entitiesToDelete.length) {
                return null;
            }
            const componentsToDelete = await Promise.all(entitiesToDelete.map((entityToDelete)=>components.get(uid, entityToDelete)));
            const deletedEntities = await strapi.db.query(uid).deleteMany(params);
            await Promise.all(componentsToDelete.map((compos)=>components.delete(uid, compos)));
            return deletedEntities;
        };
        const getDeepPopulateComponentLikeQuery = (contentType, params = {
            select: '*'
        })=>{
            const { attributes } = contentType;
            const populate = {};
            const entries = Object.entries(attributes);
            for (const [key, attribute] of entries){
                if (attribute.type === 'component') {
                    const component = strapi.getModel(attribute.component);
                    const subPopulate = getDeepPopulateComponentLikeQuery(component, params);
                    if ((fp.isArray(subPopulate) || fp.isObject(subPopulate)) && fp.size(subPopulate) > 0) {
                        populate[key] = {
                            ...params,
                            populate: subPopulate
                        };
                    }
                    if (fp.isArray(subPopulate) && fp.isEmpty(subPopulate)) {
                        populate[key] = {
                            ...params
                        };
                    }
                }
                if (attribute.type === 'dynamiczone') {
                    const { components: componentsUID } = attribute;
                    const on = {};
                    for (const componentUID of componentsUID){
                        const component = strapi.getModel(componentUID);
                        const subPopulate = getDeepPopulateComponentLikeQuery(component, params);
                        if ((fp.isArray(subPopulate) || fp.isObject(subPopulate)) && fp.size(subPopulate) > 0) {
                            on[componentUID] = {
                                ...params,
                                populate: subPopulate
                            };
                        }
                        if (fp.isArray(subPopulate) && fp.isEmpty(subPopulate)) {
                            on[componentUID] = {
                                ...params
                            };
                        }
                    }
                    populate[key] = fp.size(on) > 0 ? {
                        on
                    } : true;
                }
            }
            const values = Object.values(populate);
            if (values.every((value)=>value === true)) {
                return Object.keys(populate);
            }
            return populate;
        };
        return {
            create,
            createMany,
            deleteMany,
            getDeepPopulateComponentLikeQuery,
            get deepPopulateComponentLikeQuery () {
                const contentType = strapi.getModel(uid);
                return getDeepPopulateComponentLikeQuery(contentType);
            }
        };
    };
    return query;
};

var entity = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createEntityQuery: createEntityQuery
});

// TODO: Remove any types when we'll have types for DB metadata
const createLinkQuery = (strapi, trx)=>{
    const query = ()=>{
        const { connection } = strapi.db;
        // TODO: Export utils from database and use the addSchema that is already written
        const addSchema = (tableName)=>{
            const schemaName = connection.client.connectionSettings.schema;
            return schemaName ? `${schemaName}.${tableName}` : tableName;
        };
        async function* generateAllForAttribute(uid, fieldName) {
            const metadata = strapi.db.metadata.get(uid);
            if (!metadata) {
                throw new Error(`No metadata found for ${uid}`);
            }
            const attributes = filterValidRelationalAttributes(metadata.attributes);
            if (!(fieldName in attributes)) {
                throw new Error(`${fieldName} is not a valid relational attribute name`);
            }
            const attribute = attributes[fieldName];
            const kind = getLinkKind(attribute, uid);
            const { relation, target } = attribute;
            // The relation is stored in the same table
            // TODO: handle manyToOne joinColumn
            if (attribute.joinColumn) {
                const joinColumnName = attribute.joinColumn.name;
                const qb = connection.queryBuilder().select('id', joinColumnName).from(addSchema(metadata.tableName));
                if (trx) {
                    qb.transacting(trx);
                }
                // TODO: stream the query to improve performances
                const entries = await qb;
                for (const entry of entries){
                    const ref = entry[joinColumnName];
                    if (ref !== null) {
                        yield {
                            kind,
                            relation,
                            left: {
                                type: uid,
                                ref: entry.id,
                                field: fieldName
                            },
                            right: {
                                type: target,
                                ref
                            }
                        };
                    }
                }
            }
            // The relation uses a join table
            if (attribute.joinTable) {
                const { name, joinColumn, inverseJoinColumn, orderColumnName, morphColumn, inverseOrderColumnName } = attribute.joinTable;
                const qb = connection.queryBuilder().from(addSchema(name));
                const columns = {
                    left: {
                        ref: null
                    },
                    right: {
                        ref: null
                    }
                };
                const left = {
                    type: uid,
                    field: fieldName
                };
                const right = {};
                if (kind === 'relation.basic' || kind === 'relation.circular') {
                    right.type = attribute.target;
                    right.field = attribute.inversedBy;
                    columns.left.ref = joinColumn.name;
                    columns.right.ref = inverseJoinColumn.name;
                    if (orderColumnName) {
                        columns.left.order = orderColumnName;
                    }
                    if (inverseOrderColumnName) {
                        columns.right.order = inverseOrderColumnName;
                    }
                }
                if (kind === 'relation.morph') {
                    columns.left.ref = joinColumn.name;
                    columns.right.ref = morphColumn.idColumn.name;
                    columns.right.type = morphColumn.typeColumn.name;
                    columns.right.field = 'field';
                    columns.right.order = 'order';
                }
                const validColumns = [
                    // Left
                    columns.left.ref,
                    columns.left.order,
                    // Right
                    columns.right.ref,
                    columns.right.type,
                    columns.right.field,
                    columns.right.order
                ].filter((column)=>!fp.isNil(column));
                qb.select(validColumns);
                if (trx) {
                    qb.transacting(trx);
                }
                // TODO: stream the query to improve performances
                const entries = await qb;
                for (const entry of entries){
                    if (columns.left.ref) {
                        left.ref = entry[columns.left.ref];
                    }
                    if (columns.right.ref) {
                        right.ref = entry[columns.right.ref];
                    }
                    if (columns.left.order) {
                        left.pos = entry[columns.left.order];
                    }
                    if (columns.right.order) {
                        right.pos = entry[columns.right.order];
                    }
                    if (columns.right.type) {
                        right.type = entry[columns.right.type];
                    }
                    if (columns.right.field) {
                        right.field = entry[columns.right.field];
                    }
                    const link = {
                        kind,
                        relation,
                        left: fp.clone(left),
                        right: fp.clone(right)
                    };
                    yield link;
                }
            }
            if (attribute.morphColumn) {
                const { typeColumn, idColumn } = attribute.morphColumn;
                const qb = connection.queryBuilder().select('id', typeColumn.name, idColumn.name).from(addSchema(metadata.tableName)).whereNotNull(typeColumn.name).whereNotNull(idColumn.name);
                if (trx) {
                    qb.transacting(trx);
                }
                const entries = await qb;
                for (const entry of entries){
                    const ref = entry[idColumn.name];
                    yield {
                        kind,
                        relation,
                        left: {
                            type: uid,
                            ref: entry.id,
                            field: fieldName
                        },
                        right: {
                            type: entry[typeColumn.name],
                            ref
                        }
                    };
                }
            }
        }
        async function* generateAll(uid) {
            const metadata = strapi.db.metadata.get(uid);
            if (!metadata) {
                throw new Error(`No metadata found for ${uid}`);
            }
            const attributes = filterValidRelationalAttributes(metadata.attributes);
            for (const fieldName of Object.keys(attributes)){
                for await (const link of generateAllForAttribute(uid, fieldName)){
                    yield link;
                }
            }
        }
        const insert = async (link)=>{
            const { kind, left, right } = link;
            const metadata = strapi.db.metadata.get(left.type);
            const attribute = metadata.attributes[left.field];
            const payload = {};
            /**
       * This _should_ only happen for attributes that are added dynamically e.g. review-workflow stages
       * and a user is importing EE data into a CE project.
       */ if (!attribute) {
                return;
            }
            if (attribute.type !== 'relation') {
                throw new Error(`Attribute ${left.field} is not a relation`);
            }
            if ('joinColumn' in attribute && attribute.joinColumn) {
                const joinColumnName = attribute.joinColumn.name;
                // Note: this addSchema may not be necessary, but is added for safety
                const qb = connection(addSchema(metadata.tableName)).where('id', left.ref).update({
                    [joinColumnName]: right.ref
                });
                if (trx) {
                    qb.transacting(trx);
                }
                await qb;
            }
            if ('joinTable' in attribute && attribute.joinTable) {
                const { joinTable } = attribute;
                if (joinTable.joinColumn) {
                    Object.assign(payload, {
                        [joinTable.joinColumn.name]: left.ref
                    });
                }
                const assignInverseColumn = ()=>{
                    if ('inverseJoinColumn' in joinTable && joinTable.inverseJoinColumn) {
                        Object.assign(payload, {
                            [joinTable.inverseJoinColumn.name]: right.ref
                        });
                    }
                };
                const assignOrderColumns = ()=>{
                    if ('orderColumnName' in joinTable && joinTable.orderColumnName) {
                        Object.assign(payload, {
                            [joinTable.orderColumnName]: left.pos ?? null
                        });
                    }
                    if ('inverseOrderColumnName' in joinTable && joinTable.inverseOrderColumnName) {
                        Object.assign(payload, {
                            [joinTable.inverseOrderColumnName]: right.pos ?? null
                        });
                    }
                };
                const assignMorphColumns = ()=>{
                    if ('morphColumn' in joinTable && joinTable.morphColumn) {
                        const { idColumn, typeColumn } = joinTable.morphColumn ?? {};
                        if (idColumn) {
                            Object.assign(payload, {
                                [idColumn.name]: right.ref
                            });
                        }
                        if (typeColumn) {
                            Object.assign(payload, {
                                [typeColumn.name]: right.type
                            });
                        }
                        Object.assign(payload, {
                            order: right.pos ?? null,
                            field: right.field ?? null
                        });
                    }
                };
                if (kind === 'relation.basic' || kind === 'relation.circular') {
                    assignInverseColumn();
                }
                if (kind === 'relation.morph') {
                    assignMorphColumns();
                }
                assignOrderColumns();
                const qb = connection.insert(payload).into(addSchema(joinTable.name));
                if (trx) {
                    await qb.transacting(trx);
                }
            }
            if ('morphColumn' in attribute && attribute.morphColumn) {
                const { morphColumn } = attribute;
                const qb = connection(addSchema(metadata.tableName)).where('id', left.ref).update({
                    [morphColumn.idColumn.name]: right.ref,
                    [morphColumn.typeColumn.name]: right.type
                });
                if (trx) {
                    qb.transacting(trx);
                }
                await qb;
            }
        };
        return {
            generateAll,
            generateAllForAttribute,
            insert
        };
    };
    return query;
};
const filterValidRelationalAttributes = (attributes)=>{
    const isOwner = (attribute)=>{
        return attribute.owner || !attribute.mappedBy && !attribute.morphBy;
    };
    const isComponentLike = (attribute)=>attribute.joinTable?.name.endsWith('_cmps');
    return Object.entries(attributes).filter(([, attribute])=>{
        return attribute.type === 'relation' && isOwner(attribute) && !isComponentLike(attribute);
    }).reduce((acc, [key, attribute])=>({
            ...acc,
            [key]: attribute
        }), {});
};
const getLinkKind = (attribute, uid)=>{
    if (attribute.relation.startsWith('morph')) {
        return 'relation.morph';
    }
    if (attribute.target === uid) {
        return 'relation.circular';
    }
    return 'relation.basic';
};

var link = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createLinkQuery: createLinkQuery,
  filterValidRelationalAttributes: filterValidRelationalAttributes
});

var index$6 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  entity: entity,
  link: link
});

const createEntitiesWriteStream = (options)=>{
    const { strapi, updateMappingTable, transaction } = options;
    const query = createEntityQuery(strapi);
    return new stream$1.Writable({
        objectMode: true,
        async write (entity, _encoding, callback) {
            await transaction?.attach(async ()=>{
                const { type, id, data } = entity;
                const { create, getDeepPopulateComponentLikeQuery } = query(type);
                const contentType = strapi.getModel(type);
                try {
                    const created = await create({
                        data,
                        populate: getDeepPopulateComponentLikeQuery(contentType, {
                            select: 'id'
                        }),
                        select: 'id'
                    });
                    // Compute differences between original & new entities
                    const diffs = diff(data, created);
                    updateMappingTable(type, id, created.id);
                    // For each difference found on an ID attribute,
                    // update the mapping the table accordingly
                    diffs.forEach((diff)=>{
                        if (diff.kind === 'modified' && fp.last(diff.path) === 'id' && 'kind' in contentType) {
                            const target = resolveComponentUID({
                                paths: diff.path,
                                data,
                                contentType,
                                strapi
                            });
                            // If no type is found for the given path, then ignore the diff
                            if (!target) {
                                return;
                            }
                            const [oldID, newID] = diff.values;
                            updateMappingTable(target, oldID, newID);
                        }
                    });
                } catch (e) {
                    if (e instanceof Error) {
                        return callback(e);
                    }
                    return callback(new ProviderTransferError(`Failed to create "${type}" (${id})`));
                }
                return callback(null);
            });
        }
    });
};

const omitInvalidCreationAttributes = fp.omit([
    'id'
]);
const restoreCoreStore = async (strapi, values)=>{
    const data = omitInvalidCreationAttributes(values);
    return strapi.db.query('strapi::core-store').create({
        data: {
            ...data,
            value: JSON.stringify(data.value)
        }
    });
};
const restoreWebhooks = async (strapi, values)=>{
    const data = omitInvalidCreationAttributes(values);
    return strapi.db.query('strapi::webhook').create({
        data
    });
};
const restoreConfigs = async (strapi, config)=>{
    if (config.type === 'core-store') {
        return restoreCoreStore(strapi, config.value);
    }
    if (config.type === 'webhook') {
        return restoreWebhooks(strapi, config.value);
    }
};
const createConfigurationWriteStream = async (strapi, transaction)=>{
    return new stream$1.Writable({
        objectMode: true,
        async write (config, _encoding, callback) {
            await transaction?.attach(async ()=>{
                try {
                    await restoreConfigs(strapi, config);
                } catch (error) {
                    return callback(new ProviderTransferError(`Failed to import ${chalk.yellowBright(config.type)} (${chalk.greenBright(config.value.id)}`));
                }
                callback();
            });
        }
    });
};

const isErrorWithCode = (error)=>{
    return error && typeof error.code === 'string';
};
const isForeignKeyConstraintError = (e)=>{
    const MYSQL_FK_ERROR_CODES = [
        '1452',
        '1557',
        '1216',
        '1217',
        '1451'
    ];
    const POSTGRES_FK_ERROR_CODE = '23503';
    const SQLITE_FK_ERROR_CODE = 'SQLITE_CONSTRAINT_FOREIGNKEY';
    if (isErrorWithCode(e) && e.code) {
        return [
            SQLITE_FK_ERROR_CODE,
            POSTGRES_FK_ERROR_CODE,
            ...MYSQL_FK_ERROR_CODES
        ].includes(e.code);
    }
    return e.message.toLowerCase().includes('foreign key constraint');
};
const createLinksWriteStream = (mapID, strapi, transaction, onWarning)=>{
    return new stream$1.Writable({
        objectMode: true,
        async write (link, _encoding, callback) {
            await transaction?.attach(async (trx)=>{
                const { left, right } = link;
                const query = createLinkQuery(strapi, trx);
                const originalLeftRef = left.ref;
                const originalRightRef = right.ref;
                // Map IDs if needed
                left.ref = mapID(left.type, originalLeftRef) ?? originalLeftRef;
                right.ref = mapID(right.type, originalRightRef) ?? originalRightRef;
                try {
                    await query().insert(link);
                } catch (e) {
                    if (e instanceof Error) {
                        if (isForeignKeyConstraintError(e)) {
                            onWarning?.(`Skipping link ${left.type}:${originalLeftRef} -> ${right.type}:${originalRightRef} due to a foreign key constraint.`);
                            return callback(null);
                        }
                        return callback(e);
                    }
                    return callback(new ProviderTransferError(`An error happened while trying to import a ${left.type} link.`));
                }
                callback(null);
            });
        }
    });
};

const deleteRecords = async (strapi, options)=>{
    const entities = await deleteEntitiesRecords(strapi, options);
    const configuration = await deleteConfigurationRecords(strapi, options);
    return {
        count: entities.count + configuration.count,
        entities,
        configuration
    };
};
const deleteEntitiesRecords = async (strapi, options = {})=>{
    const { entities } = options;
    const models = strapi.get('models').get();
    const contentTypes = Object.values(strapi.contentTypes);
    const contentTypesToClear = contentTypes.filter((contentType)=>{
        let removeThisContentType = true;
        // include means "only include these types" so if it's not in here, it's not being included
        if (entities?.include) {
            removeThisContentType = entities.include.includes(contentType.uid);
        }
        // if something is excluded, remove it. But lack of being excluded doesn't mean it's kept
        if (entities?.exclude && entities.exclude.includes(contentType.uid)) {
            removeThisContentType = false;
        }
        if (entities?.filters) {
            removeThisContentType = entities.filters.every((filter)=>filter(contentType));
        }
        return removeThisContentType;
    }).map((contentType)=>contentType.uid);
    const modelsToClear = models.filter((model)=>{
        if (contentTypesToClear.includes(model.uid)) {
            return false;
        }
        let removeThisModel = true;
        // include means "only include these types" so if it's not in here, it's not being included
        if (entities?.include) {
            removeThisModel = entities.include.includes(model.uid);
        }
        // if something is excluded, remove it. But lack of being excluded doesn't mean it's kept
        if (entities?.exclude && entities.exclude.includes(model.uid)) {
            removeThisModel = false;
        }
        return removeThisModel;
    }).map((model)=>model.uid);
    const [results, updateResults] = useResults([
        ...contentTypesToClear,
        ...modelsToClear
    ]);
    const contentTypeQuery = createEntityQuery(strapi);
    const contentTypePromises = contentTypesToClear.map(async (uid)=>{
        const result = await contentTypeQuery(uid).deleteMany(entities?.params);
        if (result) {
            updateResults(result.count || 0, uid);
        }
    });
    const modelsPromises = modelsToClear.map(async (uid)=>{
        const result = await strapi.db.query(uid).deleteMany({});
        if (result) {
            updateResults(result.count || 0, uid);
        }
    });
    await Promise.all([
        ...contentTypePromises,
        ...modelsPromises
    ]);
    return results;
};
const deleteConfigurationRecords = async (strapi, options = {})=>{
    const { coreStore = true, webhook = true } = options?.configuration ?? {};
    const models = [];
    if (coreStore) {
        models.push('strapi::core-store');
    }
    if (webhook) {
        models.push('strapi::webhook');
    }
    const [results, updateResults] = useResults(models);
    const deletePromises = models.map(async (uid)=>{
        const result = await strapi.db.query(uid).deleteMany({});
        if (result) {
            updateResults(result.count, uid);
        }
    });
    await Promise.all(deletePromises);
    return results;
};
const useResults = (keys)=>{
    const results = {
        count: 0,
        aggregate: keys.reduce((acc, key)=>({
                ...acc,
                [key]: {
                    count: 0
                }
            }), {})
    };
    const update = (count, key)=>{
        if (key) {
            if (!(key in results.aggregate)) {
                throw new ProviderTransferError(`Unknown key "${key}" provided in results update`);
            }
            results.aggregate[key].count += count;
        }
        results.count += count;
    };
    return [
        results,
        update
    ];
};

const assertValidStrapi = (strapi, msg = '')=>{
    if (!strapi) {
        throw new ProviderInitializationError(`${msg}. Strapi instance not found.`);
    }
};

function _class_private_field_loose_base$5(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
}
var id$5 = 0;
function _class_private_field_loose_key$5(name) {
    return "__private_" + id$5++ + "_" + name;
}
const VALID_CONFLICT_STRATEGIES = [
    'restore'
];
const DEFAULT_CONFLICT_STRATEGY = 'restore';
var _diagnostics$5 = /*#__PURE__*/ _class_private_field_loose_key$5("_diagnostics"), /**
   * The entities mapper is used to map old entities to their new IDs
   */ _entitiesMapper = /*#__PURE__*/ _class_private_field_loose_key$5("_entitiesMapper"), // TODO: either move this to restore strategy, or restore strategy should given access to these instead of repeating the logic possibly in a different way
_areAssetsIncluded = /*#__PURE__*/ _class_private_field_loose_key$5("_areAssetsIncluded"), _isContentTypeIncluded = /*#__PURE__*/ _class_private_field_loose_key$5("_isContentTypeIncluded"), _reportInfo$5 = /*#__PURE__*/ _class_private_field_loose_key$5("_reportInfo"), _validateOptions = /*#__PURE__*/ _class_private_field_loose_key$5("_validateOptions"), _deleteFromRestoreOptions = /*#__PURE__*/ _class_private_field_loose_key$5("_deleteFromRestoreOptions"), _deleteAllAssets = /*#__PURE__*/ _class_private_field_loose_key$5("_deleteAllAssets"), _handleAssetsBackup = /*#__PURE__*/ _class_private_field_loose_key$5("_handleAssetsBackup"), _removeAssetsBackup = /*#__PURE__*/ _class_private_field_loose_key$5("_removeAssetsBackup");
class LocalStrapiDestinationProvider {
    async bootstrap(diagnostics) {
        _class_private_field_loose_base$5(this, _diagnostics$5)[_diagnostics$5] = diagnostics;
        _class_private_field_loose_base$5(this, _validateOptions)[_validateOptions]();
        this.strapi = await this.options.getStrapi();
        if (!this.strapi) {
            throw new ProviderInitializationError('Could not access local strapi');
        }
        this.strapi.db.lifecycles.disable();
        this.transaction = createTransaction(this.strapi);
    }
    async close() {
        const { autoDestroy } = this.options;
        assertValidStrapi(this.strapi);
        this.transaction?.end();
        this.strapi.db.lifecycles.enable();
        // Basically `!== false` but more deterministic
        if (autoDestroy === undefined || autoDestroy === true) {
            await this.strapi?.destroy();
        }
    }
    async rollback() {
        _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5]('Rolling back transaction');
        await this.transaction?.rollback();
        _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5]('Rolled back transaction');
    }
    async beforeTransfer() {
        if (!this.strapi) {
            throw new Error('Strapi instance not found');
        }
        await this.transaction?.attach(async (trx)=>{
            try {
                if (this.options.strategy === 'restore') {
                    await _class_private_field_loose_base$5(this, _handleAssetsBackup)[_handleAssetsBackup]();
                    await _class_private_field_loose_base$5(this, _deleteAllAssets)[_deleteAllAssets](trx);
                    await _class_private_field_loose_base$5(this, _deleteFromRestoreOptions)[_deleteFromRestoreOptions]();
                }
            } catch (error) {
                throw new Error(`restore failed ${error}`);
            }
        });
    }
    getMetadata() {
        _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5]('getting metadata');
        assertValidStrapi(this.strapi, 'Not able to get Schemas');
        const strapiVersion = this.strapi.config.get('info.strapi');
        const createdAt = new Date().toISOString();
        return {
            createdAt,
            strapi: {
                version: strapiVersion
            }
        };
    }
    getSchemas() {
        _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5]('getting schema');
        assertValidStrapi(this.strapi, 'Not able to get Schemas');
        const schemas = schemasToValidJSON({
            ...this.strapi.contentTypes,
            ...this.strapi.components
        });
        return mapSchemasValues(schemas);
    }
    createEntitiesWriteStream() {
        assertValidStrapi(this.strapi, 'Not able to import entities');
        _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5]('creating entities stream');
        const { strategy } = this.options;
        const updateMappingTable = (type, oldID, newID)=>{
            if (!_class_private_field_loose_base$5(this, _entitiesMapper)[_entitiesMapper][type]) {
                _class_private_field_loose_base$5(this, _entitiesMapper)[_entitiesMapper][type] = {};
            }
            Object.assign(_class_private_field_loose_base$5(this, _entitiesMapper)[_entitiesMapper][type], {
                [oldID]: newID
            });
        };
        if (strategy === 'restore') {
            return createEntitiesWriteStream({
                strapi: this.strapi,
                updateMappingTable,
                transaction: this.transaction
            });
        }
        throw new ProviderValidationError(`Invalid strategy ${this.options.strategy}`, {
            check: 'strategy',
            strategy: this.options.strategy,
            validStrategies: VALID_CONFLICT_STRATEGIES
        });
    }
    // TODO: Move this logic to the restore strategy
    async createAssetsWriteStream() {
        assertValidStrapi(this.strapi, 'Not able to stream Assets');
        _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5]('creating assets write stream');
        if (!_class_private_field_loose_base$5(this, _areAssetsIncluded)[_areAssetsIncluded]()) {
            throw new ProviderTransferError('Attempting to transfer assets when `assets` is not set in restore options');
        }
        const removeAssetsBackup = _class_private_field_loose_base$5(this, _removeAssetsBackup)[_removeAssetsBackup].bind(this);
        const strapi = this.strapi;
        const transaction = this.transaction;
        const fileEntitiesMapper = _class_private_field_loose_base$5(this, _entitiesMapper)[_entitiesMapper]['plugin::upload.file'];
        const restoreMediaEntitiesContent = _class_private_field_loose_base$5(this, _isContentTypeIncluded)[_isContentTypeIncluded]('plugin::upload.file');
        return new stream$1.Writable({
            objectMode: true,
            async final (next) {
                // Delete the backup folder
                await removeAssetsBackup();
                next();
            },
            async write (chunk, _encoding, callback) {
                await transaction?.attach(async ()=>{
                    const uploadData = {
                        ...chunk.metadata,
                        stream: stream$1.Readable.from(chunk.stream),
                        buffer: chunk?.buffer
                    };
                    const provider = strapi.config.get('plugin::upload').provider;
                    const fileId = fileEntitiesMapper?.[uploadData.id];
                    if (!fileId) {
                        return callback(new Error(`File ID not found for ID: ${uploadData.id}`));
                    }
                    try {
                        await strapi.plugin('upload').provider.uploadStream(uploadData);
                        // if we're not supposed to transfer the associated entities, stop here
                        if (!restoreMediaEntitiesContent) {
                            return callback();
                        }
                        // Files formats are stored within the parent file entity
                        if (uploadData?.type) {
                            const entry = await strapi.db.query('plugin::upload.file').findOne({
                                where: {
                                    id: fileId
                                }
                            });
                            if (!entry) {
                                throw new Error('file not found');
                            }
                            const specificFormat = entry?.formats?.[uploadData.type];
                            if (specificFormat) {
                                specificFormat.url = uploadData.url;
                            }
                            await strapi.db.query('plugin::upload.file').update({
                                where: {
                                    id: entry.id
                                },
                                data: {
                                    formats: entry.formats,
                                    provider
                                }
                            });
                            return callback();
                        }
                        const entry = await strapi.db.query('plugin::upload.file').findOne({
                            where: {
                                id: fileId
                            }
                        });
                        if (!entry) {
                            throw new Error('file not found');
                        }
                        entry.url = uploadData.url;
                        await strapi.db.query('plugin::upload.file').update({
                            where: {
                                id: entry.id
                            },
                            data: {
                                url: entry.url,
                                provider
                            }
                        });
                        return callback();
                    } catch (error) {
                        return callback(new Error(`Error while uploading asset ${chunk.filename} ${error}`));
                    }
                });
            }
        });
    }
    async createConfigurationWriteStream() {
        assertValidStrapi(this.strapi, 'Not able to stream Configurations');
        _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5]('creating configuration write stream');
        const { strategy } = this.options;
        if (strategy === 'restore') {
            return createConfigurationWriteStream(this.strapi, this.transaction);
        }
        throw new ProviderValidationError(`Invalid strategy ${strategy}`, {
            check: 'strategy',
            strategy,
            validStrategies: VALID_CONFLICT_STRATEGIES
        });
    }
    async createLinksWriteStream() {
        _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5]('creating links write stream');
        if (!this.strapi) {
            throw new Error('Not able to stream links. Strapi instance not found');
        }
        const { strategy } = this.options;
        const mapID = (uid, id)=>_class_private_field_loose_base$5(this, _entitiesMapper)[_entitiesMapper][uid]?.[id];
        if (strategy === 'restore') {
            return createLinksWriteStream(mapID, this.strapi, this.transaction, this.onWarning);
        }
        throw new ProviderValidationError(`Invalid strategy ${strategy}`, {
            check: 'strategy',
            strategy,
            validStrategies: VALID_CONFLICT_STRATEGIES
        });
    }
    constructor(options){
        Object.defineProperty(this, _reportInfo$5, {
            value: reportInfo$5
        });
        Object.defineProperty(this, _validateOptions, {
            value: validateOptions
        });
        Object.defineProperty(this, _deleteFromRestoreOptions, {
            value: deleteFromRestoreOptions
        });
        Object.defineProperty(this, _deleteAllAssets, {
            value: deleteAllAssets
        });
        Object.defineProperty(this, _handleAssetsBackup, {
            value: handleAssetsBackup
        });
        Object.defineProperty(this, _removeAssetsBackup, {
            value: removeAssetsBackup
        });
        Object.defineProperty(this, _diagnostics$5, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _entitiesMapper, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _areAssetsIncluded, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _isContentTypeIncluded, {
            writable: true,
            value: void 0
        });
        this.name = 'destination::local-strapi';
        this.type = 'destination';
        _class_private_field_loose_base$5(this, _areAssetsIncluded)[_areAssetsIncluded] = ()=>{
            return this.options.restore?.assets;
        };
        _class_private_field_loose_base$5(this, _isContentTypeIncluded)[_isContentTypeIncluded] = (type)=>{
            const notIncluded = this.options.restore?.entities?.include && !this.options.restore?.entities?.include?.includes(type);
            const excluded = this.options.restore?.entities?.exclude && this.options.restore?.entities.exclude.includes(type);
            return !excluded && !notIncluded;
        };
        this.options = options;
        _class_private_field_loose_base$5(this, _entitiesMapper)[_entitiesMapper] = {};
        this.uploadsBackupDirectoryName = `uploads_backup_${Date.now()}`;
    }
}
function reportInfo$5(message) {
    _class_private_field_loose_base$5(this, _diagnostics$5)[_diagnostics$5]?.report({
        details: {
            createdAt: new Date(),
            message,
            origin: 'local-destination-provider'
        },
        kind: 'info'
    });
}
function validateOptions() {
    _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5]('validating options');
    if (!VALID_CONFLICT_STRATEGIES.includes(this.options.strategy)) {
        throw new ProviderValidationError(`Invalid strategy ${this.options.strategy}`, {
            check: 'strategy',
            strategy: this.options.strategy,
            validStrategies: VALID_CONFLICT_STRATEGIES
        });
    }
    // require restore options when using restore
    if (this.options.strategy === 'restore' && !this.options.restore) {
        throw new ProviderValidationError('Missing restore options');
    }
}
async function deleteFromRestoreOptions() {
    assertValidStrapi(this.strapi);
    if (!this.options.restore) {
        throw new ProviderValidationError('Missing restore options');
    }
    _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5]('deleting record ');
    return deleteRecords(this.strapi, this.options.restore);
}
async function deleteAllAssets(trx) {
    assertValidStrapi(this.strapi);
    _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5]('deleting all assets');
    // if we're not restoring files, don't touch the files
    if (!_class_private_field_loose_base$5(this, _areAssetsIncluded)[_areAssetsIncluded]()) {
        return;
    }
    const stream = this.strapi.db// Create a query builder instance (default type is 'select')
    .queryBuilder('plugin::upload.file')// Fetch all columns
    .select('*')// Attach the transaction
    .transacting(trx)// Get a readable stream
    .stream();
    // TODO use bulk delete when exists in providers
    for await (const file of stream){
        await this.strapi.plugin('upload').provider.delete(file);
        if (file.formats) {
            for (const fileFormat of Object.values(file.formats)){
                await this.strapi.plugin('upload').provider.delete(fileFormat);
            }
        }
    }
    _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5]('deleted all assets');
}
async function handleAssetsBackup() {
    assertValidStrapi(this.strapi, 'Not able to create the assets backup');
    // if we're not restoring assets, don't back them up because they won't be touched
    if (!_class_private_field_loose_base$5(this, _areAssetsIncluded)[_areAssetsIncluded]()) {
        return;
    }
    if (this.strapi.config.get('plugin::upload').provider === 'local') {
        _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5]('creating assets backup directory');
        const assetsDirectory = path.join(this.strapi.dirs.static.public, 'uploads');
        const backupDirectory = path.join(this.strapi.dirs.static.public, this.uploadsBackupDirectoryName);
        try {
            // Check access before attempting to do anything
            await fse__namespace.access(assetsDirectory, // eslint-disable-next-line no-bitwise
            fse__namespace.constants.W_OK | fse__namespace.constants.R_OK | fse__namespace.constants.F_OK);
            // eslint-disable-next-line no-bitwise
            await fse__namespace.access(path.join(assetsDirectory, '..'), fse__namespace.constants.W_OK | fse__namespace.constants.R_OK);
            await fse__namespace.move(assetsDirectory, backupDirectory);
            await fse__namespace.mkdir(assetsDirectory);
            // Create a .gitkeep file to ensure the directory is not empty
            await fse__namespace.outputFile(path.join(assetsDirectory, '.gitkeep'), '');
            _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5](`created assets backup directory ${backupDirectory}`);
        } catch (err) {
            throw new ProviderTransferError('The backup folder for the assets could not be created inside the public folder. Please ensure Strapi has write permissions on the public directory', {
                code: 'ASSETS_DIRECTORY_ERR'
            });
        }
        return backupDirectory;
    }
}
async function removeAssetsBackup() {
    assertValidStrapi(this.strapi, 'Not able to remove Assets');
    // if we're not restoring assets, don't back them up because they won't be touched
    if (!_class_private_field_loose_base$5(this, _areAssetsIncluded)[_areAssetsIncluded]()) {
        return;
    }
    // TODO: this should catch all thrown errors and bubble it up to engine so it can be reported as a non-fatal diagnostic message telling the user they may need to manually delete assets
    if (this.strapi.config.get('plugin::upload').provider === 'local') {
        _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5]('removing assets backup');
        assertValidStrapi(this.strapi);
        const backupDirectory = path.join(this.strapi.dirs.static.public, this.uploadsBackupDirectoryName);
        await fse__namespace.rm(backupDirectory, {
            recursive: true,
            force: true
        });
        _class_private_field_loose_base$5(this, _reportInfo$5)[_reportInfo$5]('successfully removed assets backup');
    }
}
const createLocalStrapiDestinationProvider = (options)=>{
    return new LocalStrapiDestinationProvider(options);
};

/**
 * Generate and consume content-types streams in order to stream each entity individually
 */ const createEntitiesStream = (strapi)=>{
    const contentTypes = Object.values(strapi.contentTypes);
    async function* contentTypeStreamGenerator() {
        for (const contentType of contentTypes){
            const query = createEntityQuery(strapi).call(null, contentType.uid);
            const stream = strapi.db// Create a query builder instance (default type is 'select')
            .queryBuilder(contentType.uid)// Fetch all columns
            .select('*')// Apply the populate
            .populate(query.deepPopulateComponentLikeQuery)// Get a readable stream
            .stream();
            yield {
                contentType,
                stream
            };
        }
    }
    return stream$1.Readable.from(async function* entitiesGenerator() {
        for await (const { stream, contentType } of contentTypeStreamGenerator()){
            try {
                for await (const entity of stream){
                    yield {
                        entity,
                        contentType
                    };
                }
            } catch  {
            // ignore
            } finally{
                stream.destroy();
            }
        }
    }());
};
/**
 * Create an entity transform stream which convert the output of
 * the multi-content-types stream to the transfer entity format
 */ const createEntitiesTransformStream = ()=>{
    return new stream$1.Transform({
        objectMode: true,
        transform (data, _encoding, callback) {
            const { entity, contentType } = data;
            const { id, ...attributes } = entity;
            callback(null, {
                type: contentType.uid,
                id,
                data: attributes
            });
        }
    });
};

/**
 * Create a Readable which will stream all the links from a Strapi instance
 */ const createLinksStream = (strapi)=>{
    const uids = [
        ...Object.keys(strapi.contentTypes),
        ...Object.keys(strapi.components)
    ];
    // Async generator stream that returns every link from a Strapi instance
    return stream$1.Readable.from(async function* linkGenerator() {
        const query = createLinkQuery(strapi);
        for (const uid of uids){
            const generator = query().generateAll(uid);
            for await (const link of generator){
                yield link;
            }
        }
    }());
};

/**
 * Create a readable stream that export the Strapi app configuration
 */ const createConfigurationStream = (strapi)=>{
    return stream$1.Readable.from(async function* configurationGenerator() {
        // Core Store
        const coreStoreStream = streamChain.chain([
            strapi.db.queryBuilder('strapi::core-store').stream(),
            (data)=>fp.set('value', JSON.parse(data.value), data),
            wrapConfigurationItem('core-store')
        ]);
        // Webhook
        const webhooksStream = streamChain.chain([
            strapi.db.queryBuilder('strapi::webhook').stream(),
            wrapConfigurationItem('webhook')
        ]);
        const streams = [
            coreStoreStream,
            webhooksStream
        ];
        for (const stream of streams){
            for await (const item of stream){
                yield item;
            }
        }
    }());
};
const wrapConfigurationItem = (type)=>(value)=>({
            type,
            value
        });

function getFileStream(filepath, strapi1, isLocal = false) {
    if (isLocal) {
        // Todo: handle errors
        return fse.createReadStream(filepath);
    }
    const readableStream = new stream$1.PassThrough();
    // fetch the image from remote url and stream it
    strapi1.fetch(filepath).then((res)=>{
        if (res.status !== 200) {
            readableStream.emit('error', new Error(`Request failed with status code ${res.status}`));
            return;
        }
        if (res.body) {
            // pipe the image data
            stream$1.Readable.fromWeb(new webStream__namespace.ReadableStream(res.body)).pipe(readableStream);
        } else {
            readableStream.emit('error', new Error('Empty data found for file'));
        }
    }).catch((error)=>{
        readableStream.emit('error', error);
    });
    return readableStream;
}
function getFileStats(filepath, strapi1, isLocal = false) {
    if (isLocal) {
        return fse.stat(filepath);
    }
    return new Promise((resolve, reject)=>{
        strapi1.fetch(filepath).then((res)=>{
            if (res.status !== 200) {
                reject(new Error(`Request failed with status code ${res.status}`));
                return;
            }
            const contentLength = res.headers.get('content-length');
            const stats = {
                size: contentLength ? parseInt(contentLength, 10) : 0
            };
            resolve(stats);
        }).catch((error)=>{
            reject(error);
        });
    });
}
async function signFile(file) {
    const { provider } = strapi.plugins.upload;
    const { provider: providerName } = strapi.config.get('plugin.upload');
    const isPrivate = await provider.isPrivate();
    if (file?.provider === providerName && isPrivate) {
        const signUrl = async (file)=>{
            const signedUrl = await provider.getSignedUrl(file);
            file.url = signedUrl.url;
        };
        // Sign the original file
        await signUrl(file);
        // Sign each file format
        if (file.formats) {
            for (const format of Object.keys(file.formats)){
                await signUrl(file.formats[format]);
            }
        }
    }
}
/**
 * Generate and consume assets streams in order to stream each file individually
 */ const createAssetsStream = (strapi1)=>{
    const generator = async function*() {
        const stream = strapi1.db.queryBuilder('plugin::upload.file')// Create a query builder instance (default type is 'select')
        // Fetch all columns
        .select('*')// Get a readable stream
        .stream();
        for await (const file of stream){
            const isLocalProvider = file.provider === 'local';
            if (!isLocalProvider) {
                await signFile(file);
            }
            const filepath = isLocalProvider ? path.join(strapi1.dirs.static.public, file.url) : file.url;
            const stats = await getFileStats(filepath, strapi1, isLocalProvider);
            const stream = getFileStream(filepath, strapi1, isLocalProvider);
            yield {
                metadata: file,
                filepath,
                filename: file.hash + file.ext,
                stream,
                stats: {
                    size: stats.size
                }
            };
            if (file.formats) {
                for (const format of Object.keys(file.formats)){
                    const fileFormat = file.formats[format];
                    const fileFormatFilepath = isLocalProvider ? path.join(strapi1.dirs.static.public, fileFormat.url) : fileFormat.url;
                    const fileFormatStats = await getFileStats(fileFormatFilepath, strapi1, isLocalProvider);
                    const fileFormatStream = getFileStream(fileFormatFilepath, strapi1, isLocalProvider);
                    const metadata = {
                        ...fileFormat,
                        type: format,
                        id: file.id,
                        mainHash: file.hash
                    };
                    yield {
                        metadata,
                        filepath: fileFormatFilepath,
                        filename: fileFormat.hash + fileFormat.ext,
                        stream: fileFormatStream,
                        stats: {
                            size: fileFormatStats.size
                        }
                    };
                }
            }
        }
    };
    return stream$1.Duplex.from(generator());
};

function _class_private_field_loose_base$4(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
}
var id$4 = 0;
function _class_private_field_loose_key$4(name) {
    return "__private_" + id$4++ + "_" + name;
}
const createLocalStrapiSourceProvider = (options)=>{
    return new LocalStrapiSourceProvider(options);
};
var _diagnostics$4 = /*#__PURE__*/ _class_private_field_loose_key$4("_diagnostics"), _reportInfo$4 = /*#__PURE__*/ _class_private_field_loose_key$4("_reportInfo"), /**
   * Reports an error to the diagnostic reporter.
   */ _reportError = /*#__PURE__*/ _class_private_field_loose_key$4("_reportError"), /**
   * Handles errors that occur in read streams.
   */ _handleStreamError = /*#__PURE__*/ _class_private_field_loose_key$4("_handleStreamError");
class LocalStrapiSourceProvider {
    async bootstrap(diagnostics) {
        _class_private_field_loose_base$4(this, _diagnostics$4)[_diagnostics$4] = diagnostics;
        this.strapi = await this.options.getStrapi();
        this.strapi.db.lifecycles.disable();
    }
    async close() {
        const { autoDestroy } = this.options;
        assertValidStrapi(this.strapi);
        this.strapi.db.lifecycles.enable();
        // Basically `!== false` but more deterministic
        if (autoDestroy === undefined || autoDestroy === true) {
            await this.strapi?.destroy();
        }
    }
    getMetadata() {
        _class_private_field_loose_base$4(this, _reportInfo$4)[_reportInfo$4]('getting metadata');
        const strapiVersion = strapi.config.get('info.strapi');
        const createdAt = new Date().toISOString();
        return {
            createdAt,
            strapi: {
                version: strapiVersion
            }
        };
    }
    async createEntitiesReadStream() {
        assertValidStrapi(this.strapi, 'Not able to stream entities');
        _class_private_field_loose_base$4(this, _reportInfo$4)[_reportInfo$4]('creating entities read stream');
        return streamChain.chain([
            // Entities stream
            createEntitiesStream(this.strapi),
            // Transform stream
            createEntitiesTransformStream()
        ]);
    }
    createLinksReadStream() {
        assertValidStrapi(this.strapi, 'Not able to stream links');
        _class_private_field_loose_base$4(this, _reportInfo$4)[_reportInfo$4]('creating links read stream');
        return createLinksStream(this.strapi);
    }
    createConfigurationReadStream() {
        assertValidStrapi(this.strapi, 'Not able to stream configuration');
        _class_private_field_loose_base$4(this, _reportInfo$4)[_reportInfo$4]('creating configuration read stream');
        return createConfigurationStream(this.strapi);
    }
    getSchemas() {
        assertValidStrapi(this.strapi, 'Not able to get Schemas');
        _class_private_field_loose_base$4(this, _reportInfo$4)[_reportInfo$4]('getting schemas');
        const schemas = schemasToValidJSON({
            ...this.strapi.contentTypes,
            ...this.strapi.components
        });
        return mapSchemasValues(schemas);
    }
    createSchemasReadStream() {
        return stream$1.Readable.from(Object.values(this.getSchemas()));
    }
    createAssetsReadStream() {
        assertValidStrapi(this.strapi, 'Not able to stream assets');
        _class_private_field_loose_base$4(this, _reportInfo$4)[_reportInfo$4]('creating assets read stream');
        const stream = createAssetsStream(this.strapi);
        stream.on('error', (err)=>{
            _class_private_field_loose_base$4(this, _handleStreamError)[_handleStreamError]('assets', err);
        });
        return stream;
    }
    constructor(options){
        Object.defineProperty(this, _reportInfo$4, {
            value: reportInfo$4
        });
        Object.defineProperty(this, _reportError, {
            value: reportError
        });
        Object.defineProperty(this, _handleStreamError, {
            value: handleStreamError
        });
        Object.defineProperty(this, _diagnostics$4, {
            writable: true,
            value: void 0
        });
        this.name = 'source::local-strapi';
        this.type = 'source';
        this.options = options;
    }
}
function reportInfo$4(message) {
    _class_private_field_loose_base$4(this, _diagnostics$4)[_diagnostics$4]?.report({
        details: {
            createdAt: new Date(),
            message,
            origin: 'local-source-provider'
        },
        kind: 'info'
    });
}
function reportError(message, error) {
    _class_private_field_loose_base$4(this, _diagnostics$4)[_diagnostics$4]?.report({
        details: {
            createdAt: new Date(),
            message,
            error,
            severity: 'fatal',
            name: error.name
        },
        kind: 'error'
    });
}
function handleStreamError(streamType, err) {
    const { message, stack } = err;
    const errorMessage = `[Data transfer] Error in ${streamType} read stream: ${message}`;
    const formattedError = {
        message: errorMessage,
        stack,
        timestamp: new Date().toISOString()
    };
    this.strapi?.log.error(formattedError);
    _class_private_field_loose_base$4(this, _reportError)[_reportError](formattedError.message, err);
}

const createDispatcher = (ws, retryMessageOptions = {
    retryMessageMaxRetries: 5,
    retryMessageTimeout: 30000
}, reportInfo)=>{
    const state = {};
    const dispatch = async (message, options = {})=>{
        if (!ws) {
            throw new Error('No websocket connection found');
        }
        return new Promise((resolve, reject)=>{
            const uuid = crypto.randomUUID();
            const payload = {
                ...message,
                uuid
            };
            let numberOfTimesMessageWasSent = 0;
            if (options.attachTransfer) {
                Object.assign(payload, {
                    transferID: state.transfer?.id
                });
            }
            if (message.type === 'command') {
                reportInfo?.(`dispatching message command:${message.command} uuid:${uuid} sent:${numberOfTimesMessageWasSent}`);
            } else if (message.type === 'transfer') {
                const messageToSend = message;
                reportInfo?.(`dispatching message action:${messageToSend.action} ${messageToSend.kind === 'step' ? `step:${messageToSend.step}` : ''} uuid:${uuid} sent:${numberOfTimesMessageWasSent}`);
            }
            const stringifiedPayload = JSON.stringify(payload);
            ws.send(stringifiedPayload, (error)=>{
                if (error) {
                    reject(error);
                }
            });
            const { retryMessageMaxRetries, retryMessageTimeout } = retryMessageOptions;
            const sendPeriodically = ()=>{
                if (numberOfTimesMessageWasSent <= retryMessageMaxRetries) {
                    numberOfTimesMessageWasSent += 1;
                    ws.send(stringifiedPayload, (error)=>{
                        if (error) {
                            reject(error);
                        }
                    });
                } else {
                    reject(new ProviderError('error', 'Request timed out'));
                }
            };
            const interval = setInterval(sendPeriodically, retryMessageTimeout);
            const onResponse = (raw)=>{
                const response = JSON.parse(raw.toString());
                if (message.type === 'command') {
                    reportInfo?.(`received response to message command: ${message.command} uuid: ${uuid} sent: ${numberOfTimesMessageWasSent}`);
                } else if (message.type === 'transfer') {
                    const messageToSend = message;
                    reportInfo?.(`received response to message action:${messageToSend.action} ${messageToSend.kind === 'step' ? `step:${messageToSend.step}` : ''} uuid:${uuid} sent:${numberOfTimesMessageWasSent}`);
                }
                if (response.uuid === uuid) {
                    clearInterval(interval);
                    if (response.error) {
                        const message = response.error.message;
                        const details = response.error.details?.details;
                        const step = response.error.details?.step;
                        let error = new ProviderError('error', message, details);
                        if (step === 'transfer') {
                            error = new ProviderTransferError(message, details);
                        } else if (step === 'validation') {
                            error = new ProviderValidationError(message, details);
                        } else if (step === 'initialization') {
                            error = new ProviderInitializationError(message);
                        }
                        return reject(error);
                    }
                    resolve(response.data ?? null);
                } else {
                    ws.once('message', onResponse);
                }
            };
            ws.once('message', onResponse);
        });
    };
    const dispatchCommand = (payload)=>{
        return dispatch({
            type: 'command',
            ...payload
        });
    };
    const dispatchTransferAction = async (action)=>{
        const payload = {
            type: 'transfer',
            kind: 'action',
            action
        };
        return dispatch(payload, {
            attachTransfer: true
        }) ?? Promise.resolve(null);
    };
    const dispatchTransferStep = async (payload)=>{
        const message = {
            type: 'transfer',
            kind: 'step',
            ...payload
        };
        return dispatch(message, {
            attachTransfer: true
        }) ?? Promise.resolve(null);
    };
    const setTransferProperties = (properties)=>{
        state.transfer = {
            ...properties
        };
    };
    return {
        get transferID () {
            return state.transfer?.id;
        },
        get transferKind () {
            return state.transfer?.kind;
        },
        setTransferProperties,
        dispatch,
        dispatchCommand,
        dispatchTransferAction,
        dispatchTransferStep
    };
};
const connectToWebsocket = (address, options, diagnostics)=>{
    return new Promise((resolve, reject)=>{
        const server = new ws.WebSocket(address, options);
        server.once('open', ()=>{
            resolve(server);
        });
        server.on('unexpected-response', (_req, res)=>{
            if (res.statusCode === 401) {
                return reject(new ProviderInitializationError('Failed to initialize the connection: Authentication Error'));
            }
            if (res.statusCode === 403) {
                return reject(new ProviderInitializationError('Failed to initialize the connection: Authorization Error'));
            }
            if (res.statusCode === 404) {
                return reject(new ProviderInitializationError('Failed to initialize the connection: Data transfer is not enabled on the remote host'));
            }
            return reject(new ProviderInitializationError(`Failed to initialize the connection: Unexpected server response ${res.statusCode}`));
        });
        server.on('message', (raw)=>{
            const response = JSON.parse(raw.toString());
            if (response.diagnostic) {
                diagnostics?.report({
                    ...response.diagnostic
                });
            }
        });
        server.once('error', (err)=>{
            reject(new ProviderTransferError(err.message, {
                details: {
                    error: err.message
                }
            }));
        });
    });
};
const trimTrailingSlash = (input)=>{
    return input.replace(/\/$/, '');
};

const TRANSFER_PATH = '/transfer/runner';
const TRANSFER_METHODS = [
    'push',
    'pull'
];

var constants = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TRANSFER_METHODS: TRANSFER_METHODS,
  TRANSFER_PATH: TRANSFER_PATH
});

function _class_private_field_loose_base$3(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
}
var id$3 = 0;
function _class_private_field_loose_key$3(name) {
    return "__private_" + id$3++ + "_" + name;
}
const jsonLength = (obj)=>Buffer.byteLength(JSON.stringify(obj));
var _diagnostics$3 = /*#__PURE__*/ _class_private_field_loose_key$3("_diagnostics"), _startStepOnce = /*#__PURE__*/ _class_private_field_loose_key$3("_startStepOnce"), _startStep$1 = /*#__PURE__*/ _class_private_field_loose_key$3("_startStep"), _endStep$1 = /*#__PURE__*/ _class_private_field_loose_key$3("_endStep"), _streamStep = /*#__PURE__*/ _class_private_field_loose_key$3("_streamStep"), _writeStream = /*#__PURE__*/ _class_private_field_loose_key$3("_writeStream"), _reportInfo$3 = /*#__PURE__*/ _class_private_field_loose_key$3("_reportInfo");
class RemoteStrapiDestinationProvider {
    resetStats() {
        this.stats = {
            assets: {
                count: 0
            },
            entities: {
                count: 0
            },
            links: {
                count: 0
            },
            configuration: {
                count: 0
            }
        };
    }
    async initTransfer() {
        const { strategy, restore } = this.options;
        const query = this.dispatcher?.dispatchCommand({
            command: 'init',
            params: {
                options: {
                    strategy,
                    restore
                },
                transfer: 'push'
            }
        });
        const res = await query;
        if (!res?.transferID) {
            throw new ProviderTransferError('Init failed, invalid response from the server');
        }
        this.resetStats();
        return res.transferID;
    }
    async bootstrap(diagnostics) {
        _class_private_field_loose_base$3(this, _diagnostics$3)[_diagnostics$3] = diagnostics;
        const { url, auth } = this.options;
        const validProtocols = [
            'https:',
            'http:'
        ];
        let ws;
        if (!validProtocols.includes(url.protocol)) {
            throw new ProviderValidationError(`Invalid protocol "${url.protocol}"`, {
                check: 'url',
                details: {
                    protocol: url.protocol,
                    validProtocols
                }
            });
        }
        const wsProtocol = url.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${wsProtocol}//${url.host}${trimTrailingSlash(url.pathname)}${TRANSFER_PATH}/push`;
        _class_private_field_loose_base$3(this, _reportInfo$3)[_reportInfo$3]('establishing websocket connection');
        // No auth defined, trying public access for transfer
        if (!auth) {
            ws = await connectToWebsocket(wsUrl, undefined, _class_private_field_loose_base$3(this, _diagnostics$3)[_diagnostics$3]);
        } else if (auth.type === 'token') {
            const headers = {
                Authorization: `Bearer ${auth.token}`
            };
            ws = await connectToWebsocket(wsUrl, {
                headers
            }, _class_private_field_loose_base$3(this, _diagnostics$3)[_diagnostics$3]);
        } else {
            throw new ProviderValidationError('Auth method not available', {
                check: 'auth.type',
                details: {
                    auth: auth.type
                }
            });
        }
        _class_private_field_loose_base$3(this, _reportInfo$3)[_reportInfo$3]('established websocket connection');
        this.ws = ws;
        const { retryMessageOptions } = this.options;
        _class_private_field_loose_base$3(this, _reportInfo$3)[_reportInfo$3]('creating dispatcher');
        this.dispatcher = createDispatcher(this.ws, retryMessageOptions, (message)=>_class_private_field_loose_base$3(this, _reportInfo$3)[_reportInfo$3](message));
        _class_private_field_loose_base$3(this, _reportInfo$3)[_reportInfo$3]('created dispatcher');
        _class_private_field_loose_base$3(this, _reportInfo$3)[_reportInfo$3]('initialize transfer');
        this.transferID = await this.initTransfer();
        _class_private_field_loose_base$3(this, _reportInfo$3)[_reportInfo$3](`initialized transfer ${this.transferID}`);
        this.dispatcher.setTransferProperties({
            id: this.transferID,
            kind: 'push'
        });
        await this.dispatcher.dispatchTransferAction('bootstrap');
    }
    async close() {
        // Gracefully close the remote transfer process
        if (this.transferID && this.dispatcher) {
            await this.dispatcher.dispatchTransferAction('close');
            await this.dispatcher.dispatchCommand({
                command: 'end',
                params: {
                    transferID: this.transferID
                }
            });
        }
        await new Promise((resolve)=>{
            const { ws } = this;
            if (!ws || ws.CLOSED) {
                resolve();
                return;
            }
            ws.on('close', ()=>resolve()).close();
        });
    }
    getMetadata() {
        return this.dispatcher?.dispatchTransferAction('getMetadata') ?? null;
    }
    async beforeTransfer() {
        await this.dispatcher?.dispatchTransferAction('beforeTransfer');
    }
    async rollback() {
        await this.dispatcher?.dispatchTransferAction('rollback');
    }
    getSchemas() {
        if (!this.dispatcher) {
            return Promise.resolve(null);
        }
        return this.dispatcher.dispatchTransferAction('getSchemas');
    }
    createEntitiesWriteStream() {
        return _class_private_field_loose_base$3(this, _writeStream)[_writeStream]('entities');
    }
    createLinksWriteStream() {
        return _class_private_field_loose_base$3(this, _writeStream)[_writeStream]('links');
    }
    createConfigurationWriteStream() {
        return _class_private_field_loose_base$3(this, _writeStream)[_writeStream]('configuration');
    }
    createAssetsWriteStream() {
        let batch = [];
        let hasStarted = false;
        const batchSize = 1024 * 1024; // 1MB;
        const batchLength = ()=>{
            return batch.reduce((acc, chunk)=>chunk.action === 'stream' ? acc + chunk.data.byteLength : acc, 0);
        };
        const startAssetsTransferOnce = _class_private_field_loose_base$3(this, _startStepOnce)[_startStepOnce]('assets');
        const flush = async ()=>{
            const streamError = await _class_private_field_loose_base$3(this, _streamStep)[_streamStep]('assets', batch);
            batch = [];
            return streamError;
        };
        const safePush = async (chunk)=>{
            batch.push(chunk);
            if (batchLength() >= batchSize) {
                const streamError = await flush();
                if (streamError) {
                    throw streamError;
                }
            }
        };
        return new stream$1.Writable({
            objectMode: true,
            final: async (callback)=>{
                if (batch.length > 0) {
                    await flush();
                }
                if (hasStarted) {
                    const { error: endStepError } = await _class_private_field_loose_base$3(this, _endStep$1)[_endStep$1]('assets');
                    if (endStepError) {
                        return callback(endStepError);
                    }
                }
                return callback(null);
            },
            async write (asset, _encoding, callback) {
                const startError = await startAssetsTransferOnce();
                if (startError) {
                    return callback(startError);
                }
                hasStarted = true;
                const assetID = crypto.randomUUID();
                const { filename, filepath, stats, stream, metadata } = asset;
                try {
                    await safePush({
                        action: 'start',
                        assetID,
                        data: {
                            filename,
                            filepath,
                            stats,
                            metadata
                        }
                    });
                    for await (const chunk of stream){
                        await safePush({
                            action: 'stream',
                            assetID,
                            data: chunk
                        });
                    }
                    await safePush({
                        action: 'end',
                        assetID
                    });
                    callback();
                } catch (error) {
                    if (error instanceof Error) {
                        callback(error);
                    }
                }
            }
        });
    }
    constructor(options){
        Object.defineProperty(this, _startStepOnce, {
            value: startStepOnce
        });
        Object.defineProperty(this, _startStep$1, {
            value: startStep$1
        });
        Object.defineProperty(this, _endStep$1, {
            value: endStep$1
        });
        Object.defineProperty(this, _streamStep, {
            value: streamStep
        });
        Object.defineProperty(this, _writeStream, {
            value: writeStream
        });
        Object.defineProperty(this, _reportInfo$3, {
            value: reportInfo$3
        });
        Object.defineProperty(this, _diagnostics$3, {
            writable: true,
            value: void 0
        });
        this.name = 'destination::remote-strapi';
        this.type = 'destination';
        this.options = options;
        this.ws = null;
        this.dispatcher = null;
        this.transferID = null;
        this.resetStats();
    }
}
function startStepOnce(stage) {
    return fp.once(()=>_class_private_field_loose_base$3(this, _startStep$1)[_startStep$1](stage));
}
async function startStep$1(step) {
    try {
        await this.dispatcher?.dispatchTransferStep({
            action: 'start',
            step
        });
    } catch (e) {
        if (e instanceof Error) {
            return e;
        }
        if (typeof e === 'string') {
            return new ProviderTransferError(e);
        }
        return new ProviderTransferError('Unexpected error');
    }
    this.stats[step] = {
        count: 0
    };
    return null;
}
async function endStep$1(step) {
    try {
        const res = await this.dispatcher?.dispatchTransferStep({
            action: 'end',
            step
        });
        return {
            stats: res?.stats ?? null,
            error: null
        };
    } catch (e) {
        if (e instanceof Error) {
            return {
                stats: null,
                error: e
            };
        }
        if (typeof e === 'string') {
            return {
                stats: null,
                error: new ProviderTransferError(e)
            };
        }
        return {
            stats: null,
            error: new ProviderTransferError('Unexpected error')
        };
    }
}
async function streamStep(step, message) {
    try {
        if (step === 'assets') {
            const assetMessage = message;
            this.stats[step].count += assetMessage.filter((data)=>data.action === 'start').length;
        } else {
            this.stats[step].count += message.length;
        }
        await this.dispatcher?.dispatchTransferStep({
            action: 'stream',
            step,
            data: message
        });
    } catch (e) {
        if (e instanceof Error) {
            return e;
        }
        if (typeof e === 'string') {
            return new ProviderTransferError(e);
        }
        return new ProviderTransferError('Unexpected error');
    }
    return null;
}
function writeStream(step) {
    const batchSize = 1024 * 1024; // 1MB;
    const startTransferOnce = _class_private_field_loose_base$3(this, _startStepOnce)[_startStepOnce](step);
    let batch = [];
    const batchLength = ()=>jsonLength(batch);
    return new stream$1.Writable({
        objectMode: true,
        final: async (callback)=>{
            if (batch.length > 0) {
                const streamError = await _class_private_field_loose_base$3(this, _streamStep)[_streamStep](step, batch);
                batch = [];
                if (streamError) {
                    return callback(streamError);
                }
            }
            const { error, stats } = await _class_private_field_loose_base$3(this, _endStep$1)[_endStep$1](step);
            const { count } = this.stats[step];
            if (stats && (stats.started !== count || stats.finished !== count)) {
                callback(new Error(`Data missing: sent ${this.stats[step].count} ${step}, recieved ${stats.started} and saved ${stats.finished} ${step}`));
            }
            callback(error);
        },
        write: async (chunk, _encoding, callback)=>{
            const startError = await startTransferOnce();
            if (startError) {
                return callback(startError);
            }
            batch.push(chunk);
            if (batchLength() >= batchSize) {
                const streamError = await _class_private_field_loose_base$3(this, _streamStep)[_streamStep](step, batch);
                batch = [];
                if (streamError) {
                    return callback(streamError);
                }
            }
            callback();
        }
    });
}
function reportInfo$3(message) {
    _class_private_field_loose_base$3(this, _diagnostics$3)[_diagnostics$3]?.report({
        details: {
            createdAt: new Date(),
            message,
            origin: 'remote-destination-provider'
        },
        kind: 'info'
    });
}
const createRemoteStrapiDestinationProvider = (options)=>{
    return new RemoteStrapiDestinationProvider(options);
};

function _class_private_field_loose_base$2(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
}
var id$2 = 0;
function _class_private_field_loose_key$2(name) {
    return "__private_" + id$2++ + "_" + name;
}
var _diagnostics$2 = /*#__PURE__*/ _class_private_field_loose_key$2("_diagnostics"), _createStageReadStream = /*#__PURE__*/ _class_private_field_loose_key$2("_createStageReadStream"), _reportInfo$2 = /*#__PURE__*/ _class_private_field_loose_key$2("_reportInfo"), _startStep = /*#__PURE__*/ _class_private_field_loose_key$2("_startStep"), _respond = /*#__PURE__*/ _class_private_field_loose_key$2("_respond"), _endStep = /*#__PURE__*/ _class_private_field_loose_key$2("_endStep");
class RemoteStrapiSourceProvider {
    createEntitiesReadStream() {
        return _class_private_field_loose_base$2(this, _createStageReadStream)[_createStageReadStream]('entities');
    }
    createLinksReadStream() {
        return _class_private_field_loose_base$2(this, _createStageReadStream)[_createStageReadStream]('links');
    }
    async createAssetsReadStream() {
        // Create the streams used to transfer the assets
        const stream = await _class_private_field_loose_base$2(this, _createStageReadStream)[_createStageReadStream]('assets');
        const pass = new stream$1.PassThrough({
            objectMode: true
        });
        // Init the asset map
        const assets = {};
        // Watch for stalled assets; if we don't receive a chunk within timeout, abort transfer
        const resetTimeout = (assetID)=>{
            if (assets[assetID].timeout) {
                clearTimeout(assets[assetID].timeout);
            }
            assets[assetID].timeout = setTimeout(()=>{
                _class_private_field_loose_base$2(this, _reportInfo$2)[_reportInfo$2](`Asset ${assetID} transfer stalled, aborting.`);
                assets[assetID].status = 'errored';
                assets[assetID].stream.destroy(new Error(`Asset ${assetID} transfer timed out`));
            }, this.options.streamTimeout);
        };
        stream/**
       * Process a payload of many transfer assets and performs the following tasks:
       * - Start: creates a stream for new assets.
       * - Stream: writes asset chunks to the asset's stream.
       * - End: closes the stream after the asset s transferred and cleanup related resources.
       */ .on('data', async (payload)=>{
            for (const item of payload){
                const { action, assetID } = item;
                // Creates the stream to send the incoming asset through
                if (action === 'start') {
                    // if a transfer has already been started for the same asset ID, something is wrong
                    if (assets[assetID]) {
                        throw new Error(`Asset ${assetID} already started`);
                    }
                    _class_private_field_loose_base$2(this, _reportInfo$2)[_reportInfo$2](`Asset ${assetID} starting`);
                    // Register the asset
                    assets[assetID] = {
                        ...item.data,
                        stream: new stream$1.PassThrough(),
                        status: 'ok',
                        queue: []
                    };
                    resetTimeout(assetID);
                    // Connect the individual asset stream to the main asset stage stream
                    // Note: nothing is transferred until data chunks are fed to the asset stream
                    await this.writeAsync(pass, assets[assetID]);
                } else if (action === 'stream' || action === 'end') {
                    // If the asset hasn't been registered, or if it's been closed already, something is wrong
                    if (!assets[assetID]) {
                        throw new Error(`No id matching ${assetID} for stream action`);
                    }
                    // On every action, reset the timeout timer
                    if (action === 'stream') {
                        resetTimeout(assetID);
                    } else {
                        clearTimeout(assets[assetID].timeout);
                    }
                    if (assets[assetID].status === 'closed') {
                        throw new Error(`Asset ${assetID} is closed`);
                    }
                    assets[assetID].queue.push(item);
                }
            }
            // each new payload will start new processQueue calls, which may cause some extra calls
            // it's essentially saying "start processing this asset again, I added more data to the queue"
            for(const assetID in assets){
                if (Object.prototype.hasOwnProperty.call(assets, assetID)) {
                    const asset = assets[assetID];
                    if (asset.queue?.length > 0) {
                        await processQueue(assetID);
                    }
                }
            }
        }).on('close', ()=>{
            pass.end();
        });
        /**
     * Start processing the queue for a given assetID
     *
     * Even though this is a loop that attempts to process the entire queue, it is safe to call this more than once
     * for the same asset id because the queue is shared globally, the items are shifted off, and immediately written
     */ const processQueue = async (id)=>{
            if (!assets[id]) {
                throw new Error(`Failed to write asset chunk for "${id}". Asset not found.`);
            }
            const asset = assets[id];
            const { status: currentStatus } = asset;
            if ([
                'closed',
                'errored'
            ].includes(currentStatus)) {
                throw new Error(`Failed to write asset chunk for "${id}". The asset is currently "${currentStatus}"`);
            }
            while(asset.queue.length > 0){
                const data = asset.queue.shift();
                if (!data) {
                    throw new Error(`Invalid chunk found for ${id}`);
                }
                try {
                    // if this is an end chunk, close the asset stream
                    if (data.action === 'end') {
                        _class_private_field_loose_base$2(this, _reportInfo$2)[_reportInfo$2](`Ending asset stream for ${id}`);
                        await closeAssetStream(id);
                        break; // Exit the loop after closing the stream
                    }
                    // Save the current chunk
                    await writeChunkToStream(id, data);
                } catch  {
                    if (!assets[id]) {
                        throw new Error(`No id matching ${id} for writeAssetChunk`);
                    }
                }
            }
        };
        /**
     * Writes a chunk of data to the asset's stream.
     *
     * Only check if the targeted asset exists, no other validation is done.
     */ const writeChunkToStream = async (id, data)=>{
            const asset = assets[id];
            if (!asset) {
                throw new Error(`Failed to write asset chunk for "${id}". Asset not found.`);
            }
            const rawBuffer = data;
            const chunk = Buffer.from(rawBuffer.data);
            await this.writeAsync(asset.stream, chunk);
        };
        /**
     * Closes the asset stream associated with the given ID.
     *
     * It deletes the stream for the asset upon successful closure.
     */ const closeAssetStream = async (id)=>{
            if (!assets[id]) {
                throw new Error(`Failed to close asset "${id}". Asset not found.`);
            }
            assets[id].status = 'closed';
            await new Promise((resolve, reject)=>{
                const { stream } = assets[id];
                stream.on('close', ()=>{
                    resolve();
                }).on('error', (e)=>{
                    assets[id].status = 'errored';
                    reject(new Error(`Failed to close asset "${id}". Asset stream error: ${e.toString()}`));
                }).end();
            });
        };
        return pass;
    }
    createConfigurationReadStream() {
        return _class_private_field_loose_base$2(this, _createStageReadStream)[_createStageReadStream]('configuration');
    }
    async getMetadata() {
        const metadata = await this.dispatcher?.dispatchTransferAction('getMetadata');
        return metadata ?? null;
    }
    assertValidProtocol(url) {
        const validProtocols = [
            'https:',
            'http:'
        ];
        if (!validProtocols.includes(url.protocol)) {
            throw new ProviderValidationError(`Invalid protocol "${url.protocol}"`, {
                check: 'url',
                details: {
                    protocol: url.protocol,
                    validProtocols
                }
            });
        }
    }
    async initTransfer() {
        const query = this.dispatcher?.dispatchCommand({
            command: 'init'
        });
        const res = await query;
        if (!res?.transferID) {
            throw new ProviderTransferError('Init failed, invalid response from the server');
        }
        return res.transferID;
    }
    async bootstrap(diagnostics) {
        _class_private_field_loose_base$2(this, _diagnostics$2)[_diagnostics$2] = diagnostics;
        const { url, auth } = this.options;
        let ws;
        this.assertValidProtocol(url);
        const wsProtocol = url.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${wsProtocol}//${url.host}${trimTrailingSlash(url.pathname)}${TRANSFER_PATH}/pull`;
        _class_private_field_loose_base$2(this, _reportInfo$2)[_reportInfo$2]('establishing websocket connection');
        // No auth defined, trying public access for transfer
        if (!auth) {
            ws = await connectToWebsocket(wsUrl, undefined, _class_private_field_loose_base$2(this, _diagnostics$2)[_diagnostics$2]);
        } else if (auth.type === 'token') {
            const headers = {
                Authorization: `Bearer ${auth.token}`
            };
            ws = await connectToWebsocket(wsUrl, {
                headers
            }, _class_private_field_loose_base$2(this, _diagnostics$2)[_diagnostics$2]);
        } else {
            throw new ProviderValidationError('Auth method not available', {
                check: 'auth.type',
                details: {
                    auth: auth.type
                }
            });
        }
        _class_private_field_loose_base$2(this, _reportInfo$2)[_reportInfo$2]('established websocket connection');
        this.ws = ws;
        const { retryMessageOptions } = this.options;
        _class_private_field_loose_base$2(this, _reportInfo$2)[_reportInfo$2]('creating dispatcher');
        this.dispatcher = createDispatcher(this.ws, retryMessageOptions, (message)=>_class_private_field_loose_base$2(this, _reportInfo$2)[_reportInfo$2](message));
        _class_private_field_loose_base$2(this, _reportInfo$2)[_reportInfo$2]('creating dispatcher');
        _class_private_field_loose_base$2(this, _reportInfo$2)[_reportInfo$2]('initialize transfer');
        const transferID = await this.initTransfer();
        _class_private_field_loose_base$2(this, _reportInfo$2)[_reportInfo$2](`initialized transfer ${transferID}`);
        this.dispatcher.setTransferProperties({
            id: transferID,
            kind: 'pull'
        });
        await this.dispatcher.dispatchTransferAction('bootstrap');
    }
    async close() {
        await this.dispatcher?.dispatchTransferAction('close');
        await new Promise((resolve)=>{
            const { ws } = this;
            if (!ws || ws.CLOSED) {
                resolve();
                return;
            }
            ws.on('close', ()=>resolve()).close();
        });
    }
    async getSchemas() {
        const schemas = await this.dispatcher?.dispatchTransferAction('getSchemas');
        return schemas ?? null;
    }
    constructor(options){
        Object.defineProperty(this, _createStageReadStream, {
            value: createStageReadStream
        });
        Object.defineProperty(this, _reportInfo$2, {
            value: reportInfo$2
        });
        Object.defineProperty(this, _startStep, {
            value: startStep
        });
        Object.defineProperty(this, _respond, {
            value: respond
        });
        Object.defineProperty(this, _endStep, {
            value: endStep
        });
        Object.defineProperty(this, _diagnostics$2, {
            writable: true,
            value: void 0
        });
        this.name = 'source::remote-strapi';
        this.type = 'source';
        this.defaultOptions = {
            streamTimeout: 15000
        };
        this.writeAsync = (stream, data)=>{
            return new Promise((resolve, reject)=>{
                stream.write(data, (error)=>{
                    if (error) {
                        reject(error);
                    }
                    resolve();
                });
            });
        };
        this.options = {
            ...this.defaultOptions,
            ...options
        };
        this.ws = null;
        this.dispatcher = null;
    }
}
async function createStageReadStream(stage) {
    const startResult = await _class_private_field_loose_base$2(this, _startStep)[_startStep](stage);
    if (startResult instanceof Error) {
        throw startResult;
    }
    const { id: processID } = startResult;
    const stream = new stream$1.PassThrough({
        objectMode: true
    });
    const listener = async (raw)=>{
        const parsed = JSON.parse(raw.toString());
        // If not a message related to our transfer process, ignore it
        if (!parsed.uuid || parsed?.data?.type !== 'transfer' || parsed?.data?.id !== processID) {
            this.ws?.once('message', listener);
            return;
        }
        const { uuid, data: message } = parsed;
        const { ended, error, data } = message;
        if (error) {
            await _class_private_field_loose_base$2(this, _respond)[_respond](uuid);
            stream.destroy(error);
            return;
        }
        if (ended) {
            await _class_private_field_loose_base$2(this, _respond)[_respond](uuid);
            await _class_private_field_loose_base$2(this, _endStep)[_endStep](stage);
            stream.end();
            return;
        }
        // if we get a single items instead of a batch
        for (const item of fp.castArray(data)){
            stream.push(item);
        }
        this.ws?.once('message', listener);
        await _class_private_field_loose_base$2(this, _respond)[_respond](uuid);
    };
    this.ws?.once('message', listener);
    return stream;
}
function reportInfo$2(message) {
    _class_private_field_loose_base$2(this, _diagnostics$2)[_diagnostics$2]?.report({
        details: {
            createdAt: new Date(),
            message,
            origin: 'remote-source-provider'
        },
        kind: 'info'
    });
}
async function startStep(step) {
    try {
        return await this.dispatcher?.dispatchTransferStep({
            action: 'start',
            step
        });
    } catch (e) {
        if (e instanceof Error) {
            return e;
        }
        if (typeof e === 'string') {
            return new ProviderTransferError(e);
        }
        return new ProviderTransferError('Unexpected error');
    }
}
async function respond(uuid) {
    return new Promise((resolve, reject)=>{
        this.ws?.send(JSON.stringify({
            uuid
        }), (e)=>{
            if (e) {
                reject(e);
            } else {
                resolve(e);
            }
        });
    });
}
async function endStep(step) {
    try {
        await this.dispatcher?.dispatchTransferStep({
            action: 'end',
            step
        });
    } catch (e) {
        if (e instanceof Error) {
            return e;
        }
        if (typeof e === 'string') {
            return new ProviderTransferError(e);
        }
        return new ProviderTransferError('Unexpected error');
    }
    return null;
}
const createRemoteStrapiSourceProvider = (options)=>{
    return new RemoteStrapiSourceProvider(options);
};

// Local

var index$5 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DEFAULT_CONFLICT_STRATEGY: DEFAULT_CONFLICT_STRATEGY,
  VALID_CONFLICT_STRATEGIES: VALID_CONFLICT_STRATEGIES,
  createLocalStrapiDestinationProvider: createLocalStrapiDestinationProvider,
  createLocalStrapiSourceProvider: createLocalStrapiSourceProvider,
  createRemoteStrapiDestinationProvider: createRemoteStrapiDestinationProvider,
  createRemoteStrapiSourceProvider: createRemoteStrapiSourceProvider
});

var DEFAULT_TRANSFER_FLOW = [
    {
        kind: 'action',
        action: 'bootstrap'
    },
    {
        kind: 'action',
        action: 'init'
    },
    {
        kind: 'action',
        action: 'beforeTransfer'
    },
    {
        kind: 'transfer',
        stage: 'schemas'
    },
    {
        kind: 'transfer',
        stage: 'entities'
    },
    {
        kind: 'transfer',
        stage: 'assets'
    },
    {
        kind: 'transfer',
        stage: 'links'
    },
    {
        kind: 'transfer',
        stage: 'configuration'
    },
    {
        kind: 'action',
        action: 'close'
    }
];

const createFlow = (flow)=>{
    const state = {
        step: null
    };
    /**
   * Equality check between two steps
   */ const stepEqual = (stepA, stepB)=>{
        if (stepA.kind === 'action' && stepB.kind === 'action') {
            return stepA.action === stepB.action;
        }
        if (stepA.kind === 'transfer' && stepB.kind === 'transfer') {
            return stepA.stage === stepB.stage;
        }
        return false;
    };
    /**
   * Find the index for a given step
   */ const findStepIndex = (step)=>flow.findIndex((flowStep)=>stepEqual(step, flowStep));
    return {
        has (step) {
            return findStepIndex(step) !== -1;
        },
        can (step) {
            if (state.step === null) {
                return true;
            }
            const indexesDifference = findStepIndex(step) - findStepIndex(state.step);
            // It's possible to send multiple time the same transfer step in a row
            if (indexesDifference === 0 && step.kind === 'transfer') {
                return true;
            }
            return indexesDifference > 0;
        },
        cannot (step) {
            return !this.can(step);
        },
        set (step) {
            const canSwitch = this.can(step);
            if (!canSwitch) {
                throw new Error('Impossible to proceed to the given step');
            }
            state.step = step;
            return this;
        },
        get () {
            return state.step;
        }
    };
};

const VALID_TRANSFER_COMMANDS = [
    'init',
    'end',
    'status'
];

const transformUpgradeHeader = (header = '')=>{
    return header.split(',').map((s)=>s.trim().toLowerCase());
};
let timeouts;
const hasHttpServer = ()=>{
    // during server restarts, strapi may not have ever been defined at all, so we have to check it first
    return typeof strapi !== 'undefined' && !!strapi?.server?.httpServer;
};
// temporarily disable server timeouts while transfer is running
const disableTimeouts = ()=>{
    if (!hasHttpServer()) {
        return;
    }
    const { httpServer } = strapi.server;
    // save the original timeouts to restore after
    if (!timeouts) {
        timeouts = {
            headersTimeout: httpServer.headersTimeout,
            requestTimeout: httpServer.requestTimeout
        };
    }
    httpServer.headersTimeout = 0;
    httpServer.requestTimeout = 0;
    strapi.log.info('[Data transfer] Disabling http timeouts');
};
const resetTimeouts = ()=>{
    if (!hasHttpServer() || !timeouts) {
        return;
    }
    const { httpServer } = strapi.server;
    strapi.log.info('[Data transfer] Restoring http timeouts');
    httpServer.headersTimeout = timeouts.headersTimeout;
    httpServer.requestTimeout = timeouts.requestTimeout;
};
/**
 * Make sure that the upgrade header is a valid websocket one
 */ const assertValidHeader = (ctx)=>{
    // if it's exactly what we expect, it's fine
    if (ctx.headers.upgrade === 'websocket') {
        return;
    }
    // check if it could be an array that still includes websocket
    const upgradeHeader = transformUpgradeHeader(ctx.headers.upgrade);
    // Sanitize user input before writing it to our logs
    const logSafeUpgradeHeader = JSON.stringify(ctx.headers.upgrade)?.replace(/[^a-z0-9\s.,|]/gi, '').substring(0, 50);
    if (!upgradeHeader.includes('websocket')) {
        throw new Error(`Transfer Upgrade header expected 'websocket', found '${logSafeUpgradeHeader}'. Please ensure that your server or proxy is not modifying the Upgrade header.`);
    }
    /**
   * If there's more than expected but it still includes websocket, in theory it could still work
   * and could be necessary for their certain configurations, so we'll allow it to proceed but
   * log the unexpected behaviour in case it helps debug an issue
   * */ strapi.log.info(`Transfer Upgrade header expected only 'websocket', found unexpected values: ${logSafeUpgradeHeader}`);
};
const isDataTransferMessage = (message)=>{
    if (!message || typeof message !== 'object') {
        return false;
    }
    const { uuid, type } = message;
    if (typeof uuid !== 'string' || typeof type !== 'string') {
        return false;
    }
    if (![
        'command',
        'transfer'
    ].includes(type)) {
        return false;
    }
    return true;
};
/**
 * Handle the upgrade to ws connection
 */ const handleWSUpgrade = (wss, ctx, callback)=>{
    assertValidHeader(ctx);
    wss.handleUpgrade(ctx.req, ctx.request.socket, Buffer.alloc(0), (client, request)=>{
        if (!client) {
            // If the WebSocket upgrade failed, destroy the socket to avoid hanging
            ctx.request.socket.destroy();
            return;
        }
        disableTimeouts();
        strapi.db.lifecycles.disable();
        strapi.log.info('[Data transfer] Disabling lifecycle hooks');
        // Create a connection between the client & the server
        wss.emit('connection', client, ctx.req);
        // Invoke the ws callback
        callback(client, request);
    });
    ctx.respond = false;
};
// Protocol related functions
const handlerControllerFactory = (implementation)=>(options)=>{
        const { verify, server: serverOptions } = options ?? {};
        const wss = new ws.WebSocket.Server({
            ...serverOptions,
            noServer: true
        });
        return async (ctx)=>{
            const cb = (ws)=>{
                const state = {
                    id: undefined
                };
                const messageUUIDs = new Set();
                const diagnostics = createDiagnosticReporter();
                const cannotRespondHandler = (err)=>{
                    strapi?.log?.error('[Data transfer] Cannot send error response to client, closing connection');
                    strapi?.log?.error(err);
                    try {
                        ws.terminate();
                        ctx.req.socket.destroy();
                    } catch (err) {
                        strapi?.log?.error('[Data transfer] Failed to close socket on error');
                    }
                };
                const prototype = {
                    // Transfer ID
                    get transferID () {
                        return state.id;
                    },
                    set transferID (id){
                        state.id = id;
                    },
                    // Started at
                    get startedAt () {
                        return state.startedAt;
                    },
                    set startedAt (timestamp){
                        state.startedAt = timestamp;
                    },
                    get response () {
                        return state.response;
                    },
                    set response (response){
                        state.response = response;
                    },
                    get diagnostics () {
                        return diagnostics;
                    },
                    addUUID (uuid) {
                        messageUUIDs.add(uuid);
                    },
                    hasUUID (uuid) {
                        return messageUUIDs.has(uuid);
                    },
                    isTransferStarted () {
                        return this.transferID !== undefined && this.startedAt !== undefined;
                    },
                    assertValidTransfer () {
                        const isStarted = this.isTransferStarted();
                        if (!isStarted) {
                            throw new Error('Invalid Transfer Process');
                        }
                    },
                    assertValidTransferCommand (command) {
                        const isDefined = typeof this[command] === 'function';
                        const isValidTransferCommand = VALID_TRANSFER_COMMANDS.includes(command);
                        if (!isDefined || !isValidTransferCommand) {
                            throw new Error('Invalid transfer command');
                        }
                    },
                    async respond (uuid, e, data) {
                        let details = {};
                        return new Promise((resolve, reject)=>{
                            if (!uuid && !e) {
                                reject(new Error('Missing uuid for this message'));
                                return;
                            }
                            this.response = {
                                uuid,
                                data,
                                e
                            };
                            if (e instanceof ProviderError) {
                                details = e.details;
                            }
                            const payload = JSON.stringify({
                                uuid,
                                data: data ?? null,
                                error: e ? {
                                    code: e?.name ?? 'ERR',
                                    message: e?.message,
                                    details
                                } : null
                            });
                            this.send(payload, (error)=>error ? reject(error) : resolve());
                        });
                    },
                    send (message, cb) {
                        ws.send(message, cb);
                    },
                    confirm (message) {
                        return new Promise((resolve, reject)=>{
                            const uuid = crypto.randomUUID();
                            const payload = JSON.stringify({
                                uuid,
                                data: message
                            });
                            this.send(payload, (error)=>{
                                if (error) {
                                    reject(error);
                                }
                            });
                            const onResponse = (raw)=>{
                                const response1 = JSON.parse(raw.toString());
                                if (response1.uuid === uuid) {
                                    resolve(response1.data ?? null);
                                } else {
                                    ws.once('message', onResponse);
                                }
                            };
                            ws.once('message', onResponse);
                        });
                    },
                    async executeAndRespond (uuid, fn) {
                        try {
                            const response1 = await fn();
                            await this.respond(uuid, null, response1);
                        } catch (e) {
                            if (e instanceof Error) {
                                await this.respond(uuid, e).catch(cannotRespondHandler);
                            } else if (typeof e === 'string') {
                                await this.respond(uuid, new ProviderTransferError(e)).catch(cannotRespondHandler);
                            } else {
                                await this.respond(uuid, new ProviderTransferError('Unexpected error', {
                                    error: e
                                })).catch(cannotRespondHandler);
                            }
                        }
                    },
                    cleanup () {
                        this.transferID = undefined;
                        this.startedAt = undefined;
                        this.response = undefined;
                    },
                    teardown () {
                        this.cleanup();
                    },
                    verifyAuth (scope) {
                        return verify(ctx, scope);
                    },
                    // Transfer commands
                    init () {},
                    end () {},
                    status () {},
                    // Default prototype implementation for events
                    onMessage () {},
                    onError () {},
                    onClose () {},
                    onInfo () {},
                    onWarning () {}
                };
                const handler = Object.assign(Object.create(prototype), implementation(prototype));
                // Bind ws events to handler methods
                ws.on('close', async (...args)=>{
                    try {
                        await handler.onClose(...args);
                    } catch (err) {
                        strapi?.log?.error('[Data transfer] Uncaught error closing connection');
                        strapi?.log?.error(err);
                        cannotRespondHandler(err);
                    } finally{
                        resetTimeouts();
                        strapi.db.lifecycles.enable();
                        strapi.log.info('[Data transfer] Restoring lifecycle hooks');
                    }
                });
                ws.on('error', async (...args)=>{
                    try {
                        await handler.onError(...args);
                    } catch (err) {
                        strapi?.log?.error('[Data transfer] Uncaught error in error handling');
                        strapi?.log?.error(err);
                        cannotRespondHandler(err);
                    }
                });
                ws.on('message', async (...args)=>{
                    try {
                        await handler.onMessage(...args);
                    } catch (err) {
                        strapi?.log?.error('[Data transfer] Uncaught error in message handling');
                        strapi?.log?.error(err);
                        cannotRespondHandler(err);
                    }
                });
                diagnostics.onDiagnostic((diagnostic)=>{
                    const uuid = crypto.randomUUID();
                    const payload = JSON.stringify({
                        diagnostic,
                        uuid
                    });
                    handler.send(payload);
                });
            };
            try {
                handleWSUpgrade(wss, ctx, cb);
            } catch (err) {
                strapi?.log?.error('[Data transfer] Error in websocket upgrade request');
                strapi?.log?.error(err);
            }
        };
    };

const VALID_TRANSFER_ACTIONS$1 = [
    'bootstrap',
    'close',
    'rollback',
    'beforeTransfer',
    'getMetadata',
    'getSchemas'
];
const TRANSFER_KIND$1 = 'push';
const writeAsync = (stream, data)=>{
    return new Promise((resolve, reject)=>{
        stream.write(data, (error)=>{
            if (error) {
                reject(error);
            }
            resolve();
        });
    });
};
const createPushController = handlerControllerFactory((proto)=>({
        isTransferStarted () {
            return proto.isTransferStarted.call(this) && this.provider !== undefined;
        },
        verifyAuth () {
            return proto.verifyAuth.call(this, TRANSFER_KIND$1);
        },
        onInfo (message) {
            this.diagnostics?.report({
                details: {
                    message,
                    origin: 'push-handler',
                    createdAt: new Date()
                },
                kind: 'info'
            });
        },
        onWarning (message) {
            this.diagnostics?.report({
                details: {
                    message,
                    createdAt: new Date(),
                    origin: 'push-handler'
                },
                kind: 'warning'
            });
        },
        cleanup () {
            proto.cleanup.call(this);
            this.streams = {};
            this.assets = {};
            delete this.flow;
            delete this.provider;
        },
        teardown () {
            if (this.provider) {
                this.provider.rollback();
            }
            proto.teardown.call(this);
        },
        assertValidTransfer () {
            proto.assertValidTransfer.call(this);
            if (this.provider === undefined) {
                throw new Error('Invalid Transfer Process');
            }
        },
        assertValidTransferAction (action) {
            if (VALID_TRANSFER_ACTIONS$1.includes(action)) {
                return;
            }
            throw new ProviderTransferError(`Invalid action provided: "${action}"`, {
                action,
                validActions: Object.keys(VALID_TRANSFER_ACTIONS$1)
            });
        },
        assertValidStreamTransferStep (stage) {
            const currentStep = this.flow?.get();
            const nextStep = {
                kind: 'transfer',
                stage
            };
            if (currentStep?.kind === 'transfer' && !currentStep.locked) {
                throw new ProviderTransferError(`You need to initialize the transfer stage (${nextStep}) before starting to stream data`);
            }
            if (this.flow?.cannot(nextStep)) {
                throw new ProviderTransferError(`Invalid stage (${nextStep}) provided for the current flow`, {
                    step: nextStep
                });
            }
        },
        async createWritableStreamForStep (step) {
            const mapper = {
                entities: ()=>this.provider?.createEntitiesWriteStream(),
                links: ()=>this.provider?.createLinksWriteStream(),
                configuration: ()=>this.provider?.createConfigurationWriteStream(),
                assets: ()=>this.provider?.createAssetsWriteStream()
            };
            if (!(step in mapper)) {
                throw new Error('Invalid transfer step, impossible to create a stream');
            }
            if (!this.streams) {
                throw new Error('Invalid transfer state');
            }
            this.streams[step] = await mapper[step]();
        },
        async onMessage (raw) {
            const msg = JSON.parse(raw.toString());
            if (!isDataTransferMessage(msg)) {
                return;
            }
            if (!msg.uuid) {
                await this.respond(undefined, new Error('Missing uuid in message'));
            }
            if (proto.hasUUID(msg.uuid)) {
                const previousResponse = proto.response;
                if (previousResponse?.uuid === msg.uuid) {
                    await this.respond(previousResponse?.uuid, previousResponse.e, previousResponse.data);
                }
                return;
            }
            const { uuid, type } = msg;
            proto.addUUID(uuid);
            // Regular command message (init, end, status)
            if (type === 'command') {
                const { command } = msg;
                this.onInfo(`received command:${command} uuid:${uuid}`);
                await this.executeAndRespond(uuid, ()=>{
                    this.assertValidTransferCommand(command);
                    // The status command don't have params
                    if (command === 'status') {
                        return this.status();
                    }
                    return this[command](msg.params);
                });
            } else if (type === 'transfer') {
                this.onInfo(`received transfer action:${msg.action} step:${msg.kind} uuid:${uuid}`);
                await this.executeAndRespond(uuid, async ()=>{
                    await this.verifyAuth();
                    this.assertValidTransfer();
                    return this.onTransferMessage(msg);
                });
            } else {
                await this.respond(uuid, new Error('Bad Request'));
            }
        },
        async onTransferMessage (msg) {
            const { kind } = msg;
            if (kind === 'action') {
                return this.onTransferAction(msg);
            }
            if (kind === 'step') {
                return this.onTransferStep(msg);
            }
        },
        lockTransferStep (stage) {
            const currentStep = this.flow?.get();
            const nextStep = {
                kind: 'transfer',
                stage
            };
            if (currentStep?.kind === 'transfer' && currentStep.locked) {
                throw new ProviderTransferError(`It's not possible to start a new transfer stage (${stage}) while another one is in progress (${currentStep.stage})`);
            }
            if (this.flow?.cannot(nextStep)) {
                throw new ProviderTransferError(`Invalid stage (${stage}) provided for the current flow`, {
                    step: nextStep
                });
            }
            this.flow?.set({
                ...nextStep,
                locked: true
            });
        },
        unlockTransferStep (stage) {
            const currentStep = this.flow?.get();
            const nextStep = {
                kind: 'transfer',
                stage
            };
            // Cannot unlock if not locked (aka: started)
            if (currentStep?.kind === 'transfer' && !currentStep.locked) {
                throw new ProviderTransferError(`You need to initialize the transfer stage (${stage}) before ending it`);
            }
            // Cannot unlock if invalid step provided
            if (this.flow?.cannot(nextStep)) {
                throw new ProviderTransferError(`Invalid stage (${stage}) provided for the current flow`, {
                    step: nextStep
                });
            }
            this.flow?.set({
                ...nextStep,
                locked: false
            });
        },
        async onTransferStep (msg) {
            const { step: stage } = msg;
            if (msg.action === 'start') {
                this.lockTransferStep(stage);
                if (this.streams?.[stage] instanceof stream$1.Writable) {
                    throw new Error('Stream already created, something went wrong');
                }
                await this.createWritableStreamForStep(stage);
                this.stats[stage] = {
                    started: 0,
                    finished: 0
                };
                return {
                    ok: true
                };
            }
            if (msg.action === 'stream') {
                this.assertValidStreamTransferStep(stage);
                // Stream operation on the current transfer stage
                const stream = this.streams?.[stage];
                if (!stream) {
                    throw new Error('You need to init first');
                }
                // Assets are nested streams
                if (stage === 'assets') {
                    return this.streamAsset(msg.data);
                }
                // For all other steps
                await Promise.all(msg.data.map(async (item)=>{
                    this.stats[stage].started += 1;
                    await writeAsync(stream, item);
                    this.stats[stage].finished += 1;
                }));
            }
            if (msg.action === 'end') {
                this.unlockTransferStep(stage);
                const stream = this.streams?.[stage];
                if (stream && !stream.closed) {
                    await new Promise((resolve, reject)=>{
                        stream.on('close', resolve).on('error', reject).end();
                    });
                }
                delete this.streams?.[stage];
                return {
                    ok: true,
                    stats: this.stats[stage]
                };
            }
        },
        async onTransferAction (msg) {
            const { action } = msg;
            this.assertValidTransferAction(action);
            const step = {
                kind: 'action',
                action
            };
            const isStepRegistered = this.flow?.has(step);
            if (isStepRegistered) {
                if (this.flow?.cannot(step)) {
                    throw new ProviderTransferError(`Invalid action "${action}" found for the current flow `, {
                        action
                    });
                }
                this.flow?.set(step);
            }
            if (action === 'bootstrap') {
                return this.provider?.[action](this.diagnostics);
            }
            return this.provider?.[action]();
        },
        async streamAsset (payload) {
            const assetsStream = this.streams?.assets;
            // TODO: close the stream upon receiving an 'end' event instead
            if (payload === null) {
                this.streams?.assets?.end();
                return;
            }
            for (const item of payload){
                const { action, assetID } = item;
                if (!assetsStream) {
                    throw new Error('Stream not defined');
                }
                if (action === 'start') {
                    this.stats.assets.started += 1;
                    this.assets[assetID] = {
                        ...item.data,
                        stream: new stream$1.PassThrough()
                    };
                    writeAsync(assetsStream, this.assets[assetID]);
                }
                if (action === 'stream') {
                    // The buffer has gone through JSON operations and is now of shape { type: "Buffer"; data: UInt8Array }
                    // We need to transform it back into a Buffer instance
                    const rawBuffer = item.data;
                    const chunk = Buffer.from(rawBuffer.data);
                    await writeAsync(this.assets[assetID].stream, chunk);
                }
                if (action === 'end') {
                    await new Promise((resolve, reject)=>{
                        const { stream: assetStream } = this.assets[assetID];
                        assetStream.on('close', ()=>{
                            this.stats.assets.finished += 1;
                            delete this.assets[assetID];
                            resolve();
                        }).on('error', reject).end();
                    });
                }
            }
        },
        onClose () {
            this.teardown();
        },
        onError (err) {
            this.teardown();
            strapi.log.error(err);
        },
        // Commands
        async init (params) {
            if (this.transferID || this.provider) {
                throw new Error('Transfer already in progress');
            }
            await this.verifyAuth();
            this.transferID = crypto.randomUUID();
            this.startedAt = Date.now();
            this.assets = {};
            this.streams = {};
            this.stats = {
                assets: {
                    started: 0,
                    finished: 0
                },
                configuration: {
                    started: 0,
                    finished: 0
                },
                entities: {
                    started: 0,
                    finished: 0
                },
                links: {
                    started: 0,
                    finished: 0
                }
            };
            this.flow = createFlow(DEFAULT_TRANSFER_FLOW);
            this.provider = createLocalStrapiDestinationProvider({
                ...params.options,
                autoDestroy: false,
                getStrapi: ()=>strapi
            });
            this.provider.onWarning = (message)=>{
                this.onWarning(message);
                strapi.log.warn(message);
            };
            return {
                transferID: this.transferID
            };
        },
        async status () {
            const isStarted = this.isTransferStarted();
            if (isStarted) {
                const startedAt = this.startedAt;
                return {
                    active: true,
                    kind: TRANSFER_KIND$1,
                    startedAt,
                    elapsed: Date.now() - startedAt
                };
            }
            return {
                active: false,
                kind: null,
                elapsed: null,
                startedAt: null
            };
        },
        async end (params) {
            await this.verifyAuth();
            if (this.transferID !== params?.transferID) {
                throw new ProviderTransferError('Bad transfer ID provided');
            }
            this.cleanup();
            return {
                ok: true
            };
        }
    }));

const TRANSFER_KIND = 'pull';
const VALID_TRANSFER_ACTIONS = [
    'bootstrap',
    'close',
    'getMetadata',
    'getSchemas'
];
const createPullController = handlerControllerFactory((proto)=>({
        isTransferStarted () {
            return proto.isTransferStarted.call(this) && this.provider !== undefined;
        },
        verifyAuth () {
            return proto.verifyAuth.call(this, TRANSFER_KIND);
        },
        cleanup () {
            proto.cleanup.call(this);
            this.streams = {};
            delete this.provider;
        },
        onInfo (message) {
            this.diagnostics?.report({
                details: {
                    message,
                    origin: 'pull-handler',
                    createdAt: new Date()
                },
                kind: 'info'
            });
        },
        onWarning (message) {
            this.diagnostics?.report({
                details: {
                    message,
                    createdAt: new Date(),
                    origin: 'pull-handler'
                },
                kind: 'warning'
            });
        },
        onError (error) {
            this.diagnostics?.report({
                details: {
                    message: error.message,
                    error,
                    createdAt: new Date(),
                    name: error.name,
                    severity: 'fatal'
                },
                kind: 'error'
            });
        },
        assertValidTransferAction (action) {
            // Abstract the constant to string[] to allow looser check on the given action
            const validActions = VALID_TRANSFER_ACTIONS;
            if (validActions.includes(action)) {
                return;
            }
            throw new ProviderTransferError(`Invalid action provided: "${action}"`, {
                action,
                validActions: Object.keys(VALID_TRANSFER_ACTIONS)
            });
        },
        async onMessage (raw) {
            const msg = JSON.parse(raw.toString());
            if (!isDataTransferMessage(msg)) {
                return;
            }
            if (!msg.uuid) {
                await this.respond(undefined, new Error('Missing uuid in message'));
            }
            if (proto.hasUUID(msg.uuid)) {
                const previousResponse = proto.response;
                if (previousResponse?.uuid === msg.uuid) {
                    await this.respond(previousResponse?.uuid, previousResponse.e, previousResponse.data);
                }
                return;
            }
            const { uuid, type } = msg;
            proto.addUUID(uuid);
            // Regular command message (init, end, status)
            if (type === 'command') {
                const { command } = msg;
                this.onInfo(`received command:${command} uuid:${uuid}`);
                await this.executeAndRespond(uuid, ()=>{
                    this.assertValidTransferCommand(command);
                    // The status command don't have params
                    if (command === 'status') {
                        return this.status();
                    }
                    return this[command](msg.params);
                });
            } else if (type === 'transfer') {
                this.onInfo(`received transfer action:${msg.action} step:${msg.kind} uuid:${uuid}`);
                await this.executeAndRespond(uuid, async ()=>{
                    await this.verifyAuth();
                    this.assertValidTransfer();
                    return this.onTransferMessage(msg);
                });
            } else {
                await this.respond(uuid, new Error('Bad Request'));
            }
        },
        async onTransferMessage (msg) {
            const { kind } = msg;
            if (kind === 'action') {
                return this.onTransferAction(msg);
            }
            if (kind === 'step') {
                return this.onTransferStep(msg);
            }
        },
        async onTransferAction (msg) {
            const { action } = msg;
            this.assertValidTransferAction(action);
            if (action === 'bootstrap') {
                return this.provider?.[action](this.diagnostics);
            }
            return this.provider?.[action]();
        },
        async flush (stage, id) {
            const batchSize = 1024 * 1024;
            let batch = [];
            const stream = this.streams?.[stage];
            const batchLength = ()=>Buffer.byteLength(JSON.stringify(batch));
            const maybeConfirm = async (data)=>{
                try {
                    await this.confirm(data);
                } catch (error) {
                    // Handle the error, log it, or take other appropriate actions
                    strapi?.log.error(`[Data transfer] Message confirmation failed: ${error?.message}`);
                    this.onError(error);
                }
            };
            const sendBatch = async ()=>{
                await this.confirm({
                    type: 'transfer',
                    data: batch,
                    ended: false,
                    error: null,
                    id
                });
                batch = [];
            };
            if (!stream) {
                throw new ProviderTransferError(`No available stream found for ${stage}`);
            }
            try {
                for await (const chunk of stream){
                    if (stage !== 'assets') {
                        batch.push(chunk);
                        if (batchLength() >= batchSize) {
                            await sendBatch();
                        }
                    } else {
                        await this.confirm({
                            type: 'transfer',
                            data: [
                                chunk
                            ],
                            ended: false,
                            error: null,
                            id
                        });
                    }
                }
                if (batch.length > 0 && stage !== 'assets') {
                    await sendBatch();
                }
                await this.confirm({
                    type: 'transfer',
                    data: null,
                    ended: true,
                    error: null,
                    id
                });
            } catch (e) {
                // TODO: if this confirm fails, can we abort the whole transfer?
                await maybeConfirm({
                    type: 'transfer',
                    data: null,
                    ended: true,
                    error: e,
                    id
                });
            }
        },
        async onTransferStep (msg) {
            const { step, action } = msg;
            if (action === 'start') {
                if (this.streams?.[step] instanceof stream$1.Readable) {
                    throw new Error('Stream already created, something went wrong');
                }
                const flushUUID = crypto.randomUUID();
                await this.createReadableStreamForStep(step);
                this.flush(step, flushUUID);
                return {
                    ok: true,
                    id: flushUUID
                };
            }
            if (action === 'end') {
                const stream = this.streams?.[step];
                if (stream?.readableEnded === false) {
                    await new Promise((resolve)=>{
                        stream?.on('close', resolve).destroy();
                    });
                }
                delete this.streams?.[step];
                return {
                    ok: true
                };
            }
        },
        async createReadableStreamForStep (step) {
            const mapper = {
                entities: ()=>this.provider?.createEntitiesReadStream(),
                links: ()=>this.provider?.createLinksReadStream(),
                configuration: ()=>this.provider?.createConfigurationReadStream(),
                assets: ()=>{
                    const assets = this.provider?.createAssetsReadStream();
                    let batch = [];
                    const batchLength = ()=>{
                        return batch.reduce((acc, chunk)=>chunk.action === 'stream' ? acc + chunk.data.byteLength : acc, 0);
                    };
                    const BATCH_MAX_SIZE = 1024 * 1024; // 1MB
                    if (!assets) {
                        throw new Error('Assets read stream could not be created');
                    }
                    /**
         * Generates batches of 1MB of data from the assets stream to avoid
         * sending too many small chunks
         *
         * @param stream Assets stream from the local source provider
         */ async function* generator(stream) {
                        let hasStarted = false;
                        let assetID = '';
                        for await (const chunk of stream){
                            const { stream: assetStream, ...assetData } = chunk;
                            if (!hasStarted) {
                                assetID = crypto.randomUUID();
                                // Start the transfer of a new asset
                                batch.push({
                                    action: 'start',
                                    assetID,
                                    data: assetData
                                });
                                hasStarted = true;
                            }
                            for await (const assetChunk of assetStream){
                                // Add the asset data to the batch
                                batch.push({
                                    action: 'stream',
                                    assetID,
                                    data: assetChunk
                                });
                                // if the batch size is bigger than BATCH_MAX_SIZE stream the batch
                                if (batchLength() >= BATCH_MAX_SIZE) {
                                    yield batch;
                                    batch = [];
                                }
                            }
                            // All the asset data has been streamed and gets ready for the next one
                            hasStarted = false;
                            batch.push({
                                action: 'end',
                                assetID
                            });
                            yield batch;
                            batch = [];
                        }
                    }
                    return stream$1.Readable.from(generator(assets));
                }
            };
            if (!(step in mapper)) {
                throw new Error('Invalid transfer step, impossible to create a stream');
            }
            if (!this.streams) {
                throw new Error('Invalid transfer state');
            }
            this.streams[step] = await mapper[step]();
        },
        // Commands
        async init () {
            if (this.transferID || this.provider) {
                throw new Error('Transfer already in progress');
            }
            await this.verifyAuth();
            this.transferID = crypto.randomUUID();
            this.startedAt = Date.now();
            this.streams = {};
            this.provider = createLocalStrapiSourceProvider({
                autoDestroy: false,
                getStrapi: ()=>strapi
            });
            return {
                transferID: this.transferID
            };
        },
        async end (params) {
            await this.verifyAuth();
            if (this.transferID !== params?.transferID) {
                throw new ProviderTransferError('Bad transfer ID provided');
            }
            this.cleanup();
            return {
                ok: true
            };
        },
        async status () {
            const isStarted = this.isTransferStarted();
            if (!isStarted) {
                const startedAt = this.startedAt;
                return {
                    active: true,
                    kind: TRANSFER_KIND,
                    startedAt,
                    elapsed: Date.now() - startedAt
                };
            }
            return {
                active: false,
                kind: null,
                elapsed: null,
                startedAt: null
            };
        }
    }));

var index$4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createPullController: createPullController,
  createPushController: createPushController,
  handlerControllerFactory: handlerControllerFactory
});

var index$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  constants: constants,
  handlers: index$4
});

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  providers: index$5,
  queries: index$6,
  remote: index$3
});

/**
 * Note: in versions of the transfer engine <=4.9.0, exports were generated with windows paths
 * on Windows systems, and posix paths on posix systems.
 *
 * We now store all paths as posix, but need to leave a separator conversion for legacy purposes, and to
 * support manually-created tar files coming from Windows systems (ie, if a user creates a
 * backup file with a windows tar tool rather than using the `export` command)
 *
 * Because of this, export/import files may never contain files with a forward slash in the name, even escaped
 *
 * */ /**
 * Check if the directory of a given filePath (which can be either posix or win32) resolves to the same as the given posix-format path posixDirName
 * We must be able to assume the first argument is a path to a directory and the second is a path to a file, otherwise path.dirname will interpret a path without any slashes as the filename
 *
 * @param {string} posixDirName A posix path pointing to a directory
 * @param {string} filePath an unknown filesystem path pointing to a file
 * @returns {boolean} is the file located in the given directory
 */ const isFilePathInDirname = (posixDirName, filePath)=>{
    const normalizedDir = path.posix.dirname(unknownPathToPosix(filePath));
    return isPathEquivalent(posixDirName, normalizedDir);
};
/**
 *  Check if two paths that can be either in posix or win32 format resolves to the same file
 *
 * @param {string} pathA a path that may be either win32 or posix
 * @param {string} pathB a path that may be either win32 or posix
 *
 * @returns {boolean} do paths point to the same place
 */ const isPathEquivalent = (pathA, pathB)=>{
    // Check if paths appear to be win32 or posix, and if win32 convert to posix
    const normalizedPathA = path.posix.normalize(unknownPathToPosix(pathA));
    const normalizedPathB = path.posix.normalize(unknownPathToPosix(pathB));
    return !path.posix.relative(normalizedPathB, normalizedPathA).length;
};
/**
 *  Convert an unknown format path (win32 or posix) to a posix path
 *
 * @param {string} filePath a path that may be either win32 or posix
 *
 * @returns {string} a posix path
 */ const unknownPathToPosix = (filePath)=>{
    // if it includes a forward slash, it must be posix already -- we will not support win32 with mixed path separators
    if (filePath.includes(path.posix.sep)) {
        return filePath;
    }
    return path.normalize(filePath).split(path.win32.sep).join(path.posix.sep);
};

function _class_private_field_loose_base$1(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
}
var id$1 = 0;
function _class_private_field_loose_key$1(name) {
    return "__private_" + id$1++ + "_" + name;
}
/**
 * Constant for the metadata file path
 */ const METADATA_FILE_PATH = 'metadata.json';
const createLocalFileSourceProvider = (options)=>{
    return new LocalFileSourceProvider(options);
};
var _metadata = /*#__PURE__*/ _class_private_field_loose_key$1("_metadata"), _diagnostics$1 = /*#__PURE__*/ _class_private_field_loose_key$1("_diagnostics"), _reportInfo$1 = /*#__PURE__*/ _class_private_field_loose_key$1("_reportInfo"), _loadMetadata = /*#__PURE__*/ _class_private_field_loose_key$1("_loadMetadata"), _loadAssetMetadata = /*#__PURE__*/ _class_private_field_loose_key$1("_loadAssetMetadata"), _getBackupStream = /*#__PURE__*/ _class_private_field_loose_key$1("_getBackupStream"), // `directory` must be posix formatted path
_streamJsonlDirectory = /*#__PURE__*/ _class_private_field_loose_key$1("_streamJsonlDirectory"), _parseJSONFile = /*#__PURE__*/ _class_private_field_loose_key$1("_parseJSONFile");
class LocalFileSourceProvider {
    /**
   * Pre flight checks regarding the provided options, making sure that the file can be opened (decrypted, decompressed), etc.
   */ async bootstrap(diagnostics) {
        _class_private_field_loose_base$1(this, _diagnostics$1)[_diagnostics$1] = diagnostics;
        const { path: filePath } = this.options.file;
        try {
            // Read the metadata to ensure the file can be parsed
            await _class_private_field_loose_base$1(this, _loadMetadata)[_loadMetadata]();
        // TODO: we might also need to read the schema.jsonl files & implements a custom stream-check
        } catch (e) {
            if (this.options?.encryption?.enabled) {
                throw new ProviderInitializationError(`Key is incorrect or the file '${filePath}' is not a valid Strapi data file.`);
            }
            throw new ProviderInitializationError(`File '${filePath}' is not a valid Strapi data file.`);
        }
        if (!_class_private_field_loose_base$1(this, _metadata)[_metadata]) {
            throw new ProviderInitializationError('Could not load metadata from Strapi data file.');
        }
    }
    async getMetadata() {
        _class_private_field_loose_base$1(this, _reportInfo$1)[_reportInfo$1]('getting metadata');
        if (!_class_private_field_loose_base$1(this, _metadata)[_metadata]) {
            await _class_private_field_loose_base$1(this, _loadMetadata)[_loadMetadata]();
        }
        return _class_private_field_loose_base$1(this, _metadata)[_metadata] ?? null;
    }
    async getSchemas() {
        _class_private_field_loose_base$1(this, _reportInfo$1)[_reportInfo$1]('getting schemas');
        const schemaCollection = await collect(this.createSchemasReadStream());
        if (fp.isEmpty(schemaCollection)) {
            throw new ProviderInitializationError('Could not load schemas from Strapi data file.');
        }
        // Group schema by UID
        const schemas = fp.keyBy('uid', schemaCollection);
        // Transform to valid JSON
        return schemasToValidJSON(schemas);
    }
    createEntitiesReadStream() {
        _class_private_field_loose_base$1(this, _reportInfo$1)[_reportInfo$1]('creating entities read stream');
        return _class_private_field_loose_base$1(this, _streamJsonlDirectory)[_streamJsonlDirectory]('entities');
    }
    createSchemasReadStream() {
        _class_private_field_loose_base$1(this, _reportInfo$1)[_reportInfo$1]('creating schemas read stream');
        return _class_private_field_loose_base$1(this, _streamJsonlDirectory)[_streamJsonlDirectory]('schemas');
    }
    createLinksReadStream() {
        _class_private_field_loose_base$1(this, _reportInfo$1)[_reportInfo$1]('creating links read stream');
        return _class_private_field_loose_base$1(this, _streamJsonlDirectory)[_streamJsonlDirectory]('links');
    }
    createConfigurationReadStream() {
        _class_private_field_loose_base$1(this, _reportInfo$1)[_reportInfo$1]('creating configuration read stream');
        // NOTE: TBD
        return _class_private_field_loose_base$1(this, _streamJsonlDirectory)[_streamJsonlDirectory]('configuration');
    }
    createAssetsReadStream() {
        const inStream = _class_private_field_loose_base$1(this, _getBackupStream)[_getBackupStream]();
        const outStream = new stream$1.PassThrough({
            objectMode: true
        });
        const loadAssetMetadata = _class_private_field_loose_base$1(this, _loadAssetMetadata)[_loadAssetMetadata].bind(this);
        _class_private_field_loose_base$1(this, _reportInfo$1)[_reportInfo$1]('creating assets read stream');
        stream$1.pipeline([
            inStream,
            new tar.Parse({
                // find only files in the assets/uploads folder
                filter (filePath, entry) {
                    if (entry.type !== 'File') {
                        return false;
                    }
                    return isFilePathInDirname('assets/uploads', filePath);
                },
                async onentry (entry) {
                    const { path: filePath, size = 0 } = entry;
                    const normalizedPath = unknownPathToPosix(filePath);
                    const file = path.basename(normalizedPath);
                    let metadata;
                    try {
                        metadata = await loadAssetMetadata(`assets/metadata/${file}.json`);
                    } catch (error) {
                        throw new Error(`Failed to read metadata for ${file}`);
                    }
                    const asset = {
                        metadata,
                        filename: file,
                        filepath: normalizedPath,
                        stats: {
                            size
                        },
                        stream: entry
                    };
                    outStream.write(asset);
                }
            })
        ], ()=>outStream.end());
        return outStream;
    }
    constructor(options){
        Object.defineProperty(this, _reportInfo$1, {
            value: reportInfo$1
        });
        Object.defineProperty(this, _loadMetadata, {
            value: loadMetadata
        });
        Object.defineProperty(this, _loadAssetMetadata, {
            value: loadAssetMetadata
        });
        Object.defineProperty(this, _getBackupStream, {
            value: getBackupStream
        });
        Object.defineProperty(this, _streamJsonlDirectory, {
            value: streamJsonlDirectory
        });
        // For collecting an entire JSON file then parsing it, not for streaming JSONL
        Object.defineProperty(this, _parseJSONFile, {
            value: parseJSONFile
        });
        Object.defineProperty(this, _metadata, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _diagnostics$1, {
            writable: true,
            value: void 0
        });
        this.type = 'source';
        this.name = 'source::local-file';
        this.options = options;
        const { encryption } = this.options;
        if (encryption.enabled && encryption.key === undefined) {
            throw new Error('Missing encryption key');
        }
    }
}
function reportInfo$1(message) {
    _class_private_field_loose_base$1(this, _diagnostics$1)[_diagnostics$1]?.report({
        details: {
            createdAt: new Date(),
            message,
            origin: 'file-source-provider'
        },
        kind: 'info'
    });
}
async function loadMetadata() {
    const backupStream = _class_private_field_loose_base$1(this, _getBackupStream)[_getBackupStream]();
    _class_private_field_loose_base$1(this, _metadata)[_metadata] = await _class_private_field_loose_base$1(this, _parseJSONFile)[_parseJSONFile](backupStream, METADATA_FILE_PATH);
}
async function loadAssetMetadata(path) {
    const backupStream = _class_private_field_loose_base$1(this, _getBackupStream)[_getBackupStream]();
    return _class_private_field_loose_base$1(this, _parseJSONFile)[_parseJSONFile](backupStream, path);
}
function getBackupStream() {
    const { file, encryption, compression } = this.options;
    const streams = [];
    try {
        streams.push(fse.createReadStream(file.path));
    } catch (e) {
        throw new Error(`Could not read backup file path provided at "${this.options.file.path}"`);
    }
    if (encryption.enabled && encryption.key) {
        streams.push(createDecryptionCipher(encryption.key));
    }
    if (compression.enabled) {
        streams.push(zip.createGunzip());
    }
    return streamChain.chain(streams);
}
function streamJsonlDirectory(directory) {
    const inStream = _class_private_field_loose_base$1(this, _getBackupStream)[_getBackupStream]();
    const outStream = new stream$1.PassThrough({
        objectMode: true
    });
    stream$1.pipeline([
        inStream,
        new tar.Parse({
            filter (filePath, entry) {
                if (entry.type !== 'File') {
                    return false;
                }
                return isFilePathInDirname(directory, filePath);
            },
            async onentry (entry) {
                const transforms = [
                    // JSONL parser to read the data chunks one by one (line by line)
                    Parser.parser({
                        checkErrors: true
                    }),
                    // The JSONL parser returns each line as key/value
                    (line)=>line.value
                ];
                const stream = entry.pipe(streamChain.chain(transforms));
                try {
                    for await (const chunk of stream){
                        outStream.write(chunk);
                    }
                } catch (e) {
                    outStream.destroy(new ProviderTransferError(`Error parsing backup files from backup file ${entry.path}: ${e.message}`, {
                        details: {
                            error: e
                        }
                    }));
                }
            }
        })
    ], async ()=>{
        // Manually send the 'end' event to the out stream
        // once every entry has finished streaming its content
        outStream.end();
    });
    return outStream;
}
async function parseJSONFile(fileStream, filePath) {
    return new Promise((resolve, reject)=>{
        stream$1.pipeline([
            fileStream,
            // Custom backup archive parsing
            new tar.Parse({
                /**
             * Filter the parsed entries to only keep the one that matches the given filepath
             */ filter (entryPath, entry) {
                    if (entry.type !== 'File') {
                        return false;
                    }
                    return isPathEquivalent(entryPath, filePath);
                },
                async onentry (entry) {
                    // Collect all the content of the entry file
                    const content = await entry.collect();
                    try {
                        // Parse from buffer array to string to JSON
                        const parsedContent = JSON.parse(Buffer.concat(content).toString());
                        // Resolve the Promise with the parsed content
                        resolve(parsedContent);
                    } catch (e) {
                        reject(e);
                    } finally{
                        // Cleanup (close the stream associated to the entry)
                        entry.destroy();
                    }
                }
            })
        ], ()=>{
            // If the promise hasn't been resolved and we've parsed all
            // the archive entries, then the file doesn't exist
            reject(new Error(`File "${filePath}" not found`));
        });
    });
}

/**
 * Create a file path factory for a given path & prefix.
 * Upon being called, the factory will return a file path for a given index
 */ const createFilePathFactory = (type)=>(fileIndex = 0)=>{
        // always write tar files with posix paths so we have a standard format for paths regardless of system
        return path.posix.join(// "{type}" directory
        type, // "${type}_XXXXX.jsonl" file
        `${type}_${String(fileIndex).padStart(5, '0')}.jsonl`);
    };
const createTarEntryStream = (archive, pathFactory, maxSize = 2.56e8)=>{
    let fileIndex = 0;
    let buffer = '';
    const flush = async ()=>{
        if (!buffer) {
            return;
        }
        fileIndex += 1;
        const name = pathFactory(fileIndex);
        const size = buffer.length;
        await new Promise((resolve, reject)=>{
            archive.entry({
                name,
                size
            }, buffer, (err)=>{
                if (err) {
                    reject(err);
                }
                resolve();
            });
        });
        buffer = '';
    };
    const push = (chunk)=>{
        buffer += chunk;
    };
    return new stream$1.Writable({
        async destroy (err, callback) {
            await flush();
            callback(err);
        },
        async write (chunk, _encoding, callback) {
            const size = chunk.length;
            if (chunk.length > maxSize) {
                callback(new Error(`payload too large: ${chunk.length}>${maxSize}`));
                return;
            }
            if (buffer.length + size > maxSize) {
                await flush();
            }
            push(chunk);
            callback(null);
        }
    });
};

function _class_private_field_loose_base(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
}
var id = 0;
function _class_private_field_loose_key(name) {
    return "__private_" + id++ + "_" + name;
}
const createLocalFileDestinationProvider = (options)=>{
    return new LocalFileDestinationProvider(options);
};
var _providersMetadata = /*#__PURE__*/ _class_private_field_loose_key("_providersMetadata"), _archive = /*#__PURE__*/ _class_private_field_loose_key("_archive"), _diagnostics = /*#__PURE__*/ _class_private_field_loose_key("_diagnostics"), _reportInfo = /*#__PURE__*/ _class_private_field_loose_key("_reportInfo"), _archivePath = /*#__PURE__*/ _class_private_field_loose_key("_archivePath"), _writeMetadata = /*#__PURE__*/ _class_private_field_loose_key("_writeMetadata"), _getMetadataStream = /*#__PURE__*/ _class_private_field_loose_key("_getMetadataStream");
class LocalFileDestinationProvider {
    setMetadata(target, metadata) {
        _class_private_field_loose_base(this, _providersMetadata)[_providersMetadata][target] = metadata;
        return this;
    }
    createGzip() {
        _class_private_field_loose_base(this, _reportInfo)[_reportInfo]('creating gzip');
        return zip.createGzip();
    }
    bootstrap(diagnostics) {
        _class_private_field_loose_base(this, _diagnostics)[_diagnostics] = diagnostics;
        const { compression, encryption } = this.options;
        if (encryption.enabled && !encryption.key) {
            throw new Error("Can't encrypt without a key");
        }
        _class_private_field_loose_base(this, _archive)[_archive].stream = tar$1.pack();
        const outStream = fse.createWriteStream(_class_private_field_loose_base(this, _archivePath)[_archivePath]);
        outStream.on('error', (err)=>{
            if (err.code === 'ENOSPC') {
                throw new ProviderTransferError("Your server doesn't have space to proceed with the import.");
            }
            throw err;
        });
        const archiveTransforms = [];
        if (compression.enabled) {
            archiveTransforms.push(this.createGzip());
        }
        if (encryption.enabled && encryption.key) {
            archiveTransforms.push(createEncryptionCipher(encryption.key));
        }
        _class_private_field_loose_base(this, _archive)[_archive].pipeline = streamChain.chain([
            _class_private_field_loose_base(this, _archive)[_archive].stream,
            ...archiveTransforms,
            outStream
        ]);
        this.results.file = {
            path: _class_private_field_loose_base(this, _archivePath)[_archivePath]
        };
    }
    async close() {
        const { stream, pipeline } = _class_private_field_loose_base(this, _archive)[_archive];
        if (!stream) {
            return;
        }
        await _class_private_field_loose_base(this, _writeMetadata)[_writeMetadata]();
        stream.finalize();
        if (pipeline && !pipeline.closed) {
            await new Promise((resolve, reject)=>{
                pipeline.on('close', resolve).on('error', reject);
            });
        }
    }
    async rollback() {
        _class_private_field_loose_base(this, _reportInfo)[_reportInfo]('rolling back');
        await this.close();
        await fse.rm(_class_private_field_loose_base(this, _archivePath)[_archivePath], {
            force: true
        });
    }
    getMetadata() {
        return null;
    }
    createSchemasWriteStream() {
        if (!_class_private_field_loose_base(this, _archive)[_archive].stream) {
            throw new Error('Archive stream is unavailable');
        }
        _class_private_field_loose_base(this, _reportInfo)[_reportInfo]('creating schemas write stream');
        const filePathFactory = createFilePathFactory('schemas');
        const entryStream = createTarEntryStream(_class_private_field_loose_base(this, _archive)[_archive].stream, filePathFactory, this.options.file.maxSizeJsonl);
        return streamChain.chain([
            Stringer.stringer(),
            entryStream
        ]);
    }
    createEntitiesWriteStream() {
        if (!_class_private_field_loose_base(this, _archive)[_archive].stream) {
            throw new Error('Archive stream is unavailable');
        }
        _class_private_field_loose_base(this, _reportInfo)[_reportInfo]('creating entities write stream');
        const filePathFactory = createFilePathFactory('entities');
        const entryStream = createTarEntryStream(_class_private_field_loose_base(this, _archive)[_archive].stream, filePathFactory, this.options.file.maxSizeJsonl);
        return streamChain.chain([
            Stringer.stringer(),
            entryStream
        ]);
    }
    createLinksWriteStream() {
        if (!_class_private_field_loose_base(this, _archive)[_archive].stream) {
            throw new Error('Archive stream is unavailable');
        }
        _class_private_field_loose_base(this, _reportInfo)[_reportInfo]('creating links write stream');
        const filePathFactory = createFilePathFactory('links');
        const entryStream = createTarEntryStream(_class_private_field_loose_base(this, _archive)[_archive].stream, filePathFactory, this.options.file.maxSizeJsonl);
        return streamChain.chain([
            Stringer.stringer(),
            entryStream
        ]);
    }
    createConfigurationWriteStream() {
        if (!_class_private_field_loose_base(this, _archive)[_archive].stream) {
            throw new Error('Archive stream is unavailable');
        }
        _class_private_field_loose_base(this, _reportInfo)[_reportInfo]('creating configuration write stream');
        const filePathFactory = createFilePathFactory('configuration');
        const entryStream = createTarEntryStream(_class_private_field_loose_base(this, _archive)[_archive].stream, filePathFactory, this.options.file.maxSizeJsonl);
        return streamChain.chain([
            Stringer.stringer(),
            entryStream
        ]);
    }
    createAssetsWriteStream() {
        const { stream: archiveStream } = _class_private_field_loose_base(this, _archive)[_archive];
        if (!archiveStream) {
            throw new Error('Archive stream is unavailable');
        }
        _class_private_field_loose_base(this, _reportInfo)[_reportInfo]('creating assets write stream');
        return new stream$1.Writable({
            objectMode: true,
            write (data, _encoding, callback) {
                // always write tar files with posix paths so we have a standard format for paths regardless of system
                const entryPath = path.posix.join('assets', 'uploads', data.filename);
                const entryMetadataPath = path.posix.join('assets', 'metadata', `${data.filename}.json`);
                const stringifiedMetadata = JSON.stringify(data.metadata);
                archiveStream.entry({
                    name: entryMetadataPath,
                    size: stringifiedMetadata.length
                }, stringifiedMetadata);
                const entry = archiveStream.entry({
                    name: entryPath,
                    size: data.stats.size
                });
                if (!entry) {
                    callback(new Error(`Failed to created an asset tar entry for ${entryPath}`));
                    return;
                }
                data.stream.pipe(entry);
                entry.on('finish', ()=>{
                    callback(null);
                }).on('error', (error)=>{
                    callback(error);
                });
            }
        });
    }
    constructor(options){
        Object.defineProperty(this, _reportInfo, {
            value: reportInfo
        });
        Object.defineProperty(this, _archivePath, {
            get: get_archivePath,
            set: void 0
        });
        Object.defineProperty(this, _writeMetadata, {
            value: writeMetadata
        });
        Object.defineProperty(this, _getMetadataStream, {
            value: getMetadataStream
        });
        Object.defineProperty(this, _providersMetadata, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _archive, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _diagnostics, {
            writable: true,
            value: void 0
        });
        this.name = 'destination::local-file';
        this.type = 'destination';
        this.results = {};
        _class_private_field_loose_base(this, _providersMetadata)[_providersMetadata] = {};
        _class_private_field_loose_base(this, _archive)[_archive] = {};
        this.options = options;
    }
}
function reportInfo(message) {
    _class_private_field_loose_base(this, _diagnostics)[_diagnostics]?.report({
        details: {
            createdAt: new Date(),
            message,
            origin: 'file-destination-provider'
        },
        kind: 'info'
    });
}
function get_archivePath() {
    const { encryption, compression, file } = this.options;
    let filePath = `${file.path}.tar`;
    if (compression.enabled) {
        filePath += '.gz';
    }
    if (encryption.enabled) {
        filePath += '.enc';
    }
    return filePath;
}
async function writeMetadata() {
    _class_private_field_loose_base(this, _reportInfo)[_reportInfo]('writing metadata');
    const metadata = _class_private_field_loose_base(this, _providersMetadata)[_providersMetadata].source;
    if (metadata) {
        await new Promise((resolve)=>{
            const outStream = _class_private_field_loose_base(this, _getMetadataStream)[_getMetadataStream]();
            const data = JSON.stringify(metadata, null, 2);
            stream$1.Readable.from(data).pipe(outStream).on('close', resolve);
        });
    }
}
function getMetadataStream() {
    const { stream } = _class_private_field_loose_base(this, _archive)[_archive];
    if (!stream) {
        throw new Error('Archive stream is unavailable');
    }
    return createTarEntryStream(stream, ()=>'metadata.json');
}

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createLocalFileDestinationProvider: createLocalFileDestinationProvider,
  createLocalFileSourceProvider: createLocalFileSourceProvider
});

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  providers: index$1
});

exports.engine = index$7;
exports.file = index;
exports.strapi = index$2;
exports.utils = index$8;
//# sourceMappingURL=index.js.map
