'use strict';

var utils = require('@strapi/utils');
var isEqual = require('lodash/isEqual');
var lodash = require('lodash');
var _ = require('lodash/fp');
var nodeSchedule = require('node-schedule');
var yup = require('yup');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var yup__namespace = /*#__PURE__*/_interopNamespaceDefault(yup);

const RELEASE_MODEL_UID = 'plugin::content-releases.release';
const RELEASE_ACTION_MODEL_UID = 'plugin::content-releases.release-action';
const ACTIONS = [
    {
        section: 'plugins',
        displayName: 'Read',
        uid: 'read',
        pluginName: 'content-releases'
    },
    {
        section: 'plugins',
        displayName: 'Create',
        uid: 'create',
        pluginName: 'content-releases'
    },
    {
        section: 'plugins',
        displayName: 'Edit',
        uid: 'update',
        pluginName: 'content-releases'
    },
    {
        section: 'plugins',
        displayName: 'Delete',
        uid: 'delete',
        pluginName: 'content-releases'
    },
    {
        section: 'plugins',
        displayName: 'Publish',
        uid: 'publish',
        pluginName: 'content-releases'
    },
    {
        section: 'plugins',
        displayName: 'Remove an entry from a release',
        uid: 'delete-action',
        pluginName: 'content-releases'
    },
    {
        section: 'plugins',
        displayName: 'Add an entry to a release',
        uid: 'create-action',
        pluginName: 'content-releases'
    },
    // Settings
    {
        uid: 'settings.read',
        section: 'settings',
        displayName: 'Read',
        category: 'content releases',
        subCategory: 'options',
        pluginName: 'content-releases'
    },
    {
        uid: 'settings.update',
        section: 'settings',
        displayName: 'Edit',
        category: 'content releases',
        subCategory: 'options',
        pluginName: 'content-releases'
    }
];
const ALLOWED_WEBHOOK_EVENTS = {
    RELEASES_PUBLISH: 'releases.publish'
};

const getService = (name, { strapi: strapi1 })=>{
    return strapi1.plugin('content-releases').service(name);
};
const getDraftEntryValidStatus = async ({ contentType, documentId, locale }, { strapi: strapi1 })=>{
    const populateBuilderService = strapi1.plugin('content-manager').service('populate-builder');
    // @ts-expect-error - populateBuilderService should be a function but is returning service
    const populate = await populateBuilderService(contentType).populateDeep(Infinity).build();
    const entry = await getEntry({
        contentType,
        documentId,
        locale,
        populate
    }, {
        strapi: strapi1
    });
    return isEntryValid(contentType, entry, {
        strapi: strapi1
    });
};
const isEntryValid = async (contentTypeUid, entry, { strapi: strapi1 })=>{
    try {
        // @TODO: When documents service has validateEntityCreation method, use it instead
        await strapi1.entityValidator.validateEntityCreation(strapi1.getModel(contentTypeUid), entry, undefined, // @ts-expect-error - FIXME: entity here is unnecessary
        entry);
        const workflowsService = strapi1.plugin('review-workflows').service('workflows');
        const workflow = await workflowsService.getAssignedWorkflow(contentTypeUid, {
            populate: 'stageRequiredToPublish'
        });
        if (workflow?.stageRequiredToPublish) {
            return entry.strapi_stage.id === workflow.stageRequiredToPublish.id;
        }
        return true;
    } catch  {
        return false;
    }
};
const getEntry = async ({ contentType, documentId, locale, populate, status = 'draft' }, { strapi: strapi1 })=>{
    if (documentId) {
        // Try to get an existing draft or published document
        const entry = await strapi1.documents(contentType).findOne({
            documentId,
            locale,
            populate,
            status
        });
        // The document isn't published yet, but the action is to publish it, fetch the draft
        if (status === 'published' && !entry) {
            return strapi1.documents(contentType).findOne({
                documentId,
                locale,
                populate,
                status: 'draft'
            });
        }
        return entry;
    }
    return strapi1.documents(contentType).findFirst({
        locale,
        populate,
        status
    });
};
const getEntryStatus = async (contentType, entry)=>{
    if (entry.publishedAt) {
        return 'published';
    }
    const publishedEntry = await strapi.documents(contentType).findOne({
        documentId: entry.documentId,
        locale: entry.locale,
        status: 'published',
        fields: [
            'updatedAt'
        ]
    });
    if (!publishedEntry) {
        return 'draft';
    }
    const entryUpdatedAt = new Date(entry.updatedAt).getTime();
    const publishedEntryUpdatedAt = new Date(publishedEntry.updatedAt).getTime();
    if (entryUpdatedAt > publishedEntryUpdatedAt) {
        return 'modified';
    }
    return 'published';
};

async function deleteActionsOnDisableDraftAndPublish({ oldContentTypes, contentTypes }) {
    if (!oldContentTypes) {
        return;
    }
    for(const uid in contentTypes){
        if (!oldContentTypes[uid]) {
            continue;
        }
        const oldContentType = oldContentTypes[uid];
        const contentType = contentTypes[uid];
        if (utils.contentTypes.hasDraftAndPublish(oldContentType) && !utils.contentTypes.hasDraftAndPublish(contentType)) {
            await strapi.db?.queryBuilder(RELEASE_ACTION_MODEL_UID).delete().where({
                contentType: uid
            }).execute();
        }
    }
}
async function deleteActionsOnDeleteContentType({ oldContentTypes, contentTypes }) {
    const deletedContentTypes = lodash.difference(lodash.keys(oldContentTypes), lodash.keys(contentTypes)) ?? [];
    if (deletedContentTypes.length) {
        await utils.async.map(deletedContentTypes, async (deletedContentTypeUID)=>{
            return strapi.db?.queryBuilder(RELEASE_ACTION_MODEL_UID).delete().where({
                contentType: deletedContentTypeUID
            }).execute();
        });
    }
}
async function migrateIsValidAndStatusReleases() {
    const releasesWithoutStatus = await strapi.db.query(RELEASE_MODEL_UID).findMany({
        where: {
            status: null,
            releasedAt: null
        },
        populate: {
            actions: {
                populate: {
                    entry: true
                }
            }
        }
    });
    utils.async.map(releasesWithoutStatus, async (release)=>{
        const actions = release.actions;
        const notValidatedActions = actions.filter((action)=>action.isEntryValid === null);
        for (const action of notValidatedActions){
            // We need to check the Action is related to a valid entry because we can't assume this is gonna be always the case
            // example: users could make changes directly to their database, or data could be lost
            if (action.entry) {
                const isEntryValid = getDraftEntryValidStatus({
                    contentType: action.contentType,
                    documentId: action.entryDocumentId,
                    locale: action.locale
                }, {
                    strapi
                });
                await strapi.db.query(RELEASE_ACTION_MODEL_UID).update({
                    where: {
                        id: action.id
                    },
                    data: {
                        isEntryValid
                    }
                });
            }
        }
        return getService('release', {
            strapi
        }).updateReleaseStatus(release.id);
    });
    const publishedReleases = await strapi.db.query(RELEASE_MODEL_UID).findMany({
        where: {
            status: null,
            releasedAt: {
                $notNull: true
            }
        }
    });
    utils.async.map(publishedReleases, async (release)=>{
        return strapi.db.query(RELEASE_MODEL_UID).update({
            where: {
                id: release.id
            },
            data: {
                status: 'done'
            }
        });
    });
}
async function revalidateChangedContentTypes({ oldContentTypes, contentTypes }) {
    if (oldContentTypes !== undefined && contentTypes !== undefined) {
        const contentTypesWithDraftAndPublish = Object.keys(oldContentTypes).filter((uid)=>oldContentTypes[uid]?.options?.draftAndPublish);
        const releasesAffected = new Set();
        utils.async.map(contentTypesWithDraftAndPublish, async (contentTypeUID)=>{
            const oldContentType = oldContentTypes[contentTypeUID];
            const contentType = contentTypes[contentTypeUID];
            // If attributes have changed, we need to revalidate actions because maybe validations rules are different
            if (!isEqual(oldContentType?.attributes, contentType?.attributes)) {
                const actions = await strapi.db.query(RELEASE_ACTION_MODEL_UID).findMany({
                    where: {
                        contentType: contentTypeUID
                    },
                    populate: {
                        entry: true,
                        release: true
                    }
                });
                await utils.async.map(actions, async (action)=>{
                    if (action.entry && action.release && action.type === 'publish') {
                        const isEntryValid = await getDraftEntryValidStatus({
                            contentType: contentTypeUID,
                            documentId: action.entryDocumentId,
                            locale: action.locale
                        }, {
                            strapi
                        });
                        releasesAffected.add(action.release.id);
                        await strapi.db.query(RELEASE_ACTION_MODEL_UID).update({
                            where: {
                                id: action.id
                            },
                            data: {
                                isEntryValid
                            }
                        });
                    }
                });
            }
        }).then(()=>{
            // We need to update the status of the releases affected
            utils.async.map(releasesAffected, async (releaseId)=>{
                return getService('release', {
                    strapi
                }).updateReleaseStatus(releaseId);
            });
        });
    }
}
async function disableContentTypeLocalized({ oldContentTypes, contentTypes }) {
    if (!oldContentTypes) {
        return;
    }
    const i18nPlugin = strapi.plugin('i18n');
    if (!i18nPlugin) {
        return;
    }
    for(const uid in contentTypes){
        if (!oldContentTypes[uid]) {
            continue;
        }
        const oldContentType = oldContentTypes[uid];
        const contentType = contentTypes[uid];
        const { isLocalizedContentType } = i18nPlugin.service('content-types');
        // if i18N is disabled remove non default locales before sync
        if (isLocalizedContentType(oldContentType) && !isLocalizedContentType(contentType)) {
            await strapi.db.queryBuilder(RELEASE_ACTION_MODEL_UID).update({
                locale: null
            }).where({
                contentType: uid
            }).execute();
        }
    }
}
async function enableContentTypeLocalized({ oldContentTypes, contentTypes }) {
    if (!oldContentTypes) {
        return;
    }
    const i18nPlugin = strapi.plugin('i18n');
    if (!i18nPlugin) {
        return;
    }
    for(const uid in contentTypes){
        if (!oldContentTypes[uid]) {
            continue;
        }
        const oldContentType = oldContentTypes[uid];
        const contentType = contentTypes[uid];
        const { isLocalizedContentType } = i18nPlugin.service('content-types');
        const { getDefaultLocale } = i18nPlugin.service('locales');
        // if i18N is enabled remove non default locales before sync
        if (!isLocalizedContentType(oldContentType) && isLocalizedContentType(contentType)) {
            const defaultLocale = await getDefaultLocale();
            await strapi.db.queryBuilder(RELEASE_ACTION_MODEL_UID).update({
                locale: defaultLocale
            }).where({
                contentType: uid
            }).execute();
        }
    }
}

/**
 * On v4, release actions are linked with entries using the built in Polymorphic relations.
 *
 * On v5, we are going to save entryDocumentId on the release action and make the link manually.
 * This because entryId is not a reliable way to link documents, as it can change.
 */ const addEntryDocumentToReleaseActions = {
    name: 'content-releases::5.0.0-add-entry-document-id-to-release-actions',
    async up (trx, db) {
        // Check if the table exists
        const hasTable = await trx.schema.hasTable('strapi_release_actions');
        if (!hasTable) {
            return;
        }
        const hasPolymorphicColumn = await trx.schema.hasColumn('strapi_release_actions', 'target_id');
        // If user has PolymorphicColumn means that is coming from v4
        if (hasPolymorphicColumn) {
            // First time coming from v4 user doesn't have entryDocumentId
            // but we double check to avoid errors
            const hasEntryDocumentIdColumn = await trx.schema.hasColumn('strapi_release_actions', 'entry_document_id');
            if (!hasEntryDocumentIdColumn) {
                await trx.schema.alterTable('strapi_release_actions', (table)=>{
                    table.string('entry_document_id');
                });
            }
            const releaseActions = await trx.select('*').from('strapi_release_actions');
            utils.async.map(releaseActions, async (action)=>{
                const { target_type, target_id } = action;
                const entry = await db.query(target_type).findOne({
                    where: {
                        id: target_id
                    }
                });
                if (entry) {
                    await trx('strapi_release_actions').update({
                        entry_document_id: entry.documentId
                    }).where('id', action.id);
                }
            });
        }
    },
    async down () {
        throw new Error('not implemented');
    }
};

const register = async ({ strapi })=>{
    if (strapi.ee.features.isEnabled('cms-content-releases')) {
        await strapi.service('admin::permission').actionProvider.registerMany(ACTIONS);
        strapi.db.migrations.providers.internal.register(addEntryDocumentToReleaseActions);
        strapi.hook('strapi::content-types.beforeSync').register(disableContentTypeLocalized).register(deleteActionsOnDisableDraftAndPublish);
        strapi.hook('strapi::content-types.afterSync').register(deleteActionsOnDeleteContentType).register(enableContentTypeLocalized).register(revalidateChangedContentTypes).register(migrateIsValidAndStatusReleases);
    }
    if (strapi.plugin('graphql')) {
        const graphqlExtensionService = strapi.plugin('graphql').service('extension');
        // Exclude the release and release action models from the GraphQL schema
        graphqlExtensionService.shadowCRUD(RELEASE_MODEL_UID).disable();
        graphqlExtensionService.shadowCRUD(RELEASE_ACTION_MODEL_UID).disable();
    }
};

const updateActionsStatusAndUpdateReleaseStatus = async (contentType, entry)=>{
    const releases = await strapi.db.query(RELEASE_MODEL_UID).findMany({
        where: {
            releasedAt: null,
            actions: {
                contentType,
                entryDocumentId: entry.documentId,
                locale: entry.locale
            }
        }
    });
    const entryStatus = await isEntryValid(contentType, entry, {
        strapi
    });
    await strapi.db.query(RELEASE_ACTION_MODEL_UID).updateMany({
        where: {
            contentType,
            entryDocumentId: entry.documentId,
            locale: entry.locale
        },
        data: {
            isEntryValid: entryStatus
        }
    });
    for (const release of releases){
        getService('release', {
            strapi
        }).updateReleaseStatus(release.id);
    }
};
const deleteActionsAndUpdateReleaseStatus = async (params)=>{
    const releases = await strapi.db.query(RELEASE_MODEL_UID).findMany({
        where: {
            actions: params
        }
    });
    await strapi.db.query(RELEASE_ACTION_MODEL_UID).deleteMany({
        where: params
    });
    for (const release of releases){
        getService('release', {
            strapi
        }).updateReleaseStatus(release.id);
    }
};
const deleteActionsOnDelete = async (ctx, next)=>{
    if (ctx.action !== 'delete') {
        return next();
    }
    if (!utils.contentTypes.hasDraftAndPublish(ctx.contentType)) {
        return next();
    }
    const contentType = ctx.contentType.uid;
    const { documentId, locale } = ctx.params;
    const result = await next();
    if (!result) {
        return result;
    }
    try {
        deleteActionsAndUpdateReleaseStatus({
            contentType,
            entryDocumentId: documentId,
            ...locale !== '*' && {
                locale
            }
        });
    } catch (error) {
        strapi.log.error('Error while deleting release actions after delete', {
            error
        });
    }
    return result;
};
const updateActionsOnUpdate = async (ctx, next)=>{
    if (ctx.action !== 'update') {
        return next();
    }
    if (!utils.contentTypes.hasDraftAndPublish(ctx.contentType)) {
        return next();
    }
    const contentType = ctx.contentType.uid;
    const result = await next();
    if (!result) {
        return result;
    }
    try {
        updateActionsStatusAndUpdateReleaseStatus(contentType, result);
    } catch (error) {
        strapi.log.error('Error while updating release actions after update', {
            error
        });
    }
    return result;
};

const deleteReleasesActionsAndUpdateReleaseStatus = async (params)=>{
    const releases = await strapi.db.query(RELEASE_MODEL_UID).findMany({
        where: {
            actions: params
        }
    });
    await strapi.db.query(RELEASE_ACTION_MODEL_UID).deleteMany({
        where: params
    });
    // We update the status of each release after delete the actions
    for (const release of releases){
        getService('release', {
            strapi
        }).updateReleaseStatus(release.id);
    }
};
const bootstrap = async ({ strapi: strapi1 })=>{
    if (strapi1.ee.features.isEnabled('cms-content-releases')) {
        const contentTypesWithDraftAndPublish = Object.keys(strapi1.contentTypes).filter((uid)=>strapi1.contentTypes[uid]?.options?.draftAndPublish);
        strapi1.db.lifecycles.subscribe({
            models: contentTypesWithDraftAndPublish,
            /**
       * deleteMany is still used outside documents service, for example when deleting a locale
       */ async afterDeleteMany (event) {
                try {
                    const model = strapi1.getModel(event.model.uid);
                    // @ts-expect-error TODO: lifecycles types looks like are not 100% finished
                    if (model.kind === 'collectionType' && model.options?.draftAndPublish) {
                        const { where } = event.params;
                        deleteReleasesActionsAndUpdateReleaseStatus({
                            contentType: model.uid,
                            locale: where?.locale ?? null,
                            ...where?.documentId && {
                                entryDocumentId: where.documentId
                            }
                        });
                    }
                } catch (error) {
                    // If an error happens we don't want to block the delete entry flow, but we log the error
                    strapi1.log.error('Error while deleting release actions after entry deleteMany', {
                        error
                    });
                }
            }
        });
        // We register middleware to handle ReleaseActions when changes on documents are made
        strapi1.documents.use(deleteActionsOnDelete);
        strapi1.documents.use(updateActionsOnUpdate);
        getService('scheduling', {
            strapi: strapi1
        }).syncFromDatabase().catch((err)=>{
            strapi1.log.error('Error while syncing scheduled jobs from the database in the content-releases plugin. This could lead to errors in the releases scheduling.');
            throw err;
        });
        Object.entries(ALLOWED_WEBHOOK_EVENTS).forEach(([key, value])=>{
            strapi1.get('webhookStore').addAllowedEvent(key, value);
        });
    }
};

const destroy = async ({ strapi })=>{
    const scheduledJobs = getService('scheduling', {
        strapi
    }).getAll();
    for (const [, job] of scheduledJobs){
        job.cancel();
    }
};

var schema$1 = {
    collectionName: 'strapi_releases',
    info: {
        singularName: 'release',
        pluralName: 'releases',
        displayName: 'Release'
    },
    options: {
        draftAndPublish: false
    },
    pluginOptions: {
        'content-manager': {
            visible: false
        },
        'content-type-builder': {
            visible: false
        }
    },
    attributes: {
        name: {
            type: 'string',
            required: true
        },
        releasedAt: {
            type: 'datetime'
        },
        scheduledAt: {
            type: 'datetime'
        },
        timezone: {
            type: 'string'
        },
        status: {
            type: 'enumeration',
            enum: [
                'ready',
                'blocked',
                'failed',
                'done',
                'empty'
            ],
            required: true
        },
        actions: {
            type: 'relation',
            relation: 'oneToMany',
            target: RELEASE_ACTION_MODEL_UID,
            mappedBy: 'release'
        }
    }
};

const release$1 = {
    schema: schema$1
};

var schema = {
    collectionName: 'strapi_release_actions',
    info: {
        singularName: 'release-action',
        pluralName: 'release-actions',
        displayName: 'Release Action'
    },
    options: {
        draftAndPublish: false
    },
    pluginOptions: {
        'content-manager': {
            visible: false
        },
        'content-type-builder': {
            visible: false
        }
    },
    attributes: {
        type: {
            type: 'enumeration',
            enum: [
                'publish',
                'unpublish'
            ],
            required: true
        },
        contentType: {
            type: 'string',
            required: true
        },
        entryDocumentId: {
            type: 'string'
        },
        locale: {
            type: 'string'
        },
        release: {
            type: 'relation',
            relation: 'manyToOne',
            target: RELEASE_MODEL_UID,
            inversedBy: 'actions'
        },
        isEntryValid: {
            type: 'boolean'
        }
    }
};

const releaseAction$1 = {
    schema
};

const contentTypes = {
    release: release$1,
    'release-action': releaseAction$1
};

const createReleaseService = ({ strapi })=>{
    const dispatchWebhook = (event, { isPublished, release, error })=>{
        strapi.eventHub.emit(event, {
            isPublished,
            error,
            release
        });
    };
    /**
   * Given a release id, it returns the actions formatted ready to be used to publish them.
   * We split them by contentType and type (publish/unpublish) and extract only the documentIds and locales.
   */ const getFormattedActions = async (releaseId)=>{
        const actions = await strapi.db.query(RELEASE_ACTION_MODEL_UID).findMany({
            where: {
                release: {
                    id: releaseId
                }
            }
        });
        if (actions.length === 0) {
            throw new utils.errors.ValidationError('No entries to publish');
        }
        /**
     * We separate publish and unpublish actions, grouping them by contentType and extracting only their documentIds and locales.
     */ const formattedActions = {};
        for (const action of actions){
            const contentTypeUid = action.contentType;
            if (!formattedActions[contentTypeUid]) {
                formattedActions[contentTypeUid] = {
                    publish: [],
                    unpublish: []
                };
            }
            formattedActions[contentTypeUid][action.type].push({
                documentId: action.entryDocumentId,
                locale: action.locale
            });
        }
        return formattedActions;
    };
    return {
        async create (releaseData, { user }) {
            const releaseWithCreatorFields = await utils.setCreatorFields({
                user
            })(releaseData);
            const { validatePendingReleasesLimit, validateUniqueNameForPendingRelease, validateScheduledAtIsLaterThanNow } = getService('release-validation', {
                strapi
            });
            await Promise.all([
                validatePendingReleasesLimit(),
                validateUniqueNameForPendingRelease(releaseWithCreatorFields.name),
                validateScheduledAtIsLaterThanNow(releaseWithCreatorFields.scheduledAt)
            ]);
            const release = await strapi.db.query(RELEASE_MODEL_UID).create({
                data: {
                    ...releaseWithCreatorFields,
                    status: 'empty'
                }
            });
            if (releaseWithCreatorFields.scheduledAt) {
                const schedulingService = getService('scheduling', {
                    strapi
                });
                await schedulingService.set(release.id, release.scheduledAt);
            }
            strapi.telemetry.send('didCreateContentRelease');
            return release;
        },
        async findOne (id, query = {}) {
            const dbQuery = strapi.get('query-params').transform(RELEASE_MODEL_UID, query);
            const release = await strapi.db.query(RELEASE_MODEL_UID).findOne({
                ...dbQuery,
                where: {
                    id
                }
            });
            return release;
        },
        findPage (query) {
            const dbQuery = strapi.get('query-params').transform(RELEASE_MODEL_UID, query ?? {});
            return strapi.db.query(RELEASE_MODEL_UID).findPage({
                ...dbQuery,
                populate: {
                    actions: {
                        count: true
                    }
                }
            });
        },
        findMany (query) {
            const dbQuery = strapi.get('query-params').transform(RELEASE_MODEL_UID, query ?? {});
            return strapi.db.query(RELEASE_MODEL_UID).findMany({
                ...dbQuery
            });
        },
        async update (id, releaseData, { user }) {
            const releaseWithCreatorFields = await utils.setCreatorFields({
                user,
                isEdition: true
            })(releaseData);
            const { validateUniqueNameForPendingRelease, validateScheduledAtIsLaterThanNow } = getService('release-validation', {
                strapi
            });
            await Promise.all([
                validateUniqueNameForPendingRelease(releaseWithCreatorFields.name, id),
                validateScheduledAtIsLaterThanNow(releaseWithCreatorFields.scheduledAt)
            ]);
            const release = await strapi.db.query(RELEASE_MODEL_UID).findOne({
                where: {
                    id
                }
            });
            if (!release) {
                throw new utils.errors.NotFoundError(`No release found for id ${id}`);
            }
            if (release.releasedAt) {
                throw new utils.errors.ValidationError('Release already published');
            }
            const updatedRelease = await strapi.db.query(RELEASE_MODEL_UID).update({
                where: {
                    id
                },
                data: releaseWithCreatorFields
            });
            const schedulingService = getService('scheduling', {
                strapi
            });
            if (releaseData.scheduledAt) {
                // set function always cancel the previous job if it exists, so we can call it directly
                await schedulingService.set(id, releaseData.scheduledAt);
            } else if (release.scheduledAt) {
                // When user don't send a scheduledAt and we have one on the release, means that user want to unschedule it
                schedulingService.cancel(id);
            }
            this.updateReleaseStatus(id);
            strapi.telemetry.send('didUpdateContentRelease');
            return updatedRelease;
        },
        async getAllComponents () {
            const contentManagerComponentsService = strapi.plugin('content-manager').service('components');
            const components = await contentManagerComponentsService.findAllComponents();
            const componentsMap = components.reduce((acc, component)=>{
                acc[component.uid] = component;
                return acc;
            }, {});
            return componentsMap;
        },
        async delete (releaseId) {
            const release = await strapi.db.query(RELEASE_MODEL_UID).findOne({
                where: {
                    id: releaseId
                },
                populate: {
                    actions: {
                        select: [
                            'id'
                        ]
                    }
                }
            });
            if (!release) {
                throw new utils.errors.NotFoundError(`No release found for id ${releaseId}`);
            }
            if (release.releasedAt) {
                throw new utils.errors.ValidationError('Release already published');
            }
            // Only delete the release and its actions is you in fact can delete all the actions and the release
            // Otherwise, if the transaction fails it throws an error
            await strapi.db.transaction(async ()=>{
                await strapi.db.query(RELEASE_ACTION_MODEL_UID).deleteMany({
                    where: {
                        id: {
                            $in: release.actions.map((action)=>action.id)
                        }
                    }
                });
                await strapi.db.query(RELEASE_MODEL_UID).delete({
                    where: {
                        id: releaseId
                    }
                });
            });
            if (release.scheduledAt) {
                const schedulingService = getService('scheduling', {
                    strapi
                });
                await schedulingService.cancel(release.id);
            }
            strapi.telemetry.send('didDeleteContentRelease');
            return release;
        },
        async publish (releaseId) {
            const { release, error } = await strapi.db.transaction(async ({ trx })=>{
                /**
           * We lock the release in this transaction, so any other process trying to publish it will wait until this transaction is finished
           * In this transaction we don't care about rollback, becasue we want to persist the lock until the end and if it fails we want to change the release status to failed
           */ const lockedRelease = await strapi.db?.queryBuilder(RELEASE_MODEL_UID).where({
                    id: releaseId
                }).select([
                    'id',
                    'name',
                    'releasedAt',
                    'status'
                ]).first().transacting(trx).forUpdate().execute();
                if (!lockedRelease) {
                    throw new utils.errors.NotFoundError(`No release found for id ${releaseId}`);
                }
                if (lockedRelease.releasedAt) {
                    throw new utils.errors.ValidationError('Release already published');
                }
                if (lockedRelease.status === 'failed') {
                    throw new utils.errors.ValidationError('Release failed to publish');
                }
                try {
                    strapi.log.info(`[Content Releases] Starting to publish release ${lockedRelease.name}`);
                    const formattedActions = await getFormattedActions(releaseId);
                    await strapi.db.transaction(async ()=>Promise.all(Object.keys(formattedActions).map(async (contentTypeUid)=>{
                            const contentType = contentTypeUid;
                            const { publish, unpublish } = formattedActions[contentType];
                            return Promise.all([
                                ...publish.map((params)=>strapi.documents(contentType).publish(params)),
                                ...unpublish.map((params)=>strapi.documents(contentType).unpublish(params))
                            ]);
                        })));
                    const release = await strapi.db.query(RELEASE_MODEL_UID).update({
                        where: {
                            id: releaseId
                        },
                        data: {
                            status: 'done',
                            releasedAt: new Date()
                        }
                    });
                    dispatchWebhook(ALLOWED_WEBHOOK_EVENTS.RELEASES_PUBLISH, {
                        isPublished: true,
                        release
                    });
                    strapi.telemetry.send('didPublishContentRelease');
                    return {
                        release,
                        error: null
                    };
                } catch (error) {
                    dispatchWebhook(ALLOWED_WEBHOOK_EVENTS.RELEASES_PUBLISH, {
                        isPublished: false,
                        error
                    });
                    // We need to run the update in the same transaction because the release is locked
                    await strapi.db?.queryBuilder(RELEASE_MODEL_UID).where({
                        id: releaseId
                    }).update({
                        status: 'failed'
                    }).transacting(trx).execute();
                    // At this point, we don't want to throw the error because if that happen we rollback the change in the release status
                    // We want to throw the error after the transaction is finished, so we return the error
                    return {
                        release: null,
                        error
                    };
                }
            });
            // Now the first transaction is commited, we can safely throw the error if it exists
            if (error instanceof Error) {
                throw error;
            }
            return release;
        },
        async updateReleaseStatus (releaseId) {
            const releaseActionService = getService('release-action', {
                strapi
            });
            const [totalActions, invalidActions] = await Promise.all([
                releaseActionService.countActions({
                    filters: {
                        release: releaseId
                    }
                }),
                releaseActionService.countActions({
                    filters: {
                        release: releaseId,
                        isEntryValid: false
                    }
                })
            ]);
            if (totalActions > 0) {
                if (invalidActions > 0) {
                    return strapi.db.query(RELEASE_MODEL_UID).update({
                        where: {
                            id: releaseId
                        },
                        data: {
                            status: 'blocked'
                        }
                    });
                }
                return strapi.db.query(RELEASE_MODEL_UID).update({
                    where: {
                        id: releaseId
                    },
                    data: {
                        status: 'ready'
                    }
                });
            }
            return strapi.db.query(RELEASE_MODEL_UID).update({
                where: {
                    id: releaseId
                },
                data: {
                    status: 'empty'
                }
            });
        }
    };
};

const getGroupName = (queryValue)=>{
    switch(queryValue){
        case 'contentType':
            return 'contentType.displayName';
        case 'type':
            return 'type';
        case 'locale':
            return _.getOr('No locale', 'locale.name');
        default:
            return 'contentType.displayName';
    }
};
const createReleaseActionService = ({ strapi })=>{
    const getLocalesDataForActions = async ()=>{
        if (!strapi.plugin('i18n')) {
            return {};
        }
        const allLocales = await strapi.plugin('i18n').service('locales').find() || [];
        return allLocales.reduce((acc, locale)=>{
            acc[locale.code] = {
                name: locale.name,
                code: locale.code
            };
            return acc;
        }, {});
    };
    const getContentTypesDataForActions = async (contentTypesUids)=>{
        const contentManagerContentTypeService = strapi.plugin('content-manager').service('content-types');
        const contentTypesData = {};
        for (const contentTypeUid of contentTypesUids){
            const contentTypeConfig = await contentManagerContentTypeService.findConfiguration({
                uid: contentTypeUid
            });
            contentTypesData[contentTypeUid] = {
                mainField: contentTypeConfig.settings.mainField,
                displayName: strapi.getModel(contentTypeUid).info.displayName
            };
        }
        return contentTypesData;
    };
    return {
        async create (releaseId, action, { disableUpdateReleaseStatus = false } = {}) {
            const { validateEntryData, validateUniqueEntry } = getService('release-validation', {
                strapi
            });
            await Promise.all([
                validateEntryData(action.contentType, action.entryDocumentId),
                validateUniqueEntry(releaseId, action)
            ]);
            // If we are adding a singleType, we need to append the documentId of that singleType
            const model = strapi.contentType(action.contentType);
            if (model.kind === 'singleType') {
                const document = await strapi.db.query(model.uid).findOne({
                    select: [
                        'documentId'
                    ]
                });
                if (!document) {
                    throw new utils.errors.NotFoundError(`No entry found for contentType ${action.contentType}`);
                }
                action.entryDocumentId = document.documentId;
            }
            const release = await strapi.db.query(RELEASE_MODEL_UID).findOne({
                where: {
                    id: releaseId
                }
            });
            if (!release) {
                throw new utils.errors.NotFoundError(`No release found for id ${releaseId}`);
            }
            if (release.releasedAt) {
                throw new utils.errors.ValidationError('Release already published');
            }
            // If the action is a publish, check if the entry is valid
            // If the action is an unpublish, skip the validation
            const actionStatus = action.type === 'publish' ? await getDraftEntryValidStatus({
                contentType: action.contentType,
                documentId: action.entryDocumentId,
                locale: action.locale
            }, {
                strapi
            }) : true;
            const releaseAction = await strapi.db.query(RELEASE_ACTION_MODEL_UID).create({
                data: {
                    ...action,
                    release: release.id,
                    isEntryValid: actionStatus
                },
                populate: {
                    release: {
                        select: [
                            'id'
                        ]
                    }
                }
            });
            if (!disableUpdateReleaseStatus) {
                getService('release', {
                    strapi
                }).updateReleaseStatus(release.id);
            }
            return releaseAction;
        },
        async findPage (releaseId, query) {
            const release = await strapi.db.query(RELEASE_MODEL_UID).findOne({
                where: {
                    id: releaseId
                },
                select: [
                    'id'
                ]
            });
            if (!release) {
                throw new utils.errors.NotFoundError(`No release found for id ${releaseId}`);
            }
            const dbQuery = strapi.get('query-params').transform(RELEASE_ACTION_MODEL_UID, query ?? {});
            const { results: actions, pagination } = await strapi.db.query(RELEASE_ACTION_MODEL_UID).findPage({
                ...dbQuery,
                where: {
                    release: releaseId
                }
            });
            // For each contentType on the release, we create a custom populate object for nested relations
            const populateBuilderService = strapi.plugin('content-manager').service('populate-builder');
            const actionsWithEntry = await utils.async.map(actions, async (action)=>{
                // @ts-expect-error - Core.Service type is not a function
                const populate = await populateBuilderService(action.contentType).populateDeep(Infinity).build();
                const entry = await getEntry({
                    contentType: action.contentType,
                    documentId: action.entryDocumentId,
                    locale: action.locale,
                    populate,
                    status: action.type === 'publish' ? 'draft' : 'published'
                }, {
                    strapi
                });
                return {
                    ...action,
                    entry,
                    status: entry ? await getEntryStatus(action.contentType, entry) : null
                };
            });
            return {
                results: actionsWithEntry,
                pagination
            };
        },
        async groupActions (actions, groupBy) {
            const contentTypeUids = actions.reduce((acc, action)=>{
                if (!acc.includes(action.contentType)) {
                    acc.push(action.contentType);
                }
                return acc;
            }, []);
            const allReleaseContentTypesDictionary = await getContentTypesDataForActions(contentTypeUids);
            const allLocalesDictionary = await getLocalesDataForActions();
            const formattedData = actions.map((action)=>{
                const { mainField, displayName } = allReleaseContentTypesDictionary[action.contentType];
                return {
                    ...action,
                    locale: action.locale ? allLocalesDictionary[action.locale] : null,
                    contentType: {
                        displayName,
                        mainFieldValue: action.entry[mainField],
                        uid: action.contentType
                    }
                };
            });
            const groupName = getGroupName(groupBy);
            return _.groupBy(groupName)(formattedData);
        },
        async getContentTypeModelsFromActions (actions) {
            const contentTypeUids = actions.reduce((acc, action)=>{
                if (!acc.includes(action.contentType)) {
                    acc.push(action.contentType);
                }
                return acc;
            }, []);
            const workflowsService = strapi.plugin('review-workflows').service('workflows');
            const contentTypeModelsMap = await utils.async.reduce(contentTypeUids)(async (accPromise, contentTypeUid)=>{
                const acc = await accPromise;
                const contentTypeModel = strapi.getModel(contentTypeUid);
                const workflow = await workflowsService.getAssignedWorkflow(contentTypeUid, {
                    populate: 'stageRequiredToPublish'
                });
                acc[contentTypeUid] = {
                    ...contentTypeModel,
                    hasReviewWorkflow: !!workflow,
                    stageRequiredToPublish: workflow?.stageRequiredToPublish
                };
                return acc;
            }, {});
            return contentTypeModelsMap;
        },
        async countActions (query) {
            const dbQuery = strapi.get('query-params').transform(RELEASE_ACTION_MODEL_UID, query ?? {});
            return strapi.db.query(RELEASE_ACTION_MODEL_UID).count(dbQuery);
        },
        async update (actionId, releaseId, update) {
            const action = await strapi.db.query(RELEASE_ACTION_MODEL_UID).findOne({
                where: {
                    id: actionId,
                    release: {
                        id: releaseId,
                        releasedAt: {
                            $null: true
                        }
                    }
                }
            });
            if (!action) {
                throw new utils.errors.NotFoundError(`Action with id ${actionId} not found in release with id ${releaseId} or it is already published`);
            }
            const actionStatus = update.type === 'publish' ? await getDraftEntryValidStatus({
                contentType: action.contentType,
                documentId: action.entryDocumentId,
                locale: action.locale
            }, {
                strapi
            }) : true;
            const updatedAction = await strapi.db.query(RELEASE_ACTION_MODEL_UID).update({
                where: {
                    id: actionId,
                    release: {
                        id: releaseId,
                        releasedAt: {
                            $null: true
                        }
                    }
                },
                data: {
                    ...update,
                    isEntryValid: actionStatus
                }
            });
            getService('release', {
                strapi
            }).updateReleaseStatus(releaseId);
            return updatedAction;
        },
        async delete (actionId, releaseId) {
            const deletedAction = await strapi.db.query(RELEASE_ACTION_MODEL_UID).delete({
                where: {
                    id: actionId,
                    release: {
                        id: releaseId,
                        releasedAt: {
                            $null: true
                        }
                    }
                }
            });
            if (!deletedAction) {
                throw new utils.errors.NotFoundError(`Action with id ${actionId} not found in release with id ${releaseId} or it is already published`);
            }
            getService('release', {
                strapi
            }).updateReleaseStatus(releaseId);
            return deletedAction;
        },
        async validateActionsByContentTypes (contentTypeUids) {
            const actions = await strapi.db.query(RELEASE_ACTION_MODEL_UID).findMany({
                where: {
                    contentType: {
                        $in: contentTypeUids
                    },
                    // We only want to validate actions that are going to be published
                    type: 'publish',
                    release: {
                        releasedAt: {
                            $null: true
                        }
                    }
                },
                populate: {
                    release: true
                }
            });
            const releasesUpdated = [];
            await utils.async.map(actions, async (action)=>{
                const isValid = await getDraftEntryValidStatus({
                    contentType: action.contentType,
                    documentId: action.entryDocumentId,
                    locale: action.locale
                }, {
                    strapi
                });
                await strapi.db.query(RELEASE_ACTION_MODEL_UID).update({
                    where: {
                        id: action.id
                    },
                    data: {
                        isEntryValid: isValid
                    }
                });
                if (!releasesUpdated.includes(action.release.id)) {
                    releasesUpdated.push(action.release.id);
                }
                return {
                    id: action.id,
                    isEntryValid: isValid
                };
            });
            if (releasesUpdated.length > 0) {
                await utils.async.map(releasesUpdated, async (releaseId)=>{
                    await getService('release', {
                        strapi
                    }).updateReleaseStatus(releaseId);
                });
            }
        }
    };
};

class AlreadyOnReleaseError extends utils.errors.ApplicationError {
    constructor(message){
        super(message);
        this.name = 'AlreadyOnReleaseError';
    }
}
const createReleaseValidationService = ({ strapi })=>({
        async validateUniqueEntry (releaseId, releaseActionArgs) {
            /**
     * Asserting the type, otherwise TS complains: 'release.actions' is of type 'unknown', even though the types come through for non-populated fields...
     * Possibly related to the comment on GetValues: https://github.com/strapi/strapi/blob/main/packages/core/types/src/modules/entity-service/result.ts
     */ const release = await strapi.db.query(RELEASE_MODEL_UID).findOne({
                where: {
                    id: releaseId
                },
                populate: {
                    actions: true
                }
            });
            if (!release) {
                throw new utils.errors.NotFoundError(`No release found for id ${releaseId}`);
            }
            const isEntryInRelease = release.actions.some((action)=>action.entryDocumentId === releaseActionArgs.entryDocumentId && action.contentType === releaseActionArgs.contentType && (releaseActionArgs.locale ? action.locale === releaseActionArgs.locale : true));
            if (isEntryInRelease) {
                throw new AlreadyOnReleaseError(`Entry with documentId ${releaseActionArgs.entryDocumentId}${releaseActionArgs.locale ? `( ${releaseActionArgs.locale})` : ''} and contentType ${releaseActionArgs.contentType} already exists in release with id ${releaseId}`);
            }
        },
        validateEntryData (contentTypeUid, entryDocumentId) {
            const contentType = strapi.contentType(contentTypeUid);
            if (!contentType) {
                throw new utils.errors.NotFoundError(`No content type found for uid ${contentTypeUid}`);
            }
            if (!utils.contentTypes.hasDraftAndPublish(contentType)) {
                throw new utils.errors.ValidationError(`Content type with uid ${contentTypeUid} does not have draftAndPublish enabled`);
            }
            if (contentType.kind === 'collectionType' && !entryDocumentId) {
                throw new utils.errors.ValidationError('Document id is required for collection type');
            }
        },
        async validatePendingReleasesLimit () {
            // Use the maximum releases option if it exists, otherwise default to 3
            const featureCfg = strapi.ee.features.get('cms-content-releases');
            const maximumPendingReleases = typeof featureCfg === 'object' && featureCfg?.options?.maximumReleases || 3;
            const [, pendingReleasesCount] = await strapi.db.query(RELEASE_MODEL_UID).findWithCount({
                filters: {
                    releasedAt: {
                        $null: true
                    }
                }
            });
            // Unlimited is a number that will never be reached like 9999
            if (pendingReleasesCount >= maximumPendingReleases) {
                throw new utils.errors.ValidationError('You have reached the maximum number of pending releases');
            }
        },
        async validateUniqueNameForPendingRelease (name, id) {
            const pendingReleases = await strapi.db.query(RELEASE_MODEL_UID).findMany({
                where: {
                    releasedAt: {
                        $null: true
                    },
                    name,
                    ...id && {
                        id: {
                            $ne: id
                        }
                    }
                }
            });
            const isNameUnique = pendingReleases.length === 0;
            if (!isNameUnique) {
                throw new utils.errors.ValidationError(`Release with name ${name} already exists`);
            }
        },
        async validateScheduledAtIsLaterThanNow (scheduledAt) {
            if (scheduledAt && new Date(scheduledAt) <= new Date()) {
                throw new utils.errors.ValidationError('Scheduled at must be later than now');
            }
        }
    });

const createSchedulingService = ({ strapi })=>{
    const scheduledJobs = new Map();
    return {
        async set (releaseId, scheduleDate) {
            const release = await strapi.db.query(RELEASE_MODEL_UID).findOne({
                where: {
                    id: releaseId,
                    releasedAt: null
                }
            });
            if (!release) {
                throw new utils.errors.NotFoundError(`No release found for id ${releaseId}`);
            }
            const job = nodeSchedule.scheduleJob(scheduleDate, async ()=>{
                try {
                    await getService('release', {
                        strapi
                    }).publish(releaseId);
                // @TODO: Trigger webhook with success message
                } catch (error) {
                // @TODO: Trigger webhook with error message
                }
                this.cancel(releaseId);
            });
            if (scheduledJobs.has(releaseId)) {
                this.cancel(releaseId);
            }
            scheduledJobs.set(releaseId, job);
            return scheduledJobs;
        },
        cancel (releaseId) {
            if (scheduledJobs.has(releaseId)) {
                scheduledJobs.get(releaseId).cancel();
                scheduledJobs.delete(releaseId);
            }
            return scheduledJobs;
        },
        getAll () {
            return scheduledJobs;
        },
        /**
     * On bootstrap, we can use this function to make sure to sync the scheduled jobs from the database that are not yet released
     * This is useful in case the server was restarted and the scheduled jobs were lost
     * This also could be used to sync different Strapi instances in case of a cluster
     */ async syncFromDatabase () {
            const releases = await strapi.db.query(RELEASE_MODEL_UID).findMany({
                where: {
                    scheduledAt: {
                        $gte: new Date()
                    },
                    releasedAt: null
                }
            });
            for (const release of releases){
                this.set(release.id, release.scheduledAt);
            }
            return scheduledJobs;
        }
    };
};

const DEFAULT_SETTINGS = {
    defaultTimezone: null
};
const createSettingsService = ({ strapi })=>{
    const getStore = async ()=>strapi.store({
            type: 'core',
            name: 'content-releases'
        });
    return {
        async update ({ settings }) {
            const store = await getStore();
            store.set({
                key: 'settings',
                value: settings
            });
            return settings;
        },
        async find () {
            const store = await getStore();
            const settings = await store.get({
                key: 'settings'
            });
            return {
                ...DEFAULT_SETTINGS,
                ...settings || {}
            };
        }
    };
};

const services = {
    release: createReleaseService,
    'release-action': createReleaseActionService,
    'release-validation': createReleaseValidationService,
    scheduling: createSchedulingService,
    settings: createSettingsService
};

const RELEASE_SCHEMA = utils.yup.object().shape({
    name: utils.yup.string().trim().required(),
    scheduledAt: utils.yup.string().nullable(),
    timezone: utils.yup.string().when('scheduledAt', {
        is: (value)=>value !== null && value !== undefined,
        then: utils.yup.string().required(),
        otherwise: utils.yup.string().nullable()
    })
}).required().noUnknown();
const FIND_BY_DOCUMENT_ATTACHED_PARAMS_SCHEMA = utils.yup.object().shape({
    contentType: utils.yup.string().required(),
    entryDocumentId: utils.yup.string().nullable(),
    hasEntryAttached: utils.yup.string().nullable(),
    locale: utils.yup.string().nullable()
}).required().noUnknown();
const validateRelease = utils.validateYupSchema(RELEASE_SCHEMA);
const validatefindByDocumentAttachedParams = utils.validateYupSchema(FIND_BY_DOCUMENT_ATTACHED_PARAMS_SCHEMA);

const releaseController = {
    /**
   * Find releases based on documents attached or not to the release.
   * If `hasEntryAttached` is true, it will return all releases that have the entry attached.
   * If `hasEntryAttached` is false, it will return all releases that don't have the entry attached.
   */ async findByDocumentAttached (ctx) {
        const permissionsManager = strapi.service('admin::permission').createPermissionsManager({
            ability: ctx.state.userAbility,
            model: RELEASE_MODEL_UID
        });
        await permissionsManager.validateQuery(ctx.query);
        const releaseService = getService('release', {
            strapi
        });
        const query = await permissionsManager.sanitizeQuery(ctx.query);
        await validatefindByDocumentAttachedParams(query);
        // If entry is a singleType, we need to manually add the entryDocumentId to the query
        const model = strapi.getModel(query.contentType);
        if (model.kind && model.kind === 'singleType') {
            const document = await strapi.db.query(model.uid).findOne({
                select: [
                    'documentId'
                ]
            });
            if (!document) {
                throw new utils.errors.NotFoundError(`No entry found for contentType ${query.contentType}`);
            }
            query.entryDocumentId = document.documentId;
        }
        const { contentType, hasEntryAttached, entryDocumentId, locale } = query;
        const isEntryAttached = typeof hasEntryAttached === 'string' ? Boolean(JSON.parse(hasEntryAttached)) : false;
        if (isEntryAttached) {
            const releases = await releaseService.findMany({
                where: {
                    releasedAt: null,
                    actions: {
                        contentType,
                        entryDocumentId: entryDocumentId ?? null,
                        locale: locale ?? null
                    }
                },
                populate: {
                    actions: {
                        fields: [
                            'type'
                        ],
                        filters: {
                            contentType,
                            entryDocumentId: entryDocumentId ?? null,
                            locale: locale ?? null
                        }
                    }
                }
            });
            ctx.body = {
                data: releases
            };
        } else {
            const relatedReleases = await releaseService.findMany({
                where: {
                    releasedAt: null,
                    actions: {
                        contentType,
                        entryDocumentId: entryDocumentId ?? null,
                        locale: locale ?? null
                    }
                }
            });
            const releases = await releaseService.findMany({
                where: {
                    $or: [
                        {
                            id: {
                                $notIn: relatedReleases.map((release)=>release.id)
                            }
                        },
                        {
                            actions: null
                        }
                    ],
                    releasedAt: null
                }
            });
            ctx.body = {
                data: releases
            };
        }
    },
    async findPage (ctx) {
        const permissionsManager = strapi.service('admin::permission').createPermissionsManager({
            ability: ctx.state.userAbility,
            model: RELEASE_MODEL_UID
        });
        await permissionsManager.validateQuery(ctx.query);
        const releaseService = getService('release', {
            strapi
        });
        const query = await permissionsManager.sanitizeQuery(ctx.query);
        const { results, pagination } = await releaseService.findPage(query);
        const data = results.map((release)=>{
            const { actions, ...releaseData } = release;
            return {
                ...releaseData,
                actions: {
                    meta: {
                        count: actions.count
                    }
                }
            };
        });
        const pendingReleasesCount = await strapi.db.query(RELEASE_MODEL_UID).count({
            where: {
                releasedAt: null
            }
        });
        ctx.body = {
            data,
            meta: {
                pagination,
                pendingReleasesCount
            }
        };
    },
    async findOne (ctx) {
        const id = ctx.params.id;
        const releaseService = getService('release', {
            strapi
        });
        const releaseActionService = getService('release-action', {
            strapi
        });
        const release = await releaseService.findOne(id, {
            populate: [
                'createdBy'
            ]
        });
        if (!release) {
            throw new utils.errors.NotFoundError(`Release not found for id: ${id}`);
        }
        const count = await releaseActionService.countActions({
            filters: {
                release: id
            }
        });
        const sanitizedRelease = {
            ...release,
            createdBy: release.createdBy ? strapi.service('admin::user').sanitizeUser(release.createdBy) : null
        };
        // Format the data object
        const data = {
            ...sanitizedRelease,
            actions: {
                meta: {
                    count
                }
            }
        };
        ctx.body = {
            data
        };
    },
    async mapEntriesToReleases (ctx) {
        const { contentTypeUid, documentIds, locale } = ctx.query;
        if (!contentTypeUid || !documentIds) {
            throw new utils.errors.ValidationError('Missing required query parameters');
        }
        const releaseService = getService('release', {
            strapi
        });
        const releasesWithActions = await releaseService.findMany({
            where: {
                releasedAt: null,
                actions: {
                    contentType: contentTypeUid,
                    entryDocumentId: {
                        $in: documentIds
                    },
                    locale
                }
            },
            populate: {
                actions: true
            }
        });
        const mappedEntriesInReleases = releasesWithActions.reduce((acc, release)=>{
            release.actions.forEach((action)=>{
                if (action.contentType !== contentTypeUid) {
                    return;
                }
                if (locale && action.locale !== locale) {
                    return;
                }
                if (!acc[action.entryDocumentId]) {
                    acc[action.entryDocumentId] = [
                        {
                            id: release.id,
                            name: release.name
                        }
                    ];
                } else {
                    acc[action.entryDocumentId].push({
                        id: release.id,
                        name: release.name
                    });
                }
            });
            return acc;
        }, {});
        ctx.body = {
            data: mappedEntriesInReleases
        };
    },
    async create (ctx) {
        const user = ctx.state.user;
        const releaseArgs = ctx.request.body;
        await validateRelease(releaseArgs);
        const releaseService = getService('release', {
            strapi
        });
        const release = await releaseService.create(releaseArgs, {
            user
        });
        const permissionsManager = strapi.service('admin::permission').createPermissionsManager({
            ability: ctx.state.userAbility,
            model: RELEASE_MODEL_UID
        });
        ctx.created({
            data: await permissionsManager.sanitizeOutput(release)
        });
    },
    async update (ctx) {
        const user = ctx.state.user;
        const releaseArgs = ctx.request.body;
        const id = ctx.params.id;
        await validateRelease(releaseArgs);
        const releaseService = getService('release', {
            strapi
        });
        const release = await releaseService.update(id, releaseArgs, {
            user
        });
        const permissionsManager = strapi.service('admin::permission').createPermissionsManager({
            ability: ctx.state.userAbility,
            model: RELEASE_MODEL_UID
        });
        ctx.body = {
            data: await permissionsManager.sanitizeOutput(release)
        };
    },
    async delete (ctx) {
        const id = ctx.params.id;
        const releaseService = getService('release', {
            strapi
        });
        const release = await releaseService.delete(id);
        ctx.body = {
            data: release
        };
    },
    async publish (ctx) {
        const id = ctx.params.id;
        const releaseService = getService('release', {
            strapi
        });
        const releaseActionService = getService('release-action', {
            strapi
        });
        const release = await releaseService.publish(id);
        const [countPublishActions, countUnpublishActions] = await Promise.all([
            releaseActionService.countActions({
                filters: {
                    release: id,
                    type: 'publish'
                }
            }),
            releaseActionService.countActions({
                filters: {
                    release: id,
                    type: 'unpublish'
                }
            })
        ]);
        ctx.body = {
            data: release,
            meta: {
                totalEntries: countPublishActions + countUnpublishActions,
                totalPublishedEntries: countPublishActions,
                totalUnpublishedEntries: countUnpublishActions
            }
        };
    }
};

const RELEASE_ACTION_SCHEMA = utils.yup.object().shape({
    contentType: utils.yup.string().required(),
    entryDocumentId: utils.yup.strapiID(),
    locale: utils.yup.string(),
    type: utils.yup.string().oneOf([
        'publish',
        'unpublish'
    ]).required()
});
const RELEASE_ACTION_UPDATE_SCHEMA = utils.yup.object().shape({
    type: utils.yup.string().oneOf([
        'publish',
        'unpublish'
    ]).required()
});
const FIND_MANY_ACTIONS_PARAMS = utils.yup.object().shape({
    groupBy: utils.yup.string().oneOf([
        'action',
        'contentType',
        'locale'
    ])
});
const validateReleaseAction = utils.validateYupSchema(RELEASE_ACTION_SCHEMA);
const validateReleaseActionUpdateSchema = utils.validateYupSchema(RELEASE_ACTION_UPDATE_SCHEMA);
const validateFindManyActionsParams = utils.validateYupSchema(FIND_MANY_ACTIONS_PARAMS);

const releaseActionController = {
    async create (ctx) {
        const releaseId = ctx.params.releaseId;
        const releaseActionArgs = ctx.request.body;
        await validateReleaseAction(releaseActionArgs);
        const releaseActionService = getService('release-action', {
            strapi
        });
        const releaseAction = await releaseActionService.create(releaseId, releaseActionArgs);
        ctx.created({
            data: releaseAction
        });
    },
    async createMany (ctx) {
        const releaseId = ctx.params.releaseId;
        const releaseActionsArgs = ctx.request.body;
        await Promise.all(releaseActionsArgs.map((releaseActionArgs)=>validateReleaseAction(releaseActionArgs)));
        const releaseActionService = getService('release-action', {
            strapi
        });
        const releaseService = getService('release', {
            strapi
        });
        const releaseActions = await strapi.db.transaction(async ()=>{
            const releaseActions = await Promise.all(releaseActionsArgs.map(async (releaseActionArgs)=>{
                try {
                    const action = await releaseActionService.create(releaseId, releaseActionArgs, {
                        disableUpdateReleaseStatus: true
                    });
                    return action;
                } catch (error) {
                    // If the entry is already in the release, we don't want to throw an error, so we catch and ignore it
                    if (error instanceof AlreadyOnReleaseError) {
                        return null;
                    }
                    throw error;
                }
            }));
            return releaseActions;
        });
        const newReleaseActions = releaseActions.filter((action)=>action !== null);
        if (newReleaseActions.length > 0) {
            releaseService.updateReleaseStatus(releaseId);
        }
        ctx.created({
            data: newReleaseActions,
            meta: {
                entriesAlreadyInRelease: releaseActions.length - newReleaseActions.length,
                totalEntries: releaseActions.length
            }
        });
    },
    async findMany (ctx) {
        const releaseId = ctx.params.releaseId;
        const permissionsManager = strapi.service('admin::permission').createPermissionsManager({
            ability: ctx.state.userAbility,
            model: RELEASE_ACTION_MODEL_UID
        });
        await validateFindManyActionsParams(ctx.query);
        if (ctx.query.groupBy) {
            if (![
                'action',
                'contentType',
                'locale'
            ].includes(ctx.query.groupBy)) {
                ctx.badRequest('Invalid groupBy parameter');
            }
        }
        ctx.query.sort = ctx.query.groupBy === 'action' ? 'type' : ctx.query.groupBy;
        delete ctx.query.groupBy;
        const query = await permissionsManager.sanitizeQuery(ctx.query);
        const releaseActionService = getService('release-action', {
            strapi
        });
        const { results, pagination } = await releaseActionService.findPage(releaseId, {
            ...query
        });
        /**
     * Release actions can be related to entries of different content types.
     * We need to sanitize the entry output according to that content type.
     * So, we group the sanitized output function by content type.
     */ const contentTypeOutputSanitizers = results.reduce((acc, action)=>{
            if (acc[action.contentType]) {
                return acc;
            }
            const contentTypePermissionsManager = strapi.service('admin::permission').createPermissionsManager({
                ability: ctx.state.userAbility,
                model: action.contentType
            });
            acc[action.contentType] = contentTypePermissionsManager.sanitizeOutput;
            return acc;
        }, {});
        /**
     * sanitizeOutput doesn't work if you use it directly on the Release Action model, it doesn't sanitize the entries
     * So, we need to sanitize manually each entry inside a Release Action
     */ const sanitizedResults = await utils.async.map(results, async (action)=>({
                ...action,
                entry: action.entry ? await contentTypeOutputSanitizers[action.contentType](action.entry) : {}
            }));
        const groupedData = await releaseActionService.groupActions(sanitizedResults, query.sort);
        const contentTypes = await releaseActionService.getContentTypeModelsFromActions(results);
        const releaseService = getService('release', {
            strapi
        });
        const components = await releaseService.getAllComponents();
        ctx.body = {
            data: groupedData,
            meta: {
                pagination,
                contentTypes,
                components
            }
        };
    },
    async update (ctx) {
        const actionId = ctx.params.actionId;
        const releaseId = ctx.params.releaseId;
        const releaseActionUpdateArgs = ctx.request.body;
        await validateReleaseActionUpdateSchema(releaseActionUpdateArgs);
        const releaseActionService = getService('release-action', {
            strapi
        });
        const updatedAction = await releaseActionService.update(actionId, releaseId, releaseActionUpdateArgs);
        ctx.body = {
            data: updatedAction
        };
    },
    async delete (ctx) {
        const actionId = ctx.params.actionId;
        const releaseId = ctx.params.releaseId;
        const releaseActionService = getService('release-action', {
            strapi
        });
        const deletedReleaseAction = await releaseActionService.delete(actionId, releaseId);
        ctx.body = {
            data: deletedReleaseAction
        };
    }
};

const SETTINGS_SCHEMA = yup__namespace.object().shape({
    defaultTimezone: yup__namespace.string().nullable().default(null)
}).required().noUnknown();
const validateSettings = utils.validateYupSchema(SETTINGS_SCHEMA);

const settingsController = {
    async find (ctx) {
        // Get settings
        const settingsService = getService('settings', {
            strapi
        });
        const settings = await settingsService.find();
        // Response
        ctx.body = {
            data: settings
        };
    },
    async update (ctx) {
        // Data validation
        const settingsBody = ctx.request.body;
        const settings = await validateSettings(settingsBody);
        // Update
        const settingsService = getService('settings', {
            strapi
        });
        const updatedSettings = await settingsService.update({
            settings
        });
        // Response
        ctx.body = {
            data: updatedSettings
        };
    }
};

const controllers = {
    release: releaseController,
    'release-action': releaseActionController,
    settings: settingsController
};

var release = {
    type: 'admin',
    routes: [
        {
            method: 'GET',
            path: '/mapEntriesToReleases',
            handler: 'release.mapEntriesToReleases',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-releases.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/getByDocumentAttached',
            handler: 'release.findByDocumentAttached',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-releases.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/',
            handler: 'release.create',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-releases.create'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/',
            handler: 'release.findPage',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-releases.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/:id',
            handler: 'release.findOne',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-releases.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'PUT',
            path: '/:id',
            handler: 'release.update',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-releases.update'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'DELETE',
            path: '/:id',
            handler: 'release.delete',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-releases.delete'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/:id/publish',
            handler: 'release.publish',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-releases.publish'
                            ]
                        }
                    }
                ]
            }
        }
    ]
};

var releaseAction = {
    type: 'admin',
    routes: [
        {
            method: 'POST',
            path: '/:releaseId/actions',
            handler: 'release-action.create',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-releases.create-action'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/:releaseId/actions/bulk',
            handler: 'release-action.createMany',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-releases.create-action'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/:releaseId/actions',
            handler: 'release-action.findMany',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-releases.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'PUT',
            path: '/:releaseId/actions/:actionId',
            handler: 'release-action.update',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-releases.update'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'DELETE',
            path: '/:releaseId/actions/:actionId',
            handler: 'release-action.delete',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-releases.delete-action'
                            ]
                        }
                    }
                ]
            }
        }
    ]
};

var settings = {
    type: 'admin',
    routes: [
        {
            method: 'GET',
            path: '/settings',
            handler: 'settings.find',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-releases.settings.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'PUT',
            path: '/settings',
            handler: 'settings.update',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-releases.settings.update'
                            ]
                        }
                    }
                ]
            }
        }
    ]
};

const routes = {
    settings,
    release,
    'release-action': releaseAction
};

const getPlugin = ()=>{
    if (strapi.ee.features.isEnabled('cms-content-releases')) {
        return {
            register,
            bootstrap,
            destroy,
            contentTypes,
            services,
            controllers,
            routes
        };
    }
    return {
        // Always return register, it handles its own feature check
        register,
        // Always return contentTypes to avoid losing data when the feature is disabled
        contentTypes
    };
};
var index = getPlugin();

module.exports = index;
//# sourceMappingURL=index.js.map
