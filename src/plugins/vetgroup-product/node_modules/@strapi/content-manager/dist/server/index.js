'use strict';

var strapiUtils = require('@strapi/utils');
var fp = require('lodash/fp');
require('@strapi/types');
var yup = require('yup');
var nodeSchedule = require('node-schedule');
var isNil = require('lodash/isNil');
var _ = require('lodash');
var qs = require('qs');
var slugify = require('@sindresorhus/slugify');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var yup__namespace = /*#__PURE__*/_interopNamespaceDefault(yup);

const getService$2 = (name)=>{
    return strapi.plugin('content-manager').service(name);
};

function getService$1(strapi, name) {
    // Cast is needed because the return type of strapi.service is too vague
    return strapi.service(`plugin::content-manager.${name}`);
}

const historyRestoreVersionSchema = yup__namespace.object().shape({
    contentType: yup__namespace.string().trim().required()
}).required();
const validateRestoreVersion = strapiUtils.validateYupSchema(historyRestoreVersionSchema);

/**
 * Parses pagination params and makes sure they're within valid ranges
 */ const getValidPagination = ({ page, pageSize })=>{
    let pageNumber = 1;
    let pageSizeNumber = 20;
    if (page) {
        const parsedPage = parseInt(page, 10);
        pageNumber = parseInt(page, 10);
        if (!Number.isNaN(parsedPage) && parsedPage >= 1) {
            pageNumber = parsedPage;
        }
    }
    if (pageSize) {
        const parsedPageSize = parseInt(pageSize, 10);
        if (!Number.isNaN(parsedPageSize) && parsedPageSize >= 1 && parsedPageSize <= 100) {
            pageSizeNumber = parsedPageSize;
        }
    }
    return {
        page: pageNumber,
        pageSize: pageSizeNumber
    };
};
const createHistoryVersionController = ({ strapi })=>{
    return {
        async findMany (ctx) {
            const contentTypeUid = ctx.query.contentType;
            const isSingleType = strapi.getModel(contentTypeUid)?.kind === 'singleType';
            if (isSingleType && !contentTypeUid) {
                throw new strapiUtils.errors.ForbiddenError('contentType is required');
            }
            if (!isSingleType && (!contentTypeUid || !ctx.query.documentId)) {
                throw new strapiUtils.errors.ForbiddenError('contentType and documentId are required');
            }
            /**
       * There are no permissions specifically for history versions,
       * but we need to check that the user can read the content type
       */ const permissionChecker = getService$2('permission-checker').create({
                userAbility: ctx.state.userAbility,
                model: ctx.query.contentType
            });
            if (permissionChecker.cannot.read()) {
                return ctx.forbidden();
            }
            const query = await permissionChecker.sanitizeQuery(ctx.query);
            const { results, pagination } = await getService$1(strapi, 'history').findVersionsPage({
                query: {
                    ...query,
                    ...getValidPagination({
                        page: query.page,
                        pageSize: query.pageSize
                    })
                },
                state: {
                    userAbility: ctx.state.userAbility
                }
            });
            const sanitizedResults = await strapiUtils.async.map(results, async (version)=>{
                return {
                    ...version,
                    data: await permissionChecker.sanitizeOutput(version.data),
                    createdBy: version.createdBy ? fp.pick([
                        'id',
                        'firstname',
                        'lastname',
                        'username',
                        'email'
                    ], version.createdBy) : undefined
                };
            });
            return {
                data: sanitizedResults,
                meta: {
                    pagination
                }
            };
        },
        async restoreVersion (ctx) {
            const request = ctx.request;
            await validateRestoreVersion(request.body, 'contentType is required');
            const permissionChecker = getService$2('permission-checker').create({
                userAbility: ctx.state.userAbility,
                model: request.body.contentType
            });
            if (permissionChecker.cannot.update()) {
                throw new strapiUtils.errors.ForbiddenError();
            }
            const restoredDocument = await getService$1(strapi, 'history').restoreVersion(request.params.versionId);
            return {
                data: {
                    documentId: restoredDocument.documentId
                }
            };
        }
    };
};

const controllers$2 = {
    'history-version': createHistoryVersionController
};

const HISTORY_VERSION_UID = 'plugin::content-manager.history-version';
const FIELDS_TO_IGNORE = [
    'createdAt',
    'updatedAt',
    'publishedAt',
    'createdBy',
    'updatedBy',
    'strapi_stage',
    'strapi_assignee'
];

const DEFAULT_RETENTION_DAYS = 90;
const createServiceUtils = ({ strapi })=>{
    /**
   * @description
   * Get the difference between the version schema and the content type schema
   */ const getSchemaAttributesDiff = (versionSchemaAttributes, contentTypeSchemaAttributes)=>{
        // Omit the same fields that were omitted when creating a history version
        const sanitizedContentTypeSchemaAttributes = fp.omit(FIELDS_TO_IGNORE, contentTypeSchemaAttributes);
        const reduceDifferenceToAttributesObject = (diffKeys, source)=>{
            return diffKeys.reduce((previousAttributesObject, diffKey)=>{
                previousAttributesObject[diffKey] = source[diffKey];
                return previousAttributesObject;
            }, {});
        };
        const versionSchemaKeys = Object.keys(versionSchemaAttributes);
        const contentTypeSchemaAttributesKeys = Object.keys(sanitizedContentTypeSchemaAttributes);
        // The attribute is new if it's on the content type schema but not on the version schema
        const uniqueToContentType = fp.difference(contentTypeSchemaAttributesKeys, versionSchemaKeys);
        const added = reduceDifferenceToAttributesObject(uniqueToContentType, sanitizedContentTypeSchemaAttributes);
        // The attribute was removed or renamed if it's on the version schema but not on the content type schema
        const uniqueToVersion = fp.difference(versionSchemaKeys, contentTypeSchemaAttributesKeys);
        const removed = reduceDifferenceToAttributesObject(uniqueToVersion, versionSchemaAttributes);
        return {
            added,
            removed
        };
    };
    /**
   * @description
   * Gets the value to set for a relation when restoring a document
   * @returns
   * The relation if it exists or null
   */ const getRelationRestoreValue = async (versionRelationData, attribute)=>{
        if (Array.isArray(versionRelationData)) {
            if (versionRelationData.length === 0) return versionRelationData;
            const existingAndMissingRelations = await Promise.all(versionRelationData.map((relation)=>{
                return strapi.documents(attribute.target).findOne({
                    documentId: relation.documentId,
                    locale: relation.locale || undefined
                });
            }));
            return existingAndMissingRelations.filter((relation)=>relation !== null);
        }
        return strapi.documents(attribute.target).findOne({
            documentId: versionRelationData.documentId,
            locale: versionRelationData.locale || undefined
        });
    };
    /**
   * @description
   * Gets the value to set for a media asset when restoring a document
   * @returns
   * The media asset if it exists or null
   */ const getMediaRestoreValue = async (versionRelationData)=>{
        if (Array.isArray(versionRelationData)) {
            const existingAndMissingMedias = await Promise.all(versionRelationData.map((media)=>{
                return strapi.db.query('plugin::upload.file').findOne({
                    where: {
                        id: media.id
                    }
                });
            }));
            return existingAndMissingMedias.filter((media)=>media != null);
        }
        return strapi.db.query('plugin::upload.file').findOne({
            where: {
                id: versionRelationData.id
            }
        });
    };
    const localesService = strapi.plugin('i18n')?.service('locales');
    const i18nContentTypeService = strapi.plugin('i18n')?.service('content-types');
    const getDefaultLocale = async ()=>localesService ? localesService.getDefaultLocale() : null;
    const isLocalizedContentType = (model)=>i18nContentTypeService ? i18nContentTypeService.isLocalizedContentType(model) : false;
    /**
   *
   * @description
   * Creates a dictionary of all locales available
   */ const getLocaleDictionary = async ()=>{
        if (!localesService) return {};
        const locales = await localesService.find() || [];
        return locales.reduce((acc, locale)=>{
            acc[locale.code] = {
                name: locale.name,
                code: locale.code
            };
            return acc;
        }, {});
    };
    /**
   *
   * @description
   * Gets the number of retention days defined on the license or configured by the user
   */ const getRetentionDays = ()=>{
        const featureConfig = strapi.ee.features.get('cms-content-history');
        const licenseRetentionDays = typeof featureConfig === 'object' && featureConfig?.options.retentionDays;
        const userRetentionDays = strapi.config.get('admin.history.retentionDays');
        // Allow users to override the license retention days, but not to increase it
        if (userRetentionDays && userRetentionDays < licenseRetentionDays) {
            return userRetentionDays;
        }
        // User didn't provide retention days value, use the license or fallback to default
        return Math.min(licenseRetentionDays, DEFAULT_RETENTION_DAYS);
    };
    const getVersionStatus = async (contentTypeUid, document)=>{
        const documentMetadataService = strapi.plugin('content-manager').service('document-metadata');
        const meta = await documentMetadataService.getMetadata(contentTypeUid, document);
        return documentMetadataService.getStatus(document, meta.availableStatus);
    };
    /**
   * Lists all the fields of a component, excepts those that will be populated.
   * The goal is to exclude the ID, because when restoring a component,
   * referencing an ID for a component db row that was deleted creates an error.
   * So we never store component IDs to ensure they're re-created while restoring a version.
   */ const getComponentFields = (componentUID)=>{
        return Object.entries(strapi.getModel(componentUID).attributes).reduce((fieldsAcc, [key, attribute])=>{
            if (![
                'relation',
                'media',
                'component',
                'dynamiczone'
            ].includes(attribute.type)) {
                fieldsAcc.push(key);
            }
            return fieldsAcc;
        }, []);
    };
    /**
   * @description
   * Creates a populate object that looks for all the relations that need
   * to be saved in history, and populates only the fields needed to later retrieve the content.
   *
   * @param uid - The content type UID
   * @param useDatabaseSyntax - Whether to use the database syntax for populate, defaults to false
   */ const getDeepPopulate = (uid, useDatabaseSyntax = false)=>{
        const model = strapi.getModel(uid);
        const attributes = Object.entries(model.attributes);
        const fieldSelector = useDatabaseSyntax ? 'select' : 'fields';
        return attributes.reduce((acc, [attributeName, attribute])=>{
            switch(attribute.type){
                case 'relation':
                    {
                        // TODO: Support polymorphic relations
                        const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');
                        if (isMorphRelation) {
                            break;
                        }
                        const isVisible = strapiUtils.contentTypes.isVisibleAttribute(model, attributeName);
                        if (isVisible) {
                            acc[attributeName] = {
                                [fieldSelector]: [
                                    'documentId',
                                    'locale',
                                    'publishedAt'
                                ]
                            };
                        }
                        break;
                    }
                case 'media':
                    {
                        acc[attributeName] = {
                            [fieldSelector]: [
                                'id'
                            ]
                        };
                        break;
                    }
                case 'component':
                    {
                        const populate = getDeepPopulate(attribute.component);
                        acc[attributeName] = {
                            populate,
                            [fieldSelector]: getComponentFields(attribute.component)
                        };
                        break;
                    }
                case 'dynamiczone':
                    {
                        // Use fragments to populate the dynamic zone components
                        const populatedComponents = (attribute.components || []).reduce((acc, componentUID)=>{
                            acc[componentUID] = {
                                populate: getDeepPopulate(componentUID),
                                [fieldSelector]: getComponentFields(componentUID)
                            };
                            return acc;
                        }, {});
                        acc[attributeName] = {
                            on: populatedComponents
                        };
                        break;
                    }
            }
            return acc;
        }, {});
    };
    /**
   * @description
   * Builds a response object for relations containing the related data and a count of missing relations
   */ const buildMediaResponse = async (values)=>{
        return values// Until we implement proper pagination, limit relations to an arbitrary amount
        .slice(0, 25).reduce(async (currentRelationDataPromise, entry)=>{
            const currentRelationData = await currentRelationDataPromise;
            // Entry can be null if it's a toOne relation
            if (!entry) {
                return currentRelationData;
            }
            const relatedEntry = await strapi.db.query('plugin::upload.file').findOne({
                where: {
                    id: entry.id
                }
            });
            if (relatedEntry) {
                currentRelationData.results.push(relatedEntry);
            } else {
                // The related content has been deleted
                currentRelationData.meta.missingCount += 1;
            }
            return currentRelationData;
        }, Promise.resolve({
            results: [],
            meta: {
                missingCount: 0
            }
        }));
    };
    /**
   * @description
   * Builds a response object for media containing the media assets data and a count of missing media assets
   */ const buildRelationReponse = async (values, attributeSchema)=>{
        return values// Until we implement proper pagination, limit relations to an arbitrary amount
        .slice(0, 25).reduce(async (currentRelationDataPromise, entry)=>{
            const currentRelationData = await currentRelationDataPromise;
            // Entry can be null if it's a toOne relation
            if (!entry) {
                return currentRelationData;
            }
            const relatedEntry = await strapi.documents(attributeSchema.target).findOne({
                documentId: entry.documentId,
                locale: entry.locale || undefined
            });
            if (relatedEntry) {
                currentRelationData.results.push({
                    ...relatedEntry,
                    status: await getVersionStatus(attributeSchema.target, relatedEntry)
                });
            } else {
                // The related content has been deleted
                currentRelationData.meta.missingCount += 1;
            }
            return currentRelationData;
        }, Promise.resolve({
            results: [],
            meta: {
                missingCount: 0
            }
        }));
    };
    return {
        getSchemaAttributesDiff,
        getRelationRestoreValue,
        getMediaRestoreValue,
        getDefaultLocale,
        isLocalizedContentType,
        getLocaleDictionary,
        getRetentionDays,
        getVersionStatus,
        getDeepPopulate,
        buildMediaResponse,
        buildRelationReponse
    };
};

const createHistoryService = ({ strapi })=>{
    const query = strapi.db.query(HISTORY_VERSION_UID);
    const serviceUtils = createServiceUtils({
        strapi
    });
    return {
        async createVersion (historyVersionData) {
            await query.create({
                data: {
                    ...historyVersionData,
                    createdAt: new Date(),
                    createdBy: strapi.requestContext.get()?.state?.user.id
                }
            });
        },
        async findVersionsPage (params) {
            const schema = strapi.getModel(params.query.contentType);
            const isLocalizedContentType = serviceUtils.isLocalizedContentType(schema);
            const defaultLocale = await serviceUtils.getDefaultLocale();
            let locale = null;
            if (isLocalizedContentType) {
                locale = params.query.locale || defaultLocale;
            }
            const [{ results, pagination }, localeDictionary] = await Promise.all([
                query.findPage({
                    ...params.query,
                    where: {
                        $and: [
                            {
                                contentType: params.query.contentType
                            },
                            ...params.query.documentId ? [
                                {
                                    relatedDocumentId: params.query.documentId
                                }
                            ] : [],
                            ...locale ? [
                                {
                                    locale
                                }
                            ] : []
                        ]
                    },
                    populate: [
                        'createdBy'
                    ],
                    orderBy: [
                        {
                            createdAt: 'desc'
                        }
                    ]
                }),
                serviceUtils.getLocaleDictionary()
            ]);
            const populateEntry = async (entry)=>{
                return strapiUtils.traverseEntity(async (options, utils)=>{
                    if (!options.attribute) return;
                    if (!options.value) return;
                    const currentValue = Array.isArray(options.value) ? options.value : [
                        options.value
                    ];
                    if (options.attribute.type === 'component') {
                        // Ids on components throw an error when restoring
                        utils.remove('id');
                    }
                    if (options.attribute.type === 'relation' && // TODO: handle polymorphic relations
                    options.attribute.relation !== 'morphToOne' && options.attribute.relation !== 'morphToMany') {
                        if (options.attribute.target === 'admin::user') {
                            const adminUsers = await Promise.all(currentValue.map((userToPopulate)=>{
                                if (userToPopulate == null) {
                                    return null;
                                }
                                return strapi.query('admin::user').findOne({
                                    where: {
                                        ...userToPopulate.id ? {
                                            id: userToPopulate.id
                                        } : {},
                                        ...userToPopulate.documentId ? {
                                            documentId: userToPopulate.documentId
                                        } : {}
                                    }
                                });
                            }));
                            utils.set(options.key, adminUsers);
                        }
                        const permissionChecker = getService$2('permission-checker').create({
                            userAbility: params.state.userAbility,
                            model: options.attribute.target
                        });
                        const response = await serviceUtils.buildRelationReponse(currentValue, options.attribute);
                        const sanitizedResults = await Promise.all(response.results.map((media)=>permissionChecker.sanitizeOutput(media)));
                        utils.set(options.key, {
                            results: sanitizedResults,
                            meta: response.meta
                        });
                    }
                    if (options.attribute.type === 'media') {
                        const permissionChecker = getService$2('permission-checker').create({
                            userAbility: params.state.userAbility,
                            model: 'plugin::upload.file'
                        });
                        const response = await serviceUtils.buildMediaResponse(currentValue);
                        const sanitizedResults = await Promise.all(response.results.map((media)=>permissionChecker.sanitizeOutput(media)));
                        utils.set(options.key, {
                            results: sanitizedResults,
                            meta: response.meta
                        });
                    }
                }, {
                    schema,
                    getModel: strapi.getModel.bind(strapi)
                }, entry.data);
            };
            const formattedResults = await Promise.all(results.map(async (result)=>{
                return {
                    ...result,
                    data: await populateEntry(result),
                    meta: {
                        unknownAttributes: serviceUtils.getSchemaAttributesDiff(result.schema, strapi.getModel(params.query.contentType).attributes)
                    },
                    locale: result.locale ? localeDictionary[result.locale] : null
                };
            }));
            return {
                results: formattedResults,
                pagination
            };
        },
        async restoreVersion (versionId) {
            const version = await query.findOne({
                where: {
                    id: versionId
                }
            });
            const contentTypeSchemaAttributes = strapi.getModel(version.contentType).attributes;
            const schemaDiff = serviceUtils.getSchemaAttributesDiff(version.schema, contentTypeSchemaAttributes);
            // Set all added attribute values to null
            const dataWithoutAddedAttributes = Object.keys(schemaDiff.added).reduce((currentData, addedKey)=>{
                currentData[addedKey] = null;
                return currentData;
            }, // Clone to avoid mutating the original version data
            structuredClone(version.data));
            // Remove the schema attributes history should ignore
            const schema = structuredClone(version.schema);
            schema.attributes = fp.omit(FIELDS_TO_IGNORE, contentTypeSchemaAttributes);
            const dataWithoutMissingRelations = await strapiUtils.traverseEntity(async (options, utils)=>{
                if (!options.attribute) return;
                if (options.attribute.type === 'component') {
                    // Ids on components throw an error when restoring
                    utils.remove('id');
                    if (options.attribute.repeatable && options.value === null) {
                        // Repeatable Components should always be an array
                        utils.set(options.key, []);
                    }
                }
                if (options.attribute.type === 'dynamiczone') {
                    if (options.value === null) {
                        // Dynamic zones should always be an array
                        utils.set(options.key, []);
                    }
                }
                if (options.attribute.type === 'relation' && // TODO: handle polymorphic relations
                options.attribute.relation !== 'morphToOne' && options.attribute.relation !== 'morphToMany') {
                    if (!options.value) return;
                    const data = await serviceUtils.getRelationRestoreValue(options.value, options.attribute);
                    utils.set(options.key, data);
                }
                if (options.attribute.type === 'media') {
                    if (!options.value) return;
                    const data = await serviceUtils.getMediaRestoreValue(options.value);
                    utils.set(options.key, data);
                }
            }, {
                schema,
                getModel: strapi.getModel.bind(strapi)
            }, dataWithoutAddedAttributes);
            const data = fp.omit([
                'id',
                ...Object.keys(schemaDiff.removed)
            ], dataWithoutMissingRelations);
            const restoredDocument = await strapi.documents(version.contentType).update({
                documentId: version.relatedDocumentId,
                locale: version.locale,
                data
            });
            if (!restoredDocument) {
                throw new strapiUtils.errors.ApplicationError('Failed to restore version');
            }
            return restoredDocument;
        }
    };
};

/**
 * Filters out actions that should not create a history version.
 */ const shouldCreateHistoryVersion = (context)=>{
    // Ignore requests that are not related to the content manager
    if (!strapi.requestContext.get()?.request.url.startsWith('/content-manager')) {
        return false;
    }
    // NOTE: cannot do type narrowing with array includes
    if (context.action !== 'create' && context.action !== 'update' && context.action !== 'clone' && context.action !== 'publish' && context.action !== 'unpublish' && context.action !== 'discardDraft') {
        return false;
    }
    /**
   * When a document is published, the draft version of the document is also updated.
   * It creates confusion for users because they see two history versions each publish action.
   * To avoid this, we silence the update action during a publish request,
   * so that they only see the published version of the document in the history.
   */ if (context.action === 'update' && strapi.requestContext.get()?.request.url.endsWith('/actions/publish')) {
        return false;
    }
    // Ignore content types not created by the user
    if (!context.contentType.uid.startsWith('api::')) {
        return false;
    }
    return true;
};
/**
 * Returns the content type schema (and its components schemas).
 * Used to determine if changes were made in the content type builder since a history version was created.
 * And therefore which fields can be restored and which cannot.
 */ const getSchemas = (uid)=>{
    const attributesSchema = strapi.getModel(uid).attributes;
    // TODO: Handle nested components
    const componentsSchemas = Object.keys(attributesSchema).reduce((currentComponentSchemas, key)=>{
        const fieldSchema = attributesSchema[key];
        if (fieldSchema.type === 'component') {
            const componentSchema = strapi.getModel(fieldSchema.component).attributes;
            return {
                ...currentComponentSchemas,
                [fieldSchema.component]: componentSchema
            };
        }
        // Ignore anything that's not a component
        return currentComponentSchemas;
    }, {});
    return {
        schema: fp.omit(FIELDS_TO_IGNORE, attributesSchema),
        componentsSchemas
    };
};
const createLifecyclesService = ({ strapi: strapi1 })=>{
    const state = {
        deleteExpiredJob: null,
        isInitialized: false
    };
    const serviceUtils = createServiceUtils({
        strapi: strapi1
    });
    return {
        async bootstrap () {
            // Prevent initializing the service twice
            if (state.isInitialized) {
                return;
            }
            strapi1.documents.use(async (context, next)=>{
                const result = await next();
                if (!shouldCreateHistoryVersion(context)) {
                    return result;
                }
                // On create/clone actions, the documentId is not available before creating the action is executed
                const documentId = context.action === 'create' || context.action === 'clone' ? result.documentId : context.params.documentId;
                // Apply default locale if not available in the request
                const defaultLocale = await serviceUtils.getDefaultLocale();
                const locales = fp.castArray(context.params?.locale || defaultLocale);
                if (!locales.length) {
                    return result;
                }
                // All schemas related to the content type
                const uid = context.contentType.uid;
                const schemas = getSchemas(uid);
                const model = strapi1.getModel(uid);
                const isLocalizedContentType = serviceUtils.isLocalizedContentType(model);
                // Find all affected entries
                const localeEntries = await strapi1.db.query(uid).findMany({
                    where: {
                        documentId,
                        ...isLocalizedContentType ? {
                            locale: {
                                $in: locales
                            }
                        } : {},
                        ...strapiUtils.contentTypes.hasDraftAndPublish(strapi1.contentTypes[uid]) ? {
                            publishedAt: null
                        } : {}
                    },
                    populate: serviceUtils.getDeepPopulate(uid, true)
                });
                await strapi1.db.transaction(async ({ onCommit })=>{
                    // .createVersion() is executed asynchronously,
                    // onCommit prevents creating a history version
                    // when the transaction has already been committed
                    onCommit(async ()=>{
                        for (const entry of localeEntries){
                            const status = await serviceUtils.getVersionStatus(uid, entry);
                            await getService$1(strapi1, 'history').createVersion({
                                contentType: uid,
                                data: fp.omit(FIELDS_TO_IGNORE, entry),
                                relatedDocumentId: documentId,
                                locale: entry.locale,
                                status,
                                ...schemas
                            });
                        }
                    });
                });
                return result;
            });
            // Schedule a job to delete expired history versions every day at midnight
            state.deleteExpiredJob = nodeSchedule.scheduleJob('historyDaily', '0 0 * * *', ()=>{
                const retentionDaysInMilliseconds = serviceUtils.getRetentionDays() * 24 * 60 * 60 * 1000;
                const expirationDate = new Date(Date.now() - retentionDaysInMilliseconds);
                strapi1.db.query(HISTORY_VERSION_UID).deleteMany({
                    where: {
                        created_at: {
                            $lt: expirationDate
                        }
                    }
                }).catch((error)=>{
                    if (error instanceof Error) {
                        strapi1.log.error('Error deleting expired history versions', error.message);
                    }
                });
            });
            state.isInitialized = true;
        },
        async destroy () {
            if (state.deleteExpiredJob) {
                state.deleteExpiredJob.cancel();
            }
        }
    };
};

const services$2 = {
    history: createHistoryService,
    lifecycles: createLifecyclesService
};

const info$1 = {
    pluginName: 'content-manager',
    type: 'admin'
};
const historyVersionRouter = {
    type: 'admin',
    routes: [
        {
            method: 'GET',
            info: info$1,
            path: '/history-versions',
            handler: 'history-version.findMany',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin'
                ]
            }
        },
        {
            method: 'PUT',
            info: info$1,
            path: '/history-versions/:versionId/restore',
            handler: 'history-version.restoreVersion',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin'
                ]
            }
        }
    ]
};

/**
 * The routes will me merged with the other Content Manager routers,
 * so we need to avoid conficts in the router name, and to prefix the path for each route.
 */ const routes$2 = {
    'history-version': historyVersionRouter
};

const historyVersion = {
    uid: HISTORY_VERSION_UID,
    tableName: 'strapi_history_versions',
    singularName: 'history-version',
    attributes: {
        id: {
            type: 'increments'
        },
        contentType: {
            type: 'string',
            column: {
                notNullable: true
            }
        },
        relatedDocumentId: {
            type: 'string',
            // TODO: notNullable should be true once history can record publish actions
            column: {
                notNullable: false
            }
        },
        locale: {
            type: 'string'
        },
        status: {
            type: 'enumeration',
            enum: [
                'draft',
                'published',
                'modified'
            ]
        },
        data: {
            type: 'json'
        },
        schema: {
            type: 'json'
        },
        createdAt: {
            type: 'datetime',
            default: ()=>new Date()
        },
        // FIXME: joinTable should be optional
        // @ts-expect-error database model is not yet updated to support useJoinTable
        createdBy: {
            type: 'relation',
            relation: 'oneToOne',
            target: 'admin::user',
            useJoinTable: false
        }
    }
};

/**
 * Check once if the feature is enabled before loading it,
 * so that we can assume it is enabled in the other files.
 */ const getFeature$1 = ()=>{
    if (strapi.ee.features.isEnabled('cms-content-history')) {
        return {
            register ({ strapi: strapi1 }) {
                strapi1.get('models').add(historyVersion);
            },
            bootstrap ({ strapi: strapi1 }) {
                // Start recording history and saving history versions
                getService$1(strapi1, 'lifecycles').bootstrap();
            },
            destroy ({ strapi: strapi1 }) {
                getService$1(strapi1, 'lifecycles').destroy();
            },
            controllers: controllers$2,
            services: services$2,
            routes: routes$2
        };
    }
    /**
   * Keep registering the model to avoid losing the data if the feature is disabled,
   * or if the license expires.
   */ return {
        register ({ strapi: strapi1 }) {
            strapi1.get('models').add(historyVersion);
        }
    };
};
var history = getFeature$1();

const info = {
    pluginName: 'content-manager',
    type: 'admin'
};
const previewRouter = {
    type: 'admin',
    routes: [
        {
            method: 'GET',
            info,
            path: '/preview/url/:contentType',
            handler: 'preview.getPreviewUrl',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin'
                ]
            }
        }
    ]
};

/**
 * The routes will be merged with the other Content Manager routers,
 * so we need to avoid conficts in the router name, and to prefix the path for each route.
 */ const routes$1 = {
    preview: previewRouter
};

function getService(strapi, name) {
    // Cast is needed because the return type of strapi.service is too vague
    return strapi.service(`plugin::content-manager.${name}`);
}

const getPreviewUrlSchema = yup__namespace.object().shape({
    // Will be undefined for single types
    documentId: yup__namespace.string(),
    locale: yup__namespace.string().nullable(),
    status: yup__namespace.string()
}).required();
const validatePreviewUrl = async (strapi, uid, params)=>{
    // Validate the request parameters format
    await strapiUtils.validateYupSchema(getPreviewUrlSchema)(params);
    const newParams = fp.pick([
        'documentId',
        'locale',
        'status'
    ], params);
    const model = strapi.getModel(uid);
    // If it's not a collection type or single type
    if (!model || model.modelType !== 'contentType') {
        throw new strapiUtils.errors.ValidationError('Invalid content type');
    }
    // Document id is not required for single types
    const isSingleType = model?.kind === 'singleType';
    if (!isSingleType && !params.documentId) {
        throw new strapiUtils.errors.ValidationError('documentId is required for Collection Types');
    }
    // Fill the documentId if it's a single type
    if (isSingleType) {
        const doc = await strapi.documents(uid).findFirst();
        if (!doc) {
            throw new strapiUtils.errors.NotFoundError('Document not found');
        }
        newParams.documentId = doc?.documentId;
    }
    /**
   * If status is not specified, follow the following rules:
   * - D&P disabled: status is considered published
   * - D&P enabled: status is considered draft
   */ if (!newParams.status) {
        const isDPEnabled = model?.options?.draftAndPublish;
        newParams.status = isDPEnabled ? 'draft' : 'published';
    }
    return newParams;
};

const createPreviewController = ()=>{
    return {
        /**
     * Transforms an entry into a preview URL, so that it can be previewed
     * in the Content Manager.
     */ async getPreviewUrl (ctx) {
            const uid = ctx.params.contentType;
            const query = ctx.request.query;
            // Validate the request parameters
            const params = await validatePreviewUrl(strapi, uid, query);
            // TODO: Permissions to preview content
            // Get the preview URL by using the user-defined config handler
            const previewService = getService(strapi, 'preview');
            const url = await previewService.getPreviewUrl(uid, params);
            // If no url is found, set status to 204
            if (!url) {
                ctx.status = 204;
            }
            return {
                data: {
                    url
                }
            };
        }
    };
};

const controllers$1 = {
    preview: createPreviewController
};

/**
 * Responsible of routing an entry to a preview URL.
 */ const createPreviewService = ({ strapi })=>{
    const config = getService(strapi, 'preview-config');
    return {
        async getPreviewUrl (uid, params) {
            const handler = config.getPreviewHandler();
            try {
                // Try to get the preview URL from the user-defined handler
                return handler(uid, params);
            } catch (error) {
                // Log the error and throw a generic error
                strapi.log.error(`Failed to get preview URL: ${error}`);
                throw new strapiUtils.errors.ApplicationError('Failed to get preview URL');
            }
            return;
        }
    };
};

/**
 * Utility to extend Strapi configuration middlewares. Mainly used to extend the CSP directives from the security middleware.
 */ const extendMiddlewareConfiguration = (middleware = {
    name: '',
    config: {}
})=>{
    const middlewares = strapi.config.get('middlewares');
    const configuredMiddlewares = middlewares.map((currentMiddleware)=>{
        if (currentMiddleware === middleware.name) {
            // Use the new config object if the middleware has no config property yet
            return middleware;
        }
        // @ts-expect-error - currentMiddleware is not a string
        if (currentMiddleware.name === middleware.name) {
            // Deep merge (+ concat arrays) the new config with the current middleware config
            return fp.mergeWith((objValue, srcValue)=>{
                if (Array.isArray(objValue)) {
                    return objValue.concat(srcValue);
                }
                return undefined;
            }, currentMiddleware, middleware);
        }
        return currentMiddleware;
    });
    strapi.config.set('middlewares', configuredMiddlewares);
};
/**
 * Read configuration for static preview
 */ const createPreviewConfigService = ({ strapi: strapi1 })=>{
    return {
        register () {
            if (!this.isEnabled()) {
                return;
            }
            const config = strapi1.config.get('admin.preview');
            /**
       * Register the allowed origins for CSP, so the preview URL can be displayed
       */ if (config.config?.allowedOrigins) {
                extendMiddlewareConfiguration({
                    name: 'strapi::security',
                    config: {
                        contentSecurityPolicy: {
                            directives: {
                                'frame-src': config.config.allowedOrigins
                            }
                        }
                    }
                });
            }
        },
        isEnabled () {
            const config = strapi1.config.get('admin.preview');
            if (!config) {
                return false;
            }
            return config?.enabled ?? true;
        },
        /**
     * Validate if the configuration is valid
     */ validate () {
            if (!this.isEnabled()) {
                return;
            }
            const handler = this.getPreviewHandler();
            // Handler must be a function
            if (typeof handler !== 'function') {
                throw new strapiUtils.errors.ValidationError('Preview configuration is invalid. Handler must be a function');
            }
        },
        /**
     * Utility to get the preview handler from the configuration
     */ getPreviewHandler () {
            const config = strapi1.config.get('admin.preview');
            const emptyHandler = ()=>{
                return undefined;
            };
            if (!this.isEnabled()) {
                return emptyHandler;
            }
            return config?.config?.handler || emptyHandler;
        }
    };
};

const services$1 = {
    preview: createPreviewService,
    'preview-config': createPreviewConfigService
};

/**
 * Check once if the feature is enabled before loading it,
 * so that we can assume it is enabled in the other files.
 */ const getFeature = ()=>{
    return {
        register () {
            const config = getService(strapi, 'preview-config');
            config.validate();
            config.register();
        },
        bootstrap () {},
        routes: routes$1,
        controllers: controllers$1,
        services: services$1
    };
};
var preview = getFeature();

const register = async ({ strapi })=>{
    await history.register?.({
        strapi
    });
    await preview.register?.({
        strapi
    });
};

const ALLOWED_WEBHOOK_EVENTS = {
    ENTRY_PUBLISH: 'entry.publish',
    ENTRY_UNPUBLISH: 'entry.unpublish'
};

var bootstrap = (async ()=>{
    Object.entries(ALLOWED_WEBHOOK_EVENTS).forEach(([key, value])=>{
        strapi.get('webhookStore').addAllowedEvent(key, value);
    });
    getService$2('field-sizes').setCustomFieldInputSizes();
    await getService$2('components').syncConfigurations();
    await getService$2('content-types').syncConfigurations();
    await getService$2('permission').registerPermissions();
    await history.bootstrap?.({
        strapi
    });
    await preview.bootstrap?.({
        strapi
    });
});

const destroy = async ({ strapi })=>{
    await history.destroy?.({
        strapi
    });
};

var routing = (async (ctx, next)=>{
    const { model } = ctx.params;
    const ct = strapi.contentTypes[model];
    if (!ct) {
        return ctx.send({
            error: 'contentType.notFound'
        }, 404);
    }
    let controllers;
    if (!ct.plugin || ct.plugin === 'admin') {
        controllers = strapi.admin.controllers;
    } else {
        controllers = strapi.plugin(ct.plugin).controllers;
    }
    const { route } = ctx.state;
    if (typeof route.handler !== 'string') {
        return next();
    }
    const [, action] = route.handler.split('.');
    let actionConfig;
    if (!ct.plugin || ct.plugin === 'admin') {
        actionConfig = strapi.config.get(`admin.layout.${ct.modelName}.actions.${action}`);
    } else {
        actionConfig = strapi.plugin(ct.plugin).config(`layout.${ct.modelName}.actions.${action}`);
    }
    if (!isNil(actionConfig)) {
        const [controller, action] = actionConfig.split('.');
        if (controller && action) {
            return controllers[controller.toLowerCase()][action](ctx, next);
        }
    }
    await next();
});

var admin = {
    type: 'admin',
    routes: [
        {
            method: 'GET',
            path: '/init',
            handler: 'init.getInitData',
            config: {
                policies: []
            }
        },
        {
            method: 'GET',
            path: '/content-types',
            handler: 'content-types.findContentTypes',
            config: {
                policies: []
            }
        },
        {
            method: 'GET',
            path: '/content-types-settings',
            handler: 'content-types.findContentTypesSettings',
            config: {
                policies: []
            }
        },
        {
            method: 'GET',
            path: '/content-types/:uid/configuration',
            handler: 'content-types.findContentTypeConfiguration',
            config: {
                policies: []
            }
        },
        {
            method: 'PUT',
            path: '/content-types/:uid/configuration',
            handler: 'content-types.updateContentTypeConfiguration',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin'
                ]
            }
        },
        {
            method: 'GET',
            path: '/components',
            handler: 'components.findComponents',
            config: {
                policies: []
            }
        },
        {
            method: 'GET',
            path: '/components/:uid/configuration',
            handler: 'components.findComponentConfiguration',
            config: {
                policies: []
            }
        },
        {
            method: 'PUT',
            path: '/components/:uid/configuration',
            handler: 'components.updateComponentConfiguration',
            config: {
                policies: []
            }
        },
        {
            method: 'POST',
            path: '/uid/generate',
            handler: 'uid.generateUID',
            config: {
                policies: []
            }
        },
        {
            method: 'POST',
            path: '/uid/check-availability',
            handler: 'uid.checkUIDAvailability',
            config: {
                policies: []
            }
        },
        {
            method: 'GET',
            path: '/relations/:model/:targetField',
            handler: 'relations.findAvailable',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin'
                ]
            }
        },
        {
            method: 'GET',
            path: '/relations/:model/:id/:targetField',
            handler: 'relations.findExisting',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin'
                ]
            }
        },
        {
            method: 'GET',
            path: '/single-types/:model',
            handler: 'single-types.find',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'PUT',
            path: '/single-types/:model',
            handler: 'single-types.createOrUpdate',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.create',
                                'plugin::content-manager.explorer.update'
                            ],
                            hasAtLeastOne: true
                        }
                    }
                ]
            }
        },
        {
            method: 'DELETE',
            path: '/single-types/:model',
            handler: 'single-types.delete',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.delete'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/single-types/:model/actions/publish',
            handler: 'single-types.publish',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.publish'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/single-types/:model/actions/unpublish',
            handler: 'single-types.unpublish',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.publish'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/single-types/:model/actions/discard',
            handler: 'single-types.discard',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.update'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/single-types/:model/actions/countDraftRelations',
            handler: 'single-types.countDraftRelations',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/collection-types/:model',
            handler: 'collection-types.find',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/collection-types/:model',
            handler: 'collection-types.create',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.create'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/collection-types/:model/clone/:sourceId',
            handler: 'collection-types.clone',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.create'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/collection-types/:model/auto-clone/:sourceId',
            handler: 'collection-types.autoClone',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.create'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/collection-types/:model/:id',
            handler: 'collection-types.findOne',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'PUT',
            path: '/collection-types/:model/:id',
            handler: 'collection-types.update',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.update'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'DELETE',
            path: '/collection-types/:model/:id',
            handler: 'collection-types.delete',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.delete'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/collection-types/:model/actions/publish',
            handler: 'collection-types.publish',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.publish'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/collection-types/:model/:id/actions/publish',
            handler: 'collection-types.publish',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.publish'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/collection-types/:model/:id/actions/unpublish',
            handler: 'collection-types.unpublish',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.publish'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/collection-types/:model/:id/actions/discard',
            handler: 'collection-types.discard',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.update'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/collection-types/:model/actions/bulkDelete',
            handler: 'collection-types.bulkDelete',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.delete'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/collection-types/:model/actions/bulkPublish',
            handler: 'collection-types.bulkPublish',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.publish'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'POST',
            path: '/collection-types/:model/actions/bulkUnpublish',
            handler: 'collection-types.bulkUnpublish',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.publish'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/collection-types/:model/:id/actions/countDraftRelations',
            handler: 'collection-types.countDraftRelations',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/collection-types/:model/actions/countManyEntriesDraftRelations',
            handler: 'collection-types.countManyEntriesDraftRelations',
            config: {
                middlewares: [
                    routing
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'plugin::content-manager.hasPermissions',
                        config: {
                            actions: [
                                'plugin::content-manager.explorer.read'
                            ]
                        }
                    }
                ]
            }
        }
    ]
};

var routes = {
    admin,
    ...history.routes ? history.routes : {},
    ...preview.routes ? preview.routes : {}
};

const hasPermissionsSchema = strapiUtils.yup.object({
    actions: strapiUtils.yup.array().of(strapiUtils.yup.string()),
    hasAtLeastOne: strapiUtils.yup.boolean()
});
const validateHasPermissionsInput = strapiUtils.validateYupSchemaSync(hasPermissionsSchema);

const { createPolicy } = strapiUtils.policy;
var hasPermissions = createPolicy({
    name: 'plugin::content-manager.hasPermissions',
    validator: validateHasPermissionsInput,
    /**
   * NOTE: Action aliases are currently not checked at this level (policy).
   *       This is currently the intended behavior to avoid changing the behavior of API related permissions.
   *       If you want to add support for it, please create a dedicated RFC with a list of potential side effect this could have.
   */ handler (ctx, config = {}) {
        const { actions = [], hasAtLeastOne = false } = config;
        const { userAbility } = ctx.state;
        const { model } = ctx.params;
        const isAuthorized = hasAtLeastOne ? actions.some((action)=>userAbility.can(action, model)) : actions.every((action)=>userAbility.can(action, model));
        return isAuthorized;
    }
});

var policies = {
    hasPermissions
};

const { getNonVisibleAttributes, getWritableAttributes } = strapiUtils.contentTypes;
const { PUBLISHED_AT_ATTRIBUTE: PUBLISHED_AT_ATTRIBUTE$3, CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = strapiUtils.contentTypes.constants;
const NON_SORTABLES = [
    'component',
    'json',
    'media',
    'richtext',
    'dynamiczone',
    'blocks'
];
const SORTABLE_RELATIONS = [
    'oneToOne',
    'manyToOne'
];
const NON_LISTABLES = [
    'json',
    'password',
    'richtext',
    'dynamiczone',
    'blocks'
];
const LISTABLE_RELATIONS = [
    'oneToOne',
    'oneToMany',
    'manyToOne',
    'manyToMany'
];
// hidden fields are fields that are configured to be hidden from list, and edit views
const isHidden = (schema, name)=>{
    if (!_.has(schema.attributes, name)) {
        return false;
    }
    const isHidden = _.get(schema, [
        'config',
        'attributes',
        name,
        'hidden'
    ], false);
    if (isHidden === true) {
        return true;
    }
    return false;
};
const isListable = (schema, name)=>{
    if (!_.has(schema.attributes, name)) {
        return false;
    }
    if (isHidden(schema, name)) {
        return false;
    }
    const attribute = schema.attributes[name];
    if (NON_LISTABLES.includes(attribute.type)) {
        return false;
    }
    if (isRelation$1(attribute) && !LISTABLE_RELATIONS.includes(attribute.relationType)) {
        return false;
    }
    return true;
};
const isSortable = (schema, name)=>{
    if (!_.has(schema.attributes, name)) {
        return false;
    }
    if (schema.modelType === 'component' && name === 'id') return false;
    const attribute = schema.attributes[name];
    if (NON_SORTABLES.includes(attribute.type)) {
        return false;
    }
    if (isRelation$1(attribute) && !SORTABLE_RELATIONS.includes(attribute.relationType)) {
        return false;
    }
    return true;
};
const isSearchable = (schema, name)=>{
    return isSortable(schema, name);
};
const isVisible$1 = (schema, name)=>{
    if (!_.has(schema.attributes, name)) {
        return false;
    }
    if (isHidden(schema, name)) {
        return false;
    }
    if (isTimestamp(schema, name) || name === 'id') {
        return false;
    }
    if (isPublicationField(name)) {
        return false;
    }
    if (isCreatorField(schema, name)) {
        return false;
    }
    return true;
};
const isPublicationField = (name)=>PUBLISHED_AT_ATTRIBUTE$3 === name;
const isTimestamp = (schema, name)=>{
    if (!_.has(schema.attributes, name)) {
        return false;
    }
    const timestamps = strapiUtils.contentTypes.getTimestamps(schema);
    if (!timestamps || !Array.isArray(timestamps)) {
        return false;
    }
    if (timestamps.includes(name)) {
        return true;
    }
};
const isCreatorField = (schema, name)=>{
    if (!_.has(schema.attributes, name)) {
        return false;
    }
    const creatorFields = strapiUtils.contentTypes.getCreatorFields(schema);
    if (!creatorFields || !Array.isArray(creatorFields)) {
        return false;
    }
    if (creatorFields.includes(name)) {
        return true;
    }
};
const isRelation$1 = (attribute)=>attribute.type === 'relation';
const hasRelationAttribute = (schema, name)=>{
    if (!_.has(schema.attributes, name)) {
        return false;
    }
    if (isHidden(schema, name)) {
        return false;
    }
    if (!isVisible$1(schema, name)) {
        return false;
    }
    return isRelation$1(schema.attributes[name]);
};
const hasEditableAttribute = (schema, name)=>{
    if (!_.has(schema.attributes, name)) {
        return false;
    }
    if (isHidden(schema, name)) {
        return false;
    }
    if (!isVisible$1(schema, name)) {
        return false;
    }
    return true;
};
const findFirstStringAttribute = (schema)=>{
    return Object.keys(schema.attributes || {}).find((key)=>{
        const { type } = schema.attributes[key];
        return type === 'string' && key !== 'id';
    });
};
const getDefaultMainField = (schema)=>findFirstStringAttribute(schema) || 'id';
/**
 * Returns list of all sortable attributes for a given content type schema
 * TODO V5: Refactor non visible fields to be a part of content-manager schema so we can use isSortable instead
 * @param {*} schema
 * @returns
 */ const getSortableAttributes = (schema)=>{
    const validAttributes = Object.keys(schema.attributes).filter((key)=>isListable(schema, key));
    const model = strapi.getModel(schema.uid);
    const nonVisibleWritableAttributes = fp.intersection(getNonVisibleAttributes(model), getWritableAttributes(model));
    return [
        'id',
        ...validAttributes,
        ...nonVisibleWritableAttributes,
        CREATED_BY_ATTRIBUTE,
        UPDATED_BY_ATTRIBUTE
    ];
};

/** General settings */ const DEFAULT_SETTINGS = {
    bulkable: true,
    filterable: true,
    searchable: true,
    pageSize: 10
};
const settingsFields = [
    'searchable',
    'filterable',
    'bulkable',
    'pageSize',
    'mainField',
    'defaultSortBy',
    'defaultSortOrder'
];
const getModelSettings = fp.pipe([
    fp.propOr({}, 'config.settings'),
    fp.pick(settingsFields)
]);
async function isValidDefaultSort(schema, value) {
    const parsedValue = qs.parse(value);
    const omitNonSortableAttributes = ({ schema, key }, { remove })=>{
        const sortableAttributes = getSortableAttributes(schema);
        if (!sortableAttributes.includes(key)) {
            remove(key);
        }
    };
    const sanitizedValue = await strapiUtils.traverse.traverseQuerySort(omitNonSortableAttributes, {
        schema,
        getModel: strapi.getModel.bind(strapi)
    }, parsedValue);
    // If any of the keys has been removed, the sort attribute is not valid
    return fp.isEqual(parsedValue, sanitizedValue);
}
const createDefaultSettings = async (schema)=>{
    const defaultField = getDefaultMainField(schema);
    return {
        ...DEFAULT_SETTINGS,
        mainField: defaultField,
        defaultSortBy: defaultField,
        defaultSortOrder: 'ASC',
        ...getModelSettings(schema)
    };
};
const syncSettings = async (configuration, schema)=>{
    if (fp.isEmpty(configuration.settings)) return createDefaultSettings(schema);
    const defaultField = getDefaultMainField(schema);
    const { mainField = defaultField, defaultSortBy = defaultField } = configuration.settings || {};
    return {
        ...configuration.settings,
        mainField: isSortable(schema, mainField) ? mainField : defaultField,
        defaultSortBy: await isValidDefaultSort(schema, defaultSortBy) ? defaultSortBy : defaultField
    };
};

/**
 * Creates the validation schema for content-type configurations
 */ var createModelConfigurationSchema = ((schema, opts = {})=>strapiUtils.yup.object().shape({
        settings: createSettingsSchema(schema).default(null).nullable(),
        metadatas: createMetadasSchema(schema).default(null).nullable(),
        layouts: createLayoutsSchema(schema, opts).default(null).nullable(),
        options: strapiUtils.yup.object().optional()
    }).noUnknown());
const createSettingsSchema = (schema)=>{
    const validAttributes = Object.keys(schema.attributes).filter((key)=>isListable(schema, key));
    return strapiUtils.yup.object().shape({
        bulkable: strapiUtils.yup.boolean().required(),
        filterable: strapiUtils.yup.boolean().required(),
        pageSize: strapiUtils.yup.number().integer().min(10).max(100).required(),
        searchable: strapiUtils.yup.boolean().required(),
        // should be reset when the type changes
        mainField: strapiUtils.yup.string().oneOf(validAttributes.concat('id')).default('id'),
        // should be reset when the type changes
        defaultSortBy: strapiUtils.yup.string().test('is-valid-sort-attribute', '${path} is not a valid sort attribute', async (value)=>isValidDefaultSort(schema, value)).default('id'),
        defaultSortOrder: strapiUtils.yup.string().oneOf([
            'ASC',
            'DESC'
        ]).default('ASC')
    }).noUnknown();
};
const createMetadasSchema = (schema)=>{
    return strapiUtils.yup.object().shape(Object.keys(schema.attributes).reduce((acc, key)=>{
        acc[key] = strapiUtils.yup.object().shape({
            edit: strapiUtils.yup.object().shape({
                label: strapiUtils.yup.string(),
                description: strapiUtils.yup.string(),
                placeholder: strapiUtils.yup.string(),
                editable: strapiUtils.yup.boolean(),
                visible: strapiUtils.yup.boolean(),
                mainField: strapiUtils.yup.lazy((value)=>{
                    if (!value) {
                        return strapiUtils.yup.string();
                    }
                    const targetSchema = getService$2('content-types').findContentType(schema.attributes[key].targetModel);
                    if (!targetSchema) {
                        return strapiUtils.yup.string();
                    }
                    const validAttributes = Object.keys(targetSchema.attributes).filter((key)=>isListable(targetSchema, key));
                    return strapiUtils.yup.string().oneOf(validAttributes.concat('id')).default('id');
                })
            }).noUnknown().required(),
            list: strapiUtils.yup.object().shape({
                label: strapiUtils.yup.string(),
                searchable: strapiUtils.yup.boolean(),
                sortable: strapiUtils.yup.boolean()
            }).noUnknown().required()
        }).noUnknown();
        return acc;
    }, {}));
};
const createArrayTest = ({ allowUndefined = false } = {})=>({
        name: 'isArray',
        message: '${path} is required and must be an array',
        test: (val)=>allowUndefined === true && val === undefined ? true : Array.isArray(val)
    });
const createLayoutsSchema = (schema, opts = {})=>{
    const validAttributes = Object.keys(schema.attributes).filter((key)=>isListable(schema, key));
    const editAttributes = Object.keys(schema.attributes).filter((key)=>hasEditableAttribute(schema, key));
    return strapiUtils.yup.object().shape({
        edit: strapiUtils.yup.array().of(strapiUtils.yup.array().of(strapiUtils.yup.object().shape({
            name: strapiUtils.yup.string().oneOf(editAttributes).required(),
            size: strapiUtils.yup.number().integer().positive().required()
        }).noUnknown())).test(createArrayTest(opts)),
        list: strapiUtils.yup.array().of(strapiUtils.yup.string().oneOf(validAttributes)).test(createArrayTest(opts))
    });
};

const { PaginationError, ValidationError } = strapiUtils.errors;
const TYPES = [
    'singleType',
    'collectionType'
];
/**
 * Validates type kind
 */ const kindSchema = strapiUtils.yup.string().oneOf(TYPES).nullable();
const bulkActionInputSchema = strapiUtils.yup.object({
    documentIds: strapiUtils.yup.array().of(strapiUtils.yup.strapiID()).min(1).required()
}).required();
const generateUIDInputSchema = strapiUtils.yup.object({
    contentTypeUID: strapiUtils.yup.string().required(),
    field: strapiUtils.yup.string().required(),
    data: strapiUtils.yup.object().required()
});
const checkUIDAvailabilityInputSchema = strapiUtils.yup.object({
    contentTypeUID: strapiUtils.yup.string().required(),
    field: strapiUtils.yup.string().required(),
    value: strapiUtils.yup.string().matches(/^[A-Za-z0-9-_.~]*$/).required()
});
const validateUIDField = (contentTypeUID, field)=>{
    const model = strapi.contentTypes[contentTypeUID];
    if (!model) {
        throw new ValidationError('ContentType not found');
    }
    if (!_.has(model, [
        'attributes',
        field
    ]) || _.get(model, [
        'attributes',
        field,
        'type'
    ]) !== 'uid') {
        throw new ValidationError(`${field} must be a valid \`uid\` attribute`);
    }
};
const validateKind = strapiUtils.validateYupSchema(kindSchema);
const validateBulkActionInput = strapiUtils.validateYupSchema(bulkActionInputSchema);
const validateGenerateUIDInput = strapiUtils.validateYupSchema(generateUIDInputSchema);
const validateCheckUIDAvailabilityInput = strapiUtils.validateYupSchema(checkUIDAvailabilityInputSchema);

const { isVisibleAttribute: isVisibleAttribute$2 } = strapiUtils.contentTypes;
/**
 * Use an array of strings to represent the path to a field, so we can show breadcrumbs in the admin
 * We can't use special characters as delimiters, because the path includes display names
 * for dynamic zone components, which can contain any character.
 */ function checkRelation(model, attributeName, path) {
    // we don't care about createdBy, updatedBy, localizations etc.
    if (!isVisibleAttribute$2(model, attributeName)) {
        // Return empty array and not null so we can always spread the result
        return [];
    }
    /**
   * Only one-to-many and one-to-one (when they're reversed, not one-way) are dangerous,
   * because the other relations don't "steal" the relation from the entry we're cloning
   */ const { relation, inversedBy, mappedBy } = model.attributes[attributeName];
    if ([
        'oneToOne',
        'oneToMany'
    ].includes(relation) && [
        mappedBy,
        inversedBy
    ].some((key)=>key != null)) {
        return [
            [
                [
                    ...path,
                    attributeName
                ],
                'relation'
            ]
        ];
    }
    return [];
}
const getProhibitedCloningFields = (uid, pathPrefix = [])=>{
    const model = strapi.getModel(uid);
    const prohibitedFields = Object.keys(model.attributes).reduce((acc, attributeName)=>{
        const attribute = model.attributes[attributeName];
        const attributePath = [
            ...pathPrefix,
            attributeName
        ];
        switch(attribute.type){
            case 'relation':
                return [
                    ...acc,
                    ...checkRelation(model, attributeName, pathPrefix)
                ];
            case 'component':
                return [
                    ...acc,
                    ...getProhibitedCloningFields(attribute.component, attributePath)
                ];
            case 'dynamiczone':
                return [
                    ...acc,
                    ...(attribute.components || []).flatMap((componentUID)=>getProhibitedCloningFields(componentUID, [
                            ...attributePath,
                            strapi.getModel(componentUID).info.displayName
                        ]))
                ];
            case 'uid':
                return [
                    ...acc,
                    [
                        attributePath,
                        'unique'
                    ]
                ];
            default:
                if (attribute?.unique) {
                    return [
                        ...acc,
                        [
                            attributePath,
                            'unique'
                        ]
                    ];
                }
                return acc;
        }
    }, []);
    return prohibitedFields;
};
/**
 * Iterates all attributes of the content type, and removes the ones that are not creatable.
 *   - If it's a relation, it sets the value to [] or null.
 *   - If it's a regular attribute, it sets the value to null.
 * When cloning, if you don't set a field it will be copied from the original entry. So we need to
 * remove the fields that the user can't create.
 */ const excludeNotCreatableFields = (uid, permissionChecker)=>(body, path = [])=>{
        const model = strapi.getModel(uid);
        const canCreate = (path)=>permissionChecker.can.create(null, path);
        return Object.keys(model.attributes).reduce((body, attributeName)=>{
            const attribute = model.attributes[attributeName];
            const attributePath = [
                ...path,
                attributeName
            ].join('.');
            // Ignore the attribute if it's not visible
            if (!isVisibleAttribute$2(model, attributeName)) {
                return body;
            }
            switch(attribute.type){
                // Relation should be empty if the user can't create it
                case 'relation':
                    {
                        if (canCreate(attributePath)) return body;
                        return fp.set(attributePath, {
                            set: []
                        }, body);
                    }
                // Go deeper into the component
                case 'component':
                    {
                        return excludeNotCreatableFields(attribute.component, permissionChecker)(body, [
                            ...path,
                            attributeName
                        ]);
                    }
                // Attribute should be null if the user can't create it
                default:
                    {
                        if (canCreate(attributePath)) return body;
                        return fp.set(attributePath, null, body);
                    }
            }
        }, body);
    };

const singleLocaleSchema = strapiUtils.yup.string().nullable();
const multipleLocaleSchema = strapiUtils.yup.lazy((value)=>Array.isArray(value) ? strapiUtils.yup.array().of(singleLocaleSchema.required()) : singleLocaleSchema);
const statusSchema = strapiUtils.yup.mixed().oneOf([
    'draft',
    'published'
], 'Invalid status');
/**
 * From a request or query object, validates and returns the locale and status of the document.
 * If the status is not provided and Draft & Publish is disabled, it defaults to 'published'.
 */ const getDocumentLocaleAndStatus = async (request, model, opts = {
    allowMultipleLocales: false
})=>{
    const { allowMultipleLocales } = opts;
    const { locale, status: providedStatus, ...rest } = request || {};
    const defaultStatus = strapiUtils.contentTypes.hasDraftAndPublish(strapi.getModel(model)) ? undefined : 'published';
    const status = providedStatus !== undefined ? providedStatus : defaultStatus;
    const schema = strapiUtils.yup.object().shape({
        locale: allowMultipleLocales ? multipleLocaleSchema : singleLocaleSchema,
        status: statusSchema
    });
    try {
        await strapiUtils.validateYupSchema(schema, {
            strict: true,
            abortEarly: false
        })(request);
        return {
            locale,
            status,
            ...rest
        };
    } catch (error) {
        throw new strapiUtils.errors.ValidationError(`Validation error: ${error.message}`);
    }
};

/**
 * Format a document with metadata. Making sure the metadata response is
 * correctly sanitized for the current user
 */ const formatDocumentWithMetadata = async (permissionChecker, uid, document, opts = {})=>{
    const documentMetadata = getService$2('document-metadata');
    const serviceOutput = await documentMetadata.formatDocumentWithMetadata(uid, document, opts);
    let { meta: { availableLocales, availableStatus } } = serviceOutput;
    const metadataSanitizer = permissionChecker.sanitizeOutput;
    availableLocales = await strapiUtils.async.map(availableLocales, async (localeDocument)=>metadataSanitizer(localeDocument));
    availableStatus = await strapiUtils.async.map(availableStatus, async (statusDocument)=>metadataSanitizer(statusDocument));
    return {
        ...serviceOutput,
        meta: {
            availableLocales,
            availableStatus
        }
    };
};

/**
 * Create a new document.
 *
 * @param ctx - Koa context
 * @param opts - Options
 * @param opts.populate - Populate options of the returned document.
 *                        By default documentManager will populate all relations.
 */ const createDocument = async (ctx, opts)=>{
    const { userAbility, user } = ctx.state;
    const { model } = ctx.params;
    const { body } = ctx.request;
    const documentManager = getService$2('document-manager');
    const permissionChecker = getService$2('permission-checker').create({
        userAbility,
        model
    });
    if (permissionChecker.cannot.create()) {
        throw new strapiUtils.errors.ForbiddenError();
    }
    const pickPermittedFields = permissionChecker.sanitizeCreateInput;
    const setCreator = strapiUtils.setCreatorFields({
        user
    });
    const sanitizeFn = strapiUtils.async.pipe(pickPermittedFields, setCreator);
    const sanitizedBody = await sanitizeFn(body);
    const { locale, status } = await getDocumentLocaleAndStatus(body, model);
    return documentManager.create(model, {
        data: sanitizedBody,
        locale,
        status,
        populate: opts?.populate
    });
// TODO: Revert the creation if create permission conditions are not met
// if (permissionChecker.cannot.create(document)) {
//   throw new errors.ForbiddenError();
// }
};
/**
 * Update a document version.
 * - If the document version exists, it will be updated.
 * - If the document version does not exist, a new document locale will be created.
 *   By default documentManager will populate all relations.
 *
 * @param ctx - Koa context
 * @param opts - Options
 * @param opts.populate - Populate options of the returned document
 */ const updateDocument = async (ctx, opts)=>{
    const { userAbility, user } = ctx.state;
    const { id, model } = ctx.params;
    const { body } = ctx.request;
    const documentManager = getService$2('document-manager');
    const permissionChecker = getService$2('permission-checker').create({
        userAbility,
        model
    });
    if (permissionChecker.cannot.update()) {
        throw new strapiUtils.errors.ForbiddenError();
    }
    // Populate necessary fields to check permissions
    const permissionQuery = await permissionChecker.sanitizedQuery.update(ctx.query);
    const populate = await getService$2('populate-builder')(model).populateFromQuery(permissionQuery).build();
    const { locale } = await getDocumentLocaleAndStatus(body, model);
    // Load document version to update
    const [documentVersion, documentExists] = await Promise.all([
        documentManager.findOne(id, model, {
            populate,
            locale,
            status: 'draft'
        }),
        documentManager.exists(model, id)
    ]);
    if (!documentExists) {
        throw new strapiUtils.errors.NotFoundError();
    }
    // If version is not found, but document exists,
    // the intent is to create a new document locale
    if (documentVersion) {
        if (permissionChecker.cannot.update(documentVersion)) {
            throw new strapiUtils.errors.ForbiddenError();
        }
    } else if (permissionChecker.cannot.create()) {
        throw new strapiUtils.errors.ForbiddenError();
    }
    const pickPermittedFields = documentVersion ? permissionChecker.sanitizeUpdateInput(documentVersion) : permissionChecker.sanitizeCreateInput;
    const setCreator = documentVersion ? strapiUtils.setCreatorFields({
        user,
        isEdition: true
    }) : strapiUtils.setCreatorFields({
        user
    });
    const sanitizeFn = strapiUtils.async.pipe(pickPermittedFields, setCreator);
    const sanitizedBody = await sanitizeFn(body);
    return documentManager.update(documentVersion?.documentId || id, model, {
        data: sanitizedBody,
        populate: opts?.populate,
        locale
    });
};
var collectionTypes = {
    async find (ctx) {
        const { userAbility } = ctx.state;
        const { model } = ctx.params;
        const { query } = ctx.request;
        const documentMetadata = getService$2('document-metadata');
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.read()) {
            return ctx.forbidden();
        }
        const permissionQuery = await permissionChecker.sanitizedQuery.read(query);
        const populate = await getService$2('populate-builder')(model).populateFromQuery(permissionQuery).populateDeep(1).countRelations({
            toOne: false,
            toMany: true
        }).build();
        const { locale, status } = await getDocumentLocaleAndStatus(query, model);
        const { results: documents, pagination } = await documentManager.findPage({
            ...permissionQuery,
            populate,
            locale,
            status
        }, model);
        // TODO: Skip this part if not necessary (if D&P disabled or columns not displayed in the view)
        const documentsAvailableStatus = await documentMetadata.getManyAvailableStatus(model, documents);
        const setStatus = (document)=>{
            // Available status of document
            const availableStatuses = documentsAvailableStatus.filter((d)=>d.documentId === document.documentId);
            // Compute document version status
            document.status = documentMetadata.getStatus(document, availableStatuses);
            return document;
        };
        const results = await strapiUtils.async.map(documents, strapiUtils.async.pipe(permissionChecker.sanitizeOutput, setStatus));
        ctx.body = {
            results,
            pagination
        };
    },
    async findOne (ctx) {
        const { userAbility } = ctx.state;
        const { model, id } = ctx.params;
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.read()) {
            return ctx.forbidden();
        }
        const permissionQuery = await permissionChecker.sanitizedQuery.read(ctx.query);
        const populate = await getService$2('populate-builder')(model).populateFromQuery(permissionQuery).populateDeep(Infinity).countRelations().build();
        const { locale, status } = await getDocumentLocaleAndStatus(ctx.query, model);
        const version = await documentManager.findOne(id, model, {
            populate,
            locale,
            status
        });
        if (!version) {
            // Check if document exists
            const exists = await documentManager.exists(model, id);
            if (!exists) {
                return ctx.notFound();
            }
            // If the requested locale doesn't exist, return an empty response
            const { meta } = await formatDocumentWithMetadata(permissionChecker, model, // @ts-expect-error TODO: fix
            {
                documentId: id,
                locale,
                publishedAt: null
            }, {
                availableLocales: true,
                availableStatus: false
            });
            ctx.body = {
                data: {},
                meta
            };
            return;
        }
        // if the user has condition that needs populated content, it's not applied because entity don't have relations populated
        if (permissionChecker.cannot.read(version)) {
            return ctx.forbidden();
        }
        // TODO: Count populated relations by permissions
        const sanitizedDocument = await permissionChecker.sanitizeOutput(version);
        ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument);
    },
    async create (ctx) {
        const { userAbility } = ctx.state;
        const { model } = ctx.params;
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        const [totalEntries, document] = await Promise.all([
            strapi.db.query(model).count(),
            createDocument(ctx)
        ]);
        const sanitizedDocument = await permissionChecker.sanitizeOutput(document);
        ctx.status = 201;
        ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument, {
            // Empty metadata as it's not relevant for a new document
            availableLocales: false,
            availableStatus: false
        });
        if (totalEntries === 0) {
            strapi.telemetry.send('didCreateFirstContentTypeEntry', {
                eventProperties: {
                    model
                }
            });
        }
    },
    async update (ctx) {
        const { userAbility } = ctx.state;
        const { model } = ctx.params;
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        const updatedVersion = await updateDocument(ctx);
        const sanitizedVersion = await permissionChecker.sanitizeOutput(updatedVersion);
        ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedVersion);
    },
    async clone (ctx) {
        const { userAbility, user } = ctx.state;
        const { model, sourceId: id } = ctx.params;
        const { body } = ctx.request;
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.create()) {
            return ctx.forbidden();
        }
        const permissionQuery = await permissionChecker.sanitizedQuery.create(ctx.query);
        const populate = await getService$2('populate-builder')(model).populateFromQuery(permissionQuery).build();
        const { locale } = await getDocumentLocaleAndStatus(body, model);
        const document = await documentManager.findOne(id, model, {
            populate,
            locale,
            status: 'draft'
        });
        if (!document) {
            return ctx.notFound();
        }
        const pickPermittedFields = permissionChecker.sanitizeCreateInput;
        const setCreator = strapiUtils.setCreatorFields({
            user
        });
        const excludeNotCreatable = excludeNotCreatableFields(model, permissionChecker);
        const sanitizeFn = strapiUtils.async.pipe(pickPermittedFields, setCreator, excludeNotCreatable);
        const sanitizedBody = await sanitizeFn(body);
        const clonedDocument = await documentManager.clone(document.documentId, sanitizedBody, model);
        const sanitizedDocument = await permissionChecker.sanitizeOutput(clonedDocument);
        ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument, {
            // Empty metadata as it's not relevant for a new document
            availableLocales: false,
            availableStatus: false
        });
    },
    async autoClone (ctx) {
        const { model } = ctx.params;
        // Check if the model has fields that prevent auto cloning
        const prohibitedFields = getProhibitedCloningFields(model);
        if (prohibitedFields.length > 0) {
            return ctx.badRequest('Entity could not be cloned as it has unique and/or relational fields. ' + 'Please edit those fields manually and save to complete the cloning.', {
                prohibitedFields
            });
        }
        await this.clone(ctx);
    },
    async delete (ctx) {
        const { userAbility } = ctx.state;
        const { id, model } = ctx.params;
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.delete()) {
            return ctx.forbidden();
        }
        const permissionQuery = await permissionChecker.sanitizedQuery.delete(ctx.query);
        const populate = await getService$2('populate-builder')(model).populateFromQuery(permissionQuery).build();
        const { locale } = await getDocumentLocaleAndStatus(ctx.query, model);
        // Find locales to delete
        const documentLocales = await documentManager.findLocales(id, model, {
            populate,
            locale
        });
        if (documentLocales.length === 0) {
            return ctx.notFound();
        }
        for (const document of documentLocales){
            if (permissionChecker.cannot.delete(document)) {
                return ctx.forbidden();
            }
        }
        const result = await documentManager.delete(id, model, {
            locale
        });
        ctx.body = await permissionChecker.sanitizeOutput(result);
    },
    /**
   * Publish a document version.
   * Supports creating/saving a document and publishing it in one request.
   */ async publish (ctx) {
        const { userAbility } = ctx.state;
        // If id does not exist, the document has to be created
        const { id, model } = ctx.params;
        const { body } = ctx.request;
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.publish()) {
            return ctx.forbidden();
        }
        const publishedDocument = await strapi.db.transaction(async ()=>{
            // Create or update document
            const permissionQuery = await permissionChecker.sanitizedQuery.publish(ctx.query);
            const populate = await getService$2('populate-builder')(model).populateFromQuery(permissionQuery).populateDeep(Infinity).countRelations().build();
            let document;
            const { locale } = await getDocumentLocaleAndStatus(body, model);
            /**
       * Publish can be called on two scenarios:
       * 1. Create a new document and publish it in one request
       * 2. Update an existing document and publish it in one request
       *
       * Based on user permissions:
       * 1. User cannot create a document, but can publish
       *    Action will be forbidden as user cannot create a document
       * 2. User can update and publish a document
       *    Action will be allowed, but document will not be updated, only published with the latest draft
       */ const isCreate = fp.isNil(id);
            if (isCreate) {
                if (permissionChecker.cannot.create()) {
                    throw new strapiUtils.errors.ForbiddenError();
                }
                document = await createDocument(ctx, {
                    populate
                });
            }
            const isUpdate = !isCreate;
            if (isUpdate) {
                // check if the document exists
                const documentExists = await documentManager.exists(model, id);
                if (!documentExists) {
                    throw new strapiUtils.errors.NotFoundError('Document not found');
                }
                // check the document version
                document = await documentManager.findOne(id, model, {
                    populate,
                    locale
                });
                if (!document) {
                    // update and publish the new version
                    if (permissionChecker.cannot.create({
                        locale
                    }) || permissionChecker.cannot.publish({
                        locale
                    })) {
                        throw new strapiUtils.errors.ForbiddenError();
                    }
                    document = await updateDocument(ctx);
                } else if (permissionChecker.can.update(document)) {
                    await updateDocument(ctx);
                }
            }
            if (permissionChecker.cannot.publish(document)) {
                throw new strapiUtils.errors.ForbiddenError();
            }
            const publishResult = await documentManager.publish(document.documentId, model, {
                locale
            });
            if (!publishResult || publishResult.length === 0) {
                throw new strapiUtils.errors.NotFoundError('Document not found or already published.');
            }
            return publishResult[0];
        });
        const sanitizedDocument = await permissionChecker.sanitizeOutput(publishedDocument);
        ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument);
    },
    async bulkPublish (ctx) {
        const { userAbility } = ctx.state;
        const { model } = ctx.params;
        const { body } = ctx.request;
        const { documentIds } = body;
        await validateBulkActionInput(body);
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.publish()) {
            return ctx.forbidden();
        }
        const permissionQuery = await permissionChecker.sanitizedQuery.publish(ctx.query);
        const populate = await getService$2('populate-builder')(model).populateFromQuery(permissionQuery).populateDeep(Infinity).countRelations().build();
        const { locale } = await getDocumentLocaleAndStatus(body, model, {
            allowMultipleLocales: true
        });
        const entityPromises = documentIds.map((documentId)=>documentManager.findLocales(documentId, model, {
                populate,
                locale,
                isPublished: false
            }));
        const entities = (await Promise.all(entityPromises)).flat();
        for (const entity of entities){
            if (!entity) {
                return ctx.notFound();
            }
            if (permissionChecker.cannot.publish(entity)) {
                return ctx.forbidden();
            }
        }
        const count = await documentManager.publishMany(model, documentIds, locale);
        ctx.body = {
            count
        };
    },
    async bulkUnpublish (ctx) {
        const { userAbility } = ctx.state;
        const { model } = ctx.params;
        const { body } = ctx.request;
        const { documentIds } = body;
        await validateBulkActionInput(body);
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.unpublish()) {
            return ctx.forbidden();
        }
        const { locale } = await getDocumentLocaleAndStatus(body, model, {
            allowMultipleLocales: true
        });
        const entityPromises = documentIds.map((documentId)=>documentManager.findLocales(documentId, model, {
                locale,
                isPublished: true
            }));
        const entities = (await Promise.all(entityPromises)).flat();
        for (const entity of entities){
            if (!entity) {
                return ctx.notFound();
            }
            if (permissionChecker.cannot.publish(entity)) {
                return ctx.forbidden();
            }
        }
        const entitiesIds = entities.map((document)=>document.documentId);
        const { count } = await documentManager.unpublishMany(entitiesIds, model, {
            locale
        });
        ctx.body = {
            count
        };
    },
    async unpublish (ctx) {
        const { userAbility } = ctx.state;
        const { id, model } = ctx.params;
        const { body: { discardDraft, ...body } } = ctx.request;
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.unpublish()) {
            return ctx.forbidden();
        }
        if (discardDraft && permissionChecker.cannot.discard()) {
            return ctx.forbidden();
        }
        const permissionQuery = await permissionChecker.sanitizedQuery.unpublish(ctx.query);
        const populate = await getService$2('populate-builder')(model).populateFromQuery(permissionQuery).build();
        // TODO allow multiple locales for bulk locale unpublish
        const { locale } = await getDocumentLocaleAndStatus(body, model);
        const document = await documentManager.findOne(id, model, {
            populate,
            locale,
            status: 'published'
        });
        if (!document) {
            throw new strapiUtils.errors.NotFoundError();
        }
        if (permissionChecker.cannot.unpublish(document)) {
            throw new strapiUtils.errors.ForbiddenError();
        }
        if (discardDraft && permissionChecker.cannot.discard(document)) {
            throw new strapiUtils.errors.ForbiddenError();
        }
        await strapi.db.transaction(async ()=>{
            if (discardDraft) {
                await documentManager.discardDraft(document.documentId, model, {
                    locale
                });
            }
            ctx.body = await strapiUtils.async.pipe((document)=>documentManager.unpublish(document.documentId, model, {
                    locale
                }), permissionChecker.sanitizeOutput, (document)=>formatDocumentWithMetadata(permissionChecker, model, document))(document);
        });
    },
    async discard (ctx) {
        const { userAbility } = ctx.state;
        const { id, model } = ctx.params;
        const { body } = ctx.request;
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.discard()) {
            return ctx.forbidden();
        }
        const permissionQuery = await permissionChecker.sanitizedQuery.discard(ctx.query);
        const populate = await getService$2('populate-builder')(model).populateFromQuery(permissionQuery).build();
        const { locale } = await getDocumentLocaleAndStatus(body, model);
        const document = await documentManager.findOne(id, model, {
            populate,
            locale,
            status: 'published'
        });
        // Can not discard a document that is not published
        if (!document) {
            return ctx.notFound();
        }
        if (permissionChecker.cannot.discard(document)) {
            return ctx.forbidden();
        }
        ctx.body = await strapiUtils.async.pipe((document)=>documentManager.discardDraft(document.documentId, model, {
                locale
            }), permissionChecker.sanitizeOutput, (document)=>formatDocumentWithMetadata(permissionChecker, model, document))(document);
    },
    async bulkDelete (ctx) {
        const { userAbility } = ctx.state;
        const { model } = ctx.params;
        const { query, body } = ctx.request;
        const { documentIds } = body;
        await validateBulkActionInput(body);
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.delete()) {
            return ctx.forbidden();
        }
        const permissionQuery = await permissionChecker.sanitizedQuery.delete(query);
        const populate = await getService$2('populate-builder')(model).populateFromQuery(permissionQuery).build();
        const { locale } = await getDocumentLocaleAndStatus(body, model);
        const documentLocales = await documentManager.findLocales(documentIds, model, {
            populate,
            locale
        });
        if (documentLocales.length === 0) {
            return ctx.notFound();
        }
        for (const document of documentLocales){
            if (permissionChecker.cannot.delete(document)) {
                return ctx.forbidden();
            }
        }
        // We filter out documentsIds that maybe doesn't exist in a specific locale
        const localeDocumentsIds = documentLocales.map((document)=>document.documentId);
        const { count } = await documentManager.deleteMany(localeDocumentsIds, model, {
            locale
        });
        ctx.body = {
            count
        };
    },
    async countDraftRelations (ctx) {
        const { userAbility } = ctx.state;
        const { model, id } = ctx.params;
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.read()) {
            return ctx.forbidden();
        }
        const permissionQuery = await permissionChecker.sanitizedQuery.read(ctx.query);
        const populate = await getService$2('populate-builder')(model).populateFromQuery(permissionQuery).build();
        const { locale, status } = await getDocumentLocaleAndStatus(ctx.query, model);
        const entity = await documentManager.findOne(id, model, {
            populate,
            locale,
            status
        });
        if (!entity) {
            return ctx.notFound();
        }
        if (permissionChecker.cannot.read(entity)) {
            return ctx.forbidden();
        }
        const number = await documentManager.countDraftRelations(id, model, locale);
        return {
            data: number
        };
    },
    async countManyEntriesDraftRelations (ctx) {
        const { userAbility } = ctx.state;
        const ids = ctx.request.query.documentIds;
        const locale = ctx.request.query.locale;
        const { model } = ctx.params;
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.read()) {
            return ctx.forbidden();
        }
        const documents = await documentManager.findMany({
            filters: {
                documentId: ids
            },
            locale
        }, model);
        if (!documents) {
            return ctx.notFound();
        }
        const number = await documentManager.countManyEntriesDraftRelations(ids, model, locale);
        return {
            data: number
        };
    }
};

var components$1 = {
    findComponents (ctx) {
        const components = getService$2('components').findAllComponents();
        const { toDto } = getService$2('data-mapper');
        ctx.body = {
            data: components.map(toDto)
        };
    },
    async findComponentConfiguration (ctx) {
        const { uid } = ctx.params;
        const componentService = getService$2('components');
        const component = componentService.findComponent(uid);
        if (!component) {
            return ctx.notFound('component.notFound');
        }
        const configuration = await componentService.findConfiguration(component);
        const componentsConfigurations = await componentService.findComponentsConfigurations(component);
        ctx.body = {
            data: {
                component: configuration,
                components: componentsConfigurations
            }
        };
    },
    async updateComponentConfiguration (ctx) {
        const { uid } = ctx.params;
        const { body } = ctx.request;
        const componentService = getService$2('components');
        const component = componentService.findComponent(uid);
        if (!component) {
            return ctx.notFound('component.notFound');
        }
        let input;
        try {
            input = await createModelConfigurationSchema(component).validate(body, {
                abortEarly: false,
                stripUnknown: true,
                strict: true
            });
        } catch (error) {
            return ctx.badRequest(null, {
                name: 'validationError',
                errors: error.errors
            });
        }
        const newConfiguration = await componentService.updateConfiguration(component, input);
        ctx.body = {
            data: newConfiguration
        };
    }
};

const hasEditMainField = fp.has('edit.mainField');
const getEditMainField = fp.prop('edit.mainField');
const assocListMainField = fp.assoc('list.mainField');
const assocMainField = (metadata)=>hasEditMainField(metadata) ? assocListMainField(getEditMainField(metadata), metadata) : metadata;
var contentTypes = {
    async findContentTypes (ctx) {
        const { kind } = ctx.query;
        try {
            await validateKind(kind);
        } catch (error) {
            return ctx.send({
                error
            }, 400);
        }
        const contentTypes = getService$2('content-types').findContentTypesByKind(kind);
        const { toDto } = getService$2('data-mapper');
        ctx.body = {
            data: contentTypes.map(toDto)
        };
    },
    async findContentTypesSettings (ctx) {
        const { findAllContentTypes, findConfiguration } = getService$2('content-types');
        const contentTypes = await findAllContentTypes();
        const configurations = await Promise.all(contentTypes.map(async (contentType)=>{
            const { uid, settings } = await findConfiguration(contentType);
            return {
                uid,
                settings
            };
        }));
        ctx.body = {
            data: configurations
        };
    },
    async findContentTypeConfiguration (ctx) {
        const { uid } = ctx.params;
        const contentTypeService = getService$2('content-types');
        const contentType = await contentTypeService.findContentType(uid);
        if (!contentType) {
            return ctx.notFound('contentType.notFound');
        }
        const configuration = await contentTypeService.findConfiguration(contentType);
        const confWithUpdatedMetadata = {
            ...configuration,
            metadatas: fp.mapValues(assocMainField, configuration.metadatas)
        };
        const components = await contentTypeService.findComponentsConfigurations(contentType);
        ctx.body = {
            data: {
                contentType: confWithUpdatedMetadata,
                components
            }
        };
    },
    async updateContentTypeConfiguration (ctx) {
        const { userAbility } = ctx.state;
        const { uid } = ctx.params;
        const { body } = ctx.request;
        const contentTypeService = getService$2('content-types');
        const metricsService = getService$2('metrics');
        const contentType = await contentTypeService.findContentType(uid);
        if (!contentType) {
            return ctx.notFound('contentType.notFound');
        }
        if (!getService$2('permission').canConfigureContentType({
            userAbility,
            contentType
        })) {
            return ctx.forbidden();
        }
        let input;
        try {
            input = await createModelConfigurationSchema(contentType).validate(body, {
                abortEarly: false,
                stripUnknown: true,
                strict: true
            });
        } catch (error) {
            return ctx.badRequest(null, {
                name: 'validationError',
                errors: error.errors
            });
        }
        const newConfiguration = await contentTypeService.updateConfiguration(contentType, input);
        await metricsService.sendDidConfigureListView(contentType, newConfiguration);
        const confWithUpdatedMetadata = {
            ...newConfiguration,
            metadatas: fp.mapValues(assocMainField, newConfiguration.metadatas)
        };
        const components = await contentTypeService.findComponentsConfigurations(contentType);
        ctx.body = {
            data: {
                contentType: confWithUpdatedMetadata,
                components
            }
        };
    }
};

var init = {
    getInitData (ctx) {
        const { toDto } = getService$2('data-mapper');
        const { findAllComponents } = getService$2('components');
        const { getAllFieldSizes } = getService$2('field-sizes');
        const { findAllContentTypes } = getService$2('content-types');
        ctx.body = {
            data: {
                fieldSizes: getAllFieldSizes(),
                components: findAllComponents().map(toDto),
                contentTypes: findAllContentTypes().map(toDto)
            }
        };
    }
};

const validateFindAvailableSchema = strapiUtils.yup.object().shape({
    component: strapiUtils.yup.string(),
    id: strapiUtils.yup.strapiID(),
    _q: strapiUtils.yup.string(),
    idsToOmit: strapiUtils.yup.array().of(strapiUtils.yup.strapiID()),
    idsToInclude: strapiUtils.yup.array().of(strapiUtils.yup.strapiID()),
    page: strapiUtils.yup.number().integer().min(1),
    pageSize: strapiUtils.yup.number().integer().min(1).max(100),
    locale: strapiUtils.yup.string().nullable(),
    status: strapiUtils.yup.string().oneOf([
        'published',
        'draft'
    ]).nullable()
}).required();
const validateFindExistingSchema = strapiUtils.yup.object().shape({
    page: strapiUtils.yup.number().integer().min(1),
    pageSize: strapiUtils.yup.number().integer().min(1).max(100),
    locale: strapiUtils.yup.string().nullable(),
    status: strapiUtils.yup.string().oneOf([
        'published',
        'draft'
    ]).nullable()
}).required();
const validateFindAvailable = strapiUtils.validateYupSchema(validateFindAvailableSchema, {
    strict: false
});
const validateFindExisting = strapiUtils.validateYupSchema(validateFindExistingSchema, {
    strict: false
});

const { PUBLISHED_AT_ATTRIBUTE: PUBLISHED_AT_ATTRIBUTE$2, UPDATED_AT_ATTRIBUTE } = strapiUtils.contentTypes.constants;
const addFiltersClause = (params, filtersClause)=>{
    params.filters = params.filters || {};
    params.filters.$and = params.filters.$and || [];
    params.filters.$and.push(filtersClause);
};
const sanitizeMainField = (model, mainField, userAbility)=>{
    const permissionChecker = getService$2('permission-checker').create({
        userAbility,
        model: model.uid
    });
    // Whether the main field can be displayed or not, regardless of permissions.
    const isMainFieldListable = isListable(model, mainField);
    // Whether the user has the permission to access the model's main field (using RBAC abilities)
    const canReadMainField = permissionChecker.can.read(null, mainField);
    if (!isMainFieldListable || !canReadMainField) {
        // Default to 'id' if the actual main field shouldn't be displayed
        return 'id';
    }
    // Edge cases
    // 1. Enforce 'name' as the main field for users and permissions' roles
    if (model.uid === 'plugin::users-permissions.role') {
        return 'name';
    }
    return mainField;
};
/**
 *
 * All relations sent to this function should have the same status or no status
 */ const addStatusToRelations = async (targetUid, relations)=>{
    if (!strapiUtils.contentTypes.hasDraftAndPublish(strapi.getModel(targetUid))) {
        return relations;
    }
    const documentMetadata = getService$2('document-metadata');
    if (!relations.length) {
        return relations;
    }
    const firstRelation = relations[0];
    const filters = {
        documentId: {
            $in: relations.map((r)=>r.documentId)
        },
        // NOTE: find the "opposite" status
        publishedAt: firstRelation.publishedAt !== null ? {
            $null: true
        } : {
            $notNull: true
        }
    };
    const availableStatus = await strapi.query(targetUid).findMany({
        select: [
            'id',
            'documentId',
            'locale',
            'updatedAt',
            'createdAt',
            'publishedAt'
        ],
        filters
    });
    return relations.map((relation)=>{
        const availableStatuses = availableStatus.filter((availableDocument)=>availableDocument.documentId === relation.documentId && (relation.locale ? availableDocument.locale === relation.locale : true));
        return {
            ...relation,
            status: documentMetadata.getStatus(relation, availableStatuses)
        };
    });
};
const getPublishedAtClause = (status, uid)=>{
    const model = strapi.getModel(uid);
    /**
   * If dp is disabled, ignore the filter
   */ if (!model || !strapiUtils.contentTypes.hasDraftAndPublish(model)) {
        return {};
    }
    // Prioritize the draft status in case it's not provided
    return status === 'published' ? {
        $notNull: true
    } : {
        $null: true
    };
};
const validateLocale = (sourceUid, targetUid, locale)=>{
    const sourceModel = strapi.getModel(sourceUid);
    const targetModel = strapi.getModel(targetUid);
    const isLocalized = strapi.plugin('i18n').service('content-types').isLocalizedContentType;
    const isSourceLocalized = isLocalized(sourceModel);
    const isTargetLocalized = isLocalized(targetModel);
    return {
        locale,
        isSourceLocalized,
        isTargetLocalized
    };
};
const validateStatus = (sourceUid, status)=>{
    const sourceModel = strapi.getModel(sourceUid);
    const isDP = strapiUtils.contentTypes.hasDraftAndPublish;
    const isSourceDP = isDP(sourceModel);
    // Default to draft if not set
    if (!isSourceDP) return {
        status: undefined
    };
    switch(status){
        case 'published':
            return {
                status: 'published'
            };
        default:
            // Assign to draft if the status is not valid
            return {
                status: 'draft'
            };
    }
};
var relations = {
    async extractAndValidateRequestInfo (ctx, id) {
        const { userAbility } = ctx.state;
        const { model, targetField } = ctx.params;
        const sourceSchema = strapi.getModel(model);
        if (!sourceSchema) {
            throw new strapiUtils.errors.ValidationError(`The model ${model} doesn't exist`);
        }
        const attribute = sourceSchema.attributes[targetField];
        if (!attribute || attribute.type !== 'relation') {
            throw new strapiUtils.errors.ValidationError(`The relational field ${targetField} doesn't exist on ${model}`);
        }
        const sourceUid = model;
        const targetUid = attribute.target;
        const { locale, isSourceLocalized, isTargetLocalized } = validateLocale(sourceUid, targetUid, ctx.request?.query?.locale);
        const { status } = validateStatus(sourceUid, ctx.request?.query?.status);
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        const isComponent = sourceSchema.modelType === 'component';
        if (!isComponent) {
            if (permissionChecker.cannot.read(null, targetField)) {
                return ctx.forbidden();
            }
        }
        let entryId = null;
        if (id) {
            const where = {};
            if (!isComponent) {
                where.documentId = id;
                if (status) {
                    where.publishedAt = getPublishedAtClause(status, sourceUid);
                }
                if (locale && isSourceLocalized) {
                    where.locale = locale;
                }
            } else {
                // If the source is a component, we only need to filter by the
                // component's entity id
                where.id = id;
            }
            const permissionQuery = await permissionChecker.sanitizedQuery.read(ctx.query);
            const populate = await getService$2('populate-builder')(model).populateFromQuery(permissionQuery).build();
            const currentEntity = await strapi.db.query(model).findOne({
                where,
                populate
            });
            // We need to check if the entity exists
            // and if the user has the permission to read it in this way
            // There may be multiple entities (publication states) under this
            // documentId + locale. We only need to check if one exists
            if (!currentEntity) {
                throw new strapiUtils.errors.NotFoundError();
            }
            if (!isComponent) {
                if (permissionChecker.cannot.read(currentEntity, targetField)) {
                    throw new strapiUtils.errors.ForbiddenError();
                }
            }
            entryId = currentEntity.id;
        }
        const modelConfig = isComponent ? await getService$2('components').findConfiguration(sourceSchema) : await getService$2('content-types').findConfiguration(sourceSchema);
        const targetSchema = strapi.getModel(targetUid);
        const mainField = fp.flow(fp.prop(`metadatas.${targetField}.edit.mainField`), (mainField)=>mainField || 'id', (mainField)=>sanitizeMainField(targetSchema, mainField, userAbility))(modelConfig);
        const fieldsToSelect = fp.uniq([
            mainField,
            PUBLISHED_AT_ATTRIBUTE$2,
            UPDATED_AT_ATTRIBUTE,
            'documentId'
        ]);
        if (isTargetLocalized) {
            fieldsToSelect.push('locale');
        }
        return {
            entryId,
            locale,
            status,
            attribute,
            fieldsToSelect,
            mainField,
            source: {
                schema: sourceSchema,
                isLocalized: isSourceLocalized
            },
            target: {
                schema: targetSchema,
                isLocalized: isTargetLocalized
            },
            sourceSchema,
            targetSchema,
            targetField
        };
    },
    /**
   * Used to find new relations to add in a relational field.
   *
   * Component and document relations are dealt a bit differently (they don't have a document_id).
   */ async findAvailable (ctx) {
        const { id } = ctx.request.query;
        await validateFindAvailable(ctx.request.query);
        const { locale, status, targetField, fieldsToSelect, mainField, source: { schema: { uid: sourceUid, modelType: sourceModelType }, isLocalized: isSourceLocalized }, target: { schema: { uid: targetUid }, isLocalized: isTargetLocalized } } = await this.extractAndValidateRequestInfo(ctx, id);
        const { idsToOmit, idsToInclude, _q, ...query } = ctx.request.query;
        const permissionChecker = getService$2('permission-checker').create({
            userAbility: ctx.state.userAbility,
            model: targetUid
        });
        const permissionQuery = await permissionChecker.sanitizedQuery.read(query);
        const queryParams = {
            sort: mainField,
            // cannot select other fields as the user may not have the permissions
            fields: fieldsToSelect,
            ...permissionQuery
        };
        // If no status is requested, we find all the draft relations and later update them
        // with the latest available status
        addFiltersClause(queryParams, {
            publishedAt: getPublishedAtClause(status, targetUid)
        });
        // We will only filter by locale if the target content type is localized
        const filterByLocale = isTargetLocalized && locale;
        if (filterByLocale) {
            addFiltersClause(queryParams, {
                locale
            });
        }
        if (id) {
            /**
       * Exclude the relations that are already related to the source
       *
       * We also optionally filter the target relations by the requested
       * status and locale if provided.
       */ const subQuery = strapi.db.queryBuilder(sourceUid);
            // The alias refers to the DB table of the target content type model
            const alias = subQuery.getAlias();
            const where = {
                [`${alias}.id`]: {
                    $notNull: true
                },
                [`${alias}.document_id`]: {
                    $notNull: true
                }
            };
            /**
       * Content Types -> Specify document id
       * Components    -> Specify entity id (they don't have a document id)
       */ if (sourceModelType === 'contentType') {
                where.document_id = id;
            } else {
                where.id = id;
            }
            // Add the status and locale filters if they are provided
            const publishedAt = getPublishedAtClause(status, targetUid);
            if (!fp.isEmpty(publishedAt)) {
                where[`${alias}.published_at`] = publishedAt;
            }
            // If target has localization we need to filter by locale
            if (isTargetLocalized && locale) {
                where[`${alias}.locale`] = locale;
            }
            if (isSourceLocalized && locale) {
                where.locale = locale;
            }
            /**
       * UI can provide a list of ids to omit,
       * those are the relations user set in the UI but has not persisted.
       * We don't want to include them in the available relations.
       */ if ((idsToInclude?.length ?? 0) !== 0) {
                where[`${alias}.id`].$notIn = idsToInclude;
            }
            const knexSubQuery = subQuery.where(where).join({
                alias,
                targetField
            }).select(`${alias}.id`).getKnexQuery();
            addFiltersClause(queryParams, {
                id: {
                    $notIn: knexSubQuery
                }
            });
        }
        /**
     * Apply a filter to the mainField based on the search query and filter operator
     * searching should be allowed only on mainField for permission reasons
     */ if (_q) {
            const _filter = strapiUtils.isOperatorOfType('where', query._filter) ? query._filter : '$containsi';
            addFiltersClause(queryParams, {
                [mainField]: {
                    [_filter]: _q
                }
            });
        }
        if (idsToOmit?.length > 0) {
            // If we have ids to omit, we should filter them out
            addFiltersClause(queryParams, {
                id: {
                    $notIn: fp.uniq(idsToOmit)
                }
            });
        }
        const dbQuery = strapi.get('query-params').transform(targetUid, queryParams);
        const res = await strapi.db.query(targetUid).findPage(dbQuery);
        ctx.body = {
            ...res,
            results: await addStatusToRelations(targetUid, res.results)
        };
    },
    async findExisting (ctx) {
        const { userAbility } = ctx.state;
        const { id } = ctx.params;
        await validateFindExisting(ctx.request.query);
        const { entryId, attribute, targetField, fieldsToSelect, status, source: { schema: sourceSchema }, target: { schema: targetSchema } } = await this.extractAndValidateRequestInfo(ctx, id);
        const { uid: sourceUid } = sourceSchema;
        const { uid: targetUid } = targetSchema;
        const permissionQuery = await getService$2('permission-checker').create({
            userAbility,
            model: targetUid
        }).sanitizedQuery.read({
            fields: fieldsToSelect
        });
        /**
     * loadPages can not be used for single relations,
     * this unifies the loading regardless of it's type
     *
     * NOTE: Relations need to be loaded using any db.query method
     *       to ensure the proper ordering is applied
     */ const dbQuery = strapi.db.query(sourceUid);
        const loadRelations = strapiUtils.relations.isAnyToMany(attribute) ? (...args)=>dbQuery.loadPages(...args) : (...args)=>dbQuery.load(...args)// Ensure response is an array
            .then((res)=>({
                    results: res ? [
                        res
                    ] : []
                }));
        const filters = {};
        if (sourceSchema?.options?.draftAndPublish) {
            if (targetSchema?.options?.draftAndPublish) {
                if (status === 'published') {
                    filters.publishedAt = {
                        $notNull: true
                    };
                } else {
                    filters.publishedAt = {
                        $null: true
                    };
                }
            }
        } else if (targetSchema?.options?.draftAndPublish) {
            // NOTE: we must return the drafts as some targets might not have a published version yet
            filters.publishedAt = {
                $null: true
            };
        }
        /**
     * If user does not have access to specific relations (custom conditions),
     * only the ids of the relations are returned.
     *
     * - First query loads all the ids.
     * - Second one also loads the main field, and excludes forbidden relations.
     *
     * The response contains the union of the two queries.
     */ const res = await loadRelations({
            id: entryId
        }, targetField, {
            select: [
                'id',
                'documentId',
                'locale',
                'publishedAt',
                'updatedAt'
            ],
            ordering: 'desc',
            page: ctx.request.query.page,
            pageSize: ctx.request.query.pageSize,
            filters
        });
        /**
     * Add all ids to load in permissionQuery
     * If any of the relations are not accessible, the permissionQuery will exclude them
     */ const loadedIds = res.results.map((item)=>item.id);
        addFiltersClause(permissionQuery, {
            id: {
                $in: loadedIds
            }
        });
        /**
     * Load the relations with the main field, the sanitized permission query
     * will exclude the relations the user does not have access to.
     *
     * Pagination is not necessary as the permissionQuery contains the ids to load.
     */ const sanitizedRes = await loadRelations({
            id: entryId
        }, targetField, {
            ...strapi.get('query-params').transform(targetUid, permissionQuery),
            ordering: 'desc'
        });
        // NOTE: the order is very import to make sure sanitized relations are kept in priority
        const relationsUnion = fp.uniqBy('id', fp.concat(sanitizedRes.results, res.results));
        ctx.body = {
            pagination: res.pagination || {
                page: 1,
                pageCount: 1,
                pageSize: 10,
                total: relationsUnion.length
            },
            results: await addStatusToRelations(targetUid, relationsUnion)
        };
    }
};

const buildPopulateFromQuery = async (query, model)=>{
    return getService$2('populate-builder')(model).populateFromQuery(query).populateDeep(Infinity).countRelations().build();
};
const findDocument = async (query, uid, opts = {})=>{
    const documentManager = getService$2('document-manager');
    const populate = await buildPopulateFromQuery(query, uid);
    return documentManager.findMany({
        ...opts,
        populate
    }, uid)// Return the first document found
    .then((documents)=>documents[0]);
};
const createOrUpdateDocument = async (ctx, opts)=>{
    const { user, userAbility } = ctx.state;
    const { model } = ctx.params;
    const { body, query } = ctx.request;
    const documentManager = getService$2('document-manager');
    const permissionChecker = getService$2('permission-checker').create({
        userAbility,
        model
    });
    if (permissionChecker.cannot.create() && permissionChecker.cannot.update()) {
        throw new strapiUtils.errors.ForbiddenError();
    }
    const sanitizedQuery = await permissionChecker.sanitizedQuery.update(query);
    const { locale } = await getDocumentLocaleAndStatus(body, model);
    // Load document version to update
    const [documentVersion, otherDocumentVersion] = await Promise.all([
        findDocument(sanitizedQuery, model, {
            locale,
            status: 'draft'
        }),
        // Find the first document to check if it exists
        strapi.db.query(model).findOne({
            select: [
                'documentId'
            ]
        })
    ]);
    const documentId = otherDocumentVersion?.documentId;
    const pickPermittedFields = documentVersion ? permissionChecker.sanitizeUpdateInput(documentVersion) : permissionChecker.sanitizeCreateInput;
    const setCreator = documentVersion ? strapiUtils.setCreatorFields({
        user,
        isEdition: true
    }) : strapiUtils.setCreatorFields({
        user
    });
    const sanitizeFn = strapiUtils.async.pipe(pickPermittedFields, setCreator);
    // If version is not found, but document exists,
    // the intent is to create a new document locale
    if (documentVersion) {
        if (permissionChecker.cannot.update(documentVersion)) {
            throw new strapiUtils.errors.ForbiddenError();
        }
    } else if (permissionChecker.cannot.create()) {
        throw new strapiUtils.errors.ForbiddenError();
    }
    const sanitizedBody = await sanitizeFn(body);
    if (!documentId) {
        return documentManager.create(model, {
            data: sanitizedBody,
            ...sanitizedQuery,
            locale
        });
    }
    return documentManager.update(documentId, model, {
        data: sanitizedBody,
        populate: opts?.populate,
        locale
    });
};
var singleTypes = {
    async find (ctx) {
        const { userAbility } = ctx.state;
        const { model } = ctx.params;
        const { query = {} } = ctx.request;
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.read()) {
            return ctx.forbidden();
        }
        const permissionQuery = await permissionChecker.sanitizedQuery.read(query);
        const { locale, status } = await getDocumentLocaleAndStatus(query, model);
        const version = await findDocument(permissionQuery, model, {
            locale,
            status
        });
        // allow user with create permission to know a single type is not created
        if (!version) {
            if (permissionChecker.cannot.create()) {
                return ctx.forbidden();
            }
            // Check if document exists
            const document = await strapi.db.query(model).findOne({});
            if (!document) {
                return ctx.notFound();
            }
            // If the requested locale doesn't exist, return an empty response
            const { meta } = await formatDocumentWithMetadata(permissionChecker, model, // @ts-expect-error - fix types
            {
                documentId: document.documentId,
                locale,
                publishedAt: null
            }, {
                availableLocales: true,
                availableStatus: false
            });
            ctx.body = {
                data: {},
                meta
            };
            return;
        }
        if (permissionChecker.cannot.read(version)) {
            return ctx.forbidden();
        }
        const sanitizedDocument = await permissionChecker.sanitizeOutput(version);
        ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument);
    },
    async createOrUpdate (ctx) {
        const { userAbility } = ctx.state;
        const { model } = ctx.params;
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        const document = await createOrUpdateDocument(ctx);
        const sanitizedDocument = await permissionChecker.sanitizeOutput(document);
        ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument);
    },
    async delete (ctx) {
        const { userAbility } = ctx.state;
        const { model } = ctx.params;
        const { query = {} } = ctx.request;
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.delete()) {
            return ctx.forbidden();
        }
        const sanitizedQuery = await permissionChecker.sanitizedQuery.delete(query);
        const populate = await buildPopulateFromQuery(sanitizedQuery, model);
        const { locale } = await getDocumentLocaleAndStatus(query, model);
        const documentLocales = await documentManager.findLocales(undefined, model, {
            populate,
            locale
        });
        if (documentLocales.length === 0) {
            return ctx.notFound();
        }
        for (const document of documentLocales){
            if (permissionChecker.cannot.delete(document)) {
                return ctx.forbidden();
            }
        }
        const deletedEntity = await documentManager.delete(documentLocales.at(0).documentId, model, {
            locale
        });
        ctx.body = await permissionChecker.sanitizeOutput(deletedEntity);
    },
    async publish (ctx) {
        const { userAbility } = ctx.state;
        const { model } = ctx.params;
        const { query = {} } = ctx.request;
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.publish()) {
            return ctx.forbidden();
        }
        const publishedDocument = await strapi.db.transaction(async ()=>{
            const sanitizedQuery = await permissionChecker.sanitizedQuery.publish(query);
            const populate = await buildPopulateFromQuery(sanitizedQuery, model);
            const document = await createOrUpdateDocument(ctx, {
                populate
            });
            if (!document) {
                throw new strapiUtils.errors.NotFoundError();
            }
            if (permissionChecker.cannot.publish(document)) {
                throw new strapiUtils.errors.ForbiddenError();
            }
            const { locale } = await getDocumentLocaleAndStatus(document, model);
            const publishResult = await documentManager.publish(document.documentId, model, {
                locale
            });
            return publishResult.at(0);
        });
        const sanitizedDocument = await permissionChecker.sanitizeOutput(publishedDocument);
        ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument);
    },
    async unpublish (ctx) {
        const { userAbility } = ctx.state;
        const { model } = ctx.params;
        const { body: { discardDraft, ...body }, query = {} } = ctx.request;
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.unpublish()) {
            return ctx.forbidden();
        }
        if (discardDraft && permissionChecker.cannot.discard()) {
            return ctx.forbidden();
        }
        const sanitizedQuery = await permissionChecker.sanitizedQuery.unpublish(query);
        const { locale } = await getDocumentLocaleAndStatus(body, model);
        const document = await findDocument(sanitizedQuery, model, {
            locale
        });
        if (!document) {
            return ctx.notFound();
        }
        if (permissionChecker.cannot.unpublish(document)) {
            return ctx.forbidden();
        }
        if (discardDraft && permissionChecker.cannot.discard(document)) {
            return ctx.forbidden();
        }
        await strapi.db.transaction(async ()=>{
            if (discardDraft) {
                await documentManager.discardDraft(document.documentId, model, {
                    locale
                });
            }
            ctx.body = await strapiUtils.async.pipe((document)=>documentManager.unpublish(document.documentId, model, {
                    locale
                }), permissionChecker.sanitizeOutput, (document)=>formatDocumentWithMetadata(permissionChecker, model, document))(document);
        });
    },
    async discard (ctx) {
        const { userAbility } = ctx.state;
        const { model } = ctx.params;
        const { body, query = {} } = ctx.request;
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        if (permissionChecker.cannot.discard()) {
            return ctx.forbidden();
        }
        const sanitizedQuery = await permissionChecker.sanitizedQuery.discard(query);
        const { locale } = await getDocumentLocaleAndStatus(body, model);
        const document = await findDocument(sanitizedQuery, model, {
            locale,
            status: 'published'
        });
        // Can not discard a document that is not published
        if (!document) {
            return ctx.notFound();
        }
        if (permissionChecker.cannot.discard(document)) {
            return ctx.forbidden();
        }
        ctx.body = await strapiUtils.async.pipe((document)=>documentManager.discardDraft(document.documentId, model, {
                locale
            }), permissionChecker.sanitizeOutput, (document)=>formatDocumentWithMetadata(permissionChecker, model, document))(document);
    },
    async countDraftRelations (ctx) {
        const { userAbility } = ctx.state;
        const { model } = ctx.params;
        const { query } = ctx.request;
        const documentManager = getService$2('document-manager');
        const permissionChecker = getService$2('permission-checker').create({
            userAbility,
            model
        });
        const { locale } = await getDocumentLocaleAndStatus(query, model);
        if (permissionChecker.cannot.read()) {
            return ctx.forbidden();
        }
        const document = await findDocument({}, model);
        if (!document) {
            return ctx.notFound();
        }
        if (permissionChecker.cannot.read(document)) {
            return ctx.forbidden();
        }
        const number = await documentManager.countDraftRelations(document.documentId, model, locale);
        return {
            data: number
        };
    }
};

var uid$1 = {
    async generateUID (ctx) {
        const { contentTypeUID, field, data } = await validateGenerateUIDInput(ctx.request.body);
        const { query = {} } = ctx.request;
        const { locale } = await getDocumentLocaleAndStatus(query, contentTypeUID);
        await validateUIDField(contentTypeUID, field);
        const uidService = getService$2('uid');
        ctx.body = {
            data: await uidService.generateUIDField({
                contentTypeUID,
                field,
                data,
                locale
            })
        };
    },
    async checkUIDAvailability (ctx) {
        const { contentTypeUID, field, value } = await validateCheckUIDAvailabilityInput(ctx.request.body);
        const { query = {} } = ctx.request;
        const { locale } = await getDocumentLocaleAndStatus(query, contentTypeUID);
        await validateUIDField(contentTypeUID, field);
        const uidService = getService$2('uid');
        const isAvailable = await uidService.checkUIDAvailability({
            contentTypeUID,
            field,
            value,
            locale
        });
        ctx.body = {
            isAvailable,
            suggestion: !isAvailable ? await uidService.findUniqueUID({
                contentTypeUID,
                field,
                value,
                locale
            }) : null
        };
    }
};

var controllers = {
    'collection-types': collectionTypes,
    components: components$1,
    'content-types': contentTypes,
    init,
    relations,
    'single-types': singleTypes,
    uid: uid$1,
    ...history.controllers ? history.controllers : {},
    ...preview.controllers ? preview.controllers : {}
};

const keys = {
    CONFIGURATION: 'configuration'
};
const getStore = ()=>strapi.store({
        type: 'plugin',
        name: 'content_manager'
    });
/** Model configuration */ const EMPTY_CONFIG = {
    settings: {},
    metadatas: {},
    layouts: {}
};
const configurationKey = (key)=>`${keys.CONFIGURATION}_${key}`;
const getModelConfiguration = async (key)=>{
    const config = await getStore().get({
        key: configurationKey(key)
    });
    return _.merge({}, EMPTY_CONFIG, config);
};
const setModelConfiguration = async (key, value)=>{
    const storedConfig = await getStore().get({
        key: configurationKey(key)
    }) || {};
    const currentConfig = {
        ...storedConfig
    };
    Object.keys(value).forEach((key)=>{
        if (value[key] !== null && value[key] !== undefined) {
            _.set(currentConfig, key, value[key]);
        }
    });
    if (!_.isEqual(currentConfig, storedConfig)) {
        return getStore().set({
            key: configurationKey(key),
            value: currentConfig
        });
    }
};
const deleteKey = (key)=>{
    return strapi.db.query('strapi::core-store').delete({
        where: {
            key: `plugin_content_manager_configuration_${key}`
        }
    });
};
const findByKey = async (key)=>{
    const results = await strapi.db.query('strapi::core-store').findMany({
        where: {
            key: {
                $startsWith: key
            }
        }
    });
    return results.map(({ value })=>JSON.parse(value));
};
const getAllConfigurations = ()=>findByKey('plugin_content_manager_configuration');
var storeUtils = {
    getAllConfigurations,
    findByKey,
    getModelConfiguration,
    setModelConfiguration,
    deleteKey,
    keys
};

function createDefaultMetadatas(schema) {
    return {
        ...Object.keys(schema.attributes).reduce((acc, name)=>{
            acc[name] = createDefaultMetadata(schema, name);
            return acc;
        }, {}),
        id: {
            edit: {},
            list: {
                label: 'id',
                searchable: true,
                sortable: true
            }
        }
    };
}
function createDefaultMetadata(schema, name) {
    const edit = {
        label: name,
        description: '',
        placeholder: '',
        visible: isVisible$1(schema, name),
        editable: true
    };
    const fieldAttributes = schema.attributes[name];
    if (isRelation$1(fieldAttributes)) {
        const { targetModel } = fieldAttributes;
        const targetSchema = getTargetSchema(targetModel);
        if (targetSchema) {
            edit.mainField = getDefaultMainField(targetSchema);
        }
    }
    _.assign(edit, _.pick(_.get(schema, [
        'config',
        'metadatas',
        name,
        'edit'
    ], {}), [
        'label',
        'description',
        'placeholder',
        'visible',
        'editable',
        'mainField'
    ]));
    const list = {
        // @ts-expect-error we need to specify these properties
        label: name,
        // @ts-expect-error we need to specify these properties
        searchable: isSearchable(schema, name),
        // @ts-expect-error we need to specify these properties
        sortable: isSortable(schema, name),
        ..._.pick(_.get(schema, [
            'config',
            'metadatas',
            name,
            'list'
        ], {}), [
            'label',
            'searchable',
            'sortable'
        ])
    };
    return {
        edit,
        list
    };
}
/** Synchronisation functions */ async function syncMetadatas(configuration, schema) {
    // clear all keys that do not exist anymore
    if (_.isEmpty(configuration.metadatas)) {
        return createDefaultMetadatas(schema);
    }
    // remove old keys
    const metasWithValidKeys = _.pick(configuration.metadatas, Object.keys(schema.attributes));
    // add new keys and missing fields
    const metasWithDefaults = _.merge({}, createDefaultMetadatas(schema), metasWithValidKeys);
    // clear the invalid mainFields
    const updatedMetas = Object.keys(metasWithDefaults).reduce((acc, key)=>{
        const { edit, list } = metasWithDefaults[key];
        const attr = schema.attributes[key];
        const updatedMeta = {
            edit,
            list
        };
        // update sortable attr
        if (list.sortable && !isSortable(schema, key)) {
            _.set(updatedMeta, [
                'list',
                'sortable'
            ], false);
            _.set(acc, [
                key
            ], updatedMeta);
        }
        if (list.searchable && !isSearchable(schema, key)) {
            _.set(updatedMeta, [
                'list',
                'searchable'
            ], false);
            _.set(acc, [
                key
            ], updatedMeta);
        }
        if (!_.has(edit, 'mainField')) return acc;
        // remove mainField if the attribute is not a relation anymore
        if (!isRelation$1(attr)) {
            _.set(updatedMeta, 'edit', _.omit(edit, [
                'mainField'
            ]));
            _.set(acc, [
                key
            ], updatedMeta);
            return acc;
        }
        // if the mainField is id you can keep it
        if (edit.mainField === 'id') return acc;
        // check the mainField in the targetModel
        const targetSchema = getTargetSchema(attr.targetModel);
        if (!targetSchema) return acc;
        if (!isSortable(targetSchema, edit.mainField) && !isListable(targetSchema, edit.mainField)) {
            _.set(updatedMeta, [
                'edit',
                'mainField'
            ], getDefaultMainField(targetSchema));
            _.set(acc, [
                key
            ], updatedMeta);
            return acc;
        }
        return acc;
    }, {});
    return _.assign(metasWithDefaults, updatedMetas);
}
const getTargetSchema = (targetModel)=>{
    return getService$2('content-types').findContentType(targetModel);
};

const DEFAULT_LIST_LENGTH = 4;
const MAX_ROW_SIZE = 12;
const isAllowedFieldSize = (type, size)=>{
    const { getFieldSize } = getService$2('field-sizes');
    const fieldSize = getFieldSize(type);
    // Check if field was locked to another size
    if (!fieldSize.isResizable && size !== fieldSize.default) {
        return false;
    }
    // Otherwise allow unless it's bigger than a row
    return size <= MAX_ROW_SIZE;
};
const getDefaultFieldSize = (attribute)=>{
    const { hasFieldSize, getFieldSize } = getService$2('field-sizes');
    // Check if it's a custom field with a custom size and get the default size for the field type
    return getFieldSize(hasFieldSize(attribute.customField) ? attribute.customField : attribute.type).default;
};
async function createDefaultLayouts(schema) {
    return {
        // @ts-expect-error necessary to provide this default layout
        list: createDefaultListLayout(schema),
        // @ts-expect-error necessary to provide this default layout
        edit: createDefaultEditLayout(schema),
        ..._.pick(_.get(schema, [
            'config',
            'layouts'
        ], {}), [
            'list',
            'edit'
        ])
    };
}
function createDefaultListLayout(schema) {
    return Object.keys(schema.attributes).filter((name)=>isListable(schema, name)).slice(0, DEFAULT_LIST_LENGTH);
}
const rowSize = (els)=>els.reduce((sum, el)=>sum + el.size, 0);
function createDefaultEditLayout(schema) {
    const keys = Object.keys(schema.attributes).filter((name)=>hasEditableAttribute(schema, name));
    return appendToEditLayout([], keys, schema);
}
/** Synchronisation functions */ function syncLayouts(configuration, schema) {
    if (_.isEmpty(configuration.layouts)) return createDefaultLayouts(schema);
    const { list = [], editRelations = [], edit = [] } = configuration.layouts || {};
    let cleanList = list.filter((attr)=>isListable(schema, attr));
    // TODO V5: remove editRelations
    const cleanEditRelations = editRelations.filter((attr)=>hasRelationAttribute(schema, attr));
    // backward compatibility with when relations were on the side of the layout
    // it migrates the displayed relations to the main edit layout
    const elementsToReAppend = [
        ...cleanEditRelations
    ];
    let cleanEdit = [];
    for (const row of edit){
        const newRow = [];
        for (const el of row){
            if (!hasEditableAttribute(schema, el.name)) continue;
            // Check if the field is a custom field with a custom size.
            // If so, use the custom size instead of the type size
            const { hasFieldSize } = getService$2('field-sizes');
            const fieldType = hasFieldSize(schema.attributes[el.name].customField) ? schema.attributes[el.name].customField : schema.attributes[el.name].type;
            /* if the type of a field was changed (ex: string -> json) or a new field was added in the schema
         and the new type doesn't allow the size of the previous type, append the field at the end of layouts
      */ if (!isAllowedFieldSize(fieldType, el.size)) {
                elementsToReAppend.push(el.name);
                continue;
            }
            newRow.push(el);
        }
        if (newRow.length > 0) {
            cleanEdit.push(newRow);
        }
    }
    cleanEdit = appendToEditLayout(cleanEdit, elementsToReAppend, schema);
    const newAttributes = _.difference(Object.keys(schema.attributes), Object.keys(configuration.metadatas));
    /** Add new attributes where they belong */ if (cleanList.length < DEFAULT_LIST_LENGTH) {
        // add newAttributes
        // only add valid listable attributes
        cleanList = _.uniq(cleanList.concat(newAttributes.filter((key)=>isListable(schema, key))).slice(0, DEFAULT_LIST_LENGTH));
    }
    // add new attributes to edit view
    const newEditAttributes = newAttributes.filter((key)=>hasEditableAttribute(schema, key));
    cleanEdit = appendToEditLayout(cleanEdit, newEditAttributes, schema);
    return {
        list: cleanList.length > 0 ? cleanList : createDefaultListLayout(schema),
        edit: cleanEdit.length > 0 ? cleanEdit : createDefaultEditLayout(schema)
    };
}
// eslint-disable-next-line @typescript-eslint/default-param-last
const appendToEditLayout = (layout = [], keysToAppend, schema)=>{
    if (keysToAppend.length === 0) return layout;
    let currentRowIndex = Math.max(layout.length - 1, 0);
    // init currentRow if necessary
    if (!layout[currentRowIndex]) {
        layout[currentRowIndex] = [];
    }
    for (const key of keysToAppend){
        const attribute = schema.attributes[key];
        const attributeSize = getDefaultFieldSize(attribute);
        const currenRowSize = rowSize(layout[currentRowIndex]);
        if (currenRowSize + attributeSize > MAX_ROW_SIZE) {
            currentRowIndex += 1;
            layout[currentRowIndex] = [];
        }
        layout[currentRowIndex].push({
            name: key,
            size: attributeSize
        });
    }
    return layout;
};

async function validateCustomConfig(schema) {
    try {
        await createModelConfigurationSchema(schema, {
            allowUndefined: true
        }).validate(schema.config);
    } catch (error) {
        throw new Error(`Invalid Model configuration for model ${schema.uid}. Verify your {{ modelName }}.config.js(on) file:\n  - ${error.message}\n`);
    }
}
async function createDefaultConfiguration(schema) {
    await validateCustomConfig(schema);
    return {
        settings: await createDefaultSettings(schema),
        metadatas: await createDefaultMetadatas(schema),
        layouts: await createDefaultLayouts(schema)
    };
}
async function syncConfiguration(conf, schema) {
    await validateCustomConfig(schema);
    return {
        settings: await syncSettings(conf, schema),
        layouts: await syncLayouts(conf, schema),
        metadatas: await syncMetadatas(conf, schema)
    };
}

var createConfigurationService = (({ isComponent, prefix, storeUtils, getModels })=>{
    const uidToStoreKey = (uid)=>{
        return `${prefix}::${uid}`;
    };
    const getConfiguration = (uid)=>{
        const storeKey = uidToStoreKey(uid);
        return storeUtils.getModelConfiguration(storeKey);
    };
    const setConfiguration = (uid, input)=>{
        const configuration = {
            ...input,
            uid,
            isComponent: isComponent ?? undefined
        };
        const storeKey = uidToStoreKey(uid);
        return storeUtils.setModelConfiguration(storeKey, configuration);
    };
    const deleteConfiguration = (uid)=>{
        const storeKey = uidToStoreKey(uid);
        return storeUtils.deleteKey(storeKey);
    };
    const syncConfigurations = async ()=>{
        const models = getModels();
        const configurations = await storeUtils.findByKey(`plugin_content_manager_configuration_${prefix}`);
        const updateConfiguration = async (uid)=>{
            const conf = configurations.find((conf)=>conf.uid === uid);
            return setConfiguration(uid, await syncConfiguration(conf, models[uid]));
        };
        const generateNewConfiguration = async (uid)=>{
            return setConfiguration(uid, await createDefaultConfiguration(models[uid]));
        };
        const currentUIDS = Object.keys(models);
        const DBUIDs = configurations.map(({ uid })=>uid);
        const contentTypesToUpdate = _.intersection(currentUIDS, DBUIDs);
        const contentTypesToAdd = _.difference(currentUIDS, DBUIDs);
        const contentTypesToDelete = _.difference(DBUIDs, currentUIDS);
        // delete old schemas
        await Promise.all(contentTypesToDelete.map((uid)=>deleteConfiguration(uid)));
        // create new schemas
        await Promise.all(contentTypesToAdd.map((uid)=>generateNewConfiguration(uid)));
        // update current schemas
        await Promise.all(contentTypesToUpdate.map((uid)=>updateConfiguration(uid)));
    };
    return {
        getConfiguration,
        setConfiguration,
        deleteConfiguration,
        syncConfigurations
    };
});

const STORE_KEY_PREFIX = 'components';
const configurationService$1 = createConfigurationService({
    storeUtils,
    isComponent: true,
    prefix: STORE_KEY_PREFIX,
    getModels () {
        const { toContentManagerModel } = getService$2('data-mapper');
        return fp.mapValues(toContentManagerModel, strapi.components);
    }
});
var components = (({ strapi: strapi1 })=>({
        findAllComponents () {
            const { toContentManagerModel } = getService$2('data-mapper');
            return Object.values(strapi1.components).map(toContentManagerModel);
        },
        findComponent (uid) {
            const { toContentManagerModel } = getService$2('data-mapper');
            const component = strapi1.components[uid];
            return fp.isNil(component) ? component : toContentManagerModel(component);
        },
        async findConfiguration (component) {
            const configuration = await configurationService$1.getConfiguration(component.uid);
            return {
                uid: component.uid,
                category: component.category,
                ...configuration
            };
        },
        async updateConfiguration (component, newConfiguration) {
            await configurationService$1.setConfiguration(component.uid, newConfiguration);
            return this.findConfiguration(component);
        },
        async findComponentsConfigurations (model) {
            const componentsMap = {};
            const getComponentConfigurations = async (uid)=>{
                const component = this.findComponent(uid);
                if (fp.has(uid, componentsMap)) {
                    return;
                }
                const componentConfiguration = await this.findConfiguration(component);
                const componentsConfigurations = await this.findComponentsConfigurations(component);
                Object.assign(componentsMap, {
                    [uid]: componentConfiguration,
                    ...componentsConfigurations
                });
            };
            for (const key of Object.keys(model.attributes)){
                const attribute = model.attributes[key];
                if (attribute.type === 'component') {
                    await getComponentConfigurations(attribute.component);
                }
                if (attribute.type === 'dynamiczone') {
                    for (const componentUid of attribute.components){
                        await getComponentConfigurations(componentUid);
                    }
                }
            }
            return componentsMap;
        },
        syncConfigurations () {
            return configurationService$1.syncConfigurations();
        }
    }));

const configurationService = createConfigurationService({
    storeUtils,
    prefix: 'content_types',
    getModels () {
        const { toContentManagerModel } = getService$2('data-mapper');
        return fp.mapValues(toContentManagerModel, strapi.contentTypes);
    }
});
const service = ({ strapi: strapi1 })=>({
        findAllContentTypes () {
            const { toContentManagerModel } = getService$2('data-mapper');
            return Object.values(strapi1.contentTypes).map(toContentManagerModel);
        },
        findContentType (uid) {
            const { toContentManagerModel } = getService$2('data-mapper');
            const contentType = strapi1.contentTypes[uid];
            return fp.isNil(contentType) ? contentType : toContentManagerModel(contentType);
        },
        findDisplayedContentTypes () {
            return this.findAllContentTypes().filter(// TODO
            // @ts-expect-error should be resolved from data-mapper types
            ({ isDisplayed })=>isDisplayed === true);
        },
        findContentTypesByKind (kind) {
            if (!kind) {
                return this.findAllContentTypes();
            }
            // @ts-expect-error TODO when adding types
            return this.findAllContentTypes().filter(strapiUtils.contentTypes.isKind(kind));
        },
        async findConfiguration (contentType) {
            const configuration = await configurationService.getConfiguration(contentType.uid);
            return {
                uid: contentType.uid,
                ...configuration
            };
        },
        async updateConfiguration (contentType, newConfiguration) {
            await configurationService.setConfiguration(contentType.uid, newConfiguration);
            return this.findConfiguration(contentType);
        },
        findComponentsConfigurations (contentType) {
            // delegate to componentService
            return getService$2('components').findComponentsConfigurations(contentType);
        },
        syncConfigurations () {
            return configurationService.syncConfigurations();
        }
    });

const dtoFields = [
    'uid',
    'isDisplayed',
    'apiID',
    'kind',
    'category',
    'info',
    'options',
    'pluginOptions',
    'attributes',
    'pluginOptions'
];
var dataMapper = (()=>({
        toContentManagerModel (contentType) {
            return {
                ...contentType,
                apiID: contentType.modelName,
                isDisplayed: isVisible(contentType),
                attributes: {
                    id: {
                        type: 'integer'
                    },
                    ...formatAttributes(contentType)
                }
            };
        },
        toDto: fp.pick(dtoFields)
    }));
const formatAttributes = (contentType)=>{
    const { getVisibleAttributes, getTimestamps, getCreatorFields } = strapiUtils.contentTypes;
    // only get attributes that can be seen in the auto generated Edit view or List view
    return getVisibleAttributes(contentType).concat(getTimestamps(contentType)).concat(getCreatorFields(contentType)).reduce((acc, key)=>{
        const attribute = contentType.attributes[key];
        // ignore morph until they are handled in the front
        if (attribute.type === 'relation' && attribute.relation.toLowerCase().includes('morph')) {
            return acc;
        }
        acc[key] = formatAttribute(key, attribute);
        return acc;
    }, {});
};
// FIXME: not needed
const formatAttribute = (key, attribute)=>{
    if (attribute.type === 'relation') {
        return toRelation(attribute);
    }
    return attribute;
};
// FIXME: not needed
const toRelation = (attribute)=>{
    return {
        ...attribute,
        type: 'relation',
        targetModel: 'target' in attribute ? attribute.target : undefined,
        relationType: attribute.relation
    };
};
const isVisible = (model)=>fp.getOr(true, 'pluginOptions.content-manager.visible', model) === true;

const { ApplicationError: ApplicationError$1 } = strapiUtils.errors;
const needsFullSize = {
    default: 12,
    isResizable: false
};
const smallSize = {
    default: 4,
    isResizable: true
};
const defaultSize = {
    default: 6,
    isResizable: true
};
const fieldSizes = {
    // Full row and not resizable
    dynamiczone: needsFullSize,
    component: needsFullSize,
    json: needsFullSize,
    richtext: needsFullSize,
    blocks: needsFullSize,
    // Small and resizable
    checkbox: smallSize,
    boolean: smallSize,
    date: smallSize,
    time: smallSize,
    biginteger: smallSize,
    decimal: smallSize,
    float: smallSize,
    integer: smallSize,
    number: smallSize,
    // Medium and resizable
    datetime: defaultSize,
    email: defaultSize,
    enumeration: defaultSize,
    media: defaultSize,
    password: defaultSize,
    relation: defaultSize,
    string: defaultSize,
    text: defaultSize,
    timestamp: defaultSize,
    uid: defaultSize
};
const createFieldSizesService = ({ strapi })=>{
    const fieldSizesService = {
        getAllFieldSizes () {
            return fieldSizes;
        },
        hasFieldSize (type) {
            return !!fieldSizes[type];
        },
        getFieldSize (type) {
            if (!type) {
                throw new ApplicationError$1('The type is required');
            }
            const fieldSize = fieldSizes[type];
            if (!fieldSize) {
                throw new ApplicationError$1(`Could not find field size for type ${type}`);
            }
            return fieldSize;
        },
        setFieldSize (type, size) {
            if (!type) {
                throw new ApplicationError$1('The type is required');
            }
            if (!size) {
                throw new ApplicationError$1('The size is required');
            }
            fieldSizes[type] = size;
        },
        setCustomFieldInputSizes () {
            // Find all custom fields already registered
            const customFields = strapi.get('custom-fields').getAll();
            // If they have a custom field size, register it
            // TODO types can be inferred when customFields is typed
            Object.entries(customFields).forEach(([uid, customField])=>{
                if (customField.inputSize) {
                    fieldSizesService.setFieldSize(uid, customField.inputSize);
                }
            });
        }
    };
    return fieldSizesService;
};

const { getRelationalFields } = strapiUtils.relations;
var metrics = (({ strapi })=>{
    const sendDidConfigureListView = async (contentType, configuration)=>{
        const displayedFields = fp.prop('length', configuration.layouts.list);
        const relationalFields = getRelationalFields(contentType);
        const displayedRelationalFields = fp.intersection(relationalFields, configuration.layouts.list).length;
        const data = {
            eventProperties: {
                containsRelationalFields: !!displayedRelationalFields
            }
        };
        if (data.eventProperties.containsRelationalFields) {
            Object.assign(data.eventProperties, {
                displayedFields,
                displayedRelationalFields
            });
        }
        try {
            await strapi.telemetry.send('didConfigureListView', data);
        } catch (e) {
        // silence
        }
    };
    return {
        sendDidConfigureListView
    };
});

const ACTIONS = {
    read: 'plugin::content-manager.explorer.read',
    create: 'plugin::content-manager.explorer.create',
    update: 'plugin::content-manager.explorer.update',
    delete: 'plugin::content-manager.explorer.delete',
    publish: 'plugin::content-manager.explorer.publish',
    unpublish: 'plugin::content-manager.explorer.publish',
    discard: 'plugin::content-manager.explorer.update'
};
const createPermissionChecker = (strapi)=>({ userAbility, model })=>{
        const permissionsManager = strapi.service('admin::permission').createPermissionsManager({
            ability: userAbility,
            model
        });
        const { actionProvider } = strapi.service('admin::permission');
        const toSubject = (entity)=>{
            return entity ? permissionsManager.toSubject(entity, model) : model;
        };
        // @ts-expect-error preserve the parameter order
        // eslint-disable-next-line @typescript-eslint/default-param-last
        const can = (action, entity, field)=>{
            const subject = toSubject(entity);
            const aliases = actionProvider.unstable_aliases(action, model);
            return(// Test the original action to see if it passes
            userAbility.can(action, subject, field) || // Else try every known alias if at least one of them succeed, then the user "can"
            aliases.some((alias)=>userAbility.can(alias, subject, field)));
        };
        // @ts-expect-error preserve the parameter order
        // eslint-disable-next-line @typescript-eslint/default-param-last
        const cannot = (action, entity, field)=>{
            const subject = toSubject(entity);
            const aliases = actionProvider.unstable_aliases(action, model);
            return(// Test both the original action
            userAbility.cannot(action, subject, field) && // and every known alias, if all of them fail (cannot), then the user truly "cannot"
            aliases.every((alias)=>userAbility.cannot(alias, subject, field)));
        };
        const sanitizeOutput = (data, { action = ACTIONS.read } = {})=>{
            return permissionsManager.sanitizeOutput(data, {
                subject: toSubject(data),
                action
            });
        };
        const sanitizeQuery = (query, { action = ACTIONS.read } = {})=>{
            return permissionsManager.sanitizeQuery(query, {
                subject: model,
                action
            });
        };
        const sanitizeInput = (action, data, entity)=>{
            return permissionsManager.sanitizeInput(data, {
                subject: entity ? toSubject(entity) : model,
                action
            });
        };
        const validateQuery = (query, { action = ACTIONS.read } = {})=>{
            return permissionsManager.validateQuery(query, {
                subject: model,
                action
            });
        };
        const validateInput = (action, data, entity)=>{
            return permissionsManager.validateInput(data, {
                subject: entity ? toSubject(entity) : model,
                action
            });
        };
        const sanitizeCreateInput = (data)=>sanitizeInput(ACTIONS.create, data);
        const sanitizeUpdateInput = (entity)=>(data)=>sanitizeInput(ACTIONS.update, data, entity);
        const buildPermissionQuery = (query, action = {})=>{
            return permissionsManager.addPermissionsQueryTo(query, action);
        };
        const sanitizedQuery = (query, action = {})=>{
            return strapiUtils.async.pipe((q)=>sanitizeQuery(q, action), (q)=>buildPermissionQuery(q, action))(query);
        };
        // Sanitized queries shortcuts
        Object.keys(ACTIONS).forEach((action)=>{
            // @ts-expect-error TODO
            sanitizedQuery[action] = (query)=>sanitizedQuery(query, ACTIONS[action]);
        });
        // Permission utils shortcuts
        Object.keys(ACTIONS).forEach((action)=>{
            // @ts-expect-error TODO
            can[action] = (...args)=>can(ACTIONS[action], ...args);
            // @ts-expect-error TODO
            cannot[action] = (...args)=>cannot(ACTIONS[action], ...args);
        });
        return {
            // Permission utils
            can,
            cannot,
            // Sanitizers
            sanitizeOutput,
            sanitizeQuery,
            sanitizeCreateInput,
            sanitizeUpdateInput,
            // Validators
            validateQuery,
            validateInput,
            // Queries Builder
            sanitizedQuery
        };
    };
var permissionChecker = (({ strapi })=>({
        create: createPermissionChecker(strapi)
    }));

var permission = (({ strapi })=>({
        canConfigureContentType ({ userAbility, contentType }) {
            const action = strapiUtils.contentTypes.isSingleType(contentType) ? 'plugin::content-manager.single-types.configure-view' : 'plugin::content-manager.collection-types.configure-view';
            return userAbility.can(action);
        },
        async registerPermissions () {
            const displayedContentTypes = getService$2('content-types').findDisplayedContentTypes();
            const contentTypesUids = displayedContentTypes.map(fp.prop('uid'));
            const actions = [
                {
                    section: 'contentTypes',
                    displayName: 'Create',
                    uid: 'explorer.create',
                    pluginName: 'content-manager',
                    subjects: contentTypesUids,
                    options: {
                        applyToProperties: [
                            'fields'
                        ]
                    }
                },
                {
                    section: 'contentTypes',
                    displayName: 'Read',
                    uid: 'explorer.read',
                    pluginName: 'content-manager',
                    subjects: contentTypesUids,
                    options: {
                        applyToProperties: [
                            'fields'
                        ]
                    }
                },
                {
                    section: 'contentTypes',
                    displayName: 'Update',
                    uid: 'explorer.update',
                    pluginName: 'content-manager',
                    subjects: contentTypesUids,
                    options: {
                        applyToProperties: [
                            'fields'
                        ]
                    }
                },
                {
                    section: 'contentTypes',
                    displayName: 'Delete',
                    uid: 'explorer.delete',
                    pluginName: 'content-manager',
                    subjects: contentTypesUids
                },
                {
                    section: 'contentTypes',
                    displayName: 'Publish',
                    uid: 'explorer.publish',
                    pluginName: 'content-manager',
                    subjects: contentTypesUids
                },
                {
                    section: 'plugins',
                    displayName: 'Configure view',
                    uid: 'single-types.configure-view',
                    subCategory: 'single types',
                    pluginName: 'content-manager'
                },
                {
                    section: 'plugins',
                    displayName: 'Configure view',
                    uid: 'collection-types.configure-view',
                    subCategory: 'collection types',
                    pluginName: 'content-manager'
                },
                {
                    section: 'plugins',
                    displayName: 'Configure Layout',
                    uid: 'components.configure-layout',
                    subCategory: 'components',
                    pluginName: 'content-manager'
                }
            ];
            await strapi.service('admin::permission').actionProvider.registerMany(actions);
        }
    }));

const { isVisibleAttribute: isVisibleAttribute$1, isScalarAttribute, getDoesAttributeRequireValidation } = strapiUtils.contentTypes;
const { isAnyToMany } = strapiUtils.relations;
const { PUBLISHED_AT_ATTRIBUTE: PUBLISHED_AT_ATTRIBUTE$1 } = strapiUtils.contentTypes.constants;
const isMorphToRelation = (attribute)=>isRelation(attribute) && attribute.relation.includes('morphTo');
const isMedia = fp.propEq('type', 'media');
const isRelation = fp.propEq('type', 'relation');
const isComponent = fp.propEq('type', 'component');
const isDynamicZone = fp.propEq('type', 'dynamiczone');
/**
 * Populate the model for relation
 * @param attribute - Attribute containing a relation
 * @param attribute.relation - type of relation
 * @param model - Model of the populated entity
 * @param attributeName
 * @param options - Options to apply while populating
 */ function getPopulateForRelation(attribute, model, attributeName, { countMany, countOne, initialPopulate }) {
    const isManyRelation = isAnyToMany(attribute);
    if (initialPopulate) {
        return initialPopulate;
    }
    // If populating localizations attribute, also include validatable fields
    // Mainly needed for bulk locale publishing, so the Client has all the information necessary to perform validations
    if (attributeName === 'localizations') {
        const validationPopulate = getPopulateForValidation(model.uid);
        return {
            populate: validationPopulate.populate
        };
    }
    // always populate createdBy, updatedBy, localizations etc.
    if (!isVisibleAttribute$1(model, attributeName)) {
        return true;
    }
    if (isManyRelation && countMany || !isManyRelation && countOne) {
        return {
            count: true
        };
    }
    return true;
}
/**
 * Populate the model for Dynamic Zone components
 * @param attribute - Attribute containing the components
 * @param attribute.components - IDs of components
 * @param options - Options to apply while populating
 */ function getPopulateForDZ(attribute, options, level) {
    // Use fragments to populate the dynamic zone components
    const populatedComponents = (attribute.components || []).reduce((acc, componentUID)=>({
            ...acc,
            [componentUID]: {
                populate: getDeepPopulate(componentUID, options, level + 1)
            }
        }), {});
    return {
        on: populatedComponents
    };
}
/**
 * Get the populated value based on the type of the attribute
 * @param attributeName - Name of the attribute
 * @param model - Model of the populated entity
 * @param model.attributes
 * @param options - Options to apply while populating
 * @param options.countMany
 * @param options.countOne
 * @param options.maxLevel
 * @param level
 */ function getPopulateFor(attributeName, model, options, level) {
    const attribute = model.attributes[attributeName];
    switch(attribute.type){
        case 'relation':
            // @ts-expect-error - TODO: support populate count typing
            return {
                [attributeName]: getPopulateForRelation(attribute, model, attributeName, options)
            };
        case 'component':
            return {
                [attributeName]: {
                    populate: getDeepPopulate(attribute.component, options, level + 1)
                }
            };
        case 'media':
            return {
                [attributeName]: {
                    populate: {
                        folder: true
                    }
                }
            };
        case 'dynamiczone':
            return {
                [attributeName]: getPopulateForDZ(attribute, options, level)
            };
        default:
            return {};
    }
}
/**
 * Deeply populate a model based on UID
 * @param uid - Unique identifier of the model
 * @param options - Options to apply while populating
 * @param level - Current level of nested call
 */ const getDeepPopulate = (uid, { initialPopulate = {}, countMany = false, countOne = false, maxLevel = Infinity } = {}, level = 1)=>{
    if (level > maxLevel) {
        return {};
    }
    const model = strapi.getModel(uid);
    if (!model) {
        return {};
    }
    return Object.keys(model.attributes).reduce((populateAcc, attributeName)=>fp.merge(populateAcc, getPopulateFor(attributeName, model, {
            // @ts-expect-error - improve types
            initialPopulate: initialPopulate?.[attributeName],
            countMany,
            countOne,
            maxLevel
        }, level)), {});
};
/**
 * Deeply populate a model based on UID. Only populating fields that require validation.
 * @param uid - Unique identifier of the model
 * @param options - Options to apply while populating
 * @param level - Current level of nested call
 */ const getPopulateForValidation = (uid)=>{
    const model = strapi.getModel(uid);
    if (!model) {
        return {};
    }
    return Object.entries(model.attributes).reduce((populateAcc, [attributeName, attribute])=>{
        if (isScalarAttribute(attribute)) {
            // If the scalar attribute requires validation, add it to the fields array
            if (getDoesAttributeRequireValidation(attribute)) {
                populateAcc.fields = populateAcc.fields || [];
                populateAcc.fields.push(attributeName);
            }
            return populateAcc;
        }
        if (isComponent(attribute)) {
            // @ts-expect-error - should be a component
            const component = attribute.component;
            // Get the validation result for this component
            const componentResult = getPopulateForValidation(component);
            if (Object.keys(componentResult).length > 0) {
                populateAcc.populate = populateAcc.populate || {};
                populateAcc.populate[attributeName] = componentResult;
            }
            return populateAcc;
        }
        if (isDynamicZone(attribute)) {
            const components = attribute.components;
            // Handle dynamic zone components
            const componentsResult = (components || []).reduce((acc, componentUID)=>{
                // Get validation populate for this component
                const componentResult = getPopulateForValidation(componentUID);
                // Only include component if it has fields requiring validation
                if (Object.keys(componentResult).length > 0) {
                    acc[componentUID] = componentResult;
                }
                return acc;
            }, {});
            // Only add to populate if we have components requiring validation
            if (Object.keys(componentsResult).length > 0) {
                populateAcc.populate = populateAcc.populate || {};
                populateAcc.populate[attributeName] = {
                    on: componentsResult
                };
            }
        }
        return populateAcc;
    }, {});
};
/**
 * getDeepPopulateDraftCount works recursively on the attributes of a model
 * creating a populated object to count all the unpublished relations within the model
 * These relations can be direct to this content type or contained within components/dynamic zones
 * @param  uid of the model
 * @returns result
 * @returns result.populate
 * @returns result.hasRelations
 */ const getDeepPopulateDraftCount = (uid)=>{
    const model = strapi.getModel(uid);
    let hasRelations = false;
    const populate = Object.keys(model.attributes).reduce((populateAcc, attributeName)=>{
        const attribute = model.attributes[attributeName];
        switch(attribute.type){
            case 'relation':
                {
                    // TODO: Support polymorphic relations
                    const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');
                    if (isMorphRelation) {
                        break;
                    }
                    if (isVisibleAttribute$1(model, attributeName)) {
                        populateAcc[attributeName] = {
                            count: true,
                            filters: {
                                [PUBLISHED_AT_ATTRIBUTE$1]: {
                                    $null: true
                                }
                            }
                        };
                        hasRelations = true;
                    }
                    break;
                }
            case 'component':
                {
                    const { populate, hasRelations: childHasRelations } = getDeepPopulateDraftCount(attribute.component);
                    if (childHasRelations) {
                        populateAcc[attributeName] = {
                            populate
                        };
                        hasRelations = true;
                    }
                    break;
                }
            case 'dynamiczone':
                {
                    const dzPopulateFragment = attribute.components?.reduce((acc, componentUID)=>{
                        const { populate: componentPopulate, hasRelations: componentHasRelations } = getDeepPopulateDraftCount(componentUID);
                        if (componentHasRelations) {
                            hasRelations = true;
                            return {
                                ...acc,
                                [componentUID]: {
                                    populate: componentPopulate
                                }
                            };
                        }
                        return acc;
                    }, {});
                    if (!fp.isEmpty(dzPopulateFragment)) {
                        populateAcc[attributeName] = {
                            on: dzPopulateFragment
                        };
                    }
                    break;
                }
        }
        return populateAcc;
    }, {});
    return {
        populate,
        hasRelations
    };
};
/**
 *  Create a Strapi populate object which populates all attribute fields of a Strapi query.
 */ const getQueryPopulate = async (uid, query)=>{
    let populateQuery = {};
    await strapiUtils.traverse.traverseQueryFilters(/**
     *
     * @param {Object} param0
     * @param {string} param0.key - Attribute name
     * @param {Object} param0.attribute - Attribute definition
     * @param {string} param0.path - Content Type path to the attribute
     * @returns
     */ ({ attribute, path })=>{
        // TODO: handle dynamic zones and morph relations
        if (!attribute || isDynamicZone(attribute) || isMorphToRelation(attribute)) {
            return;
        }
        // Populate all relations, components and media
        if (isRelation(attribute) || isMedia(attribute) || isComponent(attribute)) {
            const populatePath = path.attribute.replace(/\./g, '.populate.');
            // @ts-expect-error - lodash doesn't resolve the Populate type correctly
            populateQuery = fp.set(populatePath, {}, populateQuery);
        }
    }, {
        schema: strapi.getModel(uid),
        getModel: strapi.getModel.bind(strapi)
    }, query);
    return populateQuery;
};
const buildDeepPopulate = (uid)=>{
    return getService$2('populate-builder')(uid).populateDeep(Infinity).countRelations().build();
};

/**
 * Builder to create a Strapi populate object.
 *
 * @param uid - Content type UID
 *
 * @example
 * const populate = await populateBuilder('api::article.article').countRelations().build();
 * // populate = { article: { populate: { count: true } } }
 *
 */ const populateBuilder = (uid)=>{
    let getInitialPopulate = async ()=>{
        return undefined;
    };
    const deepPopulateOptions = {
        countMany: false,
        countOne: false,
        maxLevel: -1
    };
    const builder = {
        /**
     * Populates all attribute fields present in a query.
     * @param query - Strapi query object
     */ populateFromQuery (query) {
            getInitialPopulate = async ()=>getQueryPopulate(uid, query);
            return builder;
        },
        /**
     * Populate relations as count.
     * @param [options]
     * @param [options.toMany] - Populate XtoMany relations as count if true.
     * @param [options.toOne] - Populate XtoOne relations as count if true.
     */ countRelations ({ toMany, toOne } = {
            toMany: true,
            toOne: true
        }) {
            if (!fp.isNil(toMany)) {
                deepPopulateOptions.countMany = toMany;
            }
            if (!fp.isNil(toOne)) {
                deepPopulateOptions.countOne = toOne;
            }
            return builder;
        },
        /**
     * Populate relations deeply, up to a certain level.
     * @param [level=Infinity] - Max level of nested populate.
     */ populateDeep (level = Infinity) {
            deepPopulateOptions.maxLevel = level;
            return builder;
        },
        /**
     * Construct the populate object based on the builder options.
     * @returns Populate object
     */ async build () {
            const initialPopulate = await getInitialPopulate();
            if (deepPopulateOptions.maxLevel === -1) {
                return initialPopulate;
            }
            return getDeepPopulate(uid, {
                ...deepPopulateOptions,
                initialPopulate
            });
        }
    };
    return builder;
};
var populateBuilder$1 = (()=>populateBuilder);

var uid = (({ strapi })=>({
        async generateUIDField ({ contentTypeUID, field, data, locale }) {
            const contentType = strapi.contentTypes[contentTypeUID];
            const { attributes } = contentType;
            const { targetField, default: defaultValue, options } = attributes[field];
            // @ts-expect-error targetField can be undefined
            const targetValue = _.get(data, targetField);
            if (!_.isEmpty(targetValue)) {
                return this.findUniqueUID({
                    contentTypeUID,
                    field,
                    value: slugify(targetValue, options),
                    locale
                });
            }
            return this.findUniqueUID({
                contentTypeUID,
                field,
                value: slugify(_.isFunction(defaultValue) ? defaultValue() : defaultValue || contentType.modelName, options),
                locale
            });
        },
        async findUniqueUID ({ contentTypeUID, field, value, locale }) {
            const foundDocuments = await strapi.documents(contentTypeUID).findMany({
                filters: {
                    [field]: {
                        $startsWith: value
                    }
                },
                locale,
                // TODO: Check UX. When modifying an entry, it only makes sense to check for collisions with other drafts
                // However, when publishing this "available" UID might collide with another published entry
                status: 'draft'
            });
            if (!foundDocuments || foundDocuments.length === 0) {
                // If there are no documents found we can return the value as is
                return value;
            }
            let possibleCollisions;
            if (!Array.isArray(foundDocuments)) {
                possibleCollisions = [
                    foundDocuments[field]
                ];
            } else {
                possibleCollisions = foundDocuments.map((doc)=>doc[field]);
            }
            // If there are no documents sharing the proposed UID, we can return the value as is
            if (!possibleCollisions.includes(value)) {
                return value;
            }
            let i = 1;
            let tmpUId = `${value}-${i}`;
            while(possibleCollisions.includes(tmpUId)){
                // While there are documents sharing the proposed UID, we need to find a new one
                // by incrementing the suffix until we find a unique one
                i += 1;
                tmpUId = `${value}-${i}`;
            }
            return tmpUId;
        },
        async checkUIDAvailability ({ contentTypeUID, field, value, locale }) {
            const documentCount = await strapi.documents(contentTypeUID).count({
                filters: {
                    [field]: value
                },
                locale,
                // TODO: Check UX. When modifying an entry, it only makes sense to check for collisions with other drafts
                // However, when publishing this "available" UID might collide with another published entry
                status: 'draft'
            });
            if (documentCount && documentCount > 0) {
                // If there are documents sharing the proposed UID, we can return false
                return false;
            }
            return true;
        }
    }));

const AVAILABLE_STATUS_FIELDS = [
    'id',
    'locale',
    'updatedAt',
    'createdAt',
    'publishedAt',
    'createdBy',
    'updatedBy',
    'status'
];
const AVAILABLE_LOCALES_FIELDS = [
    'id',
    'locale',
    'updatedAt',
    'createdAt',
    'publishedAt',
    'documentId'
];
const CONTENT_MANAGER_STATUS = {
    PUBLISHED: 'published',
    DRAFT: 'draft',
    MODIFIED: 'modified'
};
/**
 * Checks if the provided document version has been modified after all other versions.
 */ const getIsVersionLatestModification = (version, otherVersion)=>{
    if (!version || !version.updatedAt) {
        return false;
    }
    const versionUpdatedAt = version?.updatedAt ? new Date(version.updatedAt).getTime() : 0;
    const otherUpdatedAt = otherVersion?.updatedAt ? new Date(otherVersion.updatedAt).getTime() : 0;
    return versionUpdatedAt > otherUpdatedAt;
};
var documentMetadata = (({ strapi })=>({
        /**
   * Returns available locales of a document for the current status
   */ async getAvailableLocales (uid, version, allVersions) {
            // Group all versions by locale
            const versionsByLocale = fp.groupBy('locale', allVersions);
            // Delete the current locale
            if (version.locale) {
                delete versionsByLocale[version.locale];
            }
            // For each locale, get the ones with the same status
            // There will not be a draft and a version counterpart if the content
            // type does not have draft and publish
            const model = strapi.getModel(uid);
            const mappingResult = await strapiUtils.async.map(Object.values(versionsByLocale), async (localeVersions)=>{
                if (!strapiUtils.contentTypes.hasDraftAndPublish(model)) {
                    return localeVersions[0];
                }
                const draftVersion = localeVersions.find((v)=>v.publishedAt === null);
                const otherVersions = localeVersions.filter((v)=>v.id !== draftVersion?.id);
                if (!draftVersion) {
                    return;
                }
                return {
                    ...draftVersion,
                    status: this.getStatus(draftVersion, otherVersions)
                };
            });
            return mappingResult// Filter just in case there is a document with no drafts
            .filter(Boolean);
        },
        /**
   * Returns available status of a document for the current locale
   */ getAvailableStatus (version, allVersions) {
            // Find the other status of the document
            const status = version.publishedAt !== null ? CONTENT_MANAGER_STATUS.DRAFT : CONTENT_MANAGER_STATUS.PUBLISHED;
            // Get version that match the current locale and not match the current status
            const availableStatus = allVersions.find((v)=>{
                const matchLocale = v.locale === version.locale;
                const matchStatus = status === 'published' ? v.publishedAt !== null : v.publishedAt === null;
                return matchLocale && matchStatus;
            });
            if (!availableStatus) return availableStatus;
            // Pick status fields (at fields, status, by fields), use lodash fp
            return fp.pick(AVAILABLE_STATUS_FIELDS, availableStatus);
        },
        /**
   * Get the available status of many documents, useful for batch operations
   * @param uid
   * @param documents
   * @returns
   */ async getManyAvailableStatus (uid, documents) {
            if (!documents.length) return [];
            // The status and locale of all documents should be the same
            const status = documents[0].publishedAt !== null ? 'published' : 'draft';
            const locales = documents.map((d)=>d.locale).filter(Boolean);
            const where = {
                documentId: {
                    $in: documents.map((d)=>d.documentId).filter(Boolean)
                },
                publishedAt: {
                    $null: status === 'published'
                }
            };
            // If there is any locale to filter (if i18n is enabled)
            if (locales.length) {
                where.locale = {
                    $in: locales
                };
            }
            return strapi.query(uid).findMany({
                where,
                select: [
                    'id',
                    'documentId',
                    'locale',
                    'updatedAt',
                    'createdAt',
                    'publishedAt'
                ]
            });
        },
        getStatus (version, otherDocumentStatuses) {
            let draftVersion;
            let publishedVersion;
            if (version.publishedAt) {
                publishedVersion = version;
            } else {
                draftVersion = version;
            }
            const otherVersion = otherDocumentStatuses?.at(0);
            if (otherVersion?.publishedAt) {
                publishedVersion = otherVersion;
            } else if (otherVersion) {
                draftVersion = otherVersion;
            }
            if (!draftVersion) return CONTENT_MANAGER_STATUS.PUBLISHED;
            if (!publishedVersion) return CONTENT_MANAGER_STATUS.DRAFT;
            /*
     * The document is modified if the draft version has been updated more
     * recently than the published version.
     */ const isDraftModified = getIsVersionLatestModification(draftVersion, publishedVersion);
            return isDraftModified ? CONTENT_MANAGER_STATUS.MODIFIED : CONTENT_MANAGER_STATUS.PUBLISHED;
        },
        // TODO is it necessary to return metadata on every page of the CM
        // We could refactor this so the locales are only loaded when they're
        // needed. e.g. in the bulk locale action modal.
        async getMetadata (uid, version, { availableLocales = true, availableStatus = true } = {}) {
            // TODO: Ignore publishedAt if availableStatus=false, and ignore locale if
            // i18n is disabled
            const { populate = {}, fields = [] } = getPopulateForValidation(uid);
            const params = {
                populate: {
                    ...populate,
                    // NOTE: creator fields are selected in this way to avoid exposing sensitive data
                    createdBy: {
                        select: [
                            'id',
                            'firstname',
                            'lastname',
                            'email'
                        ]
                    },
                    updatedBy: {
                        select: [
                            'id',
                            'firstname',
                            'lastname',
                            'email'
                        ]
                    }
                },
                fields: fp.uniq([
                    ...AVAILABLE_LOCALES_FIELDS,
                    ...fields
                ]),
                filters: {
                    documentId: version.documentId
                }
            };
            const dbParams = strapi.get('query-params').transform(uid, params);
            const versions = await strapi.db.query(uid).findMany(dbParams);
            // TODO: Remove use of available locales and use localizations instead
            const availableLocalesResult = availableLocales ? await this.getAvailableLocales(uid, version, versions) : [];
            const availableStatusResult = availableStatus ? this.getAvailableStatus(version, versions) : null;
            return {
                availableLocales: availableLocalesResult,
                availableStatus: availableStatusResult ? [
                    availableStatusResult
                ] : []
            };
        },
        /**
   * Returns associated metadata of a document:
   * - Available locales of the document for the current status
   * - Available status of the document for the current locale
   */ async formatDocumentWithMetadata (uid, document, opts = {}) {
            if (!document) {
                return {
                    data: document,
                    meta: {
                        availableLocales: [],
                        availableStatus: []
                    }
                };
            }
            const hasDraftAndPublish = strapiUtils.contentTypes.hasDraftAndPublish(strapi.getModel(uid));
            // Ignore available status if the content type does not have draft and publish
            if (!hasDraftAndPublish) {
                opts.availableStatus = false;
            }
            const meta = await this.getMetadata(uid, document, opts);
            // Populate localization statuses
            if (document.localizations) {
                const otherStatus = await this.getManyAvailableStatus(uid, document.localizations);
                document.localizations = document.localizations.map((d)=>{
                    const status = otherStatus.find((s)=>s.documentId === d.documentId);
                    return {
                        ...d,
                        status: this.getStatus(d, status ? [
                            status
                        ] : [])
                    };
                });
            }
            return {
                data: {
                    ...document,
                    // Add status to the document only if draft and publish is enabled
                    status: hasDraftAndPublish ? this.getStatus(document, meta.availableStatus) : undefined
                },
                meta
            };
        }
    }));

const { isVisibleAttribute } = strapiUtils.contentTypes;
/**
 * sumDraftCounts works recursively on the attributes of a model counting the
 * number of draft relations
 * These relations can be direct to this content type or contained within components/dynamic zones
 * @param {Object} entity containing the draft relation counts
 * @param {String} uid of the content type
 * @returns {Number} of draft relations
 */ const sumDraftCounts = (entity, uid)=>{
    const model = strapi.getModel(uid);
    return Object.keys(model.attributes).reduce((sum, attributeName)=>{
        const attribute = model.attributes[attributeName];
        const value = entity[attributeName];
        if (!value) {
            return sum;
        }
        switch(attribute.type){
            case 'relation':
                {
                    if (isVisibleAttribute(model, attributeName)) {
                        return sum + value.count;
                    }
                    return sum;
                }
            case 'component':
                {
                    const compoSum = fp.castArray(value).reduce((acc, componentValue)=>{
                        return acc + sumDraftCounts(componentValue, attribute.component);
                    }, 0);
                    return sum + compoSum;
                }
            case 'dynamiczone':
                {
                    const dzSum = value.reduce((acc, componentValue)=>{
                        return acc + sumDraftCounts(componentValue, componentValue.__component);
                    }, 0);
                    return sum + dzSum;
                }
            default:
                return sum;
        }
    }, 0);
};

const { ApplicationError } = strapiUtils.errors;
const { PUBLISHED_AT_ATTRIBUTE } = strapiUtils.contentTypes.constants;
const omitPublishedAtField = fp.omit(PUBLISHED_AT_ATTRIBUTE);
const omitIdField = fp.omit('id');
const documentManager = ({ strapi })=>{
    return {
        async findOne (id, uid, opts = {}) {
            return strapi.documents(uid).findOne({
                ...opts,
                documentId: id
            });
        },
        /**
     * Find multiple (or all) locales for a document
     */ async findLocales (id, uid, opts) {
            // Will look for a specific locale by default
            const where = {};
            // Might not have an id if querying a single type
            if (id) {
                where.documentId = id;
            }
            // Search in array of locales
            if (Array.isArray(opts.locale)) {
                where.locale = {
                    $in: opts.locale
                };
            } else if (opts.locale && opts.locale !== '*') {
                // Look for a specific locale, ignore if looking for all locales
                where.locale = opts.locale;
            }
            // Published is passed, so we filter on it, otherwise we don't filter
            if (typeof opts.isPublished === 'boolean') {
                where.publishedAt = {
                    $notNull: opts.isPublished
                };
            }
            return strapi.db.query(uid).findMany({
                populate: opts.populate,
                where
            });
        },
        async findMany (opts, uid) {
            const params = {
                ...opts,
                populate: getDeepPopulate(uid)
            };
            return strapi.documents(uid).findMany(params);
        },
        async findPage (opts, uid) {
            const params = strapiUtils.pagination.withDefaultPagination(opts || {}, {
                maxLimit: 1000
            });
            const [documents, total = 0] = await Promise.all([
                strapi.documents(uid).findMany(params),
                strapi.documents(uid).count(params)
            ]);
            return {
                results: documents,
                pagination: strapiUtils.pagination.transformPagedPaginationInfo(params, total)
            };
        },
        async create (uid, opts = {}) {
            const populate = opts.populate ?? await buildDeepPopulate(uid);
            const params = {
                ...opts,
                status: 'draft',
                populate
            };
            return strapi.documents(uid).create(params);
        },
        async update (id, uid, opts = {}) {
            const publishData = fp.pipe(omitPublishedAtField, omitIdField)(opts.data || {});
            const populate = opts.populate ?? await buildDeepPopulate(uid);
            const params = {
                ...opts,
                data: publishData,
                populate,
                status: 'draft'
            };
            return strapi.documents(uid).update({
                ...params,
                documentId: id
            });
        },
        async clone (id, body, uid) {
            const populate = await buildDeepPopulate(uid);
            const params = {
                data: omitIdField(body),
                populate
            };
            return strapi.documents(uid).clone({
                ...params,
                documentId: id
            }).then((result)=>result?.entries.at(0));
        },
        /**
     *  Check if a document exists
     */ async exists (uid, id) {
            // Collection type
            if (id) {
                const count = await strapi.db.query(uid).count({
                    where: {
                        documentId: id
                    }
                });
                return count > 0;
            }
            // Single type
            const count = await strapi.db.query(uid).count();
            return count > 0;
        },
        async delete (id, uid, opts = {}) {
            const populate = await buildDeepPopulate(uid);
            await strapi.documents(uid).delete({
                ...opts,
                documentId: id,
                populate
            });
            return {};
        },
        // FIXME: handle relations
        async deleteMany (documentIds, uid, opts = {}) {
            const deletedEntries = await strapi.db.transaction(async ()=>{
                return Promise.all(documentIds.map(async (id)=>this.delete(id, uid, opts)));
            });
            return {
                count: deletedEntries.length
            };
        },
        async publish (id, uid, opts = {}) {
            const populate = await buildDeepPopulate(uid);
            const params = {
                ...opts,
                populate
            };
            return strapi.documents(uid).publish({
                ...params,
                documentId: id
            }).then((result)=>result?.entries);
        },
        async publishMany (uid, documentIds, locale) {
            return strapi.db.transaction(async ()=>{
                const results = await Promise.all(documentIds.map((documentId)=>this.publish(documentId, uid, {
                        locale
                    })));
                const publishedEntitiesCount = results.flat().filter(Boolean).length;
                return publishedEntitiesCount;
            });
        },
        async unpublishMany (documentIds, uid, opts = {}) {
            const unpublishedEntries = await strapi.db.transaction(async ()=>{
                return Promise.all(documentIds.map((id)=>strapi.documents(uid).unpublish({
                        ...opts,
                        documentId: id
                    }).then((result)=>result?.entries)));
            });
            const unpublishedEntitiesCount = unpublishedEntries.flat().filter(Boolean).length;
            // Return the number of unpublished entities
            return {
                count: unpublishedEntitiesCount
            };
        },
        async unpublish (id, uid, opts = {}) {
            const populate = await buildDeepPopulate(uid);
            const params = {
                ...opts,
                populate
            };
            return strapi.documents(uid).unpublish({
                ...params,
                documentId: id
            }).then((result)=>result?.entries.at(0));
        },
        async discardDraft (id, uid, opts = {}) {
            const populate = await buildDeepPopulate(uid);
            const params = {
                ...opts,
                populate
            };
            return strapi.documents(uid).discardDraft({
                ...params,
                documentId: id
            }).then((result)=>result?.entries.at(0));
        },
        async countDraftRelations (id, uid, locale) {
            const { populate, hasRelations } = getDeepPopulateDraftCount(uid);
            if (!hasRelations) {
                return 0;
            }
            const document = await strapi.documents(uid).findOne({
                documentId: id,
                populate,
                locale
            });
            if (!document) {
                throw new ApplicationError(`Unable to count draft relations, document with id ${id} and locale ${locale} not found`);
            }
            return sumDraftCounts(document, uid);
        },
        async countManyEntriesDraftRelations (documentIds, uid, locale) {
            const { populate, hasRelations } = getDeepPopulateDraftCount(uid);
            if (!hasRelations) {
                return 0;
            }
            let localeFilter = {};
            if (locale) {
                localeFilter = Array.isArray(locale) ? {
                    locale: {
                        $in: locale
                    }
                } : {
                    locale
                };
            }
            const entities = await strapi.db.query(uid).findMany({
                populate,
                where: {
                    documentId: {
                        $in: documentIds
                    },
                    ...localeFilter
                }
            });
            const totalNumberDraftRelations = entities.reduce((count, entity)=>sumDraftCounts(entity, uid) + count, 0);
            return totalNumberDraftRelations;
        }
    };
};

var services = {
    components,
    'content-types': service,
    'data-mapper': dataMapper,
    'document-metadata': documentMetadata,
    'document-manager': documentManager,
    'field-sizes': createFieldSizesService,
    metrics,
    'permission-checker': permissionChecker,
    permission,
    'populate-builder': populateBuilder$1,
    uid,
    ...history.services ? history.services : {},
    ...preview.services ? preview.services : {}
};

var index = (()=>{
    return {
        register,
        bootstrap,
        destroy,
        controllers,
        routes,
        policies,
        services
    };
});

module.exports = index;
//# sourceMappingURL=index.js.map
