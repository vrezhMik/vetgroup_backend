'use strict';

var Icons = require('@strapi/icons');
var jsxRuntime = require('react/jsx-runtime');
var strapiAdmin = require('@strapi/admin/strapi-admin');
var React = require('react');
var designSystem = require('@strapi/design-system');
var mapValues = require('lodash/fp/mapValues');
var reactIntl = require('react-intl');
var reactRouterDom = require('react-router-dom');
var styledComponents = require('styled-components');
var yup = require('yup');
var fractionalIndexing = require('fractional-indexing');
var pipe = require('lodash/fp/pipe');
var qs = require('qs');
var dateFns = require('date-fns');
var toolkit = require('@reduxjs/toolkit');
require('prismjs');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);
var yup__namespace = /*#__PURE__*/_interopNamespaceDefault(yup);

const PLUGIN_ID = 'content-manager';
const PERMISSIONS = [
    'plugin::content-manager.explorer.create',
    'plugin::content-manager.explorer.read',
    'plugin::content-manager.explorer.update',
    'plugin::content-manager.explorer.delete',
    'plugin::content-manager.explorer.publish'
];

const INJECTION_ZONES = {
    editView: {
        informations: [],
        'right-links': []
    },
    listView: {
        actions: [],
        deleteModalAdditionalInfos: [],
        publishModalAdditionalInfos: [],
        unpublishModalAdditionalInfos: []
    },
    preview: {
        actions: []
    }
};
/**
 * You can't know what this component props will be because it's generic and used everywhere
 * e.g. content-manager edit view, we just send the slug but we might not in the listView,
 * therefore, people should type it themselves on the components they render.
 */ const InjectionZone = ({ area, ...props })=>{
    const components = useInjectionZone(area);
    return /*#__PURE__*/ jsxRuntime.jsx(jsxRuntime.Fragment, {
        children: components.map((component)=>/*#__PURE__*/ jsxRuntime.jsx(component.Component, {
                ...props
            }, component.name))
    });
};
const useInjectionZone = (area)=>{
    const getPlugin = strapiAdmin.useStrapiApp('useInjectionZone', (state)=>state.getPlugin);
    const contentManagerPlugin = getPlugin(PLUGIN_ID);
    const [page, position] = area.split('.');
    return contentManagerPlugin.getInjectedComponents(page, position);
};

const ID = 'id';
const CREATED_BY_ATTRIBUTE_NAME = 'createdBy';
const UPDATED_BY_ATTRIBUTE_NAME = 'updatedBy';
const CREATOR_FIELDS = [
    CREATED_BY_ATTRIBUTE_NAME,
    UPDATED_BY_ATTRIBUTE_NAME
];
const PUBLISHED_BY_ATTRIBUTE_NAME = 'publishedBy';
const CREATED_AT_ATTRIBUTE_NAME = 'createdAt';
const UPDATED_AT_ATTRIBUTE_NAME = 'updatedAt';
const PUBLISHED_AT_ATTRIBUTE_NAME = 'publishedAt';
const DOCUMENT_META_FIELDS = [
    ID,
    ...CREATOR_FIELDS,
    PUBLISHED_BY_ATTRIBUTE_NAME,
    CREATED_AT_ATTRIBUTE_NAME,
    UPDATED_AT_ATTRIBUTE_NAME,
    PUBLISHED_AT_ATTRIBUTE_NAME
];
/**
 * List of attribute types that cannot be used as the main field.
 * Not sure the name could be any clearer.
 */ const ATTRIBUTE_TYPES_THAT_CANNOT_BE_MAIN_FIELD = [
    'dynamiczone',
    'json',
    'text',
    'relation',
    'component',
    'boolean',
    'media',
    'password',
    'richtext',
    'timestamp',
    'blocks'
];

const SINGLE_TYPES = 'single-types';
const COLLECTION_TYPES = 'collection-types';

const [DocumentRBACProvider, useDocumentRBAC] = strapiAdmin.createContext('DocumentRBAC', {
    canCreate: false,
    canCreateFields: [],
    canDelete: false,
    canPublish: false,
    canRead: false,
    canReadFields: [],
    canUpdate: false,
    canUpdateFields: [],
    canUserAction: ()=>false,
    isLoading: false
});
/**
 * @internal This component is not meant to be used outside of the Content Manager plugin.
 * It depends on knowing the slug/model of the content-type using the params of the URL.
 * If you do use the hook outside of the context, we default to `false` for all actions.
 *
 * It then creates an list of `can{Action}` that are passed to the context for consumption
 * within the app to enforce RBAC.
 */ const DocumentRBAC = ({ children, permissions })=>{
    const { slug } = reactRouterDom.useParams();
    if (!slug) {
        throw new Error('Cannot find the slug param in the URL');
    }
    const [{ rawQuery }] = strapiAdmin.useQueryParams();
    const userPermissions = strapiAdmin.useAuth('DocumentRBAC', (state)=>state.permissions);
    const contentTypePermissions = React__namespace.useMemo(()=>{
        const contentTypePermissions = userPermissions.filter((permission)=>permission.subject === slug);
        return contentTypePermissions.reduce((acc, permission)=>{
            const [action] = permission.action.split('.').slice(-1);
            return {
                ...acc,
                [action]: [
                    permission
                ]
            };
        }, {});
    }, [
        slug,
        userPermissions
    ]);
    const { isLoading, allowedActions } = strapiAdmin.useRBAC(contentTypePermissions, permissions ?? undefined, // TODO: useRBAC context should be typed and built differently
    // We are passing raw query as context to the hook so that it can
    // rely on the locale provided from DocumentRBAC for its permission calculations.
    rawQuery);
    const canCreateFields = !isLoading && allowedActions.canCreate ? extractAndDedupeFields(contentTypePermissions.create) : [];
    const canReadFields = !isLoading && allowedActions.canRead ? extractAndDedupeFields(contentTypePermissions.read) : [];
    const canUpdateFields = !isLoading && allowedActions.canUpdate ? extractAndDedupeFields(contentTypePermissions.update) : [];
    /**
   * @description Checks if the user can perform an action on a field based on the field names
   * provided as the second argument.
   */ const canUserAction = React__namespace.useCallback((fieldName, fieldsUserCanAction, fieldType)=>{
        const name = removeNumericalStrings(fieldName.split('.'));
        const componentFieldNames = fieldsUserCanAction// filter out fields that aren't components (components are dot separated)
        .filter((field)=>field.split('.').length > 1);
        if (fieldType === 'component') {
            // check if the field name is within any of those arrays
            return componentFieldNames.some((field)=>{
                return field.includes(name.join('.'));
            });
        }
        /**
       * The field is within a component.
       */ if (name.length > 1) {
            return componentFieldNames.includes(name.join('.'));
        }
        /**
       * just a regular field
       */ return fieldsUserCanAction.includes(fieldName);
    }, []);
    if (isLoading) {
        return /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Page.Loading, {});
    }
    return /*#__PURE__*/ jsxRuntime.jsx(DocumentRBACProvider, {
        isLoading: isLoading,
        canCreateFields: canCreateFields,
        canReadFields: canReadFields,
        canUpdateFields: canUpdateFields,
        canUserAction: canUserAction,
        ...allowedActions,
        children: children
    });
};
/**
 * @internal it's really small, but it's used three times in a row and DRY for something this straight forward.
 */ const extractAndDedupeFields = (permissions = [])=>permissions.flatMap((permission)=>permission.properties?.fields).filter((field, index, arr)=>arr.indexOf(field) === index && typeof field === 'string');
/**
 * @internal removes numerical strings from arrays.
 * @example
 * ```ts
 * const name = 'a.0.b';
 * const res = removeNumericalStrings(name.split('.'));
 * console.log(res); // ['a', 'b']
 * ```
 */ const removeNumericalStrings = (arr)=>arr.filter((item)=>isNaN(Number(item)));

const BLOCK_LIST_ATTRIBUTE_KEYS = [
    '__component',
    '__temp_key__'
];
/**
 * @internal This function is used to traverse the data and transform the values.
 * Given a predicate function, it will transform the value (using the given transform function)
 * if the predicate returns true. If it finds that the attribute is a component or dynamiczone,
 * it will recursively traverse those data structures as well.
 *
 * It is possible to break the ContentManager by using this function incorrectly, for example,
 * if you transform a number into a string but the attribute type is a number, the ContentManager
 * will not be able to save the data and the Form will likely crash because the component it's
 * passing the data too won't succesfully be able to handle the value.
 */ const traverseData = (predicate, transform)=>(schema, components = {})=>(data = {})=>{
            const traverse = (datum, attributes)=>{
                return Object.entries(datum).reduce((acc, [key, value])=>{
                    const attribute = attributes[key];
                    /**
         * If the attribute is a block list attribute, we don't want to transform it.
         * We also don't want to transform null or undefined values.
         */ if (BLOCK_LIST_ATTRIBUTE_KEYS.includes(key) || value === null || value === undefined) {
                        acc[key] = value;
                        return acc;
                    }
                    if (attribute.type === 'component') {
                        if (attribute.repeatable) {
                            const componentValue = predicate(attribute, value) ? transform(value, attribute) : value;
                            acc[key] = componentValue.map((componentData)=>traverse(componentData, components[attribute.component]?.attributes ?? {}));
                        } else {
                            const componentValue = predicate(attribute, value) ? transform(value, attribute) : value;
                            acc[key] = traverse(componentValue, components[attribute.component]?.attributes ?? {});
                        }
                    } else if (attribute.type === 'dynamiczone') {
                        const dynamicZoneValue = predicate(attribute, value) ? transform(value, attribute) : value;
                        acc[key] = dynamicZoneValue.map((componentData)=>traverse(componentData, components[componentData.__component]?.attributes ?? {}));
                    } else if (predicate(attribute, value)) {
                        acc[key] = transform(value, attribute);
                    } else {
                        acc[key] = value;
                    }
                    return acc;
                }, {});
            };
            return traverse(data, schema.attributes);
        };
/* -------------------------------------------------------------------------------------------------
 * removeProhibitedFields
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal Removes all the fields that are not allowed.
 */ const removeProhibitedFields = (prohibitedFields)=>traverseData((attribute)=>prohibitedFields.includes(attribute.type), ()=>'');
/* -------------------------------------------------------------------------------------------------
 * prepareRelations
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description Sets all relation values to an empty array.
 */ const prepareRelations = traverseData((attribute)=>attribute.type === 'relation', ()=>({
        connect: [],
        disconnect: []
    }));
/* -------------------------------------------------------------------------------------------------
 * prepareTempKeys
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description Adds a `__temp_key__` to each component and dynamiczone item. This gives us
 * a stable identifier regardless of its ids etc. that we can then use for drag and drop.
 */ const prepareTempKeys = traverseData((attribute)=>attribute.type === 'component' && attribute.repeatable || attribute.type === 'dynamiczone', (data)=>{
    if (Array.isArray(data) && data.length > 0) {
        const keys = fractionalIndexing.generateNKeysBetween(undefined, undefined, data.length);
        return data.map((datum, index)=>({
                ...datum,
                __temp_key__: keys[index]
            }));
    }
    return data;
});
/* -------------------------------------------------------------------------------------------------
 * removeFieldsThatDontExistOnSchema
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description Fields that don't exist in the schema like createdAt etc. are only on the first level (not nested),
 * as such we don't need to traverse the components to remove them.
 */ const removeFieldsThatDontExistOnSchema = (schema)=>(data)=>{
        const schemaKeys = Object.keys(schema.attributes);
        const dataKeys = Object.keys(data);
        const keysToRemove = dataKeys.filter((key)=>!schemaKeys.includes(key));
        const revisedData = [
            ...keysToRemove,
            ...DOCUMENT_META_FIELDS
        ].reduce((acc, key)=>{
            delete acc[key];
            return acc;
        }, structuredClone(data));
        return revisedData;
    };
/**
 * @internal
 * @description We need to remove null fields from the data-structure because it will pass it
 * to the specific inputs breaking them as most would prefer empty strings or `undefined` if
 * they're controlled / uncontrolled.
 */ const removeNullValues = (data)=>{
    return Object.entries(data).reduce((acc, [key, value])=>{
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
/* -------------------------------------------------------------------------------------------------
 * transformDocuments
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description Takes a document data structure (this could be from the API or a default form structure)
 * and applies consistent data transformations to it. This is also used when we add new components to the
 * form to ensure the data is correctly prepared from their default state e.g. relations are set to an empty array.
 */ const transformDocument = (schema, components = {})=>(document)=>{
        const transformations = pipe(removeFieldsThatDontExistOnSchema(schema), removeProhibitedFields([
            'password'
        ])(schema, components), removeNullValues, prepareRelations(schema, components), prepareTempKeys(schema, components));
        return transformations(document);
    };

/* -------------------------------------------------------------------------------------------------
 * createDefaultForm
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal Using the content-type schema & the components dictionary of the content-type,
 * creates a form with pre-filled default values. This is used when creating a new entry.
 */ const createDefaultForm = (contentType, components = {})=>{
    const traverseSchema = (attributes)=>{
        return Object.entries(attributes).reduce((acc, [key, attribute])=>{
            if ('default' in attribute) {
                acc[key] = attribute.default;
            } else if (attribute.type === 'component' && attribute.required) {
                const defaultComponentForm = traverseSchema(components[attribute.component].attributes);
                if (attribute.repeatable) {
                    acc[key] = attribute.min ? [
                        ...Array(attribute.min).fill(defaultComponentForm)
                    ] : [];
                } else {
                    acc[key] = defaultComponentForm;
                }
            } else if (attribute.type === 'dynamiczone' && attribute.required) {
                acc[key] = [];
            }
            return acc;
        }, {});
    };
    return traverseSchema(contentType.attributes);
};

const contentManagerApi = strapiAdmin.adminApi.enhanceEndpoints({
    addTagTypes: [
        'ComponentConfiguration',
        'ContentTypesConfiguration',
        'ContentTypeSettings',
        'Document',
        'InitialData',
        'HistoryVersion',
        'Relations',
        'UidAvailability',
        'RecentDocumentList'
    ]
});

const documentApi = contentManagerApi.injectEndpoints({
    overrideExisting: true,
    endpoints: (builder)=>({
            autoCloneDocument: builder.mutation({
                query: ({ model, sourceId, query })=>({
                        url: `/content-manager/collection-types/${model}/auto-clone/${sourceId}`,
                        method: 'POST',
                        config: {
                            params: query
                        }
                    }),
                invalidatesTags: (_result, error, { model })=>{
                    if (error) {
                        return [];
                    }
                    return [
                        {
                            type: 'Document',
                            id: `${model}_LIST`
                        },
                        'RecentDocumentList'
                    ];
                }
            }),
            cloneDocument: builder.mutation({
                query: ({ model, sourceId, data, params })=>({
                        url: `/content-manager/collection-types/${model}/clone/${sourceId}`,
                        method: 'POST',
                        data,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_result, _error, { model })=>[
                        {
                            type: 'Document',
                            id: `${model}_LIST`
                        },
                        {
                            type: 'UidAvailability',
                            id: model
                        },
                        'RecentDocumentList'
                    ]
            }),
            /**
     * Creates a new collection-type document. This should ONLY be used for collection-types.
     * single-types should always be using `updateDocument` since they always exist.
     */ createDocument: builder.mutation({
                query: ({ model, data, params })=>({
                        url: `/content-manager/collection-types/${model}`,
                        method: 'POST',
                        data,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (result, _error, { model })=>[
                        {
                            type: 'Document',
                            id: `${model}_LIST`
                        },
                        'Relations',
                        {
                            type: 'UidAvailability',
                            id: model
                        },
                        'RecentDocumentList'
                    ],
                transformResponse: (response, meta, arg)=>{
                    /**
         * TODO v6
         * Adapt plugin:users-permissions.user to return the same response
         * shape as all other requests. The error is returned as expected.
         */ if (!('data' in response) && arg.model === 'plugin::users-permissions.user') {
                        return {
                            data: response,
                            meta: {
                                availableStatus: [],
                                availableLocales: []
                            }
                        };
                    }
                    return response;
                }
            }),
            deleteDocument: builder.mutation({
                query: ({ collectionType, model, documentId, params })=>({
                        url: `/content-manager/${collectionType}/${model}${collectionType !== SINGLE_TYPES && documentId ? `/${documentId}` : ''}`,
                        method: 'DELETE',
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_result, _error, { collectionType, model })=>[
                        {
                            type: 'Document',
                            id: collectionType !== SINGLE_TYPES ? `${model}_LIST` : model
                        },
                        'RecentDocumentList'
                    ]
            }),
            deleteManyDocuments: builder.mutation({
                query: ({ model, params, ...body })=>({
                        url: `/content-manager/collection-types/${model}/actions/bulkDelete`,
                        method: 'POST',
                        data: body,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_res, _error, { model })=>[
                        {
                            type: 'Document',
                            id: `${model}_LIST`
                        },
                        'RecentDocumentList'
                    ]
            }),
            discardDocument: builder.mutation({
                query: ({ collectionType, model, documentId, params })=>({
                        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/discard` : `/content-manager/${collectionType}/${model}/actions/discard`,
                        method: 'POST',
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_result, _error, { collectionType, model, documentId })=>{
                    return [
                        {
                            type: 'Document',
                            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
                        },
                        {
                            type: 'Document',
                            id: `${model}_LIST`
                        },
                        'Relations',
                        {
                            type: 'UidAvailability',
                            id: model
                        },
                        'RecentDocumentList'
                    ];
                }
            }),
            /**
     * Gets all documents of a collection type or single type.
     * By passing different params you can get different results e.g. only published documents or 'es' documents.
     */ getAllDocuments: builder.query({
                query: ({ model, params })=>({
                        url: `/content-manager/collection-types/${model}`,
                        method: 'GET',
                        config: {
                            params: qs.stringify(params, {
                                encode: true
                            })
                        }
                    }),
                providesTags: (result, _error, arg)=>{
                    return [
                        {
                            type: 'Document',
                            id: `ALL_LIST`
                        },
                        {
                            type: 'Document',
                            id: `${arg.model}_LIST`
                        },
                        ...result?.results.map(({ documentId })=>({
                                type: 'Document',
                                id: `${arg.model}_${documentId}`
                            })) ?? []
                    ];
                }
            }),
            getDraftRelationCount: builder.query({
                query: ({ collectionType, model, documentId, params })=>({
                        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/countDraftRelations` : `/content-manager/${collectionType}/${model}/actions/countDraftRelations`,
                        method: 'GET',
                        config: {
                            params
                        }
                    })
            }),
            getDocument: builder.query({
                // @ts-expect-error – TODO: fix ts error where data unknown doesn't work with response via an assertion?
                queryFn: async ({ collectionType, model, documentId, params }, _api, _extraOpts, baseQuery)=>{
                    const res = await baseQuery({
                        url: `/content-manager/${collectionType}/${model}${documentId ? `/${documentId}` : ''}`,
                        method: 'GET',
                        config: {
                            params
                        }
                    });
                    /**
         * To stop the query from locking itself in multiple retries, we intercept the error here and manage correctly.
         * This is because single-types don't have a list view and fetching them with the route `/single-types/:model`
         * never returns a list, just a single document but this won't exist if you've not made one before.
         */ if (res.error && res.error.name === 'NotFoundError' && collectionType === SINGLE_TYPES) {
                        return {
                            data: {
                                document: undefined
                            },
                            error: undefined
                        };
                    }
                    return res;
                },
                providesTags: (result, _error, { collectionType, model, documentId })=>{
                    return [
                        // we prefer the result's id because we don't fetch single-types with an ID.
                        {
                            type: 'Document',
                            id: collectionType !== SINGLE_TYPES ? `${model}_${result && 'documentId' in result ? result.documentId : documentId}` : model
                        },
                        // Make it easy to invalidate all individual documents queries for a model
                        {
                            type: 'Document',
                            id: `${model}_ALL_ITEMS`
                        }
                    ];
                }
            }),
            getManyDraftRelationCount: builder.query({
                query: ({ model, ...params })=>({
                        url: `/content-manager/collection-types/${model}/actions/countManyEntriesDraftRelations`,
                        method: 'GET',
                        config: {
                            params
                        }
                    }),
                transformResponse: (response)=>response.data
            }),
            /**
     * This endpoint will either create or update documents at the same time as publishing.
     */ publishDocument: builder.mutation({
                query: ({ collectionType, model, documentId, params, data })=>({
                        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/publish` : `/content-manager/${collectionType}/${model}/actions/publish`,
                        method: 'POST',
                        data,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_result, _error, { collectionType, model, documentId })=>{
                    return [
                        {
                            type: 'Document',
                            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
                        },
                        {
                            type: 'Document',
                            id: `${model}_LIST`
                        },
                        'Relations',
                        'RecentDocumentList'
                    ];
                }
            }),
            publishManyDocuments: builder.mutation({
                query: ({ model, params, ...body })=>({
                        url: `/content-manager/collection-types/${model}/actions/bulkPublish`,
                        method: 'POST',
                        data: body,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_res, _error, { model, documentIds })=>documentIds.map((id)=>({
                            type: 'Document',
                            id: `${model}_${id}`
                        }))
            }),
            updateDocument: builder.mutation({
                query: ({ collectionType, model, documentId, data, params })=>({
                        url: `/content-manager/${collectionType}/${model}${documentId ? `/${documentId}` : ''}`,
                        method: 'PUT',
                        data,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_result, _error, { collectionType, model, documentId })=>{
                    return [
                        {
                            type: 'Document',
                            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
                        },
                        'Relations',
                        {
                            type: 'UidAvailability',
                            id: model
                        },
                        'RecentDocumentList',
                        'RecentDocumentList'
                    ];
                },
                async onQueryStarted ({ data, ...patch }, { dispatch, queryFulfilled }) {
                    // Optimistically update the cache with the new data
                    const patchResult = dispatch(documentApi.util.updateQueryData('getDocument', patch, (draft)=>{
                        Object.assign(draft.data, data);
                    }));
                    try {
                        await queryFulfilled;
                    } catch  {
                        // Rollback the optimistic update if there's an error
                        patchResult.undo();
                    }
                }
            }),
            unpublishDocument: builder.mutation({
                query: ({ collectionType, model, documentId, params, data })=>({
                        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/unpublish` : `/content-manager/${collectionType}/${model}/actions/unpublish`,
                        method: 'POST',
                        data,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_result, _error, { collectionType, model, documentId })=>{
                    return [
                        {
                            type: 'Document',
                            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
                        },
                        'RecentDocumentList'
                    ];
                }
            }),
            unpublishManyDocuments: builder.mutation({
                query: ({ model, params, ...body })=>({
                        url: `/content-manager/collection-types/${model}/actions/bulkUnpublish`,
                        method: 'POST',
                        data: body,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_res, _error, { model, documentIds })=>[
                        ...documentIds.map((id)=>({
                                type: 'Document',
                                id: `${model}_${id}`
                            })),
                        'RecentDocumentList'
                    ]
            })
        })
});
const { useAutoCloneDocumentMutation, useCloneDocumentMutation, useCreateDocumentMutation, useDeleteDocumentMutation, useDeleteManyDocumentsMutation, useDiscardDocumentMutation, useGetAllDocumentsQuery, useLazyGetDocumentQuery, useGetDocumentQuery, useLazyGetDraftRelationCountQuery, useGetManyDraftRelationCountQuery, usePublishDocumentMutation, usePublishManyDocumentsMutation, useUpdateDocumentMutation, useUnpublishDocumentMutation, useUnpublishManyDocumentsMutation } = documentApi;

/**
 * @description
 * Creates a valid query params object for get requests
 * ie. plugins[18n][locale]=en becomes locale=en
 */ const buildValidParams = (query)=>{
    if (!query) return query;
    // Extract pluginOptions from the query, they shouldn't be part of the URL
    const { plugins: _, ...validQueryParams } = {
        ...query,
        ...Object.values(query?.plugins ?? {}).reduce((acc, current)=>Object.assign(acc, current), {})
    };
    return validQueryParams;
};
const isBaseQueryError = (error)=>{
    return error.name !== undefined;
};

const arrayValidator = (attribute, options)=>({
        message: strapiAdmin.translatedErrors.required,
        test (value) {
            if (options.status === 'draft') {
                return true;
            }
            if (!attribute.required) {
                return true;
            }
            if (!value) {
                return false;
            }
            if (Array.isArray(value) && value.length === 0) {
                return false;
            }
            return true;
        }
    });
/**
 * TODO: should we create a Map to store these based on the hash of the schema?
 */ const createYupSchema = (attributes = {}, components = {}, options = {
    status: null
})=>{
    const createModelSchema = (attributes)=>yup__namespace.object().shape(Object.entries(attributes).reduce((acc, [name, attribute])=>{
            if (DOCUMENT_META_FIELDS.includes(name)) {
                return acc;
            }
            /**
           * These validations won't apply to every attribute
           * and that's okay, in that case we just return the
           * schema as it was passed.
           */ const validations = [
                addNullableValidation,
                addRequiredValidation,
                addMinLengthValidation,
                addMaxLengthValidation,
                addMinValidation,
                addMaxValidation,
                addRegexValidation
            ].map((fn)=>fn(attribute, options));
            const transformSchema = pipe(...validations);
            switch(attribute.type){
                case 'component':
                    {
                        const { attributes } = components[attribute.component];
                        if (attribute.repeatable) {
                            return {
                                ...acc,
                                [name]: transformSchema(yup__namespace.array().of(createModelSchema(attributes).nullable(false))).test(arrayValidator(attribute, options))
                            };
                        } else {
                            return {
                                ...acc,
                                [name]: transformSchema(createModelSchema(attributes).nullable())
                            };
                        }
                    }
                case 'dynamiczone':
                    return {
                        ...acc,
                        [name]: transformSchema(yup__namespace.array().of(yup__namespace.lazy((data)=>{
                            const attributes = components?.[data?.__component]?.attributes;
                            const validation = yup__namespace.object().shape({
                                __component: yup__namespace.string().required().oneOf(Object.keys(components))
                            }).nullable(false);
                            if (!attributes) {
                                return validation;
                            }
                            return validation.concat(createModelSchema(attributes));
                        }))).test(arrayValidator(attribute, options))
                    };
                case 'relation':
                    return {
                        ...acc,
                        [name]: transformSchema(yup__namespace.lazy((value)=>{
                            if (!value) {
                                return yup__namespace.mixed().nullable(true);
                            } else if (Array.isArray(value)) {
                                // If a relation value is an array, we expect
                                // an array of objects with {id} properties, representing the related entities.
                                return yup__namespace.array().of(yup__namespace.object().shape({
                                    id: yup__namespace.number().required()
                                }));
                            } else if (typeof value === 'object') {
                                // A realtion value can also be an object. Some API
                                // repsonses return the number of entities in the relation
                                // as { count: x }
                                return yup__namespace.object();
                            } else {
                                return yup__namespace.mixed().test('type-error', 'Relation values must be either null, an array of objects with {id} or an object.', ()=>false);
                            }
                        }))
                    };
                default:
                    return {
                        ...acc,
                        [name]: transformSchema(createAttributeSchema(attribute))
                    };
            }
        }, {}))/**
       * TODO: investigate why an undefined object fails a check of `nullable`.
       */ .default(null);
    return createModelSchema(attributes);
};
const createAttributeSchema = (attribute)=>{
    switch(attribute.type){
        case 'biginteger':
            return yup__namespace.string().matches(/^-?\d*$/);
        case 'boolean':
            return yup__namespace.boolean();
        case 'blocks':
            return yup__namespace.mixed().test('isBlocks', strapiAdmin.translatedErrors.json, (value)=>{
                if (!value || Array.isArray(value)) {
                    return true;
                } else {
                    return false;
                }
            });
        case 'decimal':
        case 'float':
        case 'integer':
            return yup__namespace.number();
        case 'email':
            return yup__namespace.string().email(strapiAdmin.translatedErrors.email);
        case 'enumeration':
            return yup__namespace.string().oneOf([
                ...attribute.enum,
                null
            ]);
        case 'json':
            return yup__namespace.mixed().test('isJSON', strapiAdmin.translatedErrors.json, (value)=>{
                /**
         * We don't want to validate the JSON field if it's empty.
         */ if (!value || typeof value === 'string' && value.length === 0) {
                    return true;
                }
                // If the value was created via content API and wasn't changed, then it's still an object
                if (typeof value === 'object') {
                    try {
                        JSON.stringify(value);
                        return true;
                    } catch (err) {
                        return false;
                    }
                }
                try {
                    JSON.parse(value);
                    return true;
                } catch (err) {
                    return false;
                }
            });
        case 'password':
        case 'richtext':
        case 'string':
        case 'text':
            return yup__namespace.string();
        case 'uid':
            return yup__namespace.string().matches(/^[A-Za-z0-9-_.~]*$/);
        default:
            /**
       * This allows any value.
       */ return yup__namespace.mixed();
    }
};
// Helper function to return schema.nullable() if it exists, otherwise return schema
const nullableSchema = (schema)=>{
    return schema?.nullable ? schema.nullable() : // e.g. when the schema has been built using yup.lazy (e.g. for relations).
    // In these cases we should just return the schema as it is.
    schema;
};
const addNullableValidation = ()=>(schema)=>{
        return nullableSchema(schema);
    };
const addRequiredValidation = (attribute, options)=>(schema)=>{
        if (options.status === 'draft' || !attribute.required) {
            return schema;
        }
        if (attribute.required && 'required' in schema) {
            return schema.required(strapiAdmin.translatedErrors.required);
        }
        return schema;
    };
const addMinLengthValidation = (attribute, options)=>(schema)=>{
        // Skip minLength validation for draft
        if (options.status === 'draft') {
            return schema;
        }
        if ('minLength' in attribute && attribute.minLength && Number.isInteger(attribute.minLength) && 'min' in schema) {
            return schema.min(attribute.minLength, {
                ...strapiAdmin.translatedErrors.minLength,
                values: {
                    min: attribute.minLength
                }
            });
        }
        return schema;
    };
const addMaxLengthValidation = (attribute)=>(schema)=>{
        if ('maxLength' in attribute && attribute.maxLength && Number.isInteger(attribute.maxLength) && 'max' in schema) {
            return schema.max(attribute.maxLength, {
                ...strapiAdmin.translatedErrors.maxLength,
                values: {
                    max: attribute.maxLength
                }
            });
        }
        return schema;
    };
const addMinValidation = (attribute, options)=>(schema)=>{
        // do not validate min for draft
        if (options.status === 'draft') {
            return schema;
        }
        if ('min' in attribute && 'min' in schema) {
            const min = toInteger(attribute.min);
            if (min) {
                return schema.min(min, {
                    ...strapiAdmin.translatedErrors.min,
                    values: {
                        min
                    }
                });
            }
        }
        return schema;
    };
const addMaxValidation = (attribute)=>(schema)=>{
        if ('max' in attribute) {
            const max = toInteger(attribute.max);
            if ('max' in schema && max) {
                return schema.max(max, {
                    ...strapiAdmin.translatedErrors.max,
                    values: {
                        max
                    }
                });
            }
        }
        return schema;
    };
const toInteger = (val)=>{
    if (typeof val === 'number' || val === undefined) {
        return val;
    } else {
        const num = Number(val);
        return isNaN(num) ? undefined : num;
    }
};
const addRegexValidation = (attribute)=>(schema)=>{
        if ('regex' in attribute && attribute.regex && 'matches' in schema) {
            return schema.matches(new RegExp(attribute.regex), {
                message: {
                    id: strapiAdmin.translatedErrors.regex.id,
                    defaultMessage: 'The value does not match the defined pattern.'
                },
                excludeEmptyString: !attribute.required
            });
        }
        return schema;
    };

const initApi = contentManagerApi.injectEndpoints({
    endpoints: (builder)=>({
            getInitialData: builder.query({
                query: ()=>'/content-manager/init',
                transformResponse: (response)=>response.data,
                providesTags: [
                    'InitialData'
                ]
            })
        })
});
const { useGetInitialDataQuery } = initApi;

/**
 * @internal
 * @description Given a model UID, return the schema and the schemas
 * of the associated components within said model's schema. A wrapper
 * implementation around the `useGetInitialDataQuery` with a unique
 * `selectFromResult` function to memoize the calculation.
 *
 * If no model is provided, the hook will return all the schemas.
 */ const useContentTypeSchema = (model)=>{
    const { toggleNotification } = strapiAdmin.useNotification();
    const { _unstableFormatAPIError: formatAPIError } = strapiAdmin.useAPIErrorHandler();
    const { data, error, isLoading, isFetching } = useGetInitialDataQuery(undefined);
    const { components, contentType, contentTypes } = React__namespace.useMemo(()=>{
        const contentType = data?.contentTypes.find((ct)=>ct.uid === model);
        const componentsByKey = data?.components.reduce((acc, component)=>{
            acc[component.uid] = component;
            return acc;
        }, {});
        const components = extractContentTypeComponents(contentType?.attributes, componentsByKey);
        return {
            components: Object.keys(components).length === 0 ? undefined : components,
            contentType,
            contentTypes: data?.contentTypes ?? []
        };
    }, [
        model,
        data
    ]);
    React__namespace.useEffect(()=>{
        if (error) {
            toggleNotification({
                type: 'danger',
                message: formatAPIError(error)
            });
        }
    }, [
        toggleNotification,
        error,
        formatAPIError
    ]);
    return {
        // This must be memoized to avoid inifiinite re-renders where the empty object is different everytime.
        components: React__namespace.useMemo(()=>components ?? {}, [
            components
        ]),
        schema: contentType,
        schemas: contentTypes,
        isLoading: isLoading || isFetching
    };
};
/* -------------------------------------------------------------------------------------------------
 * extractContentTypeComponents
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description Extracts the components used in a content type's attributes recursively.
 */ const extractContentTypeComponents = (attributes = {}, allComponents = {})=>{
    const getComponents = (attributes)=>{
        return attributes.reduce((acc, attribute)=>{
            /**
       * If the attribute is a component or dynamiczone, we need to recursively
       * extract the component UIDs from its attributes.
       */ if (attribute.type === 'component') {
                const componentAttributes = Object.values(allComponents[attribute.component]?.attributes ?? {});
                acc.push(attribute.component, ...getComponents(componentAttributes));
            } else if (attribute.type === 'dynamiczone') {
                acc.push(...attribute.components, /**
           * Dynamic zones have an array of components, so we flatMap over them
           * performing the same search as above.
           */ ...attribute.components.flatMap((componentUid)=>{
                    const componentAttributes = Object.values(allComponents[componentUid]?.attributes ?? {});
                    return getComponents(componentAttributes);
                }));
            }
            return acc;
        }, []);
    };
    const componentUids = getComponents(Object.values(attributes));
    const uniqueComponentUids = [
        ...new Set(componentUids)
    ];
    const componentsByKey = uniqueComponentUids.reduce((acc, uid)=>{
        acc[uid] = allComponents[uid];
        return acc;
    }, {});
    return componentsByKey;
};

const HOOKS = {
    /**
   * Hook that allows to mutate the displayed headers of the list view table
   * @constant
   * @type {string}
   */ INJECT_COLUMN_IN_TABLE: 'Admin/CM/pages/ListView/inject-column-in-table',
    /**
   * Hook that allows to mutate the CM's collection types links pre-set filters
   * @constant
   * @type {string}
   */ MUTATE_COLLECTION_TYPES_LINKS: 'Admin/CM/pages/App/mutate-collection-types-links',
    /**
   * Hook that allows to mutate the CM's edit view layout
   * @constant
   * @type {string}
   */ MUTATE_EDIT_VIEW_LAYOUT: 'Admin/CM/pages/EditView/mutate-edit-view-layout',
    /**
   * Hook that allows to mutate the CM's single types links pre-set filters
   * @constant
   * @type {string}
   */ MUTATE_SINGLE_TYPES_LINKS: 'Admin/CM/pages/App/mutate-single-types-links'
};

const contentTypesApi = contentManagerApi.injectEndpoints({
    endpoints: (builder)=>({
            getContentTypeConfiguration: builder.query({
                query: (uid)=>({
                        url: `/content-manager/content-types/${uid}/configuration`,
                        method: 'GET'
                    }),
                transformResponse: (response)=>response.data,
                providesTags: (_result, _error, uid)=>[
                        {
                            type: 'ContentTypesConfiguration',
                            id: uid
                        },
                        {
                            type: 'ContentTypeSettings',
                            id: 'LIST'
                        }
                    ]
            }),
            getAllContentTypeSettings: builder.query({
                query: ()=>'/content-manager/content-types-settings',
                transformResponse: (response)=>response.data,
                providesTags: [
                    {
                        type: 'ContentTypeSettings',
                        id: 'LIST'
                    }
                ]
            }),
            updateContentTypeConfiguration: builder.mutation({
                query: ({ uid, ...body })=>({
                        url: `/content-manager/content-types/${uid}/configuration`,
                        method: 'PUT',
                        data: body
                    }),
                transformResponse: (response)=>response.data,
                invalidatesTags: (_result, _error, { uid })=>[
                        {
                            type: 'ContentTypesConfiguration',
                            id: uid
                        },
                        {
                            type: 'ContentTypeSettings',
                            id: 'LIST'
                        },
                        // Is this necessary?
                        {
                            type: 'InitialData'
                        }
                    ]
            })
        })
});
const { useGetContentTypeConfigurationQuery, useGetAllContentTypeSettingsQuery, useUpdateContentTypeConfigurationMutation } = contentTypesApi;

const checkIfAttributeIsDisplayable = (attribute)=>{
    const { type } = attribute;
    if (type === 'relation') {
        return !attribute.relation.toLowerCase().includes('morph');
    }
    return ![
        'json',
        'dynamiczone',
        'richtext',
        'password',
        'blocks'
    ].includes(type) && !!type;
};
/**
 * @internal
 * @description given an attribute, content-type schemas & component schemas, find the mainField name & type.
 * If the attribute does not need a `mainField` then we return undefined. If we do not find the type
 * of the field, we assume it's a string #sensible-defaults
 */ const getMainField = (attribute, mainFieldName, { schemas, components })=>{
    if (!mainFieldName) {
        return undefined;
    }
    const mainFieldType = attribute.type === 'component' ? components[attribute.component].attributes[mainFieldName].type : schemas.find((schema)=>schema.uid === attribute.targetModel)?.attributes[mainFieldName].type;
    return {
        name: mainFieldName,
        type: mainFieldType ?? 'string'
    };
};

/* -------------------------------------------------------------------------------------------------
 * useDocumentLayout
 * -----------------------------------------------------------------------------------------------*/ const DEFAULT_SETTINGS = {
    bulkable: false,
    filterable: false,
    searchable: false,
    pagination: false,
    defaultSortBy: '',
    defaultSortOrder: 'asc',
    mainField: 'id',
    pageSize: 10
};
/**
 * @alpha
 * @description This hook is used to get the layouts for either the edit view or list view of a specific content-type
 * including the layouts for the components used in the content-type. It also runs the mutation hook waterfall so the data
 * is consistent wherever it is used. It's a light wrapper around the `useDocument` hook, but provides the `skip` option a document
 * is not fetched, however, it does fetch the schemas & components if they do not already exist in the cache.
 *
 * If the fetch fails, it will display a notification to the user.
 *
 * @example
 * ```tsx
 * const { model } = useParams<{ model: string }>();
 * const { edit: { schema: layout } } = useDocumentLayout(model);
 *
 * return layout.map(panel => panel.map(row => row.map(field => <Field.Root {...field} />)))
 * ```
 *
 */ const useDocumentLayout = (model)=>{
    const { schema, components } = useDocument({
        model,
        collectionType: ''
    }, {
        skip: true
    });
    const [{ query }] = strapiAdmin.useQueryParams();
    const runHookWaterfall = strapiAdmin.useStrapiApp('useDocumentLayout', (state)=>state.runHookWaterfall);
    const { toggleNotification } = strapiAdmin.useNotification();
    const { _unstableFormatAPIError: formatAPIError } = strapiAdmin.useAPIErrorHandler();
    const { isLoading: isLoadingSchemas, schemas } = useContentTypeSchema();
    const { data, isLoading: isLoadingConfigs, error, isFetching: isFetchingConfigs } = useGetContentTypeConfigurationQuery(model);
    const isLoading = isLoadingSchemas || isFetchingConfigs || isLoadingConfigs;
    React__namespace.useEffect(()=>{
        if (error) {
            toggleNotification({
                type: 'danger',
                message: formatAPIError(error)
            });
        }
    }, [
        error,
        formatAPIError,
        toggleNotification
    ]);
    const editLayout = React__namespace.useMemo(()=>data && !isLoading ? formatEditLayout(data, {
            schemas,
            schema,
            components
        }) : {
            layout: [],
            components: {},
            metadatas: {},
            options: {},
            settings: DEFAULT_SETTINGS
        }, [
        data,
        isLoading,
        schemas,
        schema,
        components
    ]);
    const listLayout = React__namespace.useMemo(()=>{
        return data && !isLoading ? formatListLayout(data, {
            schemas,
            schema,
            components
        }) : {
            layout: [],
            metadatas: {},
            options: {},
            settings: DEFAULT_SETTINGS
        };
    }, [
        data,
        isLoading,
        schemas,
        schema,
        components
    ]);
    const { layout: edit } = React__namespace.useMemo(()=>runHookWaterfall(HOOKS.MUTATE_EDIT_VIEW_LAYOUT, {
            layout: editLayout,
            query
        }), [
        editLayout,
        query,
        runHookWaterfall
    ]);
    return {
        error,
        isLoading,
        edit,
        list: listLayout
    };
};
/* -------------------------------------------------------------------------------------------------
 * useDocLayout
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal this hook uses the internal useDoc hook, as such it shouldn't be used outside of the
 * content-manager because it won't work as intended.
 */ const useDocLayout = ()=>{
    const { model } = useDoc();
    return useDocumentLayout(model);
};
/**
 * @internal
 * @description takes the configuration data, the schema & the components used in the schema and formats the edit view
 * versions of the schema & components. This is then used to render the edit view of the content-type.
 */ const formatEditLayout = (data, { schemas, schema, components })=>{
    let currentPanelIndex = 0;
    /**
   * The fields arranged by the panels, new panels are made for dynamic zones only.
   */ const panelledEditAttributes = convertEditLayoutToFieldLayouts(data.contentType.layouts.edit, schema?.attributes, data.contentType.metadatas, {
        configurations: data.components,
        schemas: components
    }, schemas).reduce((panels, row)=>{
        if (row.some((field)=>field.type === 'dynamiczone')) {
            panels.push([
                row
            ]);
            currentPanelIndex += 2;
        } else {
            if (!panels[currentPanelIndex]) {
                panels.push([
                    row
                ]);
            } else {
                panels[currentPanelIndex].push(row);
            }
        }
        return panels;
    }, []);
    const componentEditAttributes = Object.entries(data.components).reduce((acc, [uid, configuration])=>{
        acc[uid] = {
            layout: convertEditLayoutToFieldLayouts(configuration.layouts.edit, components[uid].attributes, configuration.metadatas, {
                configurations: data.components,
                schemas: components
            }),
            settings: {
                ...configuration.settings,
                icon: components[uid].info.icon,
                displayName: components[uid].info.displayName
            }
        };
        return acc;
    }, {});
    const editMetadatas = Object.entries(data.contentType.metadatas).reduce((acc, [attribute, metadata])=>{
        return {
            ...acc,
            [attribute]: metadata.edit
        };
    }, {});
    return {
        layout: panelledEditAttributes,
        components: componentEditAttributes,
        metadatas: editMetadatas,
        settings: {
            ...data.contentType.settings,
            displayName: schema?.info.displayName
        },
        options: {
            ...schema?.options,
            ...schema?.pluginOptions,
            ...data.contentType.options
        }
    };
};
/* -------------------------------------------------------------------------------------------------
 * convertEditLayoutToFieldLayouts
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description takes the edit layout from either a content-type or a component
 * and formats it into a generic object that can be used to correctly render
 * the form fields.
 */ const convertEditLayoutToFieldLayouts = (rows, attributes = {}, metadatas, components, schemas = [])=>{
    return rows.map((row)=>row.map((field)=>{
            const attribute = attributes[field.name];
            if (!attribute) {
                return null;
            }
            const { edit: metadata } = metadatas[field.name];
            const settings = attribute.type === 'component' && components ? components.configurations[attribute.component].settings : {};
            return {
                attribute,
                disabled: !metadata.editable,
                hint: metadata.description,
                label: metadata.label ?? '',
                name: field.name,
                // @ts-expect-error – mainField does exist on the metadata for a relation.
                mainField: getMainField(attribute, metadata.mainField || settings.mainField, {
                    schemas,
                    components: components?.schemas ?? {}
                }),
                placeholder: metadata.placeholder ?? '',
                required: attribute.required ?? false,
                size: field.size,
                unique: 'unique' in attribute ? attribute.unique : false,
                visible: metadata.visible ?? true,
                type: attribute.type
            };
        }).filter((field)=>field !== null));
};
/* -------------------------------------------------------------------------------------------------
 * formatListLayout
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description takes the complete configuration data, the schema & the components used in the schema and
 * formats a list view layout for the content-type. This is much simpler than the edit view layout as there
 * are less options to consider.
 */ const formatListLayout = (data, { schemas, schema, components })=>{
    const listMetadatas = Object.entries(data.contentType.metadatas).reduce((acc, [attribute, metadata])=>{
        return {
            ...acc,
            [attribute]: metadata.list
        };
    }, {});
    /**
   * The fields arranged by the panels, new panels are made for dynamic zones only.
   */ const listAttributes = convertListLayoutToFieldLayouts(data.contentType.layouts.list, schema?.attributes, listMetadatas, {
        configurations: data.components,
        schemas: components
    }, schemas);
    return {
        layout: listAttributes,
        settings: {
            ...data.contentType.settings,
            displayName: schema?.info.displayName
        },
        metadatas: listMetadatas,
        options: {
            ...schema?.options,
            ...schema?.pluginOptions,
            ...data.contentType.options
        }
    };
};
/* -------------------------------------------------------------------------------------------------
 * convertListLayoutToFieldLayouts
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description takes the columns from the list view configuration and formats them into a generic object
 * combinining metadata and attribute data.
 *
 * @note We do use this to reformat the list of strings when updating the displayed headers for the list view.
 */ const convertListLayoutToFieldLayouts = (columns, attributes = {}, metadatas, components, schemas = [])=>{
    return columns.map((name)=>{
        const attribute = attributes[name];
        if (!attribute) {
            return null;
        }
        const metadata = metadatas[name];
        const settings = attribute.type === 'component' && components ? components.configurations[attribute.component].settings : {};
        return {
            attribute,
            label: metadata.label ?? '',
            mainField: getMainField(attribute, metadata.mainField || settings.mainField, {
                schemas,
                components: components?.schemas ?? {}
            }),
            name: name,
            searchable: metadata.searchable ?? true,
            sortable: metadata.sortable ?? true
        };
    }).filter((field)=>field !== null);
};

/* -------------------------------------------------------------------------------------------------
 * useDocument
 * -----------------------------------------------------------------------------------------------*/ /**
 * @alpha
 * @public
 * @description Returns a document based on the model, collection type & id passed as arguments.
 * Also extracts its schema from the redux cache to be used for creating a validation schema.
 * @example
 * ```tsx
 * const { id, model, collectionType } = useParams<{ id: string; model: string; collectionType: string }>();
 *
 * if(!model || !collectionType) return null;
 *
 * const { document, isLoading, validate } = useDocument({ documentId: id, model, collectionType, params: { locale: 'en-GB' } })
 * const { update } = useDocumentActions()
 *
 * const onSubmit = async (document: Document) => {
 *  const errors = validate(document);
 *
 *  if(errors) {
 *      // handle errors
 *  }
 *
 *  await update({ collectionType, model, id }, document)
 * }
 * ```
 *
 * @see {@link https://contributor.strapi.io/docs/core/content-manager/hooks/use-document} for more information
 */ const useDocument = (args, opts)=>{
    const { toggleNotification } = strapiAdmin.useNotification();
    const { _unstableFormatAPIError: formatAPIError } = strapiAdmin.useAPIErrorHandler();
    const { formatMessage } = reactIntl.useIntl();
    const { currentData: data, isLoading: isLoadingDocument, isFetching: isFetchingDocument, error, refetch } = useGetDocumentQuery(args, {
        ...opts,
        skip: !args.documentId && args.collectionType !== SINGLE_TYPES || opts?.skip
    });
    const document = data?.data;
    const meta = data?.meta;
    const { components, schema, schemas, isLoading: isLoadingSchema } = useContentTypeSchema(args.model);
    const isSingleType = schema?.kind === 'singleType';
    const getTitle = (mainField)=>{
        // Always use mainField if it's not an id
        if (mainField !== 'id' && document?.[mainField]) {
            return document[mainField];
        }
        // When it's a singleType without a mainField, use the contentType displayName
        if (isSingleType && schema?.info.displayName) {
            return schema.info.displayName;
        }
        // Otherwise, use a fallback
        return formatMessage({
            id: 'content-manager.containers.untitled',
            defaultMessage: 'Untitled'
        });
    };
    React__namespace.useEffect(()=>{
        if (error) {
            toggleNotification({
                type: 'danger',
                message: formatAPIError(error)
            });
        }
    }, [
        toggleNotification,
        error,
        formatAPIError,
        args.collectionType
    ]);
    const validationSchema = React__namespace.useMemo(()=>{
        if (!schema) {
            return null;
        }
        return createYupSchema(schema.attributes, components);
    }, [
        schema,
        components
    ]);
    const validate = React__namespace.useCallback((document)=>{
        if (!validationSchema) {
            throw new Error('There is no validation schema generated, this is likely due to the schema not being loaded yet.');
        }
        try {
            validationSchema.validateSync(document, {
                abortEarly: false,
                strict: true
            });
            return null;
        } catch (error) {
            if (error instanceof yup.ValidationError) {
                return strapiAdmin.getYupValidationErrors(error);
            }
            throw error;
        }
    }, [
        validationSchema
    ]);
    /**
   * Here we prepare the form for editing, we need to:
   * - remove prohibited fields from the document (passwords | ADD YOURS WHEN THERES A NEW ONE)
   * - swap out count objects on relations for empty arrays
   * - set __temp_key__ on array objects for drag & drop
   *
   * We also prepare the form for new documents, so we need to:
   * - set default values on fields
   */ const getInitialFormValues = React__namespace.useCallback((isCreatingDocument = false)=>{
        if (!document && !isCreatingDocument && !isSingleType || !schema) {
            return undefined;
        }
        /**
       * Check that we have an ID so we know the
       * document has been created in some way.
       */ const form = document?.id ? document : createDefaultForm(schema, components);
        return transformDocument(schema, components)(form);
    }, [
        document,
        isSingleType,
        schema,
        components
    ]);
    const isLoading = isLoadingDocument || isFetchingDocument || isLoadingSchema;
    const hasError = !!error;
    return {
        components,
        document,
        meta,
        isLoading,
        hasError,
        schema,
        schemas,
        validate,
        getTitle,
        getInitialFormValues,
        refetch
    };
};
/* -------------------------------------------------------------------------------------------------
 * useDoc
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal this hook uses the router to extract the model, collection type & id from the url.
 * therefore, it shouldn't be used outside of the content-manager because it won't work as intended.
 */ const useDoc = ()=>{
    const { id, slug, collectionType, origin } = reactRouterDom.useParams();
    const [{ query }] = strapiAdmin.useQueryParams();
    const params = React__namespace.useMemo(()=>buildValidParams(query), [
        query
    ]);
    if (!collectionType) {
        throw new Error('Could not find collectionType in url params');
    }
    if (!slug) {
        throw new Error('Could not find model in url params');
    }
    const document = useDocument({
        documentId: origin || id,
        model: slug,
        collectionType,
        params
    }, {
        skip: id === 'create' || !origin && !id && collectionType !== SINGLE_TYPES
    });
    const returnId = origin || id === 'create' ? undefined : id;
    return {
        collectionType,
        model: slug,
        id: returnId,
        ...document
    };
};
/**
 * @public
 * @experimental
 * Content manager context hooks for plugin development.
 * Make sure to use this hook inside the content manager.
 */ const useContentManagerContext = ()=>{
    const { collectionType, model, id, components, isLoading: isLoadingDoc, schema, schemas } = useDoc();
    const layout = useDocumentLayout(model);
    const form = strapiAdmin.useForm('useContentManagerContext', (state)=>state);
    const isSingleType = collectionType === SINGLE_TYPES;
    const slug = model;
    const isCreatingEntry = id === 'create';
    useContentTypeSchema();
    const isLoading = isLoadingDoc || layout.isLoading;
    const error = layout.error;
    return {
        error,
        isLoading,
        // Base metadata
        model,
        collectionType,
        id,
        slug,
        isCreatingEntry,
        isSingleType,
        hasDraftAndPublish: schema?.options?.draftAndPublish ?? false,
        // All schema infos
        components,
        contentType: schema,
        contentTypes: schemas,
        // Form state
        form,
        // layout infos
        layout
    };
};

const prefixPluginTranslations = (trad, pluginId)=>{
    return Object.keys(trad).reduce((acc, current)=>{
        acc[`${pluginId}.${current}`] = trad[current];
        return acc;
    }, {});
};
const getTranslation = (id)=>`content-manager.${id}`;

const DEFAULT_UNEXPECTED_ERROR_MSG = {
    id: 'notification.error',
    defaultMessage: 'An error occurred, please try again'
};
/**
 * @alpha
 * @public
 * @description Contains all the operations that can be performed on a single document.
 * Designed to be able to be used anywhere within a Strapi app. The hooks will handle
 * notifications should the operation fail, however the response is always returned incase
 * the user needs to handle side-effects.
 * @example
 * ```tsx
 * import { Form } from '@strapi/admin/admin';
 *
 * const { id, model, collectionType } = useParams<{ id: string; model: string; collectionType: string }>();
 * const { update } = useDocumentActions();
 *
 * const handleSubmit = async (data) => {
 *  await update({ collectionType, model, documentId: id }, data);
 * }
 *
 * return <Form method="PUT" onSubmit={handleSubmit} />
 * ```
 *
 * @see {@link https://contributor.strapi.io/docs/core/content-manager/hooks/use-document-operations} for more information
 */ const useDocumentActions = ()=>{
    const { toggleNotification } = strapiAdmin.useNotification();
    const { formatMessage } = reactIntl.useIntl();
    const { trackUsage } = strapiAdmin.useTracking();
    const { _unstableFormatAPIError: formatAPIError } = strapiAdmin.useAPIErrorHandler();
    const navigate = reactRouterDom.useNavigate();
    const setCurrentStep = strapiAdmin.useGuidedTour('useDocumentActions', (state)=>state.setCurrentStep);
    const [deleteDocument, { isLoading: isDeleting }] = useDeleteDocumentMutation();
    const _delete = React__namespace.useCallback(async ({ collectionType, model, documentId, params }, trackerProperty)=>{
        try {
            trackUsage('willDeleteEntry', trackerProperty);
            const res = await deleteDocument({
                collectionType,
                model,
                documentId,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                return {
                    error: res.error
                };
            }
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.delete'),
                    defaultMessage: 'Deleted document'
                })
            });
            trackUsage('didDeleteEntry', trackerProperty);
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            trackUsage('didNotDeleteEntry', {
                error: err,
                ...trackerProperty
            });
            throw err;
        }
    }, [
        trackUsage,
        deleteDocument,
        toggleNotification,
        formatMessage,
        formatAPIError
    ]);
    const [deleteManyDocuments, { isLoading: isDeletingMany }] = useDeleteManyDocumentsMutation();
    const deleteMany = React__namespace.useCallback(async ({ model, documentIds, params })=>{
        try {
            trackUsage('willBulkDeleteEntries');
            const res = await deleteManyDocuments({
                model,
                documentIds,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                return {
                    error: res.error
                };
            }
            toggleNotification({
                type: 'success',
                title: formatMessage({
                    id: getTranslation('success.records.delete'),
                    defaultMessage: 'Successfully deleted.'
                }),
                message: ''
            });
            trackUsage('didBulkDeleteEntries');
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            trackUsage('didNotBulkDeleteEntries');
            throw err;
        }
    }, [
        trackUsage,
        deleteManyDocuments,
        toggleNotification,
        formatMessage,
        formatAPIError
    ]);
    const [discardDocument, { isLoading: isDiscardingDocument }] = useDiscardDocumentMutation();
    const discard = React__namespace.useCallback(async ({ collectionType, model, documentId, params })=>{
        try {
            const res = await discardDocument({
                collectionType,
                model,
                documentId,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                return {
                    error: res.error
                };
            }
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: 'content-manager.success.record.discard',
                    defaultMessage: 'Changes discarded'
                })
            });
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            throw err;
        }
    }, [
        discardDocument,
        formatAPIError,
        formatMessage,
        toggleNotification
    ]);
    const [publishDocument, { isLoading: isPublishing }] = usePublishDocumentMutation();
    const publish = React__namespace.useCallback(async ({ collectionType, model, documentId, params }, data)=>{
        try {
            trackUsage('willPublishEntry', {
                documentId
            });
            const res = await publishDocument({
                collectionType,
                model,
                documentId,
                data,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                return {
                    error: res.error
                };
            }
            trackUsage('didPublishEntry', {
                documentId
            });
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.publish'),
                    defaultMessage: 'Published document'
                })
            });
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            throw err;
        }
    }, [
        trackUsage,
        publishDocument,
        toggleNotification,
        formatMessage,
        formatAPIError
    ]);
    const [publishManyDocuments, { isLoading: isPublishingMany }] = usePublishManyDocumentsMutation();
    const publishMany = React__namespace.useCallback(async ({ model, documentIds, params })=>{
        try {
            // TODO Confirm tracking events for bulk publish?
            const res = await publishManyDocuments({
                model,
                documentIds,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                return {
                    error: res.error
                };
            }
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.publish'),
                    defaultMessage: 'Published document'
                })
            });
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            throw err;
        }
    }, [
        // trackUsage,
        publishManyDocuments,
        toggleNotification,
        formatMessage,
        formatAPIError
    ]);
    const [updateDocument, { isLoading: isUpdating }] = useUpdateDocumentMutation();
    const update = React__namespace.useCallback(async ({ collectionType, model, documentId, params }, data, trackerProperty)=>{
        try {
            trackUsage('willEditEntry', trackerProperty);
            const res = await updateDocument({
                collectionType,
                model,
                documentId,
                data,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                trackUsage('didNotEditEntry', {
                    error: res.error,
                    ...trackerProperty
                });
                return {
                    error: res.error
                };
            }
            trackUsage('didEditEntry', {
                ...trackerProperty,
                documentId: res.data.data.documentId
            });
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.save'),
                    defaultMessage: 'Saved document'
                })
            });
            return res.data;
        } catch (err) {
            trackUsage('didNotEditEntry', {
                error: err,
                ...trackerProperty
            });
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            throw err;
        }
    }, [
        trackUsage,
        updateDocument,
        toggleNotification,
        formatMessage,
        formatAPIError
    ]);
    const [unpublishDocument] = useUnpublishDocumentMutation();
    const unpublish = React__namespace.useCallback(async ({ collectionType, model, documentId, params }, discardDraft = false)=>{
        try {
            trackUsage('willUnpublishEntry');
            const res = await unpublishDocument({
                collectionType,
                model,
                documentId,
                params,
                data: {
                    discardDraft
                }
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                return {
                    error: res.error
                };
            }
            trackUsage('didUnpublishEntry');
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.unpublish'),
                    defaultMessage: 'Unpublished document'
                })
            });
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            throw err;
        }
    }, [
        trackUsage,
        unpublishDocument,
        toggleNotification,
        formatMessage,
        formatAPIError
    ]);
    const [unpublishManyDocuments, { isLoading: isUnpublishingMany }] = useUnpublishManyDocumentsMutation();
    const unpublishMany = React__namespace.useCallback(async ({ model, documentIds, params })=>{
        try {
            trackUsage('willBulkUnpublishEntries');
            const res = await unpublishManyDocuments({
                model,
                documentIds,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                return {
                    error: res.error
                };
            }
            trackUsage('didBulkUnpublishEntries');
            toggleNotification({
                type: 'success',
                title: formatMessage({
                    id: getTranslation('success.records.unpublish'),
                    defaultMessage: 'Successfully unpublished.'
                }),
                message: ''
            });
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            trackUsage('didNotBulkUnpublishEntries');
            throw err;
        }
    }, [
        trackUsage,
        unpublishManyDocuments,
        toggleNotification,
        formatMessage,
        formatAPIError
    ]);
    const [createDocument] = useCreateDocumentMutation();
    const create = React__namespace.useCallback(async ({ model, params }, data, trackerProperty)=>{
        try {
            const res = await createDocument({
                model,
                data,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                trackUsage('didNotCreateEntry', {
                    error: res.error,
                    ...trackerProperty
                });
                return {
                    error: res.error
                };
            }
            trackUsage('didCreateEntry', {
                ...trackerProperty,
                documentId: res.data.data.documentId
            });
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.save'),
                    defaultMessage: 'Saved document'
                })
            });
            setCurrentStep('contentManager.success');
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            trackUsage('didNotCreateEntry', {
                error: err,
                ...trackerProperty
            });
            throw err;
        }
    }, [
        createDocument,
        formatAPIError,
        formatMessage,
        toggleNotification,
        trackUsage
    ]);
    const [autoCloneDocument] = useAutoCloneDocumentMutation();
    const autoClone = React__namespace.useCallback(async ({ model, sourceId })=>{
        try {
            const res = await autoCloneDocument({
                model,
                sourceId
            });
            if ('error' in res) {
                return {
                    error: res.error
                };
            }
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.clone'),
                    defaultMessage: 'Cloned document'
                })
            });
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            throw err;
        }
    }, [
        autoCloneDocument,
        formatMessage,
        toggleNotification
    ]);
    const [cloneDocument] = useCloneDocumentMutation();
    const clone = React__namespace.useCallback(async ({ model, documentId, params }, body, trackerProperty)=>{
        try {
            const { id: _id, ...restBody } = body;
            /**
         * If we're cloning we want to post directly to this endpoint
         * so that the relations even if they're not listed in the EditView
         * are correctly attached to the entry.
         */ const res = await cloneDocument({
                model,
                sourceId: documentId,
                data: restBody,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                trackUsage('didNotCreateEntry', {
                    error: res.error,
                    ...trackerProperty
                });
                return {
                    error: res.error
                };
            }
            trackUsage('didCreateEntry', trackerProperty);
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.clone'),
                    defaultMessage: 'Cloned document'
                })
            });
            // Redirect to normal edit view
            navigate(`../../${res.data.data.documentId}`, {
                relative: 'path'
            });
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            trackUsage('didNotCreateEntry', {
                error: err,
                ...trackerProperty
            });
            throw err;
        }
    }, [
        cloneDocument,
        trackUsage,
        toggleNotification,
        formatMessage,
        formatAPIError,
        navigate
    ]);
    const [getDoc] = useLazyGetDocumentQuery();
    const getDocument = React__namespace.useCallback(async (args)=>{
        const { data } = await getDoc(args);
        return data;
    }, [
        getDoc
    ]);
    return {
        isLoading: isPublishing || isUpdating || isDiscardingDocument || isDeleting || isDeletingMany || isUnpublishingMany || isPublishingMany,
        autoClone,
        clone,
        create,
        delete: _delete,
        deleteMany,
        discard,
        getDocument,
        publish,
        publishMany,
        unpublish,
        unpublishMany,
        update
    };
};

const ProtectedHistoryPage = /*#__PURE__*/ React__namespace.lazy(()=>Promise.resolve().then(function () { return require('./History-C-_o7tz8.js'); }).then((mod)=>({
            default: mod.ProtectedHistoryPage
        })));
/**
 * These routes will be merged with the rest of the Content Manager routes
 */ const routes$2 = [
    {
        path: ':collectionType/:slug/:id/history',
        Component: ProtectedHistoryPage
    },
    {
        path: ':collectionType/:slug/history',
        Component: ProtectedHistoryPage
    }
];

const ProtectedPreviewPage = /*#__PURE__*/ React__namespace.lazy(()=>Promise.resolve().then(function () { return require('./Preview-B6ThL2SA.js'); }).then((mod)=>({
            default: mod.ProtectedPreviewPage
        })));
const routes$1 = [
    {
        path: ':collectionType/:slug/:id/preview',
        Component: ProtectedPreviewPage
    },
    {
        path: ':collectionType/:slug/preview',
        Component: ProtectedPreviewPage
    }
];

const ProtectedEditViewPage = /*#__PURE__*/ React.lazy(()=>Promise.resolve().then(function () { return require('./EditViewPage-DpvonssD.js'); }).then((mod)=>({
            default: mod.ProtectedEditViewPage
        })));
const ProtectedListViewPage = /*#__PURE__*/ React.lazy(()=>Promise.resolve().then(function () { return require('./ListViewPage-DNvysJaJ.js'); }).then((mod)=>({
            default: mod.ProtectedListViewPage
        })));
const ProtectedListConfiguration = /*#__PURE__*/ React.lazy(()=>Promise.resolve().then(function () { return require('./ListConfigurationPage-D66hgG4-.js'); }).then((mod)=>({
            default: mod.ProtectedListConfiguration
        })));
const ProtectedEditConfigurationPage = /*#__PURE__*/ React.lazy(()=>Promise.resolve().then(function () { return require('./EditConfigurationPage-yliOxLUv.js'); }).then((mod)=>({
            default: mod.ProtectedEditConfigurationPage
        })));
const ProtectedComponentConfigurationPage = /*#__PURE__*/ React.lazy(()=>Promise.resolve().then(function () { return require('./ComponentConfigurationPage-BGBNQxFJ.js'); }).then((mod)=>({
            default: mod.ProtectedComponentConfigurationPage
        })));
const NoPermissions = /*#__PURE__*/ React.lazy(()=>Promise.resolve().then(function () { return require('./NoPermissionsPage-C9sDJXRu.js'); }).then((mod)=>({
            default: mod.NoPermissions
        })));
const NoContentType = /*#__PURE__*/ React.lazy(()=>Promise.resolve().then(function () { return require('./NoContentTypePage-C5qFFfgn.js'); }).then((mod)=>({
            default: mod.NoContentType
        })));
const CollectionTypePages = ()=>{
    const { collectionType } = reactRouterDom.useParams();
    /**
   * We only support two types of collections.
   */ if (collectionType !== COLLECTION_TYPES && collectionType !== SINGLE_TYPES) {
        return /*#__PURE__*/ jsxRuntime.jsx(reactRouterDom.Navigate, {
            to: "/404"
        });
    }
    return collectionType === COLLECTION_TYPES ? /*#__PURE__*/ jsxRuntime.jsx(ProtectedListViewPage, {}) : /*#__PURE__*/ jsxRuntime.jsx(ProtectedEditViewPage, {});
};
const CLONE_RELATIVE_PATH = ':collectionType/:slug/clone/:origin';
const CLONE_PATH = `/content-manager/${CLONE_RELATIVE_PATH}`;
const LIST_RELATIVE_PATH = ':collectionType/:slug';
const LIST_PATH = `/content-manager/collection-types/:slug`;
const routes = [
    {
        path: LIST_RELATIVE_PATH,
        element: /*#__PURE__*/ jsxRuntime.jsx(CollectionTypePages, {})
    },
    {
        path: ':collectionType/:slug/:id',
        Component: ProtectedEditViewPage
    },
    {
        path: CLONE_RELATIVE_PATH,
        Component: ProtectedEditViewPage
    },
    {
        path: ':collectionType/:slug/configurations/list',
        Component: ProtectedListConfiguration
    },
    {
        path: 'components/:slug/configurations/edit',
        Component: ProtectedComponentConfigurationPage
    },
    {
        path: ':collectionType/:slug/configurations/edit',
        Component: ProtectedEditConfigurationPage
    },
    {
        path: '403',
        Component: NoPermissions
    },
    {
        path: 'no-content-types',
        Component: NoContentType
    },
    ...routes$2,
    ...routes$1
];

const DocumentActions = ({ actions })=>{
    const { formatMessage } = reactIntl.useIntl();
    const [primaryAction, secondaryAction, ...restActions] = actions.filter((action)=>{
        if (action.position === undefined) {
            return true;
        }
        const positions = Array.isArray(action.position) ? action.position : [
            action.position
        ];
        return positions.includes('panel');
    });
    if (!primaryAction) {
        return null;
    }
    return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
        direction: "column",
        gap: 2,
        alignItems: "stretch",
        width: "100%",
        children: [
            /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                gap: 2,
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx(DocumentActionButton, {
                        ...primaryAction,
                        variant: primaryAction.variant || 'default'
                    }),
                    restActions.length > 0 ? /*#__PURE__*/ jsxRuntime.jsx(DocumentActionsMenu, {
                        actions: restActions,
                        label: formatMessage({
                            id: 'content-manager.containers.edit.panels.default.more-actions',
                            defaultMessage: 'More document actions'
                        })
                    }) : null
                ]
            }),
            secondaryAction ? /*#__PURE__*/ jsxRuntime.jsx(DocumentActionButton, {
                ...secondaryAction,
                variant: secondaryAction.variant || 'secondary'
            }) : null
        ]
    });
};
const DocumentActionButton = (action)=>{
    const [dialogId, setDialogId] = React__namespace.useState(null);
    const { toggleNotification } = strapiAdmin.useNotification();
    const handleClick = (action)=>async (e)=>{
            const { onClick = ()=>false, dialog, id } = action;
            const muteDialog = await onClick(e);
            if (dialog && !muteDialog) {
                switch(dialog.type){
                    case 'notification':
                        toggleNotification({
                            title: dialog.title,
                            message: dialog.content,
                            type: dialog.status,
                            timeout: dialog.timeout,
                            onClose: dialog.onClose
                        });
                        break;
                    case 'dialog':
                    case 'modal':
                        e.preventDefault();
                        setDialogId(id);
                }
            }
        };
    const handleClose = ()=>{
        setDialogId(null);
    };
    return /*#__PURE__*/ jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [
            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
                flex: "auto",
                startIcon: action.icon,
                disabled: action.disabled,
                onClick: handleClick(action),
                justifyContent: "center",
                variant: action.variant || 'default',
                paddingTop: "7px",
                paddingBottom: "7px",
                loading: action.loading,
                children: action.label
            }),
            action.dialog?.type === 'dialog' ? /*#__PURE__*/ jsxRuntime.jsx(DocumentActionConfirmDialog, {
                ...action.dialog,
                variant: action.dialog?.variant ?? action.variant,
                isOpen: dialogId === action.id,
                onClose: handleClose
            }) : null,
            action.dialog?.type === 'modal' ? /*#__PURE__*/ jsxRuntime.jsx(DocumentActionModal, {
                ...action.dialog,
                onModalClose: handleClose,
                isOpen: dialogId === action.id
            }) : null
        ]
    });
};
const MenuItem = styledComponents.styled(designSystem.Menu.Item)`
  &:hover {
    background: ${({ theme, isVariantDanger, isDisabled })=>isVariantDanger && !isDisabled ? theme.colors.danger100 : 'neutral'};
  }
`;
const DocumentActionsMenu = ({ actions, children, label, variant = 'tertiary' })=>{
    const [isOpen, setIsOpen] = React__namespace.useState(false);
    const [dialogId, setDialogId] = React__namespace.useState(null);
    const { formatMessage } = reactIntl.useIntl();
    const { toggleNotification } = strapiAdmin.useNotification();
    const isDisabled = actions.every((action)=>action.disabled) || actions.length === 0;
    const handleClick = (action)=>async (e)=>{
            const { onClick = ()=>false, dialog, id } = action;
            const muteDialog = await onClick(e);
            if (dialog && !muteDialog) {
                switch(dialog.type){
                    case 'notification':
                        toggleNotification({
                            title: dialog.title,
                            message: dialog.content,
                            type: dialog.status,
                            timeout: dialog.timeout,
                            onClose: dialog.onClose
                        });
                        break;
                    case 'dialog':
                    case 'modal':
                        setDialogId(id);
                }
            }
        };
    const handleClose = ()=>{
        setDialogId(null);
        setIsOpen(false);
    };
    return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Menu.Root, {
        open: isOpen,
        onOpenChange: setIsOpen,
        children: [
            /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Menu.Trigger, {
                disabled: isDisabled,
                size: "S",
                endIcon: null,
                paddingTop: "4px",
                paddingLeft: "7px",
                paddingRight: "7px",
                variant: variant,
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx(Icons.More, {
                        "aria-hidden": true,
                        focusable: false
                    }),
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.VisuallyHidden, {
                        tag: "span",
                        children: label || formatMessage({
                            id: 'content-manager.containers.edit.panels.default.more-actions',
                            defaultMessage: 'More document actions'
                        })
                    })
                ]
            }),
            /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Menu.Content, {
                maxHeight: undefined,
                popoverPlacement: "bottom-end",
                children: [
                    actions.map((action)=>{
                        return /*#__PURE__*/ jsxRuntime.jsx(MenuItem, {
                            disabled: action.disabled,
                            /* @ts-expect-error – TODO: this is an error in the DS where it is most likely a synthetic event, not regular. */ onSelect: handleClick(action),
                            display: "block",
                            isVariantDanger: action.variant === 'danger',
                            isDisabled: action.disabled,
                            children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Flex, {
                                justifyContent: "space-between",
                                gap: 4,
                                children: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                                    color: !action.disabled ? convertActionVariantToColor(action.variant) : 'inherit',
                                    gap: 2,
                                    tag: "span",
                                    children: [
                                        /*#__PURE__*/ jsxRuntime.jsx(designSystem.Flex, {
                                            tag: "span",
                                            color: !action.disabled ? convertActionVariantToIconColor(action.variant) : 'inherit',
                                            children: action.icon
                                        }),
                                        action.label
                                    ]
                                })
                            })
                        }, action.id);
                    }),
                    children
                ]
            }),
            actions.map((action)=>{
                return /*#__PURE__*/ jsxRuntime.jsxs(React__namespace.Fragment, {
                    children: [
                        action.dialog?.type === 'dialog' ? /*#__PURE__*/ jsxRuntime.jsx(DocumentActionConfirmDialog, {
                            ...action.dialog,
                            variant: action.variant,
                            isOpen: dialogId === action.id,
                            onClose: handleClose
                        }) : null,
                        action.dialog?.type === 'modal' ? /*#__PURE__*/ jsxRuntime.jsx(DocumentActionModal, {
                            ...action.dialog,
                            onModalClose: handleClose,
                            isOpen: dialogId === action.id
                        }) : null
                    ]
                }, action.id);
            })
        ]
    });
};
const convertActionVariantToColor = (variant = 'secondary')=>{
    switch(variant){
        case 'danger':
            return 'danger600';
        case 'secondary':
            return undefined;
        case 'success':
            return 'success600';
        default:
            return 'primary600';
    }
};
const convertActionVariantToIconColor = (variant = 'secondary')=>{
    switch(variant){
        case 'danger':
            return 'danger600';
        case 'secondary':
            return 'neutral500';
        case 'success':
            return 'success600';
        default:
            return 'primary600';
    }
};
const DocumentActionConfirmDialog = ({ onClose, onCancel, onConfirm, title, content, isOpen, variant = 'secondary', loading })=>{
    const { formatMessage } = reactIntl.useIntl();
    const handleClose = async ()=>{
        if (onCancel) {
            await onCancel();
        }
        onClose();
    };
    const handleConfirm = async ()=>{
        if (onConfirm) {
            await onConfirm();
        }
        onClose();
    };
    return /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Root, {
        open: isOpen,
        onOpenChange: handleClose,
        children: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Dialog.Content, {
            children: [
                /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Header, {
                    children: title
                }),
                /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Body, {
                    children: content
                }),
                /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Dialog.Footer, {
                    children: [
                        /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Cancel, {
                            children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
                                variant: "tertiary",
                                fullWidth: true,
                                children: formatMessage({
                                    id: 'app.components.Button.cancel',
                                    defaultMessage: 'Cancel'
                                })
                            })
                        }),
                        /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
                            onClick: handleConfirm,
                            variant: variant,
                            fullWidth: true,
                            loading: loading,
                            children: formatMessage({
                                id: 'app.components.Button.confirm',
                                defaultMessage: 'Confirm'
                            })
                        })
                    ]
                })
            ]
        })
    });
};
const DocumentActionModal = ({ isOpen, title, onClose, footer: Footer, content: Content, onModalClose })=>{
    const handleClose = ()=>{
        if (onClose) {
            onClose();
        }
        onModalClose();
    };
    return /*#__PURE__*/ jsxRuntime.jsx(designSystem.Modal.Root, {
        open: isOpen,
        onOpenChange: handleClose,
        children: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Modal.Content, {
            children: [
                /*#__PURE__*/ jsxRuntime.jsx(designSystem.Modal.Header, {
                    children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Modal.Title, {
                        children: title
                    })
                }),
                typeof Content === 'function' ? /*#__PURE__*/ jsxRuntime.jsx(Content, {
                    onClose: handleClose
                }) : /*#__PURE__*/ jsxRuntime.jsx(designSystem.Modal.Body, {
                    children: Content
                }),
                typeof Footer === 'function' ? /*#__PURE__*/ jsxRuntime.jsx(Footer, {
                    onClose: handleClose
                }) : Footer
            ]
        })
    });
};
const transformData = (data)=>{
    if (Array.isArray(data)) {
        return data.map(transformData);
    }
    if (typeof data === 'object' && data !== null) {
        if ('apiData' in data) {
            return data.apiData;
        }
        return mapValues(transformData)(data);
    }
    return data;
};
/* -------------------------------------------------------------------------------------------------
 * DocumentActionComponents
 * -----------------------------------------------------------------------------------------------*/ const PublishAction$1 = ({ activeTab, documentId, model, collectionType, meta, document, onPreview })=>{
    const { schema } = useDoc();
    const navigate = reactRouterDom.useNavigate();
    const { toggleNotification } = strapiAdmin.useNotification();
    const { _unstableFormatValidationErrors: formatValidationErrors } = strapiAdmin.useAPIErrorHandler();
    const isListView = reactRouterDom.useMatch(LIST_PATH) !== null;
    const isCloning = reactRouterDom.useMatch(CLONE_PATH) !== null;
    const { id } = reactRouterDom.useParams();
    const { formatMessage } = reactIntl.useIntl();
    const canPublish = useDocumentRBAC('PublishAction', ({ canPublish })=>canPublish);
    const { publish, isLoading } = useDocumentActions();
    const [countDraftRelations, { isLoading: isLoadingDraftRelations, isError: isErrorDraftRelations }] = useLazyGetDraftRelationCountQuery();
    const [localCountOfDraftRelations, setLocalCountOfDraftRelations] = React__namespace.useState(0);
    const [serverCountOfDraftRelations, setServerCountOfDraftRelations] = React__namespace.useState(0);
    const [{ query, rawQuery }] = strapiAdmin.useQueryParams();
    const params = React__namespace.useMemo(()=>buildValidParams(query), [
        query
    ]);
    const modified = strapiAdmin.useForm('PublishAction', ({ modified })=>modified);
    const setSubmitting = strapiAdmin.useForm('PublishAction', ({ setSubmitting })=>setSubmitting);
    const isSubmitting = strapiAdmin.useForm('PublishAction', ({ isSubmitting })=>isSubmitting);
    const validate = strapiAdmin.useForm('PublishAction', (state)=>state.validate);
    const setErrors = strapiAdmin.useForm('PublishAction', (state)=>state.setErrors);
    const formValues = strapiAdmin.useForm('PublishAction', ({ values })=>values);
    React__namespace.useEffect(()=>{
        if (isErrorDraftRelations) {
            toggleNotification({
                type: 'danger',
                message: formatMessage({
                    id: getTranslation('error.records.fetch-draft-relatons'),
                    defaultMessage: 'An error occurred while fetching draft relations on this document.'
                })
            });
        }
    }, [
        isErrorDraftRelations,
        toggleNotification,
        formatMessage
    ]);
    React__namespace.useEffect(()=>{
        const localDraftRelations = new Set();
        /**
     * Extracts draft relations from the provided data object.
     * It checks for a connect array of relations.
     * If a relation has a status of 'draft', its id is added to the localDraftRelations set.
     */ const extractDraftRelations = (data)=>{
            const relations = data.connect || [];
            relations.forEach((relation)=>{
                if (relation.status === 'draft') {
                    localDraftRelations.add(relation.id);
                }
            });
        };
        /**
     * Recursively traverses the provided data object to extract draft relations from arrays within 'connect' keys.
     * If the data is an object, it looks for 'connect' keys to pass their array values to extractDraftRelations.
     * It recursively calls itself for any non-null objects it contains.
     */ const traverseAndExtract = (data)=>{
            Object.entries(data).forEach(([key, value])=>{
                if (key === 'connect' && Array.isArray(value)) {
                    extractDraftRelations({
                        connect: value
                    });
                } else if (typeof value === 'object' && value !== null) {
                    traverseAndExtract(value);
                }
            });
        };
        if (!documentId || modified) {
            traverseAndExtract(formValues);
            setLocalCountOfDraftRelations(localDraftRelations.size);
        }
    }, [
        documentId,
        modified,
        formValues,
        setLocalCountOfDraftRelations
    ]);
    React__namespace.useEffect(()=>{
        if (!document || !document.documentId || isListView) {
            return;
        }
        const fetchDraftRelationsCount = async ()=>{
            const { data, error } = await countDraftRelations({
                collectionType,
                model,
                documentId,
                params
            });
            if (error) {
                throw error;
            }
            if (data) {
                setServerCountOfDraftRelations(data.data);
            }
        };
        fetchDraftRelationsCount();
    }, [
        isListView,
        document,
        documentId,
        countDraftRelations,
        collectionType,
        model,
        params
    ]);
    const isDocumentPublished = (document?.[PUBLISHED_AT_ATTRIBUTE_NAME] || meta?.availableStatus.some((doc)=>doc[PUBLISHED_AT_ATTRIBUTE_NAME] !== null)) && document?.status !== 'modified';
    if (!schema?.options?.draftAndPublish) {
        return null;
    }
    const performPublish = async ()=>{
        setSubmitting(true);
        try {
            const { errors } = await validate(true, {
                status: 'published'
            });
            if (errors) {
                toggleNotification({
                    type: 'danger',
                    message: formatMessage({
                        id: 'content-manager.validation.error',
                        defaultMessage: 'There are validation errors in your document. Please fix them before saving.'
                    })
                });
                return;
            }
            const res = await publish({
                collectionType,
                model,
                documentId,
                params
            }, transformData(formValues));
            if ('data' in res && collectionType !== SINGLE_TYPES) {
                /**
         * TODO: refactor the router so we can just do `../${res.data.documentId}` instead of this.
         */ if (id === 'create') {
                    navigate({
                        pathname: `../${collectionType}/${model}/${res.data.documentId}`,
                        search: rawQuery
                    });
                }
            } else if ('error' in res && isBaseQueryError(res.error) && res.error.name === 'ValidationError') {
                setErrors(formatValidationErrors(res.error));
            }
        } finally{
            setSubmitting(false);
            if (onPreview) {
                onPreview();
            }
        }
    };
    const totalDraftRelations = localCountOfDraftRelations + serverCountOfDraftRelations;
    // TODO skipping this for now as there is a bug with the draft relation count that will be worked on separately
    // see RFC "Count draft relations" in Notion
    const enableDraftRelationsCount = false;
    const hasDraftRelations = enableDraftRelationsCount;
    return {
        loading: isLoading,
        position: [
            'panel',
            'preview'
        ],
        /**
     * Disabled when:
     *  - currently if you're cloning a document we don't support publish & clone at the same time.
     *  - the form is submitting
     *  - the active tab is the published tab
     *  - the document is already published & not modified
     *  - the document is being created & not modified
     *  - the user doesn't have the permission to publish
     */ disabled: isCloning || isSubmitting || isLoadingDraftRelations || activeTab === 'published' || !modified && isDocumentPublished || !modified && !document?.documentId || !canPublish,
        label: formatMessage({
            id: 'app.utils.publish',
            defaultMessage: 'Publish'
        }),
        onClick: async ()=>{
            await performPublish();
        },
        dialog: hasDraftRelations ? {
            type: 'dialog',
            variant: 'danger',
            footer: null,
            title: formatMessage({
                id: getTranslation(`popUpwarning.warning.bulk-has-draft-relations.title`),
                defaultMessage: 'Confirmation'
            }),
            content: formatMessage({
                id: getTranslation(`popUpwarning.warning.bulk-has-draft-relations.message`),
                defaultMessage: 'This entry is related to {count, plural, one {# draft entry} other {# draft entries}}. Publishing it could leave broken links in your app.'
            }, {
                count: totalDraftRelations
            }),
            onConfirm: async ()=>{
                await performPublish();
            }
        } : undefined
    };
};
PublishAction$1.type = 'publish';
PublishAction$1.position = [
    'panel',
    'preview'
];
const UpdateAction = ({ activeTab, documentId, model, collectionType, onPreview })=>{
    const navigate = reactRouterDom.useNavigate();
    const { toggleNotification } = strapiAdmin.useNotification();
    const { _unstableFormatValidationErrors: formatValidationErrors } = strapiAdmin.useAPIErrorHandler();
    const cloneMatch = reactRouterDom.useMatch(CLONE_PATH);
    const isCloning = cloneMatch !== null;
    const { formatMessage } = reactIntl.useIntl();
    const { create, update, clone, isLoading } = useDocumentActions();
    const [{ query, rawQuery }] = strapiAdmin.useQueryParams();
    const params = React__namespace.useMemo(()=>buildValidParams(query), [
        query
    ]);
    const isSubmitting = strapiAdmin.useForm('UpdateAction', ({ isSubmitting })=>isSubmitting);
    const modified = strapiAdmin.useForm('UpdateAction', ({ modified })=>modified);
    const setSubmitting = strapiAdmin.useForm('UpdateAction', ({ setSubmitting })=>setSubmitting);
    const document = strapiAdmin.useForm('UpdateAction', ({ values })=>values);
    const validate = strapiAdmin.useForm('UpdateAction', (state)=>state.validate);
    const setErrors = strapiAdmin.useForm('UpdateAction', (state)=>state.setErrors);
    const resetForm = strapiAdmin.useForm('PublishAction', ({ resetForm })=>resetForm);
    const handleUpdate = React__namespace.useCallback(async ()=>{
        setSubmitting(true);
        try {
            if (!modified) {
                return;
            }
            const { errors } = await validate(true, {
                status: 'draft'
            });
            if (errors) {
                toggleNotification({
                    type: 'danger',
                    message: formatMessage({
                        id: 'content-manager.validation.error',
                        defaultMessage: 'There are validation errors in your document. Please fix them before saving.'
                    })
                });
                return;
            }
            if (isCloning) {
                const res = await clone({
                    model,
                    documentId: cloneMatch.params.origin,
                    params
                }, transformData(document));
                if ('data' in res) {
                    navigate({
                        pathname: `../${res.data.documentId}`,
                        search: rawQuery
                    }, {
                        relative: 'path'
                    });
                } else if ('error' in res && isBaseQueryError(res.error) && res.error.name === 'ValidationError') {
                    setErrors(formatValidationErrors(res.error));
                }
            } else if (documentId || collectionType === SINGLE_TYPES) {
                const res = await update({
                    collectionType,
                    model,
                    documentId,
                    params
                }, transformData(document));
                if ('error' in res && isBaseQueryError(res.error) && res.error.name === 'ValidationError') {
                    setErrors(formatValidationErrors(res.error));
                } else {
                    resetForm();
                }
            } else {
                const res = await create({
                    model,
                    params
                }, transformData(document));
                if ('data' in res && collectionType !== SINGLE_TYPES) {
                    navigate({
                        pathname: `../${res.data.documentId}`,
                        search: rawQuery
                    }, {
                        replace: true,
                        relative: 'path'
                    });
                } else if ('error' in res && isBaseQueryError(res.error) && res.error.name === 'ValidationError') {
                    setErrors(formatValidationErrors(res.error));
                }
            }
        } finally{
            setSubmitting(false);
            if (onPreview) {
                onPreview();
            }
        }
    }, [
        clone,
        cloneMatch?.params.origin,
        collectionType,
        create,
        document,
        documentId,
        formatMessage,
        formatValidationErrors,
        isCloning,
        model,
        modified,
        navigate,
        params,
        rawQuery,
        resetForm,
        setErrors,
        setSubmitting,
        toggleNotification,
        update,
        validate
    ]);
    // Auto-save on CMD+S or CMD+Enter on macOS, and CTRL+S or CTRL+Enter on Windows/Linux
    React__namespace.useEffect(()=>{
        const handleKeyDown = (e)=>{
            if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                e.preventDefault();
                handleUpdate();
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return ()=>{
            window.removeEventListener('keydown', handleKeyDown);
        };
    }, [
        handleUpdate
    ]);
    return {
        loading: isLoading,
        /**
     * Disabled when:
     * - the form is submitting
     * - the document is not modified & we're not cloning (you can save a clone entity straight away)
     * - the active tab is the published tab
     */ disabled: isSubmitting || !modified && !isCloning || activeTab === 'published',
        label: formatMessage({
            id: 'global.save',
            defaultMessage: 'Save'
        }),
        onClick: handleUpdate,
        position: [
            'panel',
            'preview'
        ]
    };
};
UpdateAction.type = 'update';
UpdateAction.position = [
    'panel',
    'preview'
];
const UNPUBLISH_DRAFT_OPTIONS = {
    KEEP: 'keep',
    DISCARD: 'discard'
};
const UnpublishAction$1 = ({ activeTab, documentId, model, collectionType, document })=>{
    const { formatMessage } = reactIntl.useIntl();
    const { schema } = useDoc();
    const canPublish = useDocumentRBAC('UnpublishAction', ({ canPublish })=>canPublish);
    const { unpublish } = useDocumentActions();
    const [{ query }] = strapiAdmin.useQueryParams();
    const params = React__namespace.useMemo(()=>buildValidParams(query), [
        query
    ]);
    const { toggleNotification } = strapiAdmin.useNotification();
    const [shouldKeepDraft, setShouldKeepDraft] = React__namespace.useState(true);
    const isDocumentModified = document?.status === 'modified';
    const handleChange = (value)=>{
        setShouldKeepDraft(value === UNPUBLISH_DRAFT_OPTIONS.KEEP);
    };
    if (!schema?.options?.draftAndPublish) {
        return null;
    }
    return {
        disabled: !canPublish || activeTab === 'published' || document?.status !== 'published' && document?.status !== 'modified',
        label: formatMessage({
            id: 'app.utils.unpublish',
            defaultMessage: 'Unpublish'
        }),
        icon: /*#__PURE__*/ jsxRuntime.jsx(Icons.Cross, {}),
        onClick: async ()=>{
            /**
       * return if there's no id & we're in a collection type, or the status modified
       * for either collection type because we use a dialog to handle the process in
       * the latter case.
       */ if (!documentId && collectionType !== SINGLE_TYPES || isDocumentModified) {
                if (!documentId) {
                    // This should never, ever, happen.
                    console.error("You're trying to unpublish a document without an id, this is likely a bug with Strapi. Please open an issue.");
                    toggleNotification({
                        message: formatMessage({
                            id: 'content-manager.actions.unpublish.error',
                            defaultMessage: 'An error occurred while trying to unpublish the document.'
                        }),
                        type: 'danger'
                    });
                }
                return;
            }
            await unpublish({
                collectionType,
                model,
                documentId,
                params
            });
        },
        dialog: isDocumentModified ? {
            type: 'dialog',
            title: formatMessage({
                id: 'app.components.ConfirmDialog.title',
                defaultMessage: 'Confirmation'
            }),
            content: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                alignItems: "flex-start",
                direction: "column",
                gap: 6,
                children: [
                    /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                        width: "100%",
                        direction: "column",
                        gap: 2,
                        children: [
                            /*#__PURE__*/ jsxRuntime.jsx(Icons.WarningCircle, {
                                width: "24px",
                                height: "24px",
                                fill: "danger600"
                            }),
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                                tag: "p",
                                variant: "omega",
                                textAlign: "center",
                                children: formatMessage({
                                    id: 'content-manager.actions.unpublish.dialog.body',
                                    defaultMessage: 'Are you sure?'
                                })
                            })
                        ]
                    }),
                    /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Radio.Group, {
                        defaultValue: UNPUBLISH_DRAFT_OPTIONS.KEEP,
                        name: "discard-options",
                        "aria-label": formatMessage({
                            id: 'content-manager.actions.unpublish.dialog.radio-label',
                            defaultMessage: 'Choose an option to unpublish the document.'
                        }),
                        onValueChange: handleChange,
                        children: [
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Radio.Item, {
                                checked: shouldKeepDraft,
                                value: UNPUBLISH_DRAFT_OPTIONS.KEEP,
                                children: formatMessage({
                                    id: 'content-manager.actions.unpublish.dialog.option.keep-draft',
                                    defaultMessage: 'Keep draft'
                                })
                            }),
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Radio.Item, {
                                checked: !shouldKeepDraft,
                                value: UNPUBLISH_DRAFT_OPTIONS.DISCARD,
                                children: formatMessage({
                                    id: 'content-manager.actions.unpublish.dialog.option.replace-draft',
                                    defaultMessage: 'Replace draft'
                                })
                            })
                        ]
                    })
                ]
            }),
            onConfirm: async ()=>{
                if (!documentId && collectionType !== SINGLE_TYPES) {
                    // This should never, ever, happen.
                    console.error("You're trying to unpublish a document without an id, this is likely a bug with Strapi. Please open an issue.");
                    toggleNotification({
                        message: formatMessage({
                            id: 'content-manager.actions.unpublish.error',
                            defaultMessage: 'An error occurred while trying to unpublish the document.'
                        }),
                        type: 'danger'
                    });
                }
                await unpublish({
                    collectionType,
                    model,
                    documentId,
                    params
                }, !shouldKeepDraft);
            }
        } : undefined,
        variant: 'danger',
        position: [
            'panel',
            'table-row'
        ]
    };
};
UnpublishAction$1.type = 'unpublish';
UnpublishAction$1.position = 'panel';
const DiscardAction = ({ activeTab, documentId, model, collectionType, document })=>{
    const { formatMessage } = reactIntl.useIntl();
    const { schema } = useDoc();
    const canUpdate = useDocumentRBAC('DiscardAction', ({ canUpdate })=>canUpdate);
    const { discard, isLoading } = useDocumentActions();
    const [{ query }] = strapiAdmin.useQueryParams();
    const params = React__namespace.useMemo(()=>buildValidParams(query), [
        query
    ]);
    if (!schema?.options?.draftAndPublish) {
        return null;
    }
    return {
        disabled: !canUpdate || activeTab === 'published' || document?.status !== 'modified',
        label: formatMessage({
            id: 'content-manager.actions.discard.label',
            defaultMessage: 'Discard changes'
        }),
        icon: /*#__PURE__*/ jsxRuntime.jsx(Icons.Cross, {}),
        position: [
            'panel',
            'table-row'
        ],
        variant: 'danger',
        dialog: {
            type: 'dialog',
            title: formatMessage({
                id: 'app.components.ConfirmDialog.title',
                defaultMessage: 'Confirmation'
            }),
            content: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                direction: "column",
                gap: 2,
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx(Icons.WarningCircle, {
                        width: "24px",
                        height: "24px",
                        fill: "danger600"
                    }),
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                        tag: "p",
                        variant: "omega",
                        textAlign: "center",
                        children: formatMessage({
                            id: 'content-manager.actions.discard.dialog.body',
                            defaultMessage: 'Are you sure?'
                        })
                    })
                ]
            }),
            loading: isLoading,
            onConfirm: async ()=>{
                await discard({
                    collectionType,
                    model,
                    documentId,
                    params
                });
            }
        }
    };
};
DiscardAction.type = 'discard';
DiscardAction.position = 'panel';
const DEFAULT_ACTIONS = [
    PublishAction$1,
    UpdateAction,
    UnpublishAction$1,
    DiscardAction
];

const intervals = [
    'years',
    'months',
    'days',
    'hours',
    'minutes',
    'seconds'
];
/**
 * Displays the relative time between a given timestamp and the current time.
 * You can display a custom message for given time intervals by passing an array of custom intervals.
 *
 * @example
 * ```jsx
 * <caption>Display "last hour" if the timestamp is less than an hour ago</caption>
 * <RelativeTime
 *  timestamp={new Date('2021-01-01')}
 *  customIntervals={[
 *   { unit: 'hours', threshold: 1, text: 'last hour' },
 *  ]}
 * ```
 */ const RelativeTime = /*#__PURE__*/ React__namespace.forwardRef(({ timestamp, customIntervals = [], ...restProps }, forwardedRef)=>{
    const { formatRelativeTime, formatDate, formatTime } = reactIntl.useIntl();
    /**
     * TODO: make this auto-update, like a clock.
     */ const interval = dateFns.intervalToDuration({
        start: timestamp,
        end: Date.now()
    });
    const unit = intervals.find((intervalUnit)=>{
        return interval[intervalUnit] > 0 && Object.keys(interval).includes(intervalUnit);
    }) ?? 'seconds';
    const relativeTime = dateFns.isPast(timestamp) ? -interval[unit] : interval[unit];
    // Display custom text if interval is less than the threshold
    const customInterval = customIntervals.find((custom)=>interval[custom.unit] < custom.threshold);
    const displayText = customInterval ? customInterval.text : formatRelativeTime(relativeTime, unit, {
        numeric: 'auto'
    });
    return /*#__PURE__*/ jsxRuntime.jsx("time", {
        ref: forwardedRef,
        dateTime: timestamp.toISOString(),
        role: "time",
        title: `${formatDate(timestamp)} ${formatTime(timestamp)}`,
        ...restProps,
        children: displayText
    });
});

/**
 * Retrieves the display name of an admin panel user
 */ const getDisplayName = ({ firstname, lastname, username, email } = {})=>{
    if (username) {
        return username;
    }
    // firstname is not required if the user is created with a username
    if (firstname) {
        return `${firstname} ${lastname ?? ''}`.trim();
    }
    return email ?? '';
};

const capitalise = (str)=>str.charAt(0).toUpperCase() + str.slice(1);

/**
 * @public
 * @description Displays the status of a document (draft, published, etc.)
 * and automatically calculates the appropriate variant for the status.
 */ const DocumentStatus = ({ status = 'draft', size = 'S', ...restProps })=>{
    const statusVariant = status === 'draft' ? 'secondary' : status === 'published' ? 'success' : 'alternative';
    const { formatMessage } = reactIntl.useIntl();
    return /*#__PURE__*/ jsxRuntime.jsx(designSystem.Status, {
        ...restProps,
        size: size,
        variant: statusVariant,
        role: "status",
        "aria-labelledby": "document-status",
        children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
            tag: "span",
            variant: "omega",
            fontWeight: "bold",
            id: "document-status",
            children: formatMessage({
                id: `content-manager.containers.List.${status}`,
                defaultMessage: capitalise(status)
            })
        })
    });
};

const Header = ({ isCreating, status, title: documentTitle = 'Untitled' })=>{
    const { formatMessage } = reactIntl.useIntl();
    const isCloning = reactRouterDom.useMatch(CLONE_PATH) !== null;
    const params = reactRouterDom.useParams();
    const title = isCreating ? formatMessage({
        id: 'content-manager.containers.edit.title.new',
        defaultMessage: 'Create an entry'
    }) : documentTitle;
    return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
        direction: "column",
        alignItems: "flex-start",
        paddingTop: 6,
        paddingBottom: 4,
        gap: 2,
        children: [
            /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.BackButton, {
                fallback: params.collectionType === SINGLE_TYPES ? undefined : `../${COLLECTION_TYPES}/${params.slug}`
            }),
            /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                width: "100%",
                justifyContent: "space-between",
                gap: "80px",
                alignItems: "flex-start",
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                        variant: "alpha",
                        tag: "h1",
                        children: title
                    }),
                    /*#__PURE__*/ jsxRuntime.jsx(HeaderToolbar, {})
                ]
            }),
            status ? /*#__PURE__*/ jsxRuntime.jsx(designSystem.Box, {
                marginTop: 1,
                children: /*#__PURE__*/ jsxRuntime.jsx(DocumentStatus, {
                    status: isCloning ? 'draft' : status
                })
            }) : null
        ]
    });
};
/**
 * @description Contains the document actions that have `position: header`, if there are
 * none we still render the menu because we render the information about the document there.
 */ const HeaderToolbar = ()=>{
    const { formatMessage } = reactIntl.useIntl();
    const isCloning = reactRouterDom.useMatch(CLONE_PATH) !== null;
    const [{ query: { status = 'draft' } }] = strapiAdmin.useQueryParams();
    const { model, id, document, meta, collectionType } = useDoc();
    const plugins = strapiAdmin.useStrapiApp('HeaderToolbar', (state)=>state.plugins);
    return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
        gap: 2,
        children: [
            /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.DescriptionComponentRenderer, {
                props: {
                    activeTab: status,
                    model,
                    documentId: id,
                    document: isCloning ? undefined : document,
                    meta: isCloning ? undefined : meta,
                    collectionType
                },
                descriptions: plugins['content-manager'].apis.getHeaderActions(),
                children: (actions)=>{
                    if (actions.length > 0) {
                        return /*#__PURE__*/ jsxRuntime.jsx(HeaderActions, {
                            actions: actions
                        });
                    } else {
                        return null;
                    }
                }
            }),
            /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.DescriptionComponentRenderer, {
                props: {
                    activeTab: status,
                    model,
                    documentId: id,
                    document: isCloning ? undefined : document,
                    meta: isCloning ? undefined : meta,
                    collectionType
                },
                descriptions: plugins['content-manager'].apis.getDocumentActions('header'),
                children: (actions)=>{
                    const headerActions = actions.filter((action)=>{
                        const positions = Array.isArray(action.position) ? action.position : [
                            action.position
                        ];
                        return positions.includes('header');
                    });
                    return /*#__PURE__*/ jsxRuntime.jsx(DocumentActionsMenu, {
                        actions: headerActions,
                        label: formatMessage({
                            id: 'content-manager.containers.edit.header.more-actions',
                            defaultMessage: 'More actions'
                        }),
                        children: /*#__PURE__*/ jsxRuntime.jsx(Information, {
                            activeTab: status
                        })
                    });
                }
            })
        ]
    });
};
const Information = ({ activeTab })=>{
    const { formatMessage } = reactIntl.useIntl();
    const { document, meta } = useDoc();
    if (!document || !document.id) {
        return null;
    }
    /**
   * Because in the backend separate entries are made for draft and published
   * documents, the creator fields are different for each of them. For example,
   * you could make your draft in January and then publish it for the first time
   * in Feb. This would make the createdAt value for the published entry in Feb
   * but really we want to show the document as a whole. The draft entry will also
   * never have the publishedAt values.
   *
   * So, we decipher which document to show the creator for based on the activeTab.
   */ const createAndUpdateDocument = activeTab === 'draft' ? document : meta?.availableStatus.find((status)=>status.publishedAt === null);
    const publishDocument = activeTab === 'published' ? document : meta?.availableStatus.find((status)=>status.publishedAt !== null);
    const creator = createAndUpdateDocument?.[CREATED_BY_ATTRIBUTE_NAME] ? getDisplayName(createAndUpdateDocument[CREATED_BY_ATTRIBUTE_NAME]) : null;
    const updator = createAndUpdateDocument?.[UPDATED_BY_ATTRIBUTE_NAME] ? getDisplayName(createAndUpdateDocument[UPDATED_BY_ATTRIBUTE_NAME]) : null;
    const information = [
        {
            isDisplayed: !!publishDocument?.[PUBLISHED_AT_ATTRIBUTE_NAME],
            label: formatMessage({
                id: 'content-manager.containers.edit.information.last-published.label',
                defaultMessage: 'Published'
            }),
            value: formatMessage({
                id: 'content-manager.containers.edit.information.last-published.value',
                defaultMessage: `{time}{isAnonymous, select, true {} other { by {author}}}`
            }, {
                time: /*#__PURE__*/ jsxRuntime.jsx(RelativeTime, {
                    timestamp: new Date(publishDocument?.[PUBLISHED_AT_ATTRIBUTE_NAME])
                }),
                isAnonymous: !publishDocument?.[PUBLISHED_BY_ATTRIBUTE_NAME],
                author: publishDocument?.[PUBLISHED_BY_ATTRIBUTE_NAME] ? getDisplayName(publishDocument?.[PUBLISHED_BY_ATTRIBUTE_NAME]) : null
            })
        },
        {
            isDisplayed: !!createAndUpdateDocument?.[UPDATED_AT_ATTRIBUTE_NAME],
            label: formatMessage({
                id: 'content-manager.containers.edit.information.last-draft.label',
                defaultMessage: 'Updated'
            }),
            value: formatMessage({
                id: 'content-manager.containers.edit.information.last-draft.value',
                defaultMessage: `{time}{isAnonymous, select, true {} other { by {author}}}`
            }, {
                time: /*#__PURE__*/ jsxRuntime.jsx(RelativeTime, {
                    timestamp: new Date(createAndUpdateDocument?.[UPDATED_AT_ATTRIBUTE_NAME])
                }),
                isAnonymous: !updator,
                author: updator
            })
        },
        {
            isDisplayed: !!createAndUpdateDocument?.[CREATED_AT_ATTRIBUTE_NAME],
            label: formatMessage({
                id: 'content-manager.containers.edit.information.document.label',
                defaultMessage: 'Created'
            }),
            value: formatMessage({
                id: 'content-manager.containers.edit.information.document.value',
                defaultMessage: `{time}{isAnonymous, select, true {} other { by {author}}}`
            }, {
                time: /*#__PURE__*/ jsxRuntime.jsx(RelativeTime, {
                    timestamp: new Date(createAndUpdateDocument?.[CREATED_AT_ATTRIBUTE_NAME])
                }),
                isAnonymous: !creator,
                author: creator
            })
        }
    ].filter((info)=>info.isDisplayed);
    return /*#__PURE__*/ jsxRuntime.jsx(designSystem.Flex, {
        borderWidth: "1px 0 0 0",
        borderStyle: "solid",
        borderColor: "neutral150",
        direction: "column",
        marginTop: 2,
        tag: "dl",
        padding: 5,
        gap: 3,
        alignItems: "flex-start",
        /**
       * The menu content has a padding of 4px, but we want our divider (the border top applied) to
       * be flush with the menu content. So we need to adjust the margin & width to account for the padding.
       */ marginLeft: "-0.4rem",
        marginRight: "-0.4rem",
        width: "calc(100% + 8px)",
        children: information.map((info)=>/*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                gap: 1,
                direction: "column",
                alignItems: "flex-start",
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                        tag: "dt",
                        variant: "pi",
                        fontWeight: "bold",
                        children: info.label
                    }),
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                        tag: "dd",
                        variant: "pi",
                        textColor: "neutral600",
                        children: info.value
                    })
                ]
            }, info.label))
    });
};
const HeaderActions = ({ actions })=>{
    const [dialogId, setDialogId] = React__namespace.useState(null);
    const handleClick = (action)=>async (e)=>{
            if (!('options' in action)) {
                const { onClick = ()=>false, dialog, id } = action;
                const muteDialog = await onClick(e);
                if (dialog && !muteDialog) {
                    e.preventDefault();
                    setDialogId(id);
                }
            }
        };
    const handleClose = ()=>{
        setDialogId(null);
    };
    return /*#__PURE__*/ jsxRuntime.jsx(designSystem.Flex, {
        gap: 1,
        children: actions.map((action)=>{
            if (action.options) {
                return /*#__PURE__*/ jsxRuntime.jsx(designSystem.SingleSelect, {
                    size: "S",
                    // @ts-expect-error – the DS will handle numbers, but we're not allowing the API.
                    onChange: action.onSelect,
                    "aria-label": action.label,
                    ...action,
                    children: action.options.map(({ label, ...option })=>/*#__PURE__*/ jsxRuntime.jsx(designSystem.SingleSelectOption, {
                            ...option,
                            children: label
                        }, option.value))
                }, action.id);
            } else {
                if (action.type === 'icon') {
                    return /*#__PURE__*/ jsxRuntime.jsxs(React__namespace.Fragment, {
                        children: [
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.IconButton, {
                                disabled: action.disabled,
                                label: action.label,
                                size: "S",
                                onClick: handleClick(action),
                                children: action.icon
                            }),
                            action.dialog ? /*#__PURE__*/ jsxRuntime.jsx(HeaderActionDialog, {
                                ...action.dialog,
                                isOpen: dialogId === action.id,
                                onClose: handleClose
                            }) : null
                        ]
                    }, action.id);
                }
            }
        })
    });
};
const HeaderActionDialog = ({ onClose, onCancel, title, content: Content, isOpen })=>{
    const handleClose = async ()=>{
        if (onCancel) {
            await onCancel();
        }
        onClose();
    };
    return /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Root, {
        open: isOpen,
        onOpenChange: handleClose,
        children: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Dialog.Content, {
            children: [
                /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Header, {
                    children: title
                }),
                typeof Content === 'function' ? /*#__PURE__*/ jsxRuntime.jsx(Content, {
                    onClose: handleClose
                }) : Content
            ]
        })
    });
};
/* -------------------------------------------------------------------------------------------------
 * DocumentActionComponents
 * -----------------------------------------------------------------------------------------------*/ const ConfigureTheViewAction = ({ collectionType, model })=>{
    const navigate = reactRouterDom.useNavigate();
    const { formatMessage } = reactIntl.useIntl();
    return {
        label: formatMessage({
            id: 'app.links.configure-view',
            defaultMessage: 'Configure the view'
        }),
        icon: /*#__PURE__*/ jsxRuntime.jsx(Icons.ListPlus, {}),
        onClick: ()=>{
            navigate(`../${collectionType}/${model}/configurations/edit`);
        },
        position: 'header'
    };
};
ConfigureTheViewAction.type = 'configure-the-view';
ConfigureTheViewAction.position = 'header';
const EditTheModelAction = ({ model })=>{
    const navigate = reactRouterDom.useNavigate();
    const { formatMessage } = reactIntl.useIntl();
    return {
        label: formatMessage({
            id: 'content-manager.link-to-ctb',
            defaultMessage: 'Edit the model'
        }),
        icon: /*#__PURE__*/ jsxRuntime.jsx(Icons.Pencil, {}),
        onClick: ()=>{
            navigate(`/plugins/content-type-builder/content-types/${model}`);
        },
        position: 'header'
    };
};
EditTheModelAction.type = 'edit-the-model';
EditTheModelAction.position = 'header';
const DeleteAction$1 = ({ documentId, model, collectionType, document })=>{
    const navigate = reactRouterDom.useNavigate();
    const { formatMessage } = reactIntl.useIntl();
    const listViewPathMatch = reactRouterDom.useMatch(LIST_PATH);
    const canDelete = useDocumentRBAC('DeleteAction', (state)=>state.canDelete);
    const { delete: deleteAction, isLoading } = useDocumentActions();
    const { toggleNotification } = strapiAdmin.useNotification();
    const setSubmitting = strapiAdmin.useForm('DeleteAction', (state)=>state.setSubmitting);
    const isLocalized = document?.locale != null;
    return {
        disabled: !canDelete || !document,
        label: formatMessage({
            id: 'content-manager.actions.delete.label',
            defaultMessage: 'Delete entry{isLocalized, select, true { (all locales)} other {}}'
        }, {
            isLocalized
        }),
        icon: /*#__PURE__*/ jsxRuntime.jsx(Icons.Trash, {}),
        dialog: {
            type: 'dialog',
            title: formatMessage({
                id: 'app.components.ConfirmDialog.title',
                defaultMessage: 'Confirmation'
            }),
            content: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                direction: "column",
                gap: 2,
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx(Icons.WarningCircle, {
                        width: "24px",
                        height: "24px",
                        fill: "danger600"
                    }),
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                        tag: "p",
                        variant: "omega",
                        textAlign: "center",
                        children: formatMessage({
                            id: 'content-manager.actions.delete.dialog.body',
                            defaultMessage: 'Are you sure?'
                        })
                    })
                ]
            }),
            loading: isLoading,
            onConfirm: async ()=>{
                /**
         * If we have a match, we're in the list view
         * and therefore not in a form and shouldn't be
         * trying to set the submitting value.
         */ if (!listViewPathMatch) {
                    setSubmitting(true);
                }
                try {
                    if (!documentId && collectionType !== SINGLE_TYPES) {
                        console.error("You're trying to delete a document without an id, this is likely a bug with Strapi. Please open an issue.");
                        toggleNotification({
                            message: formatMessage({
                                id: 'content-manager.actions.delete.error',
                                defaultMessage: 'An error occurred while trying to delete the document.'
                            }),
                            type: 'danger'
                        });
                        return;
                    }
                    const res = await deleteAction({
                        documentId,
                        model,
                        collectionType,
                        params: {
                            locale: '*'
                        }
                    });
                    if (!('error' in res)) {
                        navigate({
                            pathname: `../${collectionType}/${model}`
                        }, {
                            replace: true
                        });
                    }
                } finally{
                    if (!listViewPathMatch) {
                        setSubmitting(false);
                    }
                }
            }
        },
        variant: 'danger',
        position: [
            'header',
            'table-row'
        ]
    };
};
DeleteAction$1.type = 'delete';
DeleteAction$1.position = [
    'header',
    'table-row'
];
const DEFAULT_HEADER_ACTIONS = [
    EditTheModelAction,
    ConfigureTheViewAction,
    DeleteAction$1
];

/* -------------------------------------------------------------------------------------------------
 * Panels
 * -----------------------------------------------------------------------------------------------*/ const Panels = ()=>{
    const isCloning = reactRouterDom.useMatch(CLONE_PATH) !== null;
    const [{ query: { status } }] = strapiAdmin.useQueryParams({
        status: 'draft'
    });
    const { model, id, document, meta, collectionType } = useDoc();
    const plugins = strapiAdmin.useStrapiApp('Panels', (state)=>state.plugins);
    const props = {
        activeTab: status,
        model,
        documentId: id,
        document: isCloning ? undefined : document,
        meta: isCloning ? undefined : meta,
        collectionType
    };
    return /*#__PURE__*/ jsxRuntime.jsx(designSystem.Flex, {
        direction: "column",
        alignItems: "stretch",
        gap: 2,
        children: /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.DescriptionComponentRenderer, {
            props: props,
            descriptions: plugins['content-manager'].apis.getEditViewSidePanels(),
            children: (panels)=>panels.map(({ content, id, ...description })=>/*#__PURE__*/ jsxRuntime.jsx(Panel, {
                        ...description,
                        children: content
                    }, id))
        })
    });
};
/* -------------------------------------------------------------------------------------------------
 * Default Action Panels (CE)
 * -----------------------------------------------------------------------------------------------*/ const ActionsPanel = ()=>{
    const { formatMessage } = reactIntl.useIntl();
    return {
        title: formatMessage({
            id: 'content-manager.containers.edit.panels.default.title',
            defaultMessage: 'Entry'
        }),
        content: /*#__PURE__*/ jsxRuntime.jsx(ActionsPanelContent, {})
    };
};
ActionsPanel.type = 'actions';
const ActionsPanelContent = ()=>{
    const isCloning = reactRouterDom.useMatch(CLONE_PATH) !== null;
    const [{ query: { status = 'draft' } }] = strapiAdmin.useQueryParams();
    const { model, id, document, meta, collectionType } = useDoc();
    const plugins = strapiAdmin.useStrapiApp('ActionsPanel', (state)=>state.plugins);
    const props = {
        activeTab: status,
        model,
        documentId: id,
        document: isCloning ? undefined : document,
        meta: isCloning ? undefined : meta,
        collectionType
    };
    return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
        direction: "column",
        gap: 2,
        width: "100%",
        children: [
            /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.DescriptionComponentRenderer, {
                props: props,
                descriptions: plugins['content-manager'].apis.getDocumentActions('panel'),
                children: (actions)=>/*#__PURE__*/ jsxRuntime.jsx(DocumentActions, {
                        actions: actions
                    })
            }),
            /*#__PURE__*/ jsxRuntime.jsx(InjectionZone, {
                area: "editView.right-links",
                slug: model
            })
        ]
    });
};
const Panel = /*#__PURE__*/ React__namespace.forwardRef(({ children, title }, ref)=>{
    return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
        ref: ref,
        tag: "aside",
        "aria-labelledby": "additional-information",
        background: "neutral0",
        borderColor: "neutral150",
        hasRadius: true,
        paddingBottom: 4,
        paddingLeft: 4,
        paddingRight: 4,
        paddingTop: 4,
        shadow: "tableShadow",
        gap: 3,
        direction: "column",
        justifyContent: "stretch",
        alignItems: "flex-start",
        children: [
            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                tag: "h2",
                variant: "sigma",
                textTransform: "uppercase",
                textColor: "neutral600",
                children: title
            }),
            children
        ]
    });
});

const ConfirmBulkActionDialog = ({ onToggleDialog, isOpen = false, dialogBody, endAction })=>{
    const { formatMessage } = reactIntl.useIntl();
    return /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Root, {
        open: isOpen,
        children: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Dialog.Content, {
            children: [
                /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Header, {
                    children: formatMessage({
                        id: 'app.components.ConfirmDialog.title',
                        defaultMessage: 'Confirmation'
                    })
                }),
                /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Body, {
                    children: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                        direction: "column",
                        alignItems: "stretch",
                        gap: 2,
                        children: [
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Flex, {
                                justifyContent: "center",
                                children: /*#__PURE__*/ jsxRuntime.jsx(Icons.WarningCircle, {
                                    width: "24px",
                                    height: "24px",
                                    fill: "danger600"
                                })
                            }),
                            dialogBody
                        ]
                    })
                }),
                /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Dialog.Footer, {
                    children: [
                        /*#__PURE__*/ jsxRuntime.jsx(designSystem.Dialog.Cancel, {
                            children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
                                fullWidth: true,
                                onClick: onToggleDialog,
                                variant: "tertiary",
                                children: formatMessage({
                                    id: 'app.components.Button.cancel',
                                    defaultMessage: 'Cancel'
                                })
                            })
                        }),
                        endAction
                    ]
                })
            ]
        })
    });
};
/* -------------------------------------------------------------------------------------------------
 * BoldChunk
 * -----------------------------------------------------------------------------------------------*/ const BoldChunk = (chunks)=>/*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
        fontWeight: "bold",
        children: chunks
    });
const ConfirmDialogPublishAll = ({ isOpen, onToggleDialog, isConfirmButtonLoading = false, onConfirm })=>{
    const { formatMessage } = reactIntl.useIntl();
    const selectedEntries = strapiAdmin.useTable('ConfirmDialogPublishAll', (state)=>state.selectedRows);
    const { toggleNotification } = strapiAdmin.useNotification();
    const { _unstableFormatAPIError: formatAPIError } = strapiAdmin.useAPIErrorHandler(getTranslation);
    const { model, schema } = useDoc();
    const [{ query }] = strapiAdmin.useQueryParams();
    // TODO skipping this for now as there is a bug with the draft relation count that will be worked on separately
    // see RFC "Count draft relations" in Notion
    const enableDraftRelationsCount = false;
    const { data: countDraftRelations = 0, isLoading, error } = useGetManyDraftRelationCountQuery({
        model,
        documentIds: selectedEntries.map((entry)=>entry.documentId),
        locale: query?.plugins?.i18n?.locale
    }, {
        skip: !enableDraftRelationsCount
    });
    React__namespace.useEffect(()=>{
        if (error) {
            toggleNotification({
                type: 'danger',
                message: formatAPIError(error)
            });
        }
    }, [
        error,
        formatAPIError,
        toggleNotification
    ]);
    if (error) {
        return null;
    }
    return /*#__PURE__*/ jsxRuntime.jsx(ConfirmBulkActionDialog, {
        isOpen: isOpen && !isLoading,
        onToggleDialog: onToggleDialog,
        dialogBody: /*#__PURE__*/ jsxRuntime.jsxs(jsxRuntime.Fragment, {
            children: [
                /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Typography, {
                    id: "confirm-description",
                    textAlign: "center",
                    children: [
                        countDraftRelations > 0 && formatMessage({
                            id: getTranslation(`popUpwarning.warning.bulk-has-draft-relations.message`),
                            defaultMessage: '<b>{count} {count, plural, one { relation } other { relations } } out of {entities} { entities, plural, one { entry } other { entries } } {count, plural, one { is } other { are } }</b> not published yet and might lead to unexpected behavior. '
                        }, {
                            b: BoldChunk,
                            count: countDraftRelations,
                            entities: selectedEntries.length
                        }),
                        formatMessage({
                            id: getTranslation('popUpWarning.bodyMessage.contentType.publish.all'),
                            defaultMessage: 'Are you sure you want to publish these entries?'
                        })
                    ]
                }),
                schema?.pluginOptions && 'i18n' in schema.pluginOptions && schema?.pluginOptions.i18n && /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                    textColor: "danger500",
                    textAlign: "center",
                    children: formatMessage({
                        id: getTranslation('Settings.list.actions.publishAdditionalInfos'),
                        defaultMessage: 'This will publish the active locale versions <em>(from Internationalization)</em>'
                    }, {
                        em: Emphasis
                    })
                })
            ]
        }),
        endAction: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
            onClick: onConfirm,
            variant: "secondary",
            startIcon: /*#__PURE__*/ jsxRuntime.jsx(Icons.Check, {}),
            loading: isConfirmButtonLoading,
            children: formatMessage({
                id: 'app.utils.publish',
                defaultMessage: 'Publish'
            })
        })
    });
};

const TypographyMaxWidth = styledComponents.styled(designSystem.Typography)`
  max-width: 300px;
`;
const TableComponent = styledComponents.styled(designSystem.RawTable)`
  width: 100%;
  table-layout: fixed;
  td:first-child {
    border-right: 1px solid ${({ theme })=>theme.colors.neutral150};
  }
  td:first-of-type {
    padding: ${({ theme })=>theme.spaces[4]};
  }
`;
/* -------------------------------------------------------------------------------------------------
 * EntryValidationText
 * -----------------------------------------------------------------------------------------------*/ const formatErrorMessages = (errors, parentKey, formatMessage)=>{
    const messages = [];
    Object.entries(errors).forEach(([key, value])=>{
        const currentKey = parentKey ? `${parentKey}.${key}` : key;
        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
            if ('id' in value && 'defaultMessage' in value) {
                messages.push(formatMessage({
                    id: `${value.id}.withField`,
                    defaultMessage: value.defaultMessage
                }, {
                    field: currentKey
                }));
            } else {
                messages.push(...formatErrorMessages(// @ts-expect-error TODO: check why value is not compatible with FormErrors
                value, currentKey, formatMessage));
            }
        } else {
            messages.push(formatMessage({
                id: `${value}.withField`,
                defaultMessage: value
            }, {
                field: currentKey
            }));
        }
    });
    return messages;
};
const EntryValidationText = ({ validationErrors, status })=>{
    const { formatMessage } = reactIntl.useIntl();
    if (validationErrors) {
        const validationErrorsMessages = formatErrorMessages(validationErrors, '', formatMessage).join(' ');
        return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
            gap: 2,
            children: [
                /*#__PURE__*/ jsxRuntime.jsx(Icons.CrossCircle, {
                    fill: "danger600"
                }),
                /*#__PURE__*/ jsxRuntime.jsx(designSystem.Tooltip, {
                    description: validationErrorsMessages,
                    children: /*#__PURE__*/ jsxRuntime.jsx(TypographyMaxWidth, {
                        textColor: "danger600",
                        variant: "omega",
                        fontWeight: "semiBold",
                        ellipsis: true,
                        children: validationErrorsMessages
                    })
                })
            ]
        });
    }
    if (status === 'published') {
        return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
            gap: 2,
            children: [
                /*#__PURE__*/ jsxRuntime.jsx(Icons.CheckCircle, {
                    fill: "success600"
                }),
                /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                    textColor: "success600",
                    fontWeight: "bold",
                    children: formatMessage({
                        id: 'content-manager.bulk-publish.already-published',
                        defaultMessage: 'Already Published'
                    })
                })
            ]
        });
    }
    if (status === 'modified') {
        return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
            gap: 2,
            children: [
                /*#__PURE__*/ jsxRuntime.jsx(Icons.ArrowsCounterClockwise, {
                    fill: "alternative600"
                }),
                /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                    children: formatMessage({
                        id: 'content-manager.bulk-publish.modified',
                        defaultMessage: 'Ready to publish changes'
                    })
                })
            ]
        });
    }
    return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
        gap: 2,
        children: [
            /*#__PURE__*/ jsxRuntime.jsx(Icons.CheckCircle, {
                fill: "success600"
            }),
            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                children: formatMessage({
                    id: 'app.utils.ready-to-publish',
                    defaultMessage: 'Ready to publish'
                })
            })
        ]
    });
};
const TABLE_HEADERS = [
    {
        name: 'id',
        label: 'id'
    },
    {
        name: 'name',
        label: 'name'
    },
    {
        name: 'status',
        label: 'status'
    },
    {
        name: 'publicationStatus',
        label: 'Publication status'
    }
];
const SelectedEntriesTableContent = ({ isPublishing, rowsToDisplay = [], entriesToPublish = [], validationErrors = {} })=>{
    const { pathname } = reactRouterDom.useLocation();
    const { formatMessage } = reactIntl.useIntl();
    const { list: { settings: { mainField } } } = useDocLayout();
    const shouldDisplayMainField = mainField != null && mainField !== 'id';
    return /*#__PURE__*/ jsxRuntime.jsxs(strapiAdmin.Table.Content, {
        children: [
            /*#__PURE__*/ jsxRuntime.jsxs(strapiAdmin.Table.Head, {
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.HeaderCheckboxCell, {}),
                    TABLE_HEADERS.filter((head)=>head.name !== 'name' || shouldDisplayMainField).map((head)=>/*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.HeaderCell, {
                            ...head
                        }, head.name))
                ]
            }),
            /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.Loading, {}),
            /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.Body, {
                children: rowsToDisplay.map((row)=>/*#__PURE__*/ jsxRuntime.jsxs(strapiAdmin.Table.Row, {
                        children: [
                            /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.CheckboxCell, {
                                id: row.id
                            }),
                            /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.Cell, {
                                children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                                    children: row.id
                                })
                            }),
                            shouldDisplayMainField && /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.Cell, {
                                children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                                    children: row[mainField]
                                })
                            }),
                            /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.Cell, {
                                children: /*#__PURE__*/ jsxRuntime.jsx(DocumentStatus, {
                                    status: row.status,
                                    maxWidth: 'min-content'
                                })
                            }),
                            /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.Cell, {
                                children: isPublishing && entriesToPublish.includes(row.documentId) ? /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                                    gap: 2,
                                    children: [
                                        /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                                            children: formatMessage({
                                                id: 'content-manager.success.record.publishing',
                                                defaultMessage: 'Publishing...'
                                            })
                                        }),
                                        /*#__PURE__*/ jsxRuntime.jsx(designSystem.Loader, {
                                            small: true
                                        })
                                    ]
                                }) : /*#__PURE__*/ jsxRuntime.jsx(EntryValidationText, {
                                    validationErrors: validationErrors[row.documentId],
                                    status: row.status
                                })
                            }),
                            /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.Cell, {
                                children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Flex, {
                                    children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.IconButton, {
                                        tag: reactRouterDom.Link,
                                        to: {
                                            pathname: `${pathname}/${row.documentId}`,
                                            search: row.locale && `?plugins[i18n][locale]=${row.locale}`
                                        },
                                        state: {
                                            from: pathname
                                        },
                                        label: formatMessage({
                                            id: 'content-manager.bulk-publish.edit',
                                            defaultMessage: 'Edit'
                                        }),
                                        target: "_blank",
                                        marginLeft: "auto",
                                        variant: "ghost",
                                        children: /*#__PURE__*/ jsxRuntime.jsx(Icons.Pencil, {
                                            width: '1.6rem',
                                            height: '1.6rem'
                                        })
                                    })
                                })
                            })
                        ]
                    }, row.id))
            })
        ]
    });
};
const PublicationStatusSummary = ({ count, icon, message })=>{
    return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
        justifyContent: "space-between",
        flex: 1,
        gap: 3,
        children: [
            /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                gap: 2,
                children: [
                    icon,
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                        children: message
                    })
                ]
            }),
            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                fontWeight: "bold",
                children: count
            })
        ]
    });
};
const PublicationStatusGrid = ({ entriesReadyToPublishCount, entriesPublishedCount, entriesModifiedCount, entriesWithErrorsCount })=>{
    const { formatMessage } = reactIntl.useIntl();
    return /*#__PURE__*/ jsxRuntime.jsx(designSystem.Box, {
        hasRadius: true,
        borderColor: "neutral150",
        children: /*#__PURE__*/ jsxRuntime.jsx(TableComponent, {
            colCount: 2,
            rowCount: 2,
            children: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Tbody, {
                children: [
                    /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Tr, {
                        children: [
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Td, {
                                children: /*#__PURE__*/ jsxRuntime.jsx(PublicationStatusSummary, {
                                    count: entriesReadyToPublishCount,
                                    icon: /*#__PURE__*/ jsxRuntime.jsx(Icons.CheckCircle, {
                                        fill: "success600"
                                    }),
                                    message: formatMessage({
                                        id: 'app.utils.ready-to-publish',
                                        defaultMessage: 'Ready to publish'
                                    })
                                })
                            }),
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Td, {
                                children: /*#__PURE__*/ jsxRuntime.jsx(PublicationStatusSummary, {
                                    count: entriesPublishedCount,
                                    icon: /*#__PURE__*/ jsxRuntime.jsx(Icons.CheckCircle, {
                                        fill: "success600"
                                    }),
                                    message: formatMessage({
                                        id: 'app.utils.already-published',
                                        defaultMessage: 'Already published'
                                    })
                                })
                            })
                        ]
                    }),
                    /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Tr, {
                        children: [
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Td, {
                                children: /*#__PURE__*/ jsxRuntime.jsx(PublicationStatusSummary, {
                                    count: entriesModifiedCount,
                                    icon: /*#__PURE__*/ jsxRuntime.jsx(Icons.ArrowsCounterClockwise, {
                                        fill: "alternative600"
                                    }),
                                    message: formatMessage({
                                        id: 'content-manager.bulk-publish.modified',
                                        defaultMessage: 'Ready to publish changes'
                                    })
                                })
                            }),
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Td, {
                                children: /*#__PURE__*/ jsxRuntime.jsx(PublicationStatusSummary, {
                                    count: entriesWithErrorsCount,
                                    icon: /*#__PURE__*/ jsxRuntime.jsx(Icons.CrossCircle, {
                                        fill: "danger600"
                                    }),
                                    message: formatMessage({
                                        id: 'content-manager.bulk-publish.waiting-for-action',
                                        defaultMessage: 'Waiting for action'
                                    })
                                })
                            })
                        ]
                    })
                ]
            })
        })
    });
};
const SelectedEntriesModalContent = ({ listViewSelectedEntries, toggleModal, setListViewSelectedDocuments, model })=>{
    const { formatMessage } = reactIntl.useIntl();
    const { schema, components } = useContentTypeSchema(model);
    const documentIds = listViewSelectedEntries.map(({ documentId })=>documentId);
    // We want to keep the selected entries order same as the list view
    const [{ query }] = strapiAdmin.useQueryParams();
    const params = React__namespace.useMemo(()=>buildValidParams(query), [
        query
    ]);
    // Fetch the documents based on the selected entries and update the modal table
    const { data, isLoading, isFetching, refetch } = useGetAllDocumentsQuery({
        model,
        params: {
            page: '1',
            pageSize: documentIds.length.toString(),
            sort: query.sort,
            filters: {
                documentId: {
                    $in: documentIds
                }
            },
            locale: query.plugins?.i18n?.locale
        }
    }, {
        selectFromResult: ({ data, ...restRes })=>({
                data: data?.results ?? [],
                ...restRes
            })
    });
    // Validate the entries based on the schema to show errors if any
    const { rows, validationErrors } = React__namespace.useMemo(()=>{
        if (data.length > 0 && schema) {
            const validate = createYupSchema(schema.attributes, components, // Since this is the "Publish" action, the validation
            // schema must enforce the rules for published entities
            {
                status: 'published'
            });
            const validationErrors = {};
            const rows = data.map((entry)=>{
                try {
                    validate.validateSync(entry, {
                        abortEarly: false
                    });
                    return entry;
                } catch (e) {
                    if (e instanceof yup.ValidationError) {
                        validationErrors[entry.documentId] = strapiAdmin.getYupValidationErrors(e);
                    }
                    return entry;
                }
            });
            return {
                rows,
                validationErrors
            };
        }
        return {
            rows: [],
            validationErrors: {}
        };
    }, [
        components,
        data,
        schema
    ]);
    const [isDialogOpen, setIsDialogOpen] = React__namespace.useState(false);
    const { publishMany: bulkPublishAction, isLoading: isPublishing } = useDocumentActions();
    const [, { isLoading: isSubmittingForm }] = usePublishManyDocumentsMutation();
    const selectedRows = strapiAdmin.useTable('publishAction', (state)=>state.selectedRows);
    // Filter selected entries from the updated modal table rows
    const selectedEntries = rows.filter((entry)=>selectedRows.some((selectedEntry)=>selectedEntry.documentId === entry.documentId));
    const entriesToPublish = selectedEntries.filter((entry)=>!validationErrors[entry.documentId]).map((entry)=>entry.documentId);
    const selectedEntriesWithErrorsCount = selectedEntries.filter(({ documentId })=>validationErrors[documentId]).length;
    const selectedEntriesPublishedCount = selectedEntries.filter(({ status })=>status === 'published').length;
    const selectedEntriesModifiedCount = selectedEntries.filter(({ status, documentId })=>status === 'modified' && !validationErrors[documentId]).length;
    const selectedEntriesWithNoErrorsCount = selectedEntries.length - selectedEntriesWithErrorsCount - selectedEntriesPublishedCount;
    const toggleDialog = ()=>setIsDialogOpen((prev)=>!prev);
    const handleConfirmBulkPublish = async ()=>{
        toggleDialog();
        const res = await bulkPublishAction({
            model: model,
            documentIds: entriesToPublish,
            params
        });
        if (!('error' in res)) {
            const unpublishedEntries = rows.filter((row)=>{
                return !entriesToPublish.includes(row.documentId);
            });
            // Keep selection of the entries in list view that were not published
            setListViewSelectedDocuments(unpublishedEntries);
        }
    };
    return /*#__PURE__*/ jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [
            /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Modal.Body, {
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx(PublicationStatusGrid, {
                        entriesReadyToPublishCount: selectedEntriesWithNoErrorsCount - selectedEntriesModifiedCount,
                        entriesPublishedCount: selectedEntriesPublishedCount,
                        entriesModifiedCount: selectedEntriesModifiedCount,
                        entriesWithErrorsCount: selectedEntriesWithErrorsCount
                    }),
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Box, {
                        marginTop: 7,
                        children: /*#__PURE__*/ jsxRuntime.jsx(SelectedEntriesTableContent, {
                            isPublishing: isSubmittingForm,
                            rowsToDisplay: rows,
                            entriesToPublish: entriesToPublish,
                            validationErrors: validationErrors
                        })
                    })
                ]
            }),
            /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Modal.Footer, {
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
                        onClick: toggleModal,
                        variant: "tertiary",
                        children: formatMessage({
                            id: 'app.components.Button.cancel',
                            defaultMessage: 'Cancel'
                        })
                    }),
                    /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                        gap: 2,
                        children: [
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
                                onClick: refetch,
                                variant: "tertiary",
                                loading: isFetching,
                                children: formatMessage({
                                    id: 'app.utils.refresh',
                                    defaultMessage: 'Refresh'
                                })
                            }),
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
                                onClick: toggleDialog,
                                disabled: selectedEntries.length === 0 || selectedEntries.length === selectedEntriesWithErrorsCount || selectedEntriesPublishedCount === selectedEntries.length || isLoading,
                                loading: isPublishing || isSubmittingForm,
                                children: formatMessage({
                                    id: 'app.utils.publish',
                                    defaultMessage: 'Publish'
                                })
                            })
                        ]
                    })
                ]
            }),
            /*#__PURE__*/ jsxRuntime.jsx(ConfirmDialogPublishAll, {
                isOpen: isDialogOpen,
                onToggleDialog: toggleDialog,
                isConfirmButtonLoading: isPublishing || isSubmittingForm,
                onConfirm: handleConfirmBulkPublish
            })
        ]
    });
};
/* -------------------------------------------------------------------------------------------------
 * PublishAction
 * -----------------------------------------------------------------------------------------------*/ const PublishAction = ({ documents, model })=>{
    const { formatMessage } = reactIntl.useIntl();
    // Publish button visibility
    const hasPublishPermission = useDocumentRBAC('unpublishAction', (state)=>state.canPublish);
    const showPublishButton = hasPublishPermission && documents.some(({ status })=>status !== 'published');
    const setListViewSelectedDocuments = strapiAdmin.useTable('publishAction', (state)=>state.selectRow);
    const refetchList = ()=>{
        contentManagerApi.util.invalidateTags([
            {
                type: 'Document',
                id: `${model}_LIST`
            }
        ]);
    };
    if (!showPublishButton) return null;
    return {
        actionType: 'publish',
        variant: 'tertiary',
        label: formatMessage({
            id: 'app.utils.publish',
            defaultMessage: 'Publish'
        }),
        dialog: {
            type: 'modal',
            title: formatMessage({
                id: getTranslation('containers.ListPage.selectedEntriesModal.title'),
                defaultMessage: 'Publish entries'
            }),
            content: ({ onClose })=>{
                return /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Table.Root, {
                    rows: documents,
                    defaultSelectedRows: documents,
                    headers: TABLE_HEADERS,
                    children: /*#__PURE__*/ jsxRuntime.jsx(SelectedEntriesModalContent, {
                        listViewSelectedEntries: documents,
                        toggleModal: ()=>{
                            onClose();
                            refetchList();
                        },
                        setListViewSelectedDocuments: setListViewSelectedDocuments,
                        model: model
                    })
                });
            },
            onClose: ()=>{
                refetchList();
            }
        }
    };
};

/* -------------------------------------------------------------------------------------------------
 * BulkActionsRenderer
 * -----------------------------------------------------------------------------------------------*/ const BulkActionsRenderer = ()=>{
    const plugins = strapiAdmin.useStrapiApp('BulkActionsRenderer', (state)=>state.plugins);
    const { model, collectionType } = useDoc();
    const { selectedRows } = strapiAdmin.useTable('BulkActionsRenderer', (state)=>state);
    return /*#__PURE__*/ jsxRuntime.jsx(designSystem.Flex, {
        gap: 2,
        children: /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.DescriptionComponentRenderer, {
            props: {
                model,
                collectionType,
                documents: selectedRows
            },
            descriptions: plugins['content-manager'].apis.getBulkActions(),
            children: (actions)=>actions.map((action)=>/*#__PURE__*/ jsxRuntime.jsx(DocumentActionButton, {
                        ...action
                    }, action.id))
        })
    });
};
/* -------------------------------------------------------------------------------------------------
 * DefaultBulkActions
 * -----------------------------------------------------------------------------------------------*/ const DeleteAction = ({ documents, model })=>{
    const { formatMessage } = reactIntl.useIntl();
    const { schema: contentType } = useDoc();
    const selectRow = strapiAdmin.useTable('DeleteAction', (state)=>state.selectRow);
    const hasI18nEnabled = Boolean(contentType?.pluginOptions?.i18n);
    const [{ query }] = strapiAdmin.useQueryParams();
    const params = React__namespace.useMemo(()=>buildValidParams(query), [
        query
    ]);
    const hasDeletePermission = useDocumentRBAC('deleteAction', (state)=>state.canDelete);
    const { deleteMany: bulkDeleteAction, isLoading } = useDocumentActions();
    const documentIds = documents.map(({ documentId })=>documentId);
    const handleConfirmBulkDelete = async ()=>{
        const res = await bulkDeleteAction({
            documentIds,
            model,
            params
        });
        if (!('error' in res)) {
            selectRow([]);
        }
    };
    if (!hasDeletePermission) return null;
    return {
        variant: 'danger-light',
        label: formatMessage({
            id: 'global.delete',
            defaultMessage: 'Delete'
        }),
        dialog: {
            type: 'dialog',
            title: formatMessage({
                id: 'app.components.ConfirmDialog.title',
                defaultMessage: 'Confirmation'
            }),
            loading: isLoading,
            content: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                direction: "column",
                alignItems: "stretch",
                gap: 2,
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Flex, {
                        justifyContent: "center",
                        children: /*#__PURE__*/ jsxRuntime.jsx(Icons.WarningCircle, {
                            width: "24px",
                            height: "24px",
                            fill: "danger600"
                        })
                    }),
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                        id: "confirm-description",
                        textAlign: "center",
                        children: formatMessage({
                            id: 'popUpWarning.bodyMessage.contentType.delete.all',
                            defaultMessage: 'Are you sure you want to delete these entries?'
                        })
                    }),
                    hasI18nEnabled && /*#__PURE__*/ jsxRuntime.jsx(designSystem.Box, {
                        textAlign: "center",
                        padding: 3,
                        children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                            textColor: "danger500",
                            children: formatMessage({
                                id: getTranslation('Settings.list.actions.deleteAdditionalInfos'),
                                defaultMessage: 'This will delete the active locale versions <em>(from Internationalization)</em>'
                            }, {
                                em: Emphasis
                            })
                        })
                    })
                ]
            }),
            onConfirm: handleConfirmBulkDelete
        }
    };
};
DeleteAction.type = 'delete';
const UnpublishAction = ({ documents, model })=>{
    const { formatMessage } = reactIntl.useIntl();
    const { schema } = useDoc();
    const selectRow = strapiAdmin.useTable('UnpublishAction', (state)=>state.selectRow);
    const hasPublishPermission = useDocumentRBAC('unpublishAction', (state)=>state.canPublish);
    const hasI18nEnabled = Boolean(schema?.pluginOptions?.i18n);
    const hasDraftAndPublishEnabled = Boolean(schema?.options?.draftAndPublish);
    const { unpublishMany: bulkUnpublishAction, isLoading } = useDocumentActions();
    const documentIds = documents.map(({ documentId })=>documentId);
    const [{ query }] = strapiAdmin.useQueryParams();
    const params = React__namespace.useMemo(()=>buildValidParams(query), [
        query
    ]);
    const handleConfirmBulkUnpublish = async ()=>{
        const data = await bulkUnpublishAction({
            documentIds,
            model,
            params
        });
        if (!('error' in data)) {
            selectRow([]);
        }
    };
    const showUnpublishButton = hasDraftAndPublishEnabled && hasPublishPermission && documents.some((entry)=>entry.status === 'published' || entry.status === 'modified');
    if (!showUnpublishButton) return null;
    return {
        variant: 'tertiary',
        label: formatMessage({
            id: 'app.utils.unpublish',
            defaultMessage: 'Unpublish'
        }),
        dialog: {
            type: 'dialog',
            title: formatMessage({
                id: 'app.components.ConfirmDialog.title',
                defaultMessage: 'Confirmation'
            }),
            loading: isLoading,
            content: /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                direction: "column",
                alignItems: "stretch",
                gap: 2,
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Flex, {
                        justifyContent: "center",
                        children: /*#__PURE__*/ jsxRuntime.jsx(Icons.WarningCircle, {
                            width: "24px",
                            height: "24px",
                            fill: "danger600"
                        })
                    }),
                    /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                        id: "confirm-description",
                        textAlign: "center",
                        children: formatMessage({
                            id: 'popUpWarning.bodyMessage.contentType.unpublish.all',
                            defaultMessage: 'Are you sure you want to unpublish these entries?'
                        })
                    }),
                    hasI18nEnabled && /*#__PURE__*/ jsxRuntime.jsx(designSystem.Box, {
                        textAlign: "center",
                        padding: 3,
                        children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                            textColor: "danger500",
                            children: formatMessage({
                                id: getTranslation('Settings.list.actions.unpublishAdditionalInfos'),
                                defaultMessage: 'This will unpublish the active locale versions <em>(from Internationalization)</em>'
                            }, {
                                em: Emphasis
                            })
                        })
                    })
                ]
            }),
            confirmButton: formatMessage({
                id: 'app.utils.unpublish',
                defaultMessage: 'Unpublish'
            }),
            onConfirm: handleConfirmBulkUnpublish
        }
    };
};
UnpublishAction.type = 'unpublish';
const Emphasis = (chunks)=>/*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
        fontWeight: "semiBold",
        textColor: "danger500",
        children: chunks
    });
const DEFAULT_BULK_ACTIONS = [
    PublishAction,
    UnpublishAction,
    DeleteAction
];

const AutoCloneFailureModalBody = ({ prohibitedFields })=>{
    const { formatMessage } = reactIntl.useIntl();
    const getDefaultErrorMessage = (reason)=>{
        switch(reason){
            case 'relation':
                return 'Duplicating the relation could remove it from the original entry.';
            case 'unique':
                return 'Identical values in a unique field are not allowed';
            default:
                return reason;
        }
    };
    return /*#__PURE__*/ jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [
            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                variant: "beta",
                children: formatMessage({
                    id: getTranslation('containers.list.autoCloneModal.title'),
                    defaultMessage: "This entry can't be duplicated directly."
                })
            }),
            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Box, {
                marginTop: 2,
                children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                    textColor: "neutral600",
                    children: formatMessage({
                        id: getTranslation('containers.list.autoCloneModal.description'),
                        defaultMessage: "A new entry will be created with the same content, but you'll have to change the following fields to save it."
                    })
                })
            }),
            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Flex, {
                marginTop: 6,
                gap: 2,
                direction: "column",
                alignItems: "stretch",
                children: prohibitedFields.map(([fieldPath, reason])=>/*#__PURE__*/ jsxRuntime.jsxs(designSystem.Flex, {
                        direction: "column",
                        gap: 2,
                        alignItems: "flex-start",
                        borderColor: "neutral200",
                        hasRadius: true,
                        padding: 6,
                        children: [
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Flex, {
                                direction: "row",
                                tag: "ol",
                                children: fieldPath.map((pathSegment, index)=>/*#__PURE__*/ jsxRuntime.jsxs(designSystem.Typography, {
                                        fontWeight: "semiBold",
                                        tag: "li",
                                        children: [
                                            pathSegment,
                                            index !== fieldPath.length - 1 && /*#__PURE__*/ jsxRuntime.jsx(Icons.ChevronRight, {
                                                fill: "neutral500",
                                                height: "0.8rem",
                                                width: "0.8rem",
                                                style: {
                                                    margin: '0 0.8rem'
                                                }
                                            })
                                        ]
                                    }, index))
                            }),
                            /*#__PURE__*/ jsxRuntime.jsx(designSystem.Typography, {
                                tag: "p",
                                textColor: "neutral600",
                                children: formatMessage({
                                    id: getTranslation(`containers.list.autoCloneModal.error.${reason}`),
                                    defaultMessage: getDefaultErrorMessage(reason)
                                })
                            })
                        ]
                    }, fieldPath.join()))
            })
        ]
    });
};

const TableActions = ({ document })=>{
    const { formatMessage } = reactIntl.useIntl();
    const { model, collectionType } = useDoc();
    const plugins = strapiAdmin.useStrapiApp('TableActions', (state)=>state.plugins);
    const props = {
        activeTab: null,
        model,
        documentId: document.documentId,
        collectionType,
        document
    };
    return /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.DescriptionComponentRenderer, {
        props: props,
        descriptions: plugins['content-manager'].apis.getDocumentActions('table-row')// We explicitly remove the PublishAction from description so we never render it and we don't make unnecessary requests.
        .filter((action)=>action.name !== 'PublishAction'),
        children: (actions)=>{
            const tableRowActions = actions.filter((action)=>{
                const positions = Array.isArray(action.position) ? action.position : [
                    action.position
                ];
                return positions.includes('table-row');
            });
            return /*#__PURE__*/ jsxRuntime.jsx(DocumentActionsMenu, {
                actions: tableRowActions,
                label: formatMessage({
                    id: 'content-manager.containers.list.table.row-actions',
                    defaultMessage: 'Row actions'
                }),
                variant: "ghost"
            });
        }
    });
};
/* -------------------------------------------------------------------------------------------------
 * TableActionComponents
 * -----------------------------------------------------------------------------------------------*/ const EditAction = ({ documentId })=>{
    const navigate = reactRouterDom.useNavigate();
    const { formatMessage } = reactIntl.useIntl();
    const { canRead } = useDocumentRBAC('EditAction', ({ canRead })=>({
            canRead
        }));
    const { toggleNotification } = strapiAdmin.useNotification();
    const [{ query }] = strapiAdmin.useQueryParams();
    return {
        disabled: !canRead,
        icon: /*#__PURE__*/ jsxRuntime.jsx(StyledPencil, {}),
        label: formatMessage({
            id: 'content-manager.actions.edit.label',
            defaultMessage: 'Edit'
        }),
        position: 'table-row',
        onClick: async ()=>{
            if (!documentId) {
                console.error("You're trying to edit a document without an id, this is likely a bug with Strapi. Please open an issue.");
                toggleNotification({
                    message: formatMessage({
                        id: 'content-manager.actions.edit.error',
                        defaultMessage: 'An error occurred while trying to edit the document.'
                    }),
                    type: 'danger'
                });
                return;
            }
            navigate({
                pathname: documentId,
                search: qs.stringify({
                    plugins: query.plugins
                })
            });
        }
    };
};
EditAction.type = 'edit';
EditAction.position = 'table-row';
/**
 * Because the icon system is completely broken, we have to do
 * this to remove the fill from the cog.
 */ const StyledPencil = styledComponents.styled(Icons.Pencil)`
  path {
    fill: currentColor;
  }
`;
const CloneAction = ({ model, documentId })=>{
    const navigate = reactRouterDom.useNavigate();
    const { formatMessage } = reactIntl.useIntl();
    const { canCreate } = useDocumentRBAC('CloneAction', ({ canCreate })=>({
            canCreate
        }));
    const { toggleNotification } = strapiAdmin.useNotification();
    const { autoClone } = useDocumentActions();
    const [prohibitedFields, setProhibitedFields] = React__namespace.useState([]);
    return {
        disabled: !canCreate,
        icon: /*#__PURE__*/ jsxRuntime.jsx(StyledDuplicate, {}),
        label: formatMessage({
            id: 'content-manager.actions.clone.label',
            defaultMessage: 'Duplicate'
        }),
        position: 'table-row',
        onClick: async ()=>{
            if (!documentId) {
                console.error("You're trying to clone a document in the table without an id, this is likely a bug with Strapi. Please open an issue.");
                toggleNotification({
                    message: formatMessage({
                        id: 'content-manager.actions.clone.error',
                        defaultMessage: 'An error occurred while trying to clone the document.'
                    }),
                    type: 'danger'
                });
                return;
            }
            const res = await autoClone({
                model,
                sourceId: documentId
            });
            if ('data' in res) {
                navigate(res.data.documentId);
                /**
         * We return true because we don't need to show a modal anymore.
         */ return true;
            }
            if (isBaseQueryError(res.error) && res.error.details && typeof res.error.details === 'object' && 'prohibitedFields' in res.error.details && Array.isArray(res.error.details.prohibitedFields)) {
                const prohibitedFields = res.error.details.prohibitedFields;
                setProhibitedFields(prohibitedFields);
            }
        },
        dialog: {
            type: 'modal',
            title: formatMessage({
                id: 'content-manager.containers.list.autoCloneModal.header',
                defaultMessage: 'Duplicate'
            }),
            content: /*#__PURE__*/ jsxRuntime.jsx(AutoCloneFailureModalBody, {
                prohibitedFields: prohibitedFields
            }),
            footer: ({ onClose })=>{
                return /*#__PURE__*/ jsxRuntime.jsxs(designSystem.Modal.Footer, {
                    children: [
                        /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
                            onClick: onClose,
                            variant: "tertiary",
                            children: formatMessage({
                                id: 'cancel',
                                defaultMessage: 'Cancel'
                            })
                        }),
                        /*#__PURE__*/ jsxRuntime.jsx(designSystem.LinkButton, {
                            tag: reactRouterDom.NavLink,
                            to: {
                                pathname: `clone/${documentId}`
                            },
                            children: formatMessage({
                                id: 'content-manager.containers.list.autoCloneModal.create',
                                defaultMessage: 'Create'
                            })
                        })
                    ]
                });
            }
        }
    };
};
CloneAction.type = 'clone';
CloneAction.position = 'table-row';
/**
 * Because the icon system is completely broken, we have to do
 * this to remove the fill from the cog.
 */ const StyledDuplicate = styledComponents.styled(Icons.Duplicate)`
  path {
    fill: currentColor;
  }
`;
const DEFAULT_TABLE_ROW_ACTIONS = [
    EditAction,
    CloneAction
];

/* -------------------------------------------------------------------------------------------------
 * ContentManager plugin
 * -----------------------------------------------------------------------------------------------*/ class ContentManagerPlugin {
    addEditViewSidePanel(panels) {
        if (Array.isArray(panels)) {
            this.editViewSidePanels = [
                ...this.editViewSidePanels,
                ...panels
            ];
        } else if (typeof panels === 'function') {
            this.editViewSidePanels = panels(this.editViewSidePanels);
        } else {
            throw new Error(`Expected the \`panels\` passed to \`addEditViewSidePanel\` to be an array or a function, but received ${getPrintableType(panels)}`);
        }
    }
    addDocumentAction(actions) {
        if (Array.isArray(actions)) {
            this.documentActions = [
                ...this.documentActions,
                ...actions
            ];
        } else if (typeof actions === 'function') {
            this.documentActions = actions(this.documentActions);
        } else {
            throw new Error(`Expected the \`actions\` passed to \`addDocumentAction\` to be an array or a function, but received ${getPrintableType(actions)}`);
        }
    }
    addDocumentHeaderAction(actions) {
        if (Array.isArray(actions)) {
            this.headerActions = [
                ...this.headerActions,
                ...actions
            ];
        } else if (typeof actions === 'function') {
            this.headerActions = actions(this.headerActions);
        } else {
            throw new Error(`Expected the \`actions\` passed to \`addDocumentHeaderAction\` to be an array or a function, but received ${getPrintableType(actions)}`);
        }
    }
    addBulkAction(actions) {
        if (Array.isArray(actions)) {
            this.bulkActions = [
                ...this.bulkActions,
                ...actions
            ];
        } else if (typeof actions === 'function') {
            this.bulkActions = actions(this.bulkActions);
        } else {
            throw new Error(`Expected the \`actions\` passed to \`addBulkAction\` to be an array or a function, but received ${getPrintableType(actions)}`);
        }
    }
    get config() {
        return {
            id: PLUGIN_ID,
            name: 'Content Manager',
            injectionZones: INJECTION_ZONES,
            apis: {
                addBulkAction: this.addBulkAction.bind(this),
                addDocumentAction: this.addDocumentAction.bind(this),
                addDocumentHeaderAction: this.addDocumentHeaderAction.bind(this),
                addEditViewSidePanel: this.addEditViewSidePanel.bind(this),
                getBulkActions: ()=>this.bulkActions,
                getDocumentActions: (position)=>{
                    /**
           * When possible, pre-filter the actions by the components static position property.
           * This avoids rendering the actions in multiple places where they weren't displayed,
           * which wasn't visible but created issues with useEffect for instance.
           * The response should still be filtered by the position, as the static property is new
           * and not mandatory to avoid a breaking change.
           */ if (position) {
                        return this.documentActions.filter((action)=>{
                            return action.position == undefined || [
                                action.position
                            ].flat().includes(position);
                        });
                    }
                    return this.documentActions;
                },
                getEditViewSidePanels: ()=>this.editViewSidePanels,
                getHeaderActions: ()=>this.headerActions
            }
        };
    }
    constructor(){
        /**
   * The following properties are the stored ones provided by any plugins registering with
   * the content-manager. The function calls however, need to be called at runtime in the
   * application, so instead we collate them and run them later with the complete list incl.
   * ones already registered & the context of the view.
   */ this.bulkActions = [
            ...DEFAULT_BULK_ACTIONS
        ];
        this.documentActions = [
            ...DEFAULT_ACTIONS,
            ...DEFAULT_TABLE_ROW_ACTIONS,
            ...DEFAULT_HEADER_ACTIONS
        ];
        this.editViewSidePanels = [
            ActionsPanel
        ];
        this.headerActions = [];
    }
}
/* -------------------------------------------------------------------------------------------------
 * getPrintableType
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description Gets the human-friendly printable type name for the given value, for instance it will yield
 * `array` instead of `object`, as the native `typeof` operator would do.
 */ const getPrintableType = (value)=>{
    const nativeType = typeof value;
    if (nativeType === 'object') {
        if (value === null) return 'null';
        if (Array.isArray(value)) return 'array';
        if (value instanceof Object && value.constructor.name !== 'Object') {
            return value.constructor.name;
        }
    }
    return nativeType;
};

const HistoryAction = ({ model, document })=>{
    const { formatMessage } = reactIntl.useIntl();
    const [{ query }] = strapiAdmin.useQueryParams();
    const navigate = reactRouterDom.useNavigate();
    const { trackUsage } = strapiAdmin.useTracking();
    const { pathname } = reactRouterDom.useLocation();
    const pluginsQueryParams = qs.stringify({
        plugins: query.plugins
    }, {
        encode: false
    });
    if (!window.strapi.features.isEnabled('cms-content-history')) {
        return null;
    }
    const handleOnClick = ()=>{
        const destination = {
            pathname: 'history',
            search: pluginsQueryParams
        };
        trackUsage('willNavigate', {
            from: pathname,
            to: `${pathname}/${destination.pathname}`
        });
        navigate(destination);
    };
    return {
        icon: /*#__PURE__*/ jsxRuntime.jsx(Icons.ClockCounterClockwise, {}),
        label: formatMessage({
            id: 'content-manager.history.document-action',
            defaultMessage: 'Content History'
        }),
        onClick: handleOnClick,
        disabled: /**
       * The user is creating a new document.
       * It hasn't been saved yet, so there's no history to go to
       */ !document || /**
       * The document has been created but the current dimension has never been saved.
       * For example, the user is creating a new locale in an existing document,
       * so there's no history for the document in that locale
       */ !document.id || /**
       * History is only available for content types created by the user.
       * These have the `api::` prefix, as opposed to the ones created by Strapi or plugins,
       * which start with `admin::` or `plugin::`
       */ !model.startsWith('api::'),
        position: 'header'
    };
};
HistoryAction.type = 'history';
HistoryAction.position = 'header';

const historyAdmin = {
    bootstrap (app) {
        const { addDocumentAction } = app.getPlugin('content-manager').apis;
        /**
     * Register the document action here using the public API, and not by setting the action in the
     * Content Manager directly, because this API lets us control the order of the actions array.
     * We want history to be the last non-delete action in the array.
     */ addDocumentAction((actions)=>{
            const indexOfDeleteAction = actions.findIndex((action)=>action.type === 'delete');
            actions.splice(indexOfDeleteAction, 0, HistoryAction);
            return actions;
        });
    }
};

const initialState = {
    collectionTypeLinks: [],
    components: [],
    fieldSizes: {},
    models: [],
    singleTypeLinks: [],
    isLoading: true
};
const appSlice = toolkit.createSlice({
    name: 'app',
    initialState,
    reducers: {
        setInitialData (state, action) {
            const { authorizedCollectionTypeLinks, authorizedSingleTypeLinks, components, contentTypeSchemas, fieldSizes } = action.payload;
            state.collectionTypeLinks = authorizedCollectionTypeLinks.filter(({ isDisplayed })=>isDisplayed);
            state.singleTypeLinks = authorizedSingleTypeLinks.filter(({ isDisplayed })=>isDisplayed);
            state.components = components;
            state.models = contentTypeSchemas;
            state.fieldSizes = fieldSizes;
            state.isLoading = false;
        }
    }
});
const { actions, reducer: reducer$1 } = appSlice;
const { setInitialData } = actions;

const reducer = toolkit.combineReducers({
    app: reducer$1
});

const previewApi = contentManagerApi.injectEndpoints({
    endpoints: (builder)=>({
            getPreviewUrl: builder.query({
                query ({ query, params }) {
                    return {
                        url: `/content-manager/preview/url/${params.contentType}`,
                        method: 'GET',
                        config: {
                            params: query
                        }
                    };
                }
            })
        })
});
const { useGetPreviewUrlQuery } = previewApi;

const ConditionalTooltip = ({ isShown, label, children })=>{
    if (isShown) {
        return /*#__PURE__*/ jsxRuntime.jsx(designSystem.Tooltip, {
            label: label,
            children: children
        });
    }
    return children;
};
const PreviewSidePanel = ({ model, documentId, document })=>{
    const { formatMessage } = reactIntl.useIntl();
    const { trackUsage } = strapiAdmin.useTracking();
    const { pathname } = reactRouterDom.useLocation();
    const [{ query }] = strapiAdmin.useQueryParams();
    const isModified = strapiAdmin.useForm('PreviewSidePanel', (state)=>state.modified);
    /**
   * The preview URL isn't used in this component, we just fetch it to know if preview is enabled
   * for the content type. If it's not, the panel is not displayed. If it is, we display a link to
   * /preview, and the URL will already be loaded in the RTK query cache.
   */ const { data, error } = useGetPreviewUrlQuery({
        params: {
            contentType: model
        },
        query: {
            documentId,
            locale: document?.locale,
            status: document?.status
        }
    });
    if (!data?.data?.url || error) {
        return null;
    }
    const trackNavigation = ()=>{
        // Append /preview to the current URL
        const destinationPathname = pathname.replace(/\/$/, '') + '/preview';
        trackUsage('willNavigate', {
            from: pathname,
            to: destinationPathname
        });
    };
    return {
        title: formatMessage({
            id: 'content-manager.preview.panel.title',
            defaultMessage: 'Preview'
        }),
        content: /*#__PURE__*/ jsxRuntime.jsx(ConditionalTooltip, {
            label: formatMessage({
                id: 'content-manager.preview.panel.button-disabled-tooltip',
                defaultMessage: 'Please save to open the preview'
            }),
            isShown: isModified,
            children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Box, {
                cursor: "not-allowed",
                width: "100%",
                children: /*#__PURE__*/ jsxRuntime.jsx(designSystem.Button, {
                    variant: "tertiary",
                    tag: reactRouterDom.Link,
                    to: {
                        pathname: 'preview',
                        search: qs.stringify(query, {
                            encode: false
                        })
                    },
                    onClick: trackNavigation,
                    width: "100%",
                    disabled: isModified,
                    pointerEvents: isModified ? 'none' : undefined,
                    tabIndex: isModified ? -1 : undefined,
                    children: formatMessage({
                        id: 'content-manager.preview.panel.button',
                        defaultMessage: 'Open preview'
                    })
                })
            })
        })
    };
};

const previewAdmin = {
    bootstrap (app) {
        const contentManagerPluginApis = app.getPlugin('content-manager').apis;
        contentManagerPluginApis.addEditViewSidePanel([
            PreviewSidePanel
        ]);
    }
};

function __variableDynamicImportRuntime1__(path) {
  switch (path) {
    case './translations/ar.json': return Promise.resolve().then(function () { return require('./ar-DeQBSsfl.js'); });
    case './translations/ca.json': return Promise.resolve().then(function () { return require('./ca-ClDTvatJ.js'); });
    case './translations/cs.json': return Promise.resolve().then(function () { return require('./cs-BJFxwIWj.js'); });
    case './translations/de.json': return Promise.resolve().then(function () { return require('./de-CbImAUA5.js'); });
    case './translations/en.json': return Promise.resolve().then(function () { return require('./en-CLf4SuMQ.js'); });
    case './translations/es.json': return Promise.resolve().then(function () { return require('./es-C8vLuvZL.js'); });
    case './translations/eu.json': return Promise.resolve().then(function () { return require('./eu-BJW3AvXu.js'); });
    case './translations/fr.json': return Promise.resolve().then(function () { return require('./fr-gQSilC7w.js'); });
    case './translations/gu.json': return Promise.resolve().then(function () { return require('./gu-DPU4wyx7.js'); });
    case './translations/hi.json': return Promise.resolve().then(function () { return require('./hi-Dp4omeBb.js'); });
    case './translations/hu.json': return Promise.resolve().then(function () { return require('./hu-CtFJuhTd.js'); });
    case './translations/id.json': return Promise.resolve().then(function () { return require('./id-D7V5S1rB.js'); });
    case './translations/it.json': return Promise.resolve().then(function () { return require('./it-CQFpa_Dc.js'); });
    case './translations/ja.json': return Promise.resolve().then(function () { return require('./ja-jdQM-B79.js'); });
    case './translations/ko.json': return Promise.resolve().then(function () { return require('./ko-k46sEyzt.js'); });
    case './translations/ml.json': return Promise.resolve().then(function () { return require('./ml-DqxPwODx.js'); });
    case './translations/ms.json': return Promise.resolve().then(function () { return require('./ms-CvSC0OdG.js'); });
    case './translations/nl.json': return Promise.resolve().then(function () { return require('./nl-BEubhS8C.js'); });
    case './translations/pl.json': return Promise.resolve().then(function () { return require('./pl-DWhGDzmM.js'); });
    case './translations/pt-BR.json': return Promise.resolve().then(function () { return require('./pt-BR-CPtAXD-4.js'); });
    case './translations/pt.json': return Promise.resolve().then(function () { return require('./pt-BoPxN80n.js'); });
    case './translations/ru.json': return Promise.resolve().then(function () { return require('./ru-C0op0ALG.js'); });
    case './translations/sa.json': return Promise.resolve().then(function () { return require('./sa-B_FuPyMw.js'); });
    case './translations/sk.json': return Promise.resolve().then(function () { return require('./sk-D_iXML2C.js'); });
    case './translations/sv.json': return Promise.resolve().then(function () { return require('./sv-BstBC1Yp.js'); });
    case './translations/th.json': return Promise.resolve().then(function () { return require('./th-lXoOCqPC.js'); });
    case './translations/tr.json': return Promise.resolve().then(function () { return require('./tr-CkS6sLIE.js'); });
    case './translations/uk.json': return Promise.resolve().then(function () { return require('./uk-DB6OgySY.js'); });
    case './translations/vi.json': return Promise.resolve().then(function () { return require('./vi-BGr1X_HZ.js'); });
    case './translations/zh-Hans.json': return Promise.resolve().then(function () { return require('./zh-Hans-JVK9x7xr.js'); });
    case './translations/zh.json': return Promise.resolve().then(function () { return require('./zh-DwFu_Kfj.js'); });
    default: return new Promise(function(resolve, reject) {
      (typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
        reject.bind(null, new Error("Unknown variable dynamic import: " + path))
      );
    })
   }
 }
// eslint-disable-next-line import/no-default-export
var index = {
    register (app) {
        const cm = new ContentManagerPlugin();
        app.addReducers({
            [PLUGIN_ID]: reducer
        });
        app.addMenuLink({
            to: PLUGIN_ID,
            icon: Icons.Feather,
            intlLabel: {
                id: `content-manager.plugin.name`,
                defaultMessage: 'Content Manager'
            },
            permissions: [],
            position: 1
        });
        app.router.addRoute({
            path: 'content-manager/*',
            lazy: async ()=>{
                const { Layout } = await Promise.resolve().then(function () { return require('./layout-xxDnIsHG.js'); });
                return {
                    Component: Layout
                };
            },
            children: routes
        });
        app.registerPlugin(cm.config);
    },
    bootstrap (app) {
        if (typeof historyAdmin.bootstrap === 'function') {
            historyAdmin.bootstrap(app);
        }
        if (typeof previewAdmin.bootstrap === 'function') {
            previewAdmin.bootstrap(app);
        }
    },
    async registerTrads ({ locales }) {
        const importedTrads = await Promise.all(locales.map((locale)=>{
            return __variableDynamicImportRuntime1__(`./translations/${locale}.json`).then(({ default: data })=>{
                return {
                    data: prefixPluginTranslations(data, PLUGIN_ID),
                    locale
                };
            }).catch(()=>{
                return {
                    data: {},
                    locale
                };
            });
        }));
        return Promise.resolve(importedTrads);
    }
};

exports.ATTRIBUTE_TYPES_THAT_CANNOT_BE_MAIN_FIELD = ATTRIBUTE_TYPES_THAT_CANNOT_BE_MAIN_FIELD;
exports.BulkActionsRenderer = BulkActionsRenderer;
exports.CLONE_PATH = CLONE_PATH;
exports.COLLECTION_TYPES = COLLECTION_TYPES;
exports.CREATOR_FIELDS = CREATOR_FIELDS;
exports.DEFAULT_SETTINGS = DEFAULT_SETTINGS;
exports.DocumentActionButton = DocumentActionButton;
exports.DocumentRBAC = DocumentRBAC;
exports.DocumentStatus = DocumentStatus;
exports.HOOKS = HOOKS;
exports.Header = Header;
exports.InjectionZone = InjectionZone;
exports.PERMISSIONS = PERMISSIONS;
exports.Panels = Panels;
exports.RelativeTime = RelativeTime;
exports.SINGLE_TYPES = SINGLE_TYPES;
exports.TableActions = TableActions;
exports.buildValidParams = buildValidParams;
exports.capitalise = capitalise;
exports.checkIfAttributeIsDisplayable = checkIfAttributeIsDisplayable;
exports.contentManagerApi = contentManagerApi;
exports.convertEditLayoutToFieldLayouts = convertEditLayoutToFieldLayouts;
exports.convertListLayoutToFieldLayouts = convertListLayoutToFieldLayouts;
exports.createDefaultForm = createDefaultForm;
exports.createYupSchema = createYupSchema;
exports.extractContentTypeComponents = extractContentTypeComponents;
exports.getDisplayName = getDisplayName;
exports.getMainField = getMainField;
exports.getTranslation = getTranslation;
exports.index = index;
exports.prepareTempKeys = prepareTempKeys;
exports.removeFieldsThatDontExistOnSchema = removeFieldsThatDontExistOnSchema;
exports.setInitialData = setInitialData;
exports.transformDocument = transformDocument;
exports.useContentManagerContext = useContentManagerContext;
exports.useContentTypeSchema = useContentTypeSchema;
exports.useDoc = useDoc;
exports.useDocLayout = useDocLayout;
exports.useDocument = useDocument;
exports.useDocumentActions = useDocumentActions;
exports.useDocumentLayout = useDocumentLayout;
exports.useDocumentRBAC = useDocumentRBAC;
exports.useGetAllContentTypeSettingsQuery = useGetAllContentTypeSettingsQuery;
exports.useGetAllDocumentsQuery = useGetAllDocumentsQuery;
exports.useGetContentTypeConfigurationQuery = useGetContentTypeConfigurationQuery;
exports.useGetInitialDataQuery = useGetInitialDataQuery;
exports.useGetPreviewUrlQuery = useGetPreviewUrlQuery;
exports.useUpdateContentTypeConfigurationMutation = useUpdateContentTypeConfigurationMutation;
//# sourceMappingURL=index-SQ88CePz.js.map
