'use strict';

var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var strapiAdmin = require('@strapi/admin/strapi-admin');
var reactIntl = require('react-intl');
var reactRouterDom = require('react-router-dom');
var Form = require('./Form-XD_sf25E.js');
var index = require('./index-SQ88CePz.js');
var hooks = require('./hooks-D-sOYd1s.js');
var objects = require('./objects-C3EebVVe.js');
require('@strapi/design-system');
require('fractional-indexing');
require('lodash/fp/pipe');
require('@strapi/icons');
require('react-dnd-html5-backend');
require('styled-components');
require('./useDragAndDrop-gcqEJMnO.js');
require('react-dnd');
require('./ComponentIcon-C-EjOUPA.js');
require('@strapi/icons/symbols');
require('yup');
require('./FieldTypeIcon-Bxh-7Jin.js');
require('lodash/fp/mapValues');
require('qs');
require('date-fns');
require('@reduxjs/toolkit');
require('prismjs');
require('react-redux');
require('lodash/clone');
require('lodash/toPath');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

const componentsApi = index.contentManagerApi.injectEndpoints({
    endpoints: (builder)=>({
            getComponentConfiguration: builder.query({
                query: (uid)=>`/content-manager/components/${uid}/configuration`,
                transformResponse: (response)=>response.data,
                providesTags: (_result, _error, uid)=>[
                        {
                            type: 'ComponentConfiguration',
                            id: uid
                        }
                    ]
            }),
            updateComponentConfiguration: builder.mutation({
                query: ({ uid, ...body })=>({
                        url: `/content-manager/components/${uid}/configuration`,
                        method: 'PUT',
                        data: body
                    }),
                transformResponse: (response)=>response.data,
                invalidatesTags: (_result, _error, { uid })=>[
                        {
                            type: 'ComponentConfiguration',
                            id: uid
                        },
                        // otherwise layouts already fetched will have stale component configuration data.
                        {
                            type: 'ContentTypeSettings',
                            id: 'LIST'
                        }
                    ]
            })
        })
});
const { useGetComponentConfigurationQuery, useUpdateComponentConfigurationMutation } = componentsApi;

/* -------------------------------------------------------------------------------------------------
 * ComponentConfigurationPage
 * -----------------------------------------------------------------------------------------------*/ const ComponentConfigurationPage = ()=>{
    /**
   * useDocumentLayout only works for documents, not components,
   * it feels weird to make that hook work for both when this is SUCH
   * a unique use case and we only do it here, so in short, we essentially
   * just extracted the logic to make an edit view layout and reproduced it here.
   */ const { slug: model } = reactRouterDom.useParams();
    const { toggleNotification } = strapiAdmin.useNotification();
    const { formatMessage } = reactIntl.useIntl();
    const { _unstableFormatAPIError: formatAPIError } = strapiAdmin.useAPIErrorHandler();
    const { components, fieldSizes, schema, error: errorSchema, isLoading: isLoadingSchema, isFetching: isFetchingSchema } = index.useGetInitialDataQuery(undefined, {
        selectFromResult: (res)=>{
            const schema = res.data?.components.find((ct)=>ct.uid === model);
            const componentsByKey = res.data?.components.reduce((acc, component)=>{
                acc[component.uid] = component;
                return acc;
            }, {});
            const components = index.extractContentTypeComponents(schema?.attributes, componentsByKey);
            const fieldSizes = Object.entries(res.data?.fieldSizes ?? {}).reduce((acc, [attributeName, { default: size }])=>{
                acc[attributeName] = size;
                return acc;
            }, {});
            return {
                isFetching: res.isFetching,
                isLoading: res.isLoading,
                error: res.error,
                components,
                schema,
                fieldSizes
            };
        }
    });
    React__namespace.useEffect(()=>{
        if (errorSchema) {
            toggleNotification({
                type: 'danger',
                message: formatAPIError(errorSchema)
            });
        }
    }, [
        errorSchema,
        formatAPIError,
        toggleNotification
    ]);
    const { data, isLoading: isLoadingConfig, isFetching: isFetchingConfig, error } = useGetComponentConfigurationQuery(model ?? '');
    React__namespace.useEffect(()=>{
        if (error) {
            toggleNotification({
                type: 'danger',
                message: formatAPIError(error)
            });
        }
    }, [
        error,
        formatAPIError,
        toggleNotification
    ]);
    /**
   * you **must** check if we're loading or fetching in case the component gets new props
   * but nothing was unmounted, it then becomes a fetch, not a load.
   */ const isLoading = isLoadingConfig || isLoadingSchema || isFetchingConfig || isFetchingSchema;
    const editLayout = React__namespace.useMemo(()=>data && !isLoading ? formatEditLayout(data, {
            schema,
            components
        }) : {
            layout: [],
            components: {},
            metadatas: {},
            options: {},
            settings: index.DEFAULT_SETTINGS
        }, [
        data,
        isLoading,
        schema,
        components
    ]);
    const [updateConfiguration] = useUpdateComponentConfigurationMutation();
    const handleSubmit = async (formData)=>{
        try {
            /**
       * We reconstruct the metadatas object by taking the existing list metadatas
       * and re-merging that by attribute name with the current list metadatas, whilst overwriting
       * the data from the form we've built.
       */ const meta = Object.entries(data?.component.metadatas ?? {}).reduce((acc, [name, { edit, list }])=>{
                const { __temp_key__, size: _size, name: _name, ...editedMetadata } = formData.layout.flatMap((row)=>row.children).find((field)=>field.name === name) ?? {};
                acc[name] = {
                    edit: {
                        ...edit,
                        ...editedMetadata
                    },
                    list
                };
                return acc;
            }, {});
            const res = await updateConfiguration({
                layouts: {
                    edit: formData.layout.map((row)=>row.children.reduce((acc, { name, size })=>{
                            if (name !== Form.TEMP_FIELD_NAME) {
                                return [
                                    ...acc,
                                    {
                                        name,
                                        size
                                    }
                                ];
                            }
                            return acc;
                        }, [])),
                    list: data?.component.layouts.list
                },
                settings: objects.setIn(formData.settings, 'displayName', undefined),
                metadatas: meta,
                uid: model
            });
            if ('data' in res) {
                toggleNotification({
                    type: 'success',
                    message: formatMessage({
                        id: 'notification.success.saved',
                        defaultMessage: 'Saved'
                    })
                });
            } else {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
            }
        } catch  {
            toggleNotification({
                type: 'danger',
                message: formatMessage({
                    id: 'notification.error',
                    defaultMessage: 'An error occurred'
                })
            });
        }
    };
    if (isLoading) {
        return /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Page.Loading, {});
    }
    if (error || errorSchema || !schema) {
        return /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Page.Error, {});
    }
    return /*#__PURE__*/ jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [
            /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Page.Title, {
                children: `Configure ${editLayout.settings.displayName} Edit View`
            }),
            /*#__PURE__*/ jsxRuntime.jsx(Form.ConfigurationForm, {
                onSubmit: handleSubmit,
                attributes: schema.attributes,
                fieldSizes: fieldSizes,
                layout: editLayout
            })
        ]
    });
};
/* -------------------------------------------------------------------------------------------------
 * Header
 * -----------------------------------------------------------------------------------------------*/ const formatEditLayout = (data, { schema, components })=>{
    const editAttributes = index.convertEditLayoutToFieldLayouts(data.component.layouts.edit, schema?.attributes, data.component.metadatas, {
        configurations: data.components,
        schemas: components
    });
    const componentEditAttributes = Object.entries(data.components).reduce((acc, [uid, configuration])=>{
        acc[uid] = {
            layout: index.convertEditLayoutToFieldLayouts(configuration.layouts.edit, components[uid].attributes, configuration.metadatas),
            settings: {
                ...configuration.settings,
                icon: components[uid].info.icon,
                displayName: components[uid].info.displayName
            }
        };
        return acc;
    }, {});
    const editMetadatas = Object.entries(data.component.metadatas).reduce((acc, [attribute, metadata])=>{
        return {
            ...acc,
            [attribute]: metadata.edit
        };
    }, {});
    return {
        layout: [
            editAttributes
        ],
        components: componentEditAttributes,
        metadatas: editMetadatas,
        options: {
            ...schema?.options,
            ...schema?.pluginOptions
        },
        settings: {
            ...data.component.settings,
            displayName: schema?.info.displayName
        }
    };
};
/* -------------------------------------------------------------------------------------------------
 * Header
 * -----------------------------------------------------------------------------------------------*/ const ProtectedComponentConfigurationPage = ()=>{
    const permissions = hooks.useTypedSelector((state)=>state.admin_app.permissions.contentManager?.componentsConfigurations);
    return /*#__PURE__*/ jsxRuntime.jsx(strapiAdmin.Page.Protect, {
        permissions: permissions,
        children: /*#__PURE__*/ jsxRuntime.jsx(ComponentConfigurationPage, {})
    });
};

exports.ComponentConfigurationPage = ComponentConfigurationPage;
exports.ProtectedComponentConfigurationPage = ProtectedComponentConfigurationPage;
//# sourceMappingURL=ComponentConfigurationPage-BGBNQxFJ.js.map
