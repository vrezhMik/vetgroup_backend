import { Cross, WarningCircle, More, ListPlus, Pencil, Trash, Check, CheckCircle, ArrowsCounterClockwise, CrossCircle, ChevronRight, Duplicate, ClockCounterClockwise, Feather } from '@strapi/icons';
import { jsx, Fragment, jsxs } from 'react/jsx-runtime';
import { useStrapiApp, createContext, useQueryParams, useAuth, useRBAC, Page, adminApi, translatedErrors, useNotification, useAPIErrorHandler, getYupValidationErrors, useForm, useTracking, useGuidedTour, BackButton, DescriptionComponentRenderer, useTable, Table } from '@strapi/admin/strapi-admin';
import * as React from 'react';
import { lazy } from 'react';
import { Menu, Flex, Typography, Radio, Button, VisuallyHidden, Dialog, Modal, Status, Box, SingleSelect, SingleSelectOption, IconButton, RawTable, Loader, Tbody, Tr, Td, Tooltip, LinkButton } from '@strapi/design-system';
import mapValues from 'lodash/fp/mapValues';
import { useIntl } from 'react-intl';
import { useParams, useNavigate, Navigate, useMatch, useLocation, Link, NavLink } from 'react-router-dom';
import { styled } from 'styled-components';
import * as yup from 'yup';
import { ValidationError } from 'yup';
import { generateNKeysBetween } from 'fractional-indexing';
import pipe from 'lodash/fp/pipe';
import { stringify } from 'qs';
import { intervalToDuration, isPast } from 'date-fns';
import { createSlice, combineReducers } from '@reduxjs/toolkit';
import 'prismjs';

const PLUGIN_ID = 'content-manager';
const PERMISSIONS = [
    'plugin::content-manager.explorer.create',
    'plugin::content-manager.explorer.read',
    'plugin::content-manager.explorer.update',
    'plugin::content-manager.explorer.delete',
    'plugin::content-manager.explorer.publish'
];

const INJECTION_ZONES = {
    editView: {
        informations: [],
        'right-links': []
    },
    listView: {
        actions: [],
        deleteModalAdditionalInfos: [],
        publishModalAdditionalInfos: [],
        unpublishModalAdditionalInfos: []
    },
    preview: {
        actions: []
    }
};
/**
 * You can't know what this component props will be because it's generic and used everywhere
 * e.g. content-manager edit view, we just send the slug but we might not in the listView,
 * therefore, people should type it themselves on the components they render.
 */ const InjectionZone = ({ area, ...props })=>{
    const components = useInjectionZone(area);
    return /*#__PURE__*/ jsx(Fragment, {
        children: components.map((component)=>/*#__PURE__*/ jsx(component.Component, {
                ...props
            }, component.name))
    });
};
const useInjectionZone = (area)=>{
    const getPlugin = useStrapiApp('useInjectionZone', (state)=>state.getPlugin);
    const contentManagerPlugin = getPlugin(PLUGIN_ID);
    const [page, position] = area.split('.');
    return contentManagerPlugin.getInjectedComponents(page, position);
};

const ID = 'id';
const CREATED_BY_ATTRIBUTE_NAME = 'createdBy';
const UPDATED_BY_ATTRIBUTE_NAME = 'updatedBy';
const CREATOR_FIELDS = [
    CREATED_BY_ATTRIBUTE_NAME,
    UPDATED_BY_ATTRIBUTE_NAME
];
const PUBLISHED_BY_ATTRIBUTE_NAME = 'publishedBy';
const CREATED_AT_ATTRIBUTE_NAME = 'createdAt';
const UPDATED_AT_ATTRIBUTE_NAME = 'updatedAt';
const PUBLISHED_AT_ATTRIBUTE_NAME = 'publishedAt';
const DOCUMENT_META_FIELDS = [
    ID,
    ...CREATOR_FIELDS,
    PUBLISHED_BY_ATTRIBUTE_NAME,
    CREATED_AT_ATTRIBUTE_NAME,
    UPDATED_AT_ATTRIBUTE_NAME,
    PUBLISHED_AT_ATTRIBUTE_NAME
];
/**
 * List of attribute types that cannot be used as the main field.
 * Not sure the name could be any clearer.
 */ const ATTRIBUTE_TYPES_THAT_CANNOT_BE_MAIN_FIELD = [
    'dynamiczone',
    'json',
    'text',
    'relation',
    'component',
    'boolean',
    'media',
    'password',
    'richtext',
    'timestamp',
    'blocks'
];

const SINGLE_TYPES = 'single-types';
const COLLECTION_TYPES = 'collection-types';

const [DocumentRBACProvider, useDocumentRBAC] = createContext('DocumentRBAC', {
    canCreate: false,
    canCreateFields: [],
    canDelete: false,
    canPublish: false,
    canRead: false,
    canReadFields: [],
    canUpdate: false,
    canUpdateFields: [],
    canUserAction: ()=>false,
    isLoading: false
});
/**
 * @internal This component is not meant to be used outside of the Content Manager plugin.
 * It depends on knowing the slug/model of the content-type using the params of the URL.
 * If you do use the hook outside of the context, we default to `false` for all actions.
 *
 * It then creates an list of `can{Action}` that are passed to the context for consumption
 * within the app to enforce RBAC.
 */ const DocumentRBAC = ({ children, permissions })=>{
    const { slug } = useParams();
    if (!slug) {
        throw new Error('Cannot find the slug param in the URL');
    }
    const [{ rawQuery }] = useQueryParams();
    const userPermissions = useAuth('DocumentRBAC', (state)=>state.permissions);
    const contentTypePermissions = React.useMemo(()=>{
        const contentTypePermissions = userPermissions.filter((permission)=>permission.subject === slug);
        return contentTypePermissions.reduce((acc, permission)=>{
            const [action] = permission.action.split('.').slice(-1);
            return {
                ...acc,
                [action]: [
                    permission
                ]
            };
        }, {});
    }, [
        slug,
        userPermissions
    ]);
    const { isLoading, allowedActions } = useRBAC(contentTypePermissions, permissions ?? undefined, // TODO: useRBAC context should be typed and built differently
    // We are passing raw query as context to the hook so that it can
    // rely on the locale provided from DocumentRBAC for its permission calculations.
    rawQuery);
    const canCreateFields = !isLoading && allowedActions.canCreate ? extractAndDedupeFields(contentTypePermissions.create) : [];
    const canReadFields = !isLoading && allowedActions.canRead ? extractAndDedupeFields(contentTypePermissions.read) : [];
    const canUpdateFields = !isLoading && allowedActions.canUpdate ? extractAndDedupeFields(contentTypePermissions.update) : [];
    /**
   * @description Checks if the user can perform an action on a field based on the field names
   * provided as the second argument.
   */ const canUserAction = React.useCallback((fieldName, fieldsUserCanAction, fieldType)=>{
        const name = removeNumericalStrings(fieldName.split('.'));
        const componentFieldNames = fieldsUserCanAction// filter out fields that aren't components (components are dot separated)
        .filter((field)=>field.split('.').length > 1);
        if (fieldType === 'component') {
            // check if the field name is within any of those arrays
            return componentFieldNames.some((field)=>{
                return field.includes(name.join('.'));
            });
        }
        /**
       * The field is within a component.
       */ if (name.length > 1) {
            return componentFieldNames.includes(name.join('.'));
        }
        /**
       * just a regular field
       */ return fieldsUserCanAction.includes(fieldName);
    }, []);
    if (isLoading) {
        return /*#__PURE__*/ jsx(Page.Loading, {});
    }
    return /*#__PURE__*/ jsx(DocumentRBACProvider, {
        isLoading: isLoading,
        canCreateFields: canCreateFields,
        canReadFields: canReadFields,
        canUpdateFields: canUpdateFields,
        canUserAction: canUserAction,
        ...allowedActions,
        children: children
    });
};
/**
 * @internal it's really small, but it's used three times in a row and DRY for something this straight forward.
 */ const extractAndDedupeFields = (permissions = [])=>permissions.flatMap((permission)=>permission.properties?.fields).filter((field, index, arr)=>arr.indexOf(field) === index && typeof field === 'string');
/**
 * @internal removes numerical strings from arrays.
 * @example
 * ```ts
 * const name = 'a.0.b';
 * const res = removeNumericalStrings(name.split('.'));
 * console.log(res); // ['a', 'b']
 * ```
 */ const removeNumericalStrings = (arr)=>arr.filter((item)=>isNaN(Number(item)));

const BLOCK_LIST_ATTRIBUTE_KEYS = [
    '__component',
    '__temp_key__'
];
/**
 * @internal This function is used to traverse the data and transform the values.
 * Given a predicate function, it will transform the value (using the given transform function)
 * if the predicate returns true. If it finds that the attribute is a component or dynamiczone,
 * it will recursively traverse those data structures as well.
 *
 * It is possible to break the ContentManager by using this function incorrectly, for example,
 * if you transform a number into a string but the attribute type is a number, the ContentManager
 * will not be able to save the data and the Form will likely crash because the component it's
 * passing the data too won't succesfully be able to handle the value.
 */ const traverseData = (predicate, transform)=>(schema, components = {})=>(data = {})=>{
            const traverse = (datum, attributes)=>{
                return Object.entries(datum).reduce((acc, [key, value])=>{
                    const attribute = attributes[key];
                    /**
         * If the attribute is a block list attribute, we don't want to transform it.
         * We also don't want to transform null or undefined values.
         */ if (BLOCK_LIST_ATTRIBUTE_KEYS.includes(key) || value === null || value === undefined) {
                        acc[key] = value;
                        return acc;
                    }
                    if (attribute.type === 'component') {
                        if (attribute.repeatable) {
                            const componentValue = predicate(attribute, value) ? transform(value, attribute) : value;
                            acc[key] = componentValue.map((componentData)=>traverse(componentData, components[attribute.component]?.attributes ?? {}));
                        } else {
                            const componentValue = predicate(attribute, value) ? transform(value, attribute) : value;
                            acc[key] = traverse(componentValue, components[attribute.component]?.attributes ?? {});
                        }
                    } else if (attribute.type === 'dynamiczone') {
                        const dynamicZoneValue = predicate(attribute, value) ? transform(value, attribute) : value;
                        acc[key] = dynamicZoneValue.map((componentData)=>traverse(componentData, components[componentData.__component]?.attributes ?? {}));
                    } else if (predicate(attribute, value)) {
                        acc[key] = transform(value, attribute);
                    } else {
                        acc[key] = value;
                    }
                    return acc;
                }, {});
            };
            return traverse(data, schema.attributes);
        };
/* -------------------------------------------------------------------------------------------------
 * removeProhibitedFields
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal Removes all the fields that are not allowed.
 */ const removeProhibitedFields = (prohibitedFields)=>traverseData((attribute)=>prohibitedFields.includes(attribute.type), ()=>'');
/* -------------------------------------------------------------------------------------------------
 * prepareRelations
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description Sets all relation values to an empty array.
 */ const prepareRelations = traverseData((attribute)=>attribute.type === 'relation', ()=>({
        connect: [],
        disconnect: []
    }));
/* -------------------------------------------------------------------------------------------------
 * prepareTempKeys
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description Adds a `__temp_key__` to each component and dynamiczone item. This gives us
 * a stable identifier regardless of its ids etc. that we can then use for drag and drop.
 */ const prepareTempKeys = traverseData((attribute)=>attribute.type === 'component' && attribute.repeatable || attribute.type === 'dynamiczone', (data)=>{
    if (Array.isArray(data) && data.length > 0) {
        const keys = generateNKeysBetween(undefined, undefined, data.length);
        return data.map((datum, index)=>({
                ...datum,
                __temp_key__: keys[index]
            }));
    }
    return data;
});
/* -------------------------------------------------------------------------------------------------
 * removeFieldsThatDontExistOnSchema
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description Fields that don't exist in the schema like createdAt etc. are only on the first level (not nested),
 * as such we don't need to traverse the components to remove them.
 */ const removeFieldsThatDontExistOnSchema = (schema)=>(data)=>{
        const schemaKeys = Object.keys(schema.attributes);
        const dataKeys = Object.keys(data);
        const keysToRemove = dataKeys.filter((key)=>!schemaKeys.includes(key));
        const revisedData = [
            ...keysToRemove,
            ...DOCUMENT_META_FIELDS
        ].reduce((acc, key)=>{
            delete acc[key];
            return acc;
        }, structuredClone(data));
        return revisedData;
    };
/**
 * @internal
 * @description We need to remove null fields from the data-structure because it will pass it
 * to the specific inputs breaking them as most would prefer empty strings or `undefined` if
 * they're controlled / uncontrolled.
 */ const removeNullValues = (data)=>{
    return Object.entries(data).reduce((acc, [key, value])=>{
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
/* -------------------------------------------------------------------------------------------------
 * transformDocuments
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description Takes a document data structure (this could be from the API or a default form structure)
 * and applies consistent data transformations to it. This is also used when we add new components to the
 * form to ensure the data is correctly prepared from their default state e.g. relations are set to an empty array.
 */ const transformDocument = (schema, components = {})=>(document)=>{
        const transformations = pipe(removeFieldsThatDontExistOnSchema(schema), removeProhibitedFields([
            'password'
        ])(schema, components), removeNullValues, prepareRelations(schema, components), prepareTempKeys(schema, components));
        return transformations(document);
    };

/* -------------------------------------------------------------------------------------------------
 * createDefaultForm
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal Using the content-type schema & the components dictionary of the content-type,
 * creates a form with pre-filled default values. This is used when creating a new entry.
 */ const createDefaultForm = (contentType, components = {})=>{
    const traverseSchema = (attributes)=>{
        return Object.entries(attributes).reduce((acc, [key, attribute])=>{
            if ('default' in attribute) {
                acc[key] = attribute.default;
            } else if (attribute.type === 'component' && attribute.required) {
                const defaultComponentForm = traverseSchema(components[attribute.component].attributes);
                if (attribute.repeatable) {
                    acc[key] = attribute.min ? [
                        ...Array(attribute.min).fill(defaultComponentForm)
                    ] : [];
                } else {
                    acc[key] = defaultComponentForm;
                }
            } else if (attribute.type === 'dynamiczone' && attribute.required) {
                acc[key] = [];
            }
            return acc;
        }, {});
    };
    return traverseSchema(contentType.attributes);
};

const contentManagerApi = adminApi.enhanceEndpoints({
    addTagTypes: [
        'ComponentConfiguration',
        'ContentTypesConfiguration',
        'ContentTypeSettings',
        'Document',
        'InitialData',
        'HistoryVersion',
        'Relations',
        'UidAvailability',
        'RecentDocumentList'
    ]
});

const documentApi = contentManagerApi.injectEndpoints({
    overrideExisting: true,
    endpoints: (builder)=>({
            autoCloneDocument: builder.mutation({
                query: ({ model, sourceId, query })=>({
                        url: `/content-manager/collection-types/${model}/auto-clone/${sourceId}`,
                        method: 'POST',
                        config: {
                            params: query
                        }
                    }),
                invalidatesTags: (_result, error, { model })=>{
                    if (error) {
                        return [];
                    }
                    return [
                        {
                            type: 'Document',
                            id: `${model}_LIST`
                        },
                        'RecentDocumentList'
                    ];
                }
            }),
            cloneDocument: builder.mutation({
                query: ({ model, sourceId, data, params })=>({
                        url: `/content-manager/collection-types/${model}/clone/${sourceId}`,
                        method: 'POST',
                        data,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_result, _error, { model })=>[
                        {
                            type: 'Document',
                            id: `${model}_LIST`
                        },
                        {
                            type: 'UidAvailability',
                            id: model
                        },
                        'RecentDocumentList'
                    ]
            }),
            /**
     * Creates a new collection-type document. This should ONLY be used for collection-types.
     * single-types should always be using `updateDocument` since they always exist.
     */ createDocument: builder.mutation({
                query: ({ model, data, params })=>({
                        url: `/content-manager/collection-types/${model}`,
                        method: 'POST',
                        data,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (result, _error, { model })=>[
                        {
                            type: 'Document',
                            id: `${model}_LIST`
                        },
                        'Relations',
                        {
                            type: 'UidAvailability',
                            id: model
                        },
                        'RecentDocumentList'
                    ],
                transformResponse: (response, meta, arg)=>{
                    /**
         * TODO v6
         * Adapt plugin:users-permissions.user to return the same response
         * shape as all other requests. The error is returned as expected.
         */ if (!('data' in response) && arg.model === 'plugin::users-permissions.user') {
                        return {
                            data: response,
                            meta: {
                                availableStatus: [],
                                availableLocales: []
                            }
                        };
                    }
                    return response;
                }
            }),
            deleteDocument: builder.mutation({
                query: ({ collectionType, model, documentId, params })=>({
                        url: `/content-manager/${collectionType}/${model}${collectionType !== SINGLE_TYPES && documentId ? `/${documentId}` : ''}`,
                        method: 'DELETE',
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_result, _error, { collectionType, model })=>[
                        {
                            type: 'Document',
                            id: collectionType !== SINGLE_TYPES ? `${model}_LIST` : model
                        },
                        'RecentDocumentList'
                    ]
            }),
            deleteManyDocuments: builder.mutation({
                query: ({ model, params, ...body })=>({
                        url: `/content-manager/collection-types/${model}/actions/bulkDelete`,
                        method: 'POST',
                        data: body,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_res, _error, { model })=>[
                        {
                            type: 'Document',
                            id: `${model}_LIST`
                        },
                        'RecentDocumentList'
                    ]
            }),
            discardDocument: builder.mutation({
                query: ({ collectionType, model, documentId, params })=>({
                        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/discard` : `/content-manager/${collectionType}/${model}/actions/discard`,
                        method: 'POST',
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_result, _error, { collectionType, model, documentId })=>{
                    return [
                        {
                            type: 'Document',
                            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
                        },
                        {
                            type: 'Document',
                            id: `${model}_LIST`
                        },
                        'Relations',
                        {
                            type: 'UidAvailability',
                            id: model
                        },
                        'RecentDocumentList'
                    ];
                }
            }),
            /**
     * Gets all documents of a collection type or single type.
     * By passing different params you can get different results e.g. only published documents or 'es' documents.
     */ getAllDocuments: builder.query({
                query: ({ model, params })=>({
                        url: `/content-manager/collection-types/${model}`,
                        method: 'GET',
                        config: {
                            params: stringify(params, {
                                encode: true
                            })
                        }
                    }),
                providesTags: (result, _error, arg)=>{
                    return [
                        {
                            type: 'Document',
                            id: `ALL_LIST`
                        },
                        {
                            type: 'Document',
                            id: `${arg.model}_LIST`
                        },
                        ...result?.results.map(({ documentId })=>({
                                type: 'Document',
                                id: `${arg.model}_${documentId}`
                            })) ?? []
                    ];
                }
            }),
            getDraftRelationCount: builder.query({
                query: ({ collectionType, model, documentId, params })=>({
                        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/countDraftRelations` : `/content-manager/${collectionType}/${model}/actions/countDraftRelations`,
                        method: 'GET',
                        config: {
                            params
                        }
                    })
            }),
            getDocument: builder.query({
                // @ts-expect-error – TODO: fix ts error where data unknown doesn't work with response via an assertion?
                queryFn: async ({ collectionType, model, documentId, params }, _api, _extraOpts, baseQuery)=>{
                    const res = await baseQuery({
                        url: `/content-manager/${collectionType}/${model}${documentId ? `/${documentId}` : ''}`,
                        method: 'GET',
                        config: {
                            params
                        }
                    });
                    /**
         * To stop the query from locking itself in multiple retries, we intercept the error here and manage correctly.
         * This is because single-types don't have a list view and fetching them with the route `/single-types/:model`
         * never returns a list, just a single document but this won't exist if you've not made one before.
         */ if (res.error && res.error.name === 'NotFoundError' && collectionType === SINGLE_TYPES) {
                        return {
                            data: {
                                document: undefined
                            },
                            error: undefined
                        };
                    }
                    return res;
                },
                providesTags: (result, _error, { collectionType, model, documentId })=>{
                    return [
                        // we prefer the result's id because we don't fetch single-types with an ID.
                        {
                            type: 'Document',
                            id: collectionType !== SINGLE_TYPES ? `${model}_${result && 'documentId' in result ? result.documentId : documentId}` : model
                        },
                        // Make it easy to invalidate all individual documents queries for a model
                        {
                            type: 'Document',
                            id: `${model}_ALL_ITEMS`
                        }
                    ];
                }
            }),
            getManyDraftRelationCount: builder.query({
                query: ({ model, ...params })=>({
                        url: `/content-manager/collection-types/${model}/actions/countManyEntriesDraftRelations`,
                        method: 'GET',
                        config: {
                            params
                        }
                    }),
                transformResponse: (response)=>response.data
            }),
            /**
     * This endpoint will either create or update documents at the same time as publishing.
     */ publishDocument: builder.mutation({
                query: ({ collectionType, model, documentId, params, data })=>({
                        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/publish` : `/content-manager/${collectionType}/${model}/actions/publish`,
                        method: 'POST',
                        data,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_result, _error, { collectionType, model, documentId })=>{
                    return [
                        {
                            type: 'Document',
                            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
                        },
                        {
                            type: 'Document',
                            id: `${model}_LIST`
                        },
                        'Relations',
                        'RecentDocumentList'
                    ];
                }
            }),
            publishManyDocuments: builder.mutation({
                query: ({ model, params, ...body })=>({
                        url: `/content-manager/collection-types/${model}/actions/bulkPublish`,
                        method: 'POST',
                        data: body,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_res, _error, { model, documentIds })=>documentIds.map((id)=>({
                            type: 'Document',
                            id: `${model}_${id}`
                        }))
            }),
            updateDocument: builder.mutation({
                query: ({ collectionType, model, documentId, data, params })=>({
                        url: `/content-manager/${collectionType}/${model}${documentId ? `/${documentId}` : ''}`,
                        method: 'PUT',
                        data,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_result, _error, { collectionType, model, documentId })=>{
                    return [
                        {
                            type: 'Document',
                            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
                        },
                        'Relations',
                        {
                            type: 'UidAvailability',
                            id: model
                        },
                        'RecentDocumentList',
                        'RecentDocumentList'
                    ];
                },
                async onQueryStarted ({ data, ...patch }, { dispatch, queryFulfilled }) {
                    // Optimistically update the cache with the new data
                    const patchResult = dispatch(documentApi.util.updateQueryData('getDocument', patch, (draft)=>{
                        Object.assign(draft.data, data);
                    }));
                    try {
                        await queryFulfilled;
                    } catch  {
                        // Rollback the optimistic update if there's an error
                        patchResult.undo();
                    }
                }
            }),
            unpublishDocument: builder.mutation({
                query: ({ collectionType, model, documentId, params, data })=>({
                        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/unpublish` : `/content-manager/${collectionType}/${model}/actions/unpublish`,
                        method: 'POST',
                        data,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_result, _error, { collectionType, model, documentId })=>{
                    return [
                        {
                            type: 'Document',
                            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
                        },
                        'RecentDocumentList'
                    ];
                }
            }),
            unpublishManyDocuments: builder.mutation({
                query: ({ model, params, ...body })=>({
                        url: `/content-manager/collection-types/${model}/actions/bulkUnpublish`,
                        method: 'POST',
                        data: body,
                        config: {
                            params
                        }
                    }),
                invalidatesTags: (_res, _error, { model, documentIds })=>[
                        ...documentIds.map((id)=>({
                                type: 'Document',
                                id: `${model}_${id}`
                            })),
                        'RecentDocumentList'
                    ]
            })
        })
});
const { useAutoCloneDocumentMutation, useCloneDocumentMutation, useCreateDocumentMutation, useDeleteDocumentMutation, useDeleteManyDocumentsMutation, useDiscardDocumentMutation, useGetAllDocumentsQuery, useLazyGetDocumentQuery, useGetDocumentQuery, useLazyGetDraftRelationCountQuery, useGetManyDraftRelationCountQuery, usePublishDocumentMutation, usePublishManyDocumentsMutation, useUpdateDocumentMutation, useUnpublishDocumentMutation, useUnpublishManyDocumentsMutation } = documentApi;

/**
 * @description
 * Creates a valid query params object for get requests
 * ie. plugins[18n][locale]=en becomes locale=en
 */ const buildValidParams = (query)=>{
    if (!query) return query;
    // Extract pluginOptions from the query, they shouldn't be part of the URL
    const { plugins: _, ...validQueryParams } = {
        ...query,
        ...Object.values(query?.plugins ?? {}).reduce((acc, current)=>Object.assign(acc, current), {})
    };
    return validQueryParams;
};
const isBaseQueryError = (error)=>{
    return error.name !== undefined;
};

const arrayValidator = (attribute, options)=>({
        message: translatedErrors.required,
        test (value) {
            if (options.status === 'draft') {
                return true;
            }
            if (!attribute.required) {
                return true;
            }
            if (!value) {
                return false;
            }
            if (Array.isArray(value) && value.length === 0) {
                return false;
            }
            return true;
        }
    });
/**
 * TODO: should we create a Map to store these based on the hash of the schema?
 */ const createYupSchema = (attributes = {}, components = {}, options = {
    status: null
})=>{
    const createModelSchema = (attributes)=>yup.object().shape(Object.entries(attributes).reduce((acc, [name, attribute])=>{
            if (DOCUMENT_META_FIELDS.includes(name)) {
                return acc;
            }
            /**
           * These validations won't apply to every attribute
           * and that's okay, in that case we just return the
           * schema as it was passed.
           */ const validations = [
                addNullableValidation,
                addRequiredValidation,
                addMinLengthValidation,
                addMaxLengthValidation,
                addMinValidation,
                addMaxValidation,
                addRegexValidation
            ].map((fn)=>fn(attribute, options));
            const transformSchema = pipe(...validations);
            switch(attribute.type){
                case 'component':
                    {
                        const { attributes } = components[attribute.component];
                        if (attribute.repeatable) {
                            return {
                                ...acc,
                                [name]: transformSchema(yup.array().of(createModelSchema(attributes).nullable(false))).test(arrayValidator(attribute, options))
                            };
                        } else {
                            return {
                                ...acc,
                                [name]: transformSchema(createModelSchema(attributes).nullable())
                            };
                        }
                    }
                case 'dynamiczone':
                    return {
                        ...acc,
                        [name]: transformSchema(yup.array().of(yup.lazy((data)=>{
                            const attributes = components?.[data?.__component]?.attributes;
                            const validation = yup.object().shape({
                                __component: yup.string().required().oneOf(Object.keys(components))
                            }).nullable(false);
                            if (!attributes) {
                                return validation;
                            }
                            return validation.concat(createModelSchema(attributes));
                        }))).test(arrayValidator(attribute, options))
                    };
                case 'relation':
                    return {
                        ...acc,
                        [name]: transformSchema(yup.lazy((value)=>{
                            if (!value) {
                                return yup.mixed().nullable(true);
                            } else if (Array.isArray(value)) {
                                // If a relation value is an array, we expect
                                // an array of objects with {id} properties, representing the related entities.
                                return yup.array().of(yup.object().shape({
                                    id: yup.number().required()
                                }));
                            } else if (typeof value === 'object') {
                                // A realtion value can also be an object. Some API
                                // repsonses return the number of entities in the relation
                                // as { count: x }
                                return yup.object();
                            } else {
                                return yup.mixed().test('type-error', 'Relation values must be either null, an array of objects with {id} or an object.', ()=>false);
                            }
                        }))
                    };
                default:
                    return {
                        ...acc,
                        [name]: transformSchema(createAttributeSchema(attribute))
                    };
            }
        }, {}))/**
       * TODO: investigate why an undefined object fails a check of `nullable`.
       */ .default(null);
    return createModelSchema(attributes);
};
const createAttributeSchema = (attribute)=>{
    switch(attribute.type){
        case 'biginteger':
            return yup.string().matches(/^-?\d*$/);
        case 'boolean':
            return yup.boolean();
        case 'blocks':
            return yup.mixed().test('isBlocks', translatedErrors.json, (value)=>{
                if (!value || Array.isArray(value)) {
                    return true;
                } else {
                    return false;
                }
            });
        case 'decimal':
        case 'float':
        case 'integer':
            return yup.number();
        case 'email':
            return yup.string().email(translatedErrors.email);
        case 'enumeration':
            return yup.string().oneOf([
                ...attribute.enum,
                null
            ]);
        case 'json':
            return yup.mixed().test('isJSON', translatedErrors.json, (value)=>{
                /**
         * We don't want to validate the JSON field if it's empty.
         */ if (!value || typeof value === 'string' && value.length === 0) {
                    return true;
                }
                // If the value was created via content API and wasn't changed, then it's still an object
                if (typeof value === 'object') {
                    try {
                        JSON.stringify(value);
                        return true;
                    } catch (err) {
                        return false;
                    }
                }
                try {
                    JSON.parse(value);
                    return true;
                } catch (err) {
                    return false;
                }
            });
        case 'password':
        case 'richtext':
        case 'string':
        case 'text':
            return yup.string();
        case 'uid':
            return yup.string().matches(/^[A-Za-z0-9-_.~]*$/);
        default:
            /**
       * This allows any value.
       */ return yup.mixed();
    }
};
// Helper function to return schema.nullable() if it exists, otherwise return schema
const nullableSchema = (schema)=>{
    return schema?.nullable ? schema.nullable() : // e.g. when the schema has been built using yup.lazy (e.g. for relations).
    // In these cases we should just return the schema as it is.
    schema;
};
const addNullableValidation = ()=>(schema)=>{
        return nullableSchema(schema);
    };
const addRequiredValidation = (attribute, options)=>(schema)=>{
        if (options.status === 'draft' || !attribute.required) {
            return schema;
        }
        if (attribute.required && 'required' in schema) {
            return schema.required(translatedErrors.required);
        }
        return schema;
    };
const addMinLengthValidation = (attribute, options)=>(schema)=>{
        // Skip minLength validation for draft
        if (options.status === 'draft') {
            return schema;
        }
        if ('minLength' in attribute && attribute.minLength && Number.isInteger(attribute.minLength) && 'min' in schema) {
            return schema.min(attribute.minLength, {
                ...translatedErrors.minLength,
                values: {
                    min: attribute.minLength
                }
            });
        }
        return schema;
    };
const addMaxLengthValidation = (attribute)=>(schema)=>{
        if ('maxLength' in attribute && attribute.maxLength && Number.isInteger(attribute.maxLength) && 'max' in schema) {
            return schema.max(attribute.maxLength, {
                ...translatedErrors.maxLength,
                values: {
                    max: attribute.maxLength
                }
            });
        }
        return schema;
    };
const addMinValidation = (attribute, options)=>(schema)=>{
        // do not validate min for draft
        if (options.status === 'draft') {
            return schema;
        }
        if ('min' in attribute && 'min' in schema) {
            const min = toInteger(attribute.min);
            if (min) {
                return schema.min(min, {
                    ...translatedErrors.min,
                    values: {
                        min
                    }
                });
            }
        }
        return schema;
    };
const addMaxValidation = (attribute)=>(schema)=>{
        if ('max' in attribute) {
            const max = toInteger(attribute.max);
            if ('max' in schema && max) {
                return schema.max(max, {
                    ...translatedErrors.max,
                    values: {
                        max
                    }
                });
            }
        }
        return schema;
    };
const toInteger = (val)=>{
    if (typeof val === 'number' || val === undefined) {
        return val;
    } else {
        const num = Number(val);
        return isNaN(num) ? undefined : num;
    }
};
const addRegexValidation = (attribute)=>(schema)=>{
        if ('regex' in attribute && attribute.regex && 'matches' in schema) {
            return schema.matches(new RegExp(attribute.regex), {
                message: {
                    id: translatedErrors.regex.id,
                    defaultMessage: 'The value does not match the defined pattern.'
                },
                excludeEmptyString: !attribute.required
            });
        }
        return schema;
    };

const initApi = contentManagerApi.injectEndpoints({
    endpoints: (builder)=>({
            getInitialData: builder.query({
                query: ()=>'/content-manager/init',
                transformResponse: (response)=>response.data,
                providesTags: [
                    'InitialData'
                ]
            })
        })
});
const { useGetInitialDataQuery } = initApi;

/**
 * @internal
 * @description Given a model UID, return the schema and the schemas
 * of the associated components within said model's schema. A wrapper
 * implementation around the `useGetInitialDataQuery` with a unique
 * `selectFromResult` function to memoize the calculation.
 *
 * If no model is provided, the hook will return all the schemas.
 */ const useContentTypeSchema = (model)=>{
    const { toggleNotification } = useNotification();
    const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();
    const { data, error, isLoading, isFetching } = useGetInitialDataQuery(undefined);
    const { components, contentType, contentTypes } = React.useMemo(()=>{
        const contentType = data?.contentTypes.find((ct)=>ct.uid === model);
        const componentsByKey = data?.components.reduce((acc, component)=>{
            acc[component.uid] = component;
            return acc;
        }, {});
        const components = extractContentTypeComponents(contentType?.attributes, componentsByKey);
        return {
            components: Object.keys(components).length === 0 ? undefined : components,
            contentType,
            contentTypes: data?.contentTypes ?? []
        };
    }, [
        model,
        data
    ]);
    React.useEffect(()=>{
        if (error) {
            toggleNotification({
                type: 'danger',
                message: formatAPIError(error)
            });
        }
    }, [
        toggleNotification,
        error,
        formatAPIError
    ]);
    return {
        // This must be memoized to avoid inifiinite re-renders where the empty object is different everytime.
        components: React.useMemo(()=>components ?? {}, [
            components
        ]),
        schema: contentType,
        schemas: contentTypes,
        isLoading: isLoading || isFetching
    };
};
/* -------------------------------------------------------------------------------------------------
 * extractContentTypeComponents
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description Extracts the components used in a content type's attributes recursively.
 */ const extractContentTypeComponents = (attributes = {}, allComponents = {})=>{
    const getComponents = (attributes)=>{
        return attributes.reduce((acc, attribute)=>{
            /**
       * If the attribute is a component or dynamiczone, we need to recursively
       * extract the component UIDs from its attributes.
       */ if (attribute.type === 'component') {
                const componentAttributes = Object.values(allComponents[attribute.component]?.attributes ?? {});
                acc.push(attribute.component, ...getComponents(componentAttributes));
            } else if (attribute.type === 'dynamiczone') {
                acc.push(...attribute.components, /**
           * Dynamic zones have an array of components, so we flatMap over them
           * performing the same search as above.
           */ ...attribute.components.flatMap((componentUid)=>{
                    const componentAttributes = Object.values(allComponents[componentUid]?.attributes ?? {});
                    return getComponents(componentAttributes);
                }));
            }
            return acc;
        }, []);
    };
    const componentUids = getComponents(Object.values(attributes));
    const uniqueComponentUids = [
        ...new Set(componentUids)
    ];
    const componentsByKey = uniqueComponentUids.reduce((acc, uid)=>{
        acc[uid] = allComponents[uid];
        return acc;
    }, {});
    return componentsByKey;
};

const HOOKS = {
    /**
   * Hook that allows to mutate the displayed headers of the list view table
   * @constant
   * @type {string}
   */ INJECT_COLUMN_IN_TABLE: 'Admin/CM/pages/ListView/inject-column-in-table',
    /**
   * Hook that allows to mutate the CM's collection types links pre-set filters
   * @constant
   * @type {string}
   */ MUTATE_COLLECTION_TYPES_LINKS: 'Admin/CM/pages/App/mutate-collection-types-links',
    /**
   * Hook that allows to mutate the CM's edit view layout
   * @constant
   * @type {string}
   */ MUTATE_EDIT_VIEW_LAYOUT: 'Admin/CM/pages/EditView/mutate-edit-view-layout',
    /**
   * Hook that allows to mutate the CM's single types links pre-set filters
   * @constant
   * @type {string}
   */ MUTATE_SINGLE_TYPES_LINKS: 'Admin/CM/pages/App/mutate-single-types-links'
};

const contentTypesApi = contentManagerApi.injectEndpoints({
    endpoints: (builder)=>({
            getContentTypeConfiguration: builder.query({
                query: (uid)=>({
                        url: `/content-manager/content-types/${uid}/configuration`,
                        method: 'GET'
                    }),
                transformResponse: (response)=>response.data,
                providesTags: (_result, _error, uid)=>[
                        {
                            type: 'ContentTypesConfiguration',
                            id: uid
                        },
                        {
                            type: 'ContentTypeSettings',
                            id: 'LIST'
                        }
                    ]
            }),
            getAllContentTypeSettings: builder.query({
                query: ()=>'/content-manager/content-types-settings',
                transformResponse: (response)=>response.data,
                providesTags: [
                    {
                        type: 'ContentTypeSettings',
                        id: 'LIST'
                    }
                ]
            }),
            updateContentTypeConfiguration: builder.mutation({
                query: ({ uid, ...body })=>({
                        url: `/content-manager/content-types/${uid}/configuration`,
                        method: 'PUT',
                        data: body
                    }),
                transformResponse: (response)=>response.data,
                invalidatesTags: (_result, _error, { uid })=>[
                        {
                            type: 'ContentTypesConfiguration',
                            id: uid
                        },
                        {
                            type: 'ContentTypeSettings',
                            id: 'LIST'
                        },
                        // Is this necessary?
                        {
                            type: 'InitialData'
                        }
                    ]
            })
        })
});
const { useGetContentTypeConfigurationQuery, useGetAllContentTypeSettingsQuery, useUpdateContentTypeConfigurationMutation } = contentTypesApi;

const checkIfAttributeIsDisplayable = (attribute)=>{
    const { type } = attribute;
    if (type === 'relation') {
        return !attribute.relation.toLowerCase().includes('morph');
    }
    return ![
        'json',
        'dynamiczone',
        'richtext',
        'password',
        'blocks'
    ].includes(type) && !!type;
};
/**
 * @internal
 * @description given an attribute, content-type schemas & component schemas, find the mainField name & type.
 * If the attribute does not need a `mainField` then we return undefined. If we do not find the type
 * of the field, we assume it's a string #sensible-defaults
 */ const getMainField = (attribute, mainFieldName, { schemas, components })=>{
    if (!mainFieldName) {
        return undefined;
    }
    const mainFieldType = attribute.type === 'component' ? components[attribute.component].attributes[mainFieldName].type : schemas.find((schema)=>schema.uid === attribute.targetModel)?.attributes[mainFieldName].type;
    return {
        name: mainFieldName,
        type: mainFieldType ?? 'string'
    };
};

/* -------------------------------------------------------------------------------------------------
 * useDocumentLayout
 * -----------------------------------------------------------------------------------------------*/ const DEFAULT_SETTINGS = {
    bulkable: false,
    filterable: false,
    searchable: false,
    pagination: false,
    defaultSortBy: '',
    defaultSortOrder: 'asc',
    mainField: 'id',
    pageSize: 10
};
/**
 * @alpha
 * @description This hook is used to get the layouts for either the edit view or list view of a specific content-type
 * including the layouts for the components used in the content-type. It also runs the mutation hook waterfall so the data
 * is consistent wherever it is used. It's a light wrapper around the `useDocument` hook, but provides the `skip` option a document
 * is not fetched, however, it does fetch the schemas & components if they do not already exist in the cache.
 *
 * If the fetch fails, it will display a notification to the user.
 *
 * @example
 * ```tsx
 * const { model } = useParams<{ model: string }>();
 * const { edit: { schema: layout } } = useDocumentLayout(model);
 *
 * return layout.map(panel => panel.map(row => row.map(field => <Field.Root {...field} />)))
 * ```
 *
 */ const useDocumentLayout = (model)=>{
    const { schema, components } = useDocument({
        model,
        collectionType: ''
    }, {
        skip: true
    });
    const [{ query }] = useQueryParams();
    const runHookWaterfall = useStrapiApp('useDocumentLayout', (state)=>state.runHookWaterfall);
    const { toggleNotification } = useNotification();
    const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();
    const { isLoading: isLoadingSchemas, schemas } = useContentTypeSchema();
    const { data, isLoading: isLoadingConfigs, error, isFetching: isFetchingConfigs } = useGetContentTypeConfigurationQuery(model);
    const isLoading = isLoadingSchemas || isFetchingConfigs || isLoadingConfigs;
    React.useEffect(()=>{
        if (error) {
            toggleNotification({
                type: 'danger',
                message: formatAPIError(error)
            });
        }
    }, [
        error,
        formatAPIError,
        toggleNotification
    ]);
    const editLayout = React.useMemo(()=>data && !isLoading ? formatEditLayout(data, {
            schemas,
            schema,
            components
        }) : {
            layout: [],
            components: {},
            metadatas: {},
            options: {},
            settings: DEFAULT_SETTINGS
        }, [
        data,
        isLoading,
        schemas,
        schema,
        components
    ]);
    const listLayout = React.useMemo(()=>{
        return data && !isLoading ? formatListLayout(data, {
            schemas,
            schema,
            components
        }) : {
            layout: [],
            metadatas: {},
            options: {},
            settings: DEFAULT_SETTINGS
        };
    }, [
        data,
        isLoading,
        schemas,
        schema,
        components
    ]);
    const { layout: edit } = React.useMemo(()=>runHookWaterfall(HOOKS.MUTATE_EDIT_VIEW_LAYOUT, {
            layout: editLayout,
            query
        }), [
        editLayout,
        query,
        runHookWaterfall
    ]);
    return {
        error,
        isLoading,
        edit,
        list: listLayout
    };
};
/* -------------------------------------------------------------------------------------------------
 * useDocLayout
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal this hook uses the internal useDoc hook, as such it shouldn't be used outside of the
 * content-manager because it won't work as intended.
 */ const useDocLayout = ()=>{
    const { model } = useDoc();
    return useDocumentLayout(model);
};
/**
 * @internal
 * @description takes the configuration data, the schema & the components used in the schema and formats the edit view
 * versions of the schema & components. This is then used to render the edit view of the content-type.
 */ const formatEditLayout = (data, { schemas, schema, components })=>{
    let currentPanelIndex = 0;
    /**
   * The fields arranged by the panels, new panels are made for dynamic zones only.
   */ const panelledEditAttributes = convertEditLayoutToFieldLayouts(data.contentType.layouts.edit, schema?.attributes, data.contentType.metadatas, {
        configurations: data.components,
        schemas: components
    }, schemas).reduce((panels, row)=>{
        if (row.some((field)=>field.type === 'dynamiczone')) {
            panels.push([
                row
            ]);
            currentPanelIndex += 2;
        } else {
            if (!panels[currentPanelIndex]) {
                panels.push([
                    row
                ]);
            } else {
                panels[currentPanelIndex].push(row);
            }
        }
        return panels;
    }, []);
    const componentEditAttributes = Object.entries(data.components).reduce((acc, [uid, configuration])=>{
        acc[uid] = {
            layout: convertEditLayoutToFieldLayouts(configuration.layouts.edit, components[uid].attributes, configuration.metadatas, {
                configurations: data.components,
                schemas: components
            }),
            settings: {
                ...configuration.settings,
                icon: components[uid].info.icon,
                displayName: components[uid].info.displayName
            }
        };
        return acc;
    }, {});
    const editMetadatas = Object.entries(data.contentType.metadatas).reduce((acc, [attribute, metadata])=>{
        return {
            ...acc,
            [attribute]: metadata.edit
        };
    }, {});
    return {
        layout: panelledEditAttributes,
        components: componentEditAttributes,
        metadatas: editMetadatas,
        settings: {
            ...data.contentType.settings,
            displayName: schema?.info.displayName
        },
        options: {
            ...schema?.options,
            ...schema?.pluginOptions,
            ...data.contentType.options
        }
    };
};
/* -------------------------------------------------------------------------------------------------
 * convertEditLayoutToFieldLayouts
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description takes the edit layout from either a content-type or a component
 * and formats it into a generic object that can be used to correctly render
 * the form fields.
 */ const convertEditLayoutToFieldLayouts = (rows, attributes = {}, metadatas, components, schemas = [])=>{
    return rows.map((row)=>row.map((field)=>{
            const attribute = attributes[field.name];
            if (!attribute) {
                return null;
            }
            const { edit: metadata } = metadatas[field.name];
            const settings = attribute.type === 'component' && components ? components.configurations[attribute.component].settings : {};
            return {
                attribute,
                disabled: !metadata.editable,
                hint: metadata.description,
                label: metadata.label ?? '',
                name: field.name,
                // @ts-expect-error – mainField does exist on the metadata for a relation.
                mainField: getMainField(attribute, metadata.mainField || settings.mainField, {
                    schemas,
                    components: components?.schemas ?? {}
                }),
                placeholder: metadata.placeholder ?? '',
                required: attribute.required ?? false,
                size: field.size,
                unique: 'unique' in attribute ? attribute.unique : false,
                visible: metadata.visible ?? true,
                type: attribute.type
            };
        }).filter((field)=>field !== null));
};
/* -------------------------------------------------------------------------------------------------
 * formatListLayout
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description takes the complete configuration data, the schema & the components used in the schema and
 * formats a list view layout for the content-type. This is much simpler than the edit view layout as there
 * are less options to consider.
 */ const formatListLayout = (data, { schemas, schema, components })=>{
    const listMetadatas = Object.entries(data.contentType.metadatas).reduce((acc, [attribute, metadata])=>{
        return {
            ...acc,
            [attribute]: metadata.list
        };
    }, {});
    /**
   * The fields arranged by the panels, new panels are made for dynamic zones only.
   */ const listAttributes = convertListLayoutToFieldLayouts(data.contentType.layouts.list, schema?.attributes, listMetadatas, {
        configurations: data.components,
        schemas: components
    }, schemas);
    return {
        layout: listAttributes,
        settings: {
            ...data.contentType.settings,
            displayName: schema?.info.displayName
        },
        metadatas: listMetadatas,
        options: {
            ...schema?.options,
            ...schema?.pluginOptions,
            ...data.contentType.options
        }
    };
};
/* -------------------------------------------------------------------------------------------------
 * convertListLayoutToFieldLayouts
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description takes the columns from the list view configuration and formats them into a generic object
 * combinining metadata and attribute data.
 *
 * @note We do use this to reformat the list of strings when updating the displayed headers for the list view.
 */ const convertListLayoutToFieldLayouts = (columns, attributes = {}, metadatas, components, schemas = [])=>{
    return columns.map((name)=>{
        const attribute = attributes[name];
        if (!attribute) {
            return null;
        }
        const metadata = metadatas[name];
        const settings = attribute.type === 'component' && components ? components.configurations[attribute.component].settings : {};
        return {
            attribute,
            label: metadata.label ?? '',
            mainField: getMainField(attribute, metadata.mainField || settings.mainField, {
                schemas,
                components: components?.schemas ?? {}
            }),
            name: name,
            searchable: metadata.searchable ?? true,
            sortable: metadata.sortable ?? true
        };
    }).filter((field)=>field !== null);
};

/* -------------------------------------------------------------------------------------------------
 * useDocument
 * -----------------------------------------------------------------------------------------------*/ /**
 * @alpha
 * @public
 * @description Returns a document based on the model, collection type & id passed as arguments.
 * Also extracts its schema from the redux cache to be used for creating a validation schema.
 * @example
 * ```tsx
 * const { id, model, collectionType } = useParams<{ id: string; model: string; collectionType: string }>();
 *
 * if(!model || !collectionType) return null;
 *
 * const { document, isLoading, validate } = useDocument({ documentId: id, model, collectionType, params: { locale: 'en-GB' } })
 * const { update } = useDocumentActions()
 *
 * const onSubmit = async (document: Document) => {
 *  const errors = validate(document);
 *
 *  if(errors) {
 *      // handle errors
 *  }
 *
 *  await update({ collectionType, model, id }, document)
 * }
 * ```
 *
 * @see {@link https://contributor.strapi.io/docs/core/content-manager/hooks/use-document} for more information
 */ const useDocument = (args, opts)=>{
    const { toggleNotification } = useNotification();
    const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();
    const { formatMessage } = useIntl();
    const { currentData: data, isLoading: isLoadingDocument, isFetching: isFetchingDocument, error, refetch } = useGetDocumentQuery(args, {
        ...opts,
        skip: !args.documentId && args.collectionType !== SINGLE_TYPES || opts?.skip
    });
    const document = data?.data;
    const meta = data?.meta;
    const { components, schema, schemas, isLoading: isLoadingSchema } = useContentTypeSchema(args.model);
    const isSingleType = schema?.kind === 'singleType';
    const getTitle = (mainField)=>{
        // Always use mainField if it's not an id
        if (mainField !== 'id' && document?.[mainField]) {
            return document[mainField];
        }
        // When it's a singleType without a mainField, use the contentType displayName
        if (isSingleType && schema?.info.displayName) {
            return schema.info.displayName;
        }
        // Otherwise, use a fallback
        return formatMessage({
            id: 'content-manager.containers.untitled',
            defaultMessage: 'Untitled'
        });
    };
    React.useEffect(()=>{
        if (error) {
            toggleNotification({
                type: 'danger',
                message: formatAPIError(error)
            });
        }
    }, [
        toggleNotification,
        error,
        formatAPIError,
        args.collectionType
    ]);
    const validationSchema = React.useMemo(()=>{
        if (!schema) {
            return null;
        }
        return createYupSchema(schema.attributes, components);
    }, [
        schema,
        components
    ]);
    const validate = React.useCallback((document)=>{
        if (!validationSchema) {
            throw new Error('There is no validation schema generated, this is likely due to the schema not being loaded yet.');
        }
        try {
            validationSchema.validateSync(document, {
                abortEarly: false,
                strict: true
            });
            return null;
        } catch (error) {
            if (error instanceof ValidationError) {
                return getYupValidationErrors(error);
            }
            throw error;
        }
    }, [
        validationSchema
    ]);
    /**
   * Here we prepare the form for editing, we need to:
   * - remove prohibited fields from the document (passwords | ADD YOURS WHEN THERES A NEW ONE)
   * - swap out count objects on relations for empty arrays
   * - set __temp_key__ on array objects for drag & drop
   *
   * We also prepare the form for new documents, so we need to:
   * - set default values on fields
   */ const getInitialFormValues = React.useCallback((isCreatingDocument = false)=>{
        if (!document && !isCreatingDocument && !isSingleType || !schema) {
            return undefined;
        }
        /**
       * Check that we have an ID so we know the
       * document has been created in some way.
       */ const form = document?.id ? document : createDefaultForm(schema, components);
        return transformDocument(schema, components)(form);
    }, [
        document,
        isSingleType,
        schema,
        components
    ]);
    const isLoading = isLoadingDocument || isFetchingDocument || isLoadingSchema;
    const hasError = !!error;
    return {
        components,
        document,
        meta,
        isLoading,
        hasError,
        schema,
        schemas,
        validate,
        getTitle,
        getInitialFormValues,
        refetch
    };
};
/* -------------------------------------------------------------------------------------------------
 * useDoc
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal this hook uses the router to extract the model, collection type & id from the url.
 * therefore, it shouldn't be used outside of the content-manager because it won't work as intended.
 */ const useDoc = ()=>{
    const { id, slug, collectionType, origin } = useParams();
    const [{ query }] = useQueryParams();
    const params = React.useMemo(()=>buildValidParams(query), [
        query
    ]);
    if (!collectionType) {
        throw new Error('Could not find collectionType in url params');
    }
    if (!slug) {
        throw new Error('Could not find model in url params');
    }
    const document = useDocument({
        documentId: origin || id,
        model: slug,
        collectionType,
        params
    }, {
        skip: id === 'create' || !origin && !id && collectionType !== SINGLE_TYPES
    });
    const returnId = origin || id === 'create' ? undefined : id;
    return {
        collectionType,
        model: slug,
        id: returnId,
        ...document
    };
};
/**
 * @public
 * @experimental
 * Content manager context hooks for plugin development.
 * Make sure to use this hook inside the content manager.
 */ const useContentManagerContext = ()=>{
    const { collectionType, model, id, components, isLoading: isLoadingDoc, schema, schemas } = useDoc();
    const layout = useDocumentLayout(model);
    const form = useForm('useContentManagerContext', (state)=>state);
    const isSingleType = collectionType === SINGLE_TYPES;
    const slug = model;
    const isCreatingEntry = id === 'create';
    useContentTypeSchema();
    const isLoading = isLoadingDoc || layout.isLoading;
    const error = layout.error;
    return {
        error,
        isLoading,
        // Base metadata
        model,
        collectionType,
        id,
        slug,
        isCreatingEntry,
        isSingleType,
        hasDraftAndPublish: schema?.options?.draftAndPublish ?? false,
        // All schema infos
        components,
        contentType: schema,
        contentTypes: schemas,
        // Form state
        form,
        // layout infos
        layout
    };
};

const prefixPluginTranslations = (trad, pluginId)=>{
    return Object.keys(trad).reduce((acc, current)=>{
        acc[`${pluginId}.${current}`] = trad[current];
        return acc;
    }, {});
};
const getTranslation = (id)=>`content-manager.${id}`;

const DEFAULT_UNEXPECTED_ERROR_MSG = {
    id: 'notification.error',
    defaultMessage: 'An error occurred, please try again'
};
/**
 * @alpha
 * @public
 * @description Contains all the operations that can be performed on a single document.
 * Designed to be able to be used anywhere within a Strapi app. The hooks will handle
 * notifications should the operation fail, however the response is always returned incase
 * the user needs to handle side-effects.
 * @example
 * ```tsx
 * import { Form } from '@strapi/admin/admin';
 *
 * const { id, model, collectionType } = useParams<{ id: string; model: string; collectionType: string }>();
 * const { update } = useDocumentActions();
 *
 * const handleSubmit = async (data) => {
 *  await update({ collectionType, model, documentId: id }, data);
 * }
 *
 * return <Form method="PUT" onSubmit={handleSubmit} />
 * ```
 *
 * @see {@link https://contributor.strapi.io/docs/core/content-manager/hooks/use-document-operations} for more information
 */ const useDocumentActions = ()=>{
    const { toggleNotification } = useNotification();
    const { formatMessage } = useIntl();
    const { trackUsage } = useTracking();
    const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();
    const navigate = useNavigate();
    const setCurrentStep = useGuidedTour('useDocumentActions', (state)=>state.setCurrentStep);
    const [deleteDocument, { isLoading: isDeleting }] = useDeleteDocumentMutation();
    const _delete = React.useCallback(async ({ collectionType, model, documentId, params }, trackerProperty)=>{
        try {
            trackUsage('willDeleteEntry', trackerProperty);
            const res = await deleteDocument({
                collectionType,
                model,
                documentId,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                return {
                    error: res.error
                };
            }
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.delete'),
                    defaultMessage: 'Deleted document'
                })
            });
            trackUsage('didDeleteEntry', trackerProperty);
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            trackUsage('didNotDeleteEntry', {
                error: err,
                ...trackerProperty
            });
            throw err;
        }
    }, [
        trackUsage,
        deleteDocument,
        toggleNotification,
        formatMessage,
        formatAPIError
    ]);
    const [deleteManyDocuments, { isLoading: isDeletingMany }] = useDeleteManyDocumentsMutation();
    const deleteMany = React.useCallback(async ({ model, documentIds, params })=>{
        try {
            trackUsage('willBulkDeleteEntries');
            const res = await deleteManyDocuments({
                model,
                documentIds,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                return {
                    error: res.error
                };
            }
            toggleNotification({
                type: 'success',
                title: formatMessage({
                    id: getTranslation('success.records.delete'),
                    defaultMessage: 'Successfully deleted.'
                }),
                message: ''
            });
            trackUsage('didBulkDeleteEntries');
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            trackUsage('didNotBulkDeleteEntries');
            throw err;
        }
    }, [
        trackUsage,
        deleteManyDocuments,
        toggleNotification,
        formatMessage,
        formatAPIError
    ]);
    const [discardDocument, { isLoading: isDiscardingDocument }] = useDiscardDocumentMutation();
    const discard = React.useCallback(async ({ collectionType, model, documentId, params })=>{
        try {
            const res = await discardDocument({
                collectionType,
                model,
                documentId,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                return {
                    error: res.error
                };
            }
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: 'content-manager.success.record.discard',
                    defaultMessage: 'Changes discarded'
                })
            });
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            throw err;
        }
    }, [
        discardDocument,
        formatAPIError,
        formatMessage,
        toggleNotification
    ]);
    const [publishDocument, { isLoading: isPublishing }] = usePublishDocumentMutation();
    const publish = React.useCallback(async ({ collectionType, model, documentId, params }, data)=>{
        try {
            trackUsage('willPublishEntry', {
                documentId
            });
            const res = await publishDocument({
                collectionType,
                model,
                documentId,
                data,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                return {
                    error: res.error
                };
            }
            trackUsage('didPublishEntry', {
                documentId
            });
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.publish'),
                    defaultMessage: 'Published document'
                })
            });
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            throw err;
        }
    }, [
        trackUsage,
        publishDocument,
        toggleNotification,
        formatMessage,
        formatAPIError
    ]);
    const [publishManyDocuments, { isLoading: isPublishingMany }] = usePublishManyDocumentsMutation();
    const publishMany = React.useCallback(async ({ model, documentIds, params })=>{
        try {
            // TODO Confirm tracking events for bulk publish?
            const res = await publishManyDocuments({
                model,
                documentIds,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                return {
                    error: res.error
                };
            }
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.publish'),
                    defaultMessage: 'Published document'
                })
            });
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            throw err;
        }
    }, [
        // trackUsage,
        publishManyDocuments,
        toggleNotification,
        formatMessage,
        formatAPIError
    ]);
    const [updateDocument, { isLoading: isUpdating }] = useUpdateDocumentMutation();
    const update = React.useCallback(async ({ collectionType, model, documentId, params }, data, trackerProperty)=>{
        try {
            trackUsage('willEditEntry', trackerProperty);
            const res = await updateDocument({
                collectionType,
                model,
                documentId,
                data,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                trackUsage('didNotEditEntry', {
                    error: res.error,
                    ...trackerProperty
                });
                return {
                    error: res.error
                };
            }
            trackUsage('didEditEntry', {
                ...trackerProperty,
                documentId: res.data.data.documentId
            });
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.save'),
                    defaultMessage: 'Saved document'
                })
            });
            return res.data;
        } catch (err) {
            trackUsage('didNotEditEntry', {
                error: err,
                ...trackerProperty
            });
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            throw err;
        }
    }, [
        trackUsage,
        updateDocument,
        toggleNotification,
        formatMessage,
        formatAPIError
    ]);
    const [unpublishDocument] = useUnpublishDocumentMutation();
    const unpublish = React.useCallback(async ({ collectionType, model, documentId, params }, discardDraft = false)=>{
        try {
            trackUsage('willUnpublishEntry');
            const res = await unpublishDocument({
                collectionType,
                model,
                documentId,
                params,
                data: {
                    discardDraft
                }
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                return {
                    error: res.error
                };
            }
            trackUsage('didUnpublishEntry');
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.unpublish'),
                    defaultMessage: 'Unpublished document'
                })
            });
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            throw err;
        }
    }, [
        trackUsage,
        unpublishDocument,
        toggleNotification,
        formatMessage,
        formatAPIError
    ]);
    const [unpublishManyDocuments, { isLoading: isUnpublishingMany }] = useUnpublishManyDocumentsMutation();
    const unpublishMany = React.useCallback(async ({ model, documentIds, params })=>{
        try {
            trackUsage('willBulkUnpublishEntries');
            const res = await unpublishManyDocuments({
                model,
                documentIds,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                return {
                    error: res.error
                };
            }
            trackUsage('didBulkUnpublishEntries');
            toggleNotification({
                type: 'success',
                title: formatMessage({
                    id: getTranslation('success.records.unpublish'),
                    defaultMessage: 'Successfully unpublished.'
                }),
                message: ''
            });
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            trackUsage('didNotBulkUnpublishEntries');
            throw err;
        }
    }, [
        trackUsage,
        unpublishManyDocuments,
        toggleNotification,
        formatMessage,
        formatAPIError
    ]);
    const [createDocument] = useCreateDocumentMutation();
    const create = React.useCallback(async ({ model, params }, data, trackerProperty)=>{
        try {
            const res = await createDocument({
                model,
                data,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                trackUsage('didNotCreateEntry', {
                    error: res.error,
                    ...trackerProperty
                });
                return {
                    error: res.error
                };
            }
            trackUsage('didCreateEntry', {
                ...trackerProperty,
                documentId: res.data.data.documentId
            });
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.save'),
                    defaultMessage: 'Saved document'
                })
            });
            setCurrentStep('contentManager.success');
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            trackUsage('didNotCreateEntry', {
                error: err,
                ...trackerProperty
            });
            throw err;
        }
    }, [
        createDocument,
        formatAPIError,
        formatMessage,
        toggleNotification,
        trackUsage
    ]);
    const [autoCloneDocument] = useAutoCloneDocumentMutation();
    const autoClone = React.useCallback(async ({ model, sourceId })=>{
        try {
            const res = await autoCloneDocument({
                model,
                sourceId
            });
            if ('error' in res) {
                return {
                    error: res.error
                };
            }
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.clone'),
                    defaultMessage: 'Cloned document'
                })
            });
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            throw err;
        }
    }, [
        autoCloneDocument,
        formatMessage,
        toggleNotification
    ]);
    const [cloneDocument] = useCloneDocumentMutation();
    const clone = React.useCallback(async ({ model, documentId, params }, body, trackerProperty)=>{
        try {
            const { id: _id, ...restBody } = body;
            /**
         * If we're cloning we want to post directly to this endpoint
         * so that the relations even if they're not listed in the EditView
         * are correctly attached to the entry.
         */ const res = await cloneDocument({
                model,
                sourceId: documentId,
                data: restBody,
                params
            });
            if ('error' in res) {
                toggleNotification({
                    type: 'danger',
                    message: formatAPIError(res.error)
                });
                trackUsage('didNotCreateEntry', {
                    error: res.error,
                    ...trackerProperty
                });
                return {
                    error: res.error
                };
            }
            trackUsage('didCreateEntry', trackerProperty);
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTranslation('success.record.clone'),
                    defaultMessage: 'Cloned document'
                })
            });
            // Redirect to normal edit view
            navigate(`../../${res.data.data.documentId}`, {
                relative: 'path'
            });
            return res.data;
        } catch (err) {
            toggleNotification({
                type: 'danger',
                message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
            });
            trackUsage('didNotCreateEntry', {
                error: err,
                ...trackerProperty
            });
            throw err;
        }
    }, [
        cloneDocument,
        trackUsage,
        toggleNotification,
        formatMessage,
        formatAPIError,
        navigate
    ]);
    const [getDoc] = useLazyGetDocumentQuery();
    const getDocument = React.useCallback(async (args)=>{
        const { data } = await getDoc(args);
        return data;
    }, [
        getDoc
    ]);
    return {
        isLoading: isPublishing || isUpdating || isDiscardingDocument || isDeleting || isDeletingMany || isUnpublishingMany || isPublishingMany,
        autoClone,
        clone,
        create,
        delete: _delete,
        deleteMany,
        discard,
        getDocument,
        publish,
        publishMany,
        unpublish,
        unpublishMany,
        update
    };
};

const ProtectedHistoryPage = /*#__PURE__*/ React.lazy(()=>import('./History-DClLuGIg.mjs').then((mod)=>({
            default: mod.ProtectedHistoryPage
        })));
/**
 * These routes will be merged with the rest of the Content Manager routes
 */ const routes$2 = [
    {
        path: ':collectionType/:slug/:id/history',
        Component: ProtectedHistoryPage
    },
    {
        path: ':collectionType/:slug/history',
        Component: ProtectedHistoryPage
    }
];

const ProtectedPreviewPage = /*#__PURE__*/ React.lazy(()=>import('./Preview-05BZGpV2.mjs').then((mod)=>({
            default: mod.ProtectedPreviewPage
        })));
const routes$1 = [
    {
        path: ':collectionType/:slug/:id/preview',
        Component: ProtectedPreviewPage
    },
    {
        path: ':collectionType/:slug/preview',
        Component: ProtectedPreviewPage
    }
];

const ProtectedEditViewPage = /*#__PURE__*/ lazy(()=>import('./EditViewPage-BAI2r49P.mjs').then((mod)=>({
            default: mod.ProtectedEditViewPage
        })));
const ProtectedListViewPage = /*#__PURE__*/ lazy(()=>import('./ListViewPage-Q0auz5lE.mjs').then((mod)=>({
            default: mod.ProtectedListViewPage
        })));
const ProtectedListConfiguration = /*#__PURE__*/ lazy(()=>import('./ListConfigurationPage-Do3UDres.mjs').then((mod)=>({
            default: mod.ProtectedListConfiguration
        })));
const ProtectedEditConfigurationPage = /*#__PURE__*/ lazy(()=>import('./EditConfigurationPage-KDwSFRyn.mjs').then((mod)=>({
            default: mod.ProtectedEditConfigurationPage
        })));
const ProtectedComponentConfigurationPage = /*#__PURE__*/ lazy(()=>import('./ComponentConfigurationPage-DKtL-tec.mjs').then((mod)=>({
            default: mod.ProtectedComponentConfigurationPage
        })));
const NoPermissions = /*#__PURE__*/ lazy(()=>import('./NoPermissionsPage-BAW7WY-M.mjs').then((mod)=>({
            default: mod.NoPermissions
        })));
const NoContentType = /*#__PURE__*/ lazy(()=>import('./NoContentTypePage-B_oOeOQb.mjs').then((mod)=>({
            default: mod.NoContentType
        })));
const CollectionTypePages = ()=>{
    const { collectionType } = useParams();
    /**
   * We only support two types of collections.
   */ if (collectionType !== COLLECTION_TYPES && collectionType !== SINGLE_TYPES) {
        return /*#__PURE__*/ jsx(Navigate, {
            to: "/404"
        });
    }
    return collectionType === COLLECTION_TYPES ? /*#__PURE__*/ jsx(ProtectedListViewPage, {}) : /*#__PURE__*/ jsx(ProtectedEditViewPage, {});
};
const CLONE_RELATIVE_PATH = ':collectionType/:slug/clone/:origin';
const CLONE_PATH = `/content-manager/${CLONE_RELATIVE_PATH}`;
const LIST_RELATIVE_PATH = ':collectionType/:slug';
const LIST_PATH = `/content-manager/collection-types/:slug`;
const routes = [
    {
        path: LIST_RELATIVE_PATH,
        element: /*#__PURE__*/ jsx(CollectionTypePages, {})
    },
    {
        path: ':collectionType/:slug/:id',
        Component: ProtectedEditViewPage
    },
    {
        path: CLONE_RELATIVE_PATH,
        Component: ProtectedEditViewPage
    },
    {
        path: ':collectionType/:slug/configurations/list',
        Component: ProtectedListConfiguration
    },
    {
        path: 'components/:slug/configurations/edit',
        Component: ProtectedComponentConfigurationPage
    },
    {
        path: ':collectionType/:slug/configurations/edit',
        Component: ProtectedEditConfigurationPage
    },
    {
        path: '403',
        Component: NoPermissions
    },
    {
        path: 'no-content-types',
        Component: NoContentType
    },
    ...routes$2,
    ...routes$1
];

const DocumentActions = ({ actions })=>{
    const { formatMessage } = useIntl();
    const [primaryAction, secondaryAction, ...restActions] = actions.filter((action)=>{
        if (action.position === undefined) {
            return true;
        }
        const positions = Array.isArray(action.position) ? action.position : [
            action.position
        ];
        return positions.includes('panel');
    });
    if (!primaryAction) {
        return null;
    }
    return /*#__PURE__*/ jsxs(Flex, {
        direction: "column",
        gap: 2,
        alignItems: "stretch",
        width: "100%",
        children: [
            /*#__PURE__*/ jsxs(Flex, {
                gap: 2,
                children: [
                    /*#__PURE__*/ jsx(DocumentActionButton, {
                        ...primaryAction,
                        variant: primaryAction.variant || 'default'
                    }),
                    restActions.length > 0 ? /*#__PURE__*/ jsx(DocumentActionsMenu, {
                        actions: restActions,
                        label: formatMessage({
                            id: 'content-manager.containers.edit.panels.default.more-actions',
                            defaultMessage: 'More document actions'
                        })
                    }) : null
                ]
            }),
            secondaryAction ? /*#__PURE__*/ jsx(DocumentActionButton, {
                ...secondaryAction,
                variant: secondaryAction.variant || 'secondary'
            }) : null
        ]
    });
};
const DocumentActionButton = (action)=>{
    const [dialogId, setDialogId] = React.useState(null);
    const { toggleNotification } = useNotification();
    const handleClick = (action)=>async (e)=>{
            const { onClick = ()=>false, dialog, id } = action;
            const muteDialog = await onClick(e);
            if (dialog && !muteDialog) {
                switch(dialog.type){
                    case 'notification':
                        toggleNotification({
                            title: dialog.title,
                            message: dialog.content,
                            type: dialog.status,
                            timeout: dialog.timeout,
                            onClose: dialog.onClose
                        });
                        break;
                    case 'dialog':
                    case 'modal':
                        e.preventDefault();
                        setDialogId(id);
                }
            }
        };
    const handleClose = ()=>{
        setDialogId(null);
    };
    return /*#__PURE__*/ jsxs(Fragment, {
        children: [
            /*#__PURE__*/ jsx(Button, {
                flex: "auto",
                startIcon: action.icon,
                disabled: action.disabled,
                onClick: handleClick(action),
                justifyContent: "center",
                variant: action.variant || 'default',
                paddingTop: "7px",
                paddingBottom: "7px",
                loading: action.loading,
                children: action.label
            }),
            action.dialog?.type === 'dialog' ? /*#__PURE__*/ jsx(DocumentActionConfirmDialog, {
                ...action.dialog,
                variant: action.dialog?.variant ?? action.variant,
                isOpen: dialogId === action.id,
                onClose: handleClose
            }) : null,
            action.dialog?.type === 'modal' ? /*#__PURE__*/ jsx(DocumentActionModal, {
                ...action.dialog,
                onModalClose: handleClose,
                isOpen: dialogId === action.id
            }) : null
        ]
    });
};
const MenuItem = styled(Menu.Item)`
  &:hover {
    background: ${({ theme, isVariantDanger, isDisabled })=>isVariantDanger && !isDisabled ? theme.colors.danger100 : 'neutral'};
  }
`;
const DocumentActionsMenu = ({ actions, children, label, variant = 'tertiary' })=>{
    const [isOpen, setIsOpen] = React.useState(false);
    const [dialogId, setDialogId] = React.useState(null);
    const { formatMessage } = useIntl();
    const { toggleNotification } = useNotification();
    const isDisabled = actions.every((action)=>action.disabled) || actions.length === 0;
    const handleClick = (action)=>async (e)=>{
            const { onClick = ()=>false, dialog, id } = action;
            const muteDialog = await onClick(e);
            if (dialog && !muteDialog) {
                switch(dialog.type){
                    case 'notification':
                        toggleNotification({
                            title: dialog.title,
                            message: dialog.content,
                            type: dialog.status,
                            timeout: dialog.timeout,
                            onClose: dialog.onClose
                        });
                        break;
                    case 'dialog':
                    case 'modal':
                        setDialogId(id);
                }
            }
        };
    const handleClose = ()=>{
        setDialogId(null);
        setIsOpen(false);
    };
    return /*#__PURE__*/ jsxs(Menu.Root, {
        open: isOpen,
        onOpenChange: setIsOpen,
        children: [
            /*#__PURE__*/ jsxs(Menu.Trigger, {
                disabled: isDisabled,
                size: "S",
                endIcon: null,
                paddingTop: "4px",
                paddingLeft: "7px",
                paddingRight: "7px",
                variant: variant,
                children: [
                    /*#__PURE__*/ jsx(More, {
                        "aria-hidden": true,
                        focusable: false
                    }),
                    /*#__PURE__*/ jsx(VisuallyHidden, {
                        tag: "span",
                        children: label || formatMessage({
                            id: 'content-manager.containers.edit.panels.default.more-actions',
                            defaultMessage: 'More document actions'
                        })
                    })
                ]
            }),
            /*#__PURE__*/ jsxs(Menu.Content, {
                maxHeight: undefined,
                popoverPlacement: "bottom-end",
                children: [
                    actions.map((action)=>{
                        return /*#__PURE__*/ jsx(MenuItem, {
                            disabled: action.disabled,
                            /* @ts-expect-error – TODO: this is an error in the DS where it is most likely a synthetic event, not regular. */ onSelect: handleClick(action),
                            display: "block",
                            isVariantDanger: action.variant === 'danger',
                            isDisabled: action.disabled,
                            children: /*#__PURE__*/ jsx(Flex, {
                                justifyContent: "space-between",
                                gap: 4,
                                children: /*#__PURE__*/ jsxs(Flex, {
                                    color: !action.disabled ? convertActionVariantToColor(action.variant) : 'inherit',
                                    gap: 2,
                                    tag: "span",
                                    children: [
                                        /*#__PURE__*/ jsx(Flex, {
                                            tag: "span",
                                            color: !action.disabled ? convertActionVariantToIconColor(action.variant) : 'inherit',
                                            children: action.icon
                                        }),
                                        action.label
                                    ]
                                })
                            })
                        }, action.id);
                    }),
                    children
                ]
            }),
            actions.map((action)=>{
                return /*#__PURE__*/ jsxs(React.Fragment, {
                    children: [
                        action.dialog?.type === 'dialog' ? /*#__PURE__*/ jsx(DocumentActionConfirmDialog, {
                            ...action.dialog,
                            variant: action.variant,
                            isOpen: dialogId === action.id,
                            onClose: handleClose
                        }) : null,
                        action.dialog?.type === 'modal' ? /*#__PURE__*/ jsx(DocumentActionModal, {
                            ...action.dialog,
                            onModalClose: handleClose,
                            isOpen: dialogId === action.id
                        }) : null
                    ]
                }, action.id);
            })
        ]
    });
};
const convertActionVariantToColor = (variant = 'secondary')=>{
    switch(variant){
        case 'danger':
            return 'danger600';
        case 'secondary':
            return undefined;
        case 'success':
            return 'success600';
        default:
            return 'primary600';
    }
};
const convertActionVariantToIconColor = (variant = 'secondary')=>{
    switch(variant){
        case 'danger':
            return 'danger600';
        case 'secondary':
            return 'neutral500';
        case 'success':
            return 'success600';
        default:
            return 'primary600';
    }
};
const DocumentActionConfirmDialog = ({ onClose, onCancel, onConfirm, title, content, isOpen, variant = 'secondary', loading })=>{
    const { formatMessage } = useIntl();
    const handleClose = async ()=>{
        if (onCancel) {
            await onCancel();
        }
        onClose();
    };
    const handleConfirm = async ()=>{
        if (onConfirm) {
            await onConfirm();
        }
        onClose();
    };
    return /*#__PURE__*/ jsx(Dialog.Root, {
        open: isOpen,
        onOpenChange: handleClose,
        children: /*#__PURE__*/ jsxs(Dialog.Content, {
            children: [
                /*#__PURE__*/ jsx(Dialog.Header, {
                    children: title
                }),
                /*#__PURE__*/ jsx(Dialog.Body, {
                    children: content
                }),
                /*#__PURE__*/ jsxs(Dialog.Footer, {
                    children: [
                        /*#__PURE__*/ jsx(Dialog.Cancel, {
                            children: /*#__PURE__*/ jsx(Button, {
                                variant: "tertiary",
                                fullWidth: true,
                                children: formatMessage({
                                    id: 'app.components.Button.cancel',
                                    defaultMessage: 'Cancel'
                                })
                            })
                        }),
                        /*#__PURE__*/ jsx(Button, {
                            onClick: handleConfirm,
                            variant: variant,
                            fullWidth: true,
                            loading: loading,
                            children: formatMessage({
                                id: 'app.components.Button.confirm',
                                defaultMessage: 'Confirm'
                            })
                        })
                    ]
                })
            ]
        })
    });
};
const DocumentActionModal = ({ isOpen, title, onClose, footer: Footer, content: Content, onModalClose })=>{
    const handleClose = ()=>{
        if (onClose) {
            onClose();
        }
        onModalClose();
    };
    return /*#__PURE__*/ jsx(Modal.Root, {
        open: isOpen,
        onOpenChange: handleClose,
        children: /*#__PURE__*/ jsxs(Modal.Content, {
            children: [
                /*#__PURE__*/ jsx(Modal.Header, {
                    children: /*#__PURE__*/ jsx(Modal.Title, {
                        children: title
                    })
                }),
                typeof Content === 'function' ? /*#__PURE__*/ jsx(Content, {
                    onClose: handleClose
                }) : /*#__PURE__*/ jsx(Modal.Body, {
                    children: Content
                }),
                typeof Footer === 'function' ? /*#__PURE__*/ jsx(Footer, {
                    onClose: handleClose
                }) : Footer
            ]
        })
    });
};
const transformData = (data)=>{
    if (Array.isArray(data)) {
        return data.map(transformData);
    }
    if (typeof data === 'object' && data !== null) {
        if ('apiData' in data) {
            return data.apiData;
        }
        return mapValues(transformData)(data);
    }
    return data;
};
/* -------------------------------------------------------------------------------------------------
 * DocumentActionComponents
 * -----------------------------------------------------------------------------------------------*/ const PublishAction$1 = ({ activeTab, documentId, model, collectionType, meta, document, onPreview })=>{
    const { schema } = useDoc();
    const navigate = useNavigate();
    const { toggleNotification } = useNotification();
    const { _unstableFormatValidationErrors: formatValidationErrors } = useAPIErrorHandler();
    const isListView = useMatch(LIST_PATH) !== null;
    const isCloning = useMatch(CLONE_PATH) !== null;
    const { id } = useParams();
    const { formatMessage } = useIntl();
    const canPublish = useDocumentRBAC('PublishAction', ({ canPublish })=>canPublish);
    const { publish, isLoading } = useDocumentActions();
    const [countDraftRelations, { isLoading: isLoadingDraftRelations, isError: isErrorDraftRelations }] = useLazyGetDraftRelationCountQuery();
    const [localCountOfDraftRelations, setLocalCountOfDraftRelations] = React.useState(0);
    const [serverCountOfDraftRelations, setServerCountOfDraftRelations] = React.useState(0);
    const [{ query, rawQuery }] = useQueryParams();
    const params = React.useMemo(()=>buildValidParams(query), [
        query
    ]);
    const modified = useForm('PublishAction', ({ modified })=>modified);
    const setSubmitting = useForm('PublishAction', ({ setSubmitting })=>setSubmitting);
    const isSubmitting = useForm('PublishAction', ({ isSubmitting })=>isSubmitting);
    const validate = useForm('PublishAction', (state)=>state.validate);
    const setErrors = useForm('PublishAction', (state)=>state.setErrors);
    const formValues = useForm('PublishAction', ({ values })=>values);
    React.useEffect(()=>{
        if (isErrorDraftRelations) {
            toggleNotification({
                type: 'danger',
                message: formatMessage({
                    id: getTranslation('error.records.fetch-draft-relatons'),
                    defaultMessage: 'An error occurred while fetching draft relations on this document.'
                })
            });
        }
    }, [
        isErrorDraftRelations,
        toggleNotification,
        formatMessage
    ]);
    React.useEffect(()=>{
        const localDraftRelations = new Set();
        /**
     * Extracts draft relations from the provided data object.
     * It checks for a connect array of relations.
     * If a relation has a status of 'draft', its id is added to the localDraftRelations set.
     */ const extractDraftRelations = (data)=>{
            const relations = data.connect || [];
            relations.forEach((relation)=>{
                if (relation.status === 'draft') {
                    localDraftRelations.add(relation.id);
                }
            });
        };
        /**
     * Recursively traverses the provided data object to extract draft relations from arrays within 'connect' keys.
     * If the data is an object, it looks for 'connect' keys to pass their array values to extractDraftRelations.
     * It recursively calls itself for any non-null objects it contains.
     */ const traverseAndExtract = (data)=>{
            Object.entries(data).forEach(([key, value])=>{
                if (key === 'connect' && Array.isArray(value)) {
                    extractDraftRelations({
                        connect: value
                    });
                } else if (typeof value === 'object' && value !== null) {
                    traverseAndExtract(value);
                }
            });
        };
        if (!documentId || modified) {
            traverseAndExtract(formValues);
            setLocalCountOfDraftRelations(localDraftRelations.size);
        }
    }, [
        documentId,
        modified,
        formValues,
        setLocalCountOfDraftRelations
    ]);
    React.useEffect(()=>{
        if (!document || !document.documentId || isListView) {
            return;
        }
        const fetchDraftRelationsCount = async ()=>{
            const { data, error } = await countDraftRelations({
                collectionType,
                model,
                documentId,
                params
            });
            if (error) {
                throw error;
            }
            if (data) {
                setServerCountOfDraftRelations(data.data);
            }
        };
        fetchDraftRelationsCount();
    }, [
        isListView,
        document,
        documentId,
        countDraftRelations,
        collectionType,
        model,
        params
    ]);
    const isDocumentPublished = (document?.[PUBLISHED_AT_ATTRIBUTE_NAME] || meta?.availableStatus.some((doc)=>doc[PUBLISHED_AT_ATTRIBUTE_NAME] !== null)) && document?.status !== 'modified';
    if (!schema?.options?.draftAndPublish) {
        return null;
    }
    const performPublish = async ()=>{
        setSubmitting(true);
        try {
            const { errors } = await validate(true, {
                status: 'published'
            });
            if (errors) {
                toggleNotification({
                    type: 'danger',
                    message: formatMessage({
                        id: 'content-manager.validation.error',
                        defaultMessage: 'There are validation errors in your document. Please fix them before saving.'
                    })
                });
                return;
            }
            const res = await publish({
                collectionType,
                model,
                documentId,
                params
            }, transformData(formValues));
            if ('data' in res && collectionType !== SINGLE_TYPES) {
                /**
         * TODO: refactor the router so we can just do `../${res.data.documentId}` instead of this.
         */ if (id === 'create') {
                    navigate({
                        pathname: `../${collectionType}/${model}/${res.data.documentId}`,
                        search: rawQuery
                    });
                }
            } else if ('error' in res && isBaseQueryError(res.error) && res.error.name === 'ValidationError') {
                setErrors(formatValidationErrors(res.error));
            }
        } finally{
            setSubmitting(false);
            if (onPreview) {
                onPreview();
            }
        }
    };
    const totalDraftRelations = localCountOfDraftRelations + serverCountOfDraftRelations;
    // TODO skipping this for now as there is a bug with the draft relation count that will be worked on separately
    // see RFC "Count draft relations" in Notion
    const enableDraftRelationsCount = false;
    const hasDraftRelations = enableDraftRelationsCount;
    return {
        loading: isLoading,
        position: [
            'panel',
            'preview'
        ],
        /**
     * Disabled when:
     *  - currently if you're cloning a document we don't support publish & clone at the same time.
     *  - the form is submitting
     *  - the active tab is the published tab
     *  - the document is already published & not modified
     *  - the document is being created & not modified
     *  - the user doesn't have the permission to publish
     */ disabled: isCloning || isSubmitting || isLoadingDraftRelations || activeTab === 'published' || !modified && isDocumentPublished || !modified && !document?.documentId || !canPublish,
        label: formatMessage({
            id: 'app.utils.publish',
            defaultMessage: 'Publish'
        }),
        onClick: async ()=>{
            await performPublish();
        },
        dialog: hasDraftRelations ? {
            type: 'dialog',
            variant: 'danger',
            footer: null,
            title: formatMessage({
                id: getTranslation(`popUpwarning.warning.bulk-has-draft-relations.title`),
                defaultMessage: 'Confirmation'
            }),
            content: formatMessage({
                id: getTranslation(`popUpwarning.warning.bulk-has-draft-relations.message`),
                defaultMessage: 'This entry is related to {count, plural, one {# draft entry} other {# draft entries}}. Publishing it could leave broken links in your app.'
            }, {
                count: totalDraftRelations
            }),
            onConfirm: async ()=>{
                await performPublish();
            }
        } : undefined
    };
};
PublishAction$1.type = 'publish';
PublishAction$1.position = [
    'panel',
    'preview'
];
const UpdateAction = ({ activeTab, documentId, model, collectionType, onPreview })=>{
    const navigate = useNavigate();
    const { toggleNotification } = useNotification();
    const { _unstableFormatValidationErrors: formatValidationErrors } = useAPIErrorHandler();
    const cloneMatch = useMatch(CLONE_PATH);
    const isCloning = cloneMatch !== null;
    const { formatMessage } = useIntl();
    const { create, update, clone, isLoading } = useDocumentActions();
    const [{ query, rawQuery }] = useQueryParams();
    const params = React.useMemo(()=>buildValidParams(query), [
        query
    ]);
    const isSubmitting = useForm('UpdateAction', ({ isSubmitting })=>isSubmitting);
    const modified = useForm('UpdateAction', ({ modified })=>modified);
    const setSubmitting = useForm('UpdateAction', ({ setSubmitting })=>setSubmitting);
    const document = useForm('UpdateAction', ({ values })=>values);
    const validate = useForm('UpdateAction', (state)=>state.validate);
    const setErrors = useForm('UpdateAction', (state)=>state.setErrors);
    const resetForm = useForm('PublishAction', ({ resetForm })=>resetForm);
    const handleUpdate = React.useCallback(async ()=>{
        setSubmitting(true);
        try {
            if (!modified) {
                return;
            }
            const { errors } = await validate(true, {
                status: 'draft'
            });
            if (errors) {
                toggleNotification({
                    type: 'danger',
                    message: formatMessage({
                        id: 'content-manager.validation.error',
                        defaultMessage: 'There are validation errors in your document. Please fix them before saving.'
                    })
                });
                return;
            }
            if (isCloning) {
                const res = await clone({
                    model,
                    documentId: cloneMatch.params.origin,
                    params
                }, transformData(document));
                if ('data' in res) {
                    navigate({
                        pathname: `../${res.data.documentId}`,
                        search: rawQuery
                    }, {
                        relative: 'path'
                    });
                } else if ('error' in res && isBaseQueryError(res.error) && res.error.name === 'ValidationError') {
                    setErrors(formatValidationErrors(res.error));
                }
            } else if (documentId || collectionType === SINGLE_TYPES) {
                const res = await update({
                    collectionType,
                    model,
                    documentId,
                    params
                }, transformData(document));
                if ('error' in res && isBaseQueryError(res.error) && res.error.name === 'ValidationError') {
                    setErrors(formatValidationErrors(res.error));
                } else {
                    resetForm();
                }
            } else {
                const res = await create({
                    model,
                    params
                }, transformData(document));
                if ('data' in res && collectionType !== SINGLE_TYPES) {
                    navigate({
                        pathname: `../${res.data.documentId}`,
                        search: rawQuery
                    }, {
                        replace: true,
                        relative: 'path'
                    });
                } else if ('error' in res && isBaseQueryError(res.error) && res.error.name === 'ValidationError') {
                    setErrors(formatValidationErrors(res.error));
                }
            }
        } finally{
            setSubmitting(false);
            if (onPreview) {
                onPreview();
            }
        }
    }, [
        clone,
        cloneMatch?.params.origin,
        collectionType,
        create,
        document,
        documentId,
        formatMessage,
        formatValidationErrors,
        isCloning,
        model,
        modified,
        navigate,
        params,
        rawQuery,
        resetForm,
        setErrors,
        setSubmitting,
        toggleNotification,
        update,
        validate
    ]);
    // Auto-save on CMD+S or CMD+Enter on macOS, and CTRL+S or CTRL+Enter on Windows/Linux
    React.useEffect(()=>{
        const handleKeyDown = (e)=>{
            if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                e.preventDefault();
                handleUpdate();
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return ()=>{
            window.removeEventListener('keydown', handleKeyDown);
        };
    }, [
        handleUpdate
    ]);
    return {
        loading: isLoading,
        /**
     * Disabled when:
     * - the form is submitting
     * - the document is not modified & we're not cloning (you can save a clone entity straight away)
     * - the active tab is the published tab
     */ disabled: isSubmitting || !modified && !isCloning || activeTab === 'published',
        label: formatMessage({
            id: 'global.save',
            defaultMessage: 'Save'
        }),
        onClick: handleUpdate,
        position: [
            'panel',
            'preview'
        ]
    };
};
UpdateAction.type = 'update';
UpdateAction.position = [
    'panel',
    'preview'
];
const UNPUBLISH_DRAFT_OPTIONS = {
    KEEP: 'keep',
    DISCARD: 'discard'
};
const UnpublishAction$1 = ({ activeTab, documentId, model, collectionType, document })=>{
    const { formatMessage } = useIntl();
    const { schema } = useDoc();
    const canPublish = useDocumentRBAC('UnpublishAction', ({ canPublish })=>canPublish);
    const { unpublish } = useDocumentActions();
    const [{ query }] = useQueryParams();
    const params = React.useMemo(()=>buildValidParams(query), [
        query
    ]);
    const { toggleNotification } = useNotification();
    const [shouldKeepDraft, setShouldKeepDraft] = React.useState(true);
    const isDocumentModified = document?.status === 'modified';
    const handleChange = (value)=>{
        setShouldKeepDraft(value === UNPUBLISH_DRAFT_OPTIONS.KEEP);
    };
    if (!schema?.options?.draftAndPublish) {
        return null;
    }
    return {
        disabled: !canPublish || activeTab === 'published' || document?.status !== 'published' && document?.status !== 'modified',
        label: formatMessage({
            id: 'app.utils.unpublish',
            defaultMessage: 'Unpublish'
        }),
        icon: /*#__PURE__*/ jsx(Cross, {}),
        onClick: async ()=>{
            /**
       * return if there's no id & we're in a collection type, or the status modified
       * for either collection type because we use a dialog to handle the process in
       * the latter case.
       */ if (!documentId && collectionType !== SINGLE_TYPES || isDocumentModified) {
                if (!documentId) {
                    // This should never, ever, happen.
                    console.error("You're trying to unpublish a document without an id, this is likely a bug with Strapi. Please open an issue.");
                    toggleNotification({
                        message: formatMessage({
                            id: 'content-manager.actions.unpublish.error',
                            defaultMessage: 'An error occurred while trying to unpublish the document.'
                        }),
                        type: 'danger'
                    });
                }
                return;
            }
            await unpublish({
                collectionType,
                model,
                documentId,
                params
            });
        },
        dialog: isDocumentModified ? {
            type: 'dialog',
            title: formatMessage({
                id: 'app.components.ConfirmDialog.title',
                defaultMessage: 'Confirmation'
            }),
            content: /*#__PURE__*/ jsxs(Flex, {
                alignItems: "flex-start",
                direction: "column",
                gap: 6,
                children: [
                    /*#__PURE__*/ jsxs(Flex, {
                        width: "100%",
                        direction: "column",
                        gap: 2,
                        children: [
                            /*#__PURE__*/ jsx(WarningCircle, {
                                width: "24px",
                                height: "24px",
                                fill: "danger600"
                            }),
                            /*#__PURE__*/ jsx(Typography, {
                                tag: "p",
                                variant: "omega",
                                textAlign: "center",
                                children: formatMessage({
                                    id: 'content-manager.actions.unpublish.dialog.body',
                                    defaultMessage: 'Are you sure?'
                                })
                            })
                        ]
                    }),
                    /*#__PURE__*/ jsxs(Radio.Group, {
                        defaultValue: UNPUBLISH_DRAFT_OPTIONS.KEEP,
                        name: "discard-options",
                        "aria-label": formatMessage({
                            id: 'content-manager.actions.unpublish.dialog.radio-label',
                            defaultMessage: 'Choose an option to unpublish the document.'
                        }),
                        onValueChange: handleChange,
                        children: [
                            /*#__PURE__*/ jsx(Radio.Item, {
                                checked: shouldKeepDraft,
                                value: UNPUBLISH_DRAFT_OPTIONS.KEEP,
                                children: formatMessage({
                                    id: 'content-manager.actions.unpublish.dialog.option.keep-draft',
                                    defaultMessage: 'Keep draft'
                                })
                            }),
                            /*#__PURE__*/ jsx(Radio.Item, {
                                checked: !shouldKeepDraft,
                                value: UNPUBLISH_DRAFT_OPTIONS.DISCARD,
                                children: formatMessage({
                                    id: 'content-manager.actions.unpublish.dialog.option.replace-draft',
                                    defaultMessage: 'Replace draft'
                                })
                            })
                        ]
                    })
                ]
            }),
            onConfirm: async ()=>{
                if (!documentId && collectionType !== SINGLE_TYPES) {
                    // This should never, ever, happen.
                    console.error("You're trying to unpublish a document without an id, this is likely a bug with Strapi. Please open an issue.");
                    toggleNotification({
                        message: formatMessage({
                            id: 'content-manager.actions.unpublish.error',
                            defaultMessage: 'An error occurred while trying to unpublish the document.'
                        }),
                        type: 'danger'
                    });
                }
                await unpublish({
                    collectionType,
                    model,
                    documentId,
                    params
                }, !shouldKeepDraft);
            }
        } : undefined,
        variant: 'danger',
        position: [
            'panel',
            'table-row'
        ]
    };
};
UnpublishAction$1.type = 'unpublish';
UnpublishAction$1.position = 'panel';
const DiscardAction = ({ activeTab, documentId, model, collectionType, document })=>{
    const { formatMessage } = useIntl();
    const { schema } = useDoc();
    const canUpdate = useDocumentRBAC('DiscardAction', ({ canUpdate })=>canUpdate);
    const { discard, isLoading } = useDocumentActions();
    const [{ query }] = useQueryParams();
    const params = React.useMemo(()=>buildValidParams(query), [
        query
    ]);
    if (!schema?.options?.draftAndPublish) {
        return null;
    }
    return {
        disabled: !canUpdate || activeTab === 'published' || document?.status !== 'modified',
        label: formatMessage({
            id: 'content-manager.actions.discard.label',
            defaultMessage: 'Discard changes'
        }),
        icon: /*#__PURE__*/ jsx(Cross, {}),
        position: [
            'panel',
            'table-row'
        ],
        variant: 'danger',
        dialog: {
            type: 'dialog',
            title: formatMessage({
                id: 'app.components.ConfirmDialog.title',
                defaultMessage: 'Confirmation'
            }),
            content: /*#__PURE__*/ jsxs(Flex, {
                direction: "column",
                gap: 2,
                children: [
                    /*#__PURE__*/ jsx(WarningCircle, {
                        width: "24px",
                        height: "24px",
                        fill: "danger600"
                    }),
                    /*#__PURE__*/ jsx(Typography, {
                        tag: "p",
                        variant: "omega",
                        textAlign: "center",
                        children: formatMessage({
                            id: 'content-manager.actions.discard.dialog.body',
                            defaultMessage: 'Are you sure?'
                        })
                    })
                ]
            }),
            loading: isLoading,
            onConfirm: async ()=>{
                await discard({
                    collectionType,
                    model,
                    documentId,
                    params
                });
            }
        }
    };
};
DiscardAction.type = 'discard';
DiscardAction.position = 'panel';
const DEFAULT_ACTIONS = [
    PublishAction$1,
    UpdateAction,
    UnpublishAction$1,
    DiscardAction
];

const intervals = [
    'years',
    'months',
    'days',
    'hours',
    'minutes',
    'seconds'
];
/**
 * Displays the relative time between a given timestamp and the current time.
 * You can display a custom message for given time intervals by passing an array of custom intervals.
 *
 * @example
 * ```jsx
 * <caption>Display "last hour" if the timestamp is less than an hour ago</caption>
 * <RelativeTime
 *  timestamp={new Date('2021-01-01')}
 *  customIntervals={[
 *   { unit: 'hours', threshold: 1, text: 'last hour' },
 *  ]}
 * ```
 */ const RelativeTime = /*#__PURE__*/ React.forwardRef(({ timestamp, customIntervals = [], ...restProps }, forwardedRef)=>{
    const { formatRelativeTime, formatDate, formatTime } = useIntl();
    /**
     * TODO: make this auto-update, like a clock.
     */ const interval = intervalToDuration({
        start: timestamp,
        end: Date.now()
    });
    const unit = intervals.find((intervalUnit)=>{
        return interval[intervalUnit] > 0 && Object.keys(interval).includes(intervalUnit);
    }) ?? 'seconds';
    const relativeTime = isPast(timestamp) ? -interval[unit] : interval[unit];
    // Display custom text if interval is less than the threshold
    const customInterval = customIntervals.find((custom)=>interval[custom.unit] < custom.threshold);
    const displayText = customInterval ? customInterval.text : formatRelativeTime(relativeTime, unit, {
        numeric: 'auto'
    });
    return /*#__PURE__*/ jsx("time", {
        ref: forwardedRef,
        dateTime: timestamp.toISOString(),
        role: "time",
        title: `${formatDate(timestamp)} ${formatTime(timestamp)}`,
        ...restProps,
        children: displayText
    });
});

/**
 * Retrieves the display name of an admin panel user
 */ const getDisplayName = ({ firstname, lastname, username, email } = {})=>{
    if (username) {
        return username;
    }
    // firstname is not required if the user is created with a username
    if (firstname) {
        return `${firstname} ${lastname ?? ''}`.trim();
    }
    return email ?? '';
};

const capitalise = (str)=>str.charAt(0).toUpperCase() + str.slice(1);

/**
 * @public
 * @description Displays the status of a document (draft, published, etc.)
 * and automatically calculates the appropriate variant for the status.
 */ const DocumentStatus = ({ status = 'draft', size = 'S', ...restProps })=>{
    const statusVariant = status === 'draft' ? 'secondary' : status === 'published' ? 'success' : 'alternative';
    const { formatMessage } = useIntl();
    return /*#__PURE__*/ jsx(Status, {
        ...restProps,
        size: size,
        variant: statusVariant,
        role: "status",
        "aria-labelledby": "document-status",
        children: /*#__PURE__*/ jsx(Typography, {
            tag: "span",
            variant: "omega",
            fontWeight: "bold",
            id: "document-status",
            children: formatMessage({
                id: `content-manager.containers.List.${status}`,
                defaultMessage: capitalise(status)
            })
        })
    });
};

const Header = ({ isCreating, status, title: documentTitle = 'Untitled' })=>{
    const { formatMessage } = useIntl();
    const isCloning = useMatch(CLONE_PATH) !== null;
    const params = useParams();
    const title = isCreating ? formatMessage({
        id: 'content-manager.containers.edit.title.new',
        defaultMessage: 'Create an entry'
    }) : documentTitle;
    return /*#__PURE__*/ jsxs(Flex, {
        direction: "column",
        alignItems: "flex-start",
        paddingTop: 6,
        paddingBottom: 4,
        gap: 2,
        children: [
            /*#__PURE__*/ jsx(BackButton, {
                fallback: params.collectionType === SINGLE_TYPES ? undefined : `../${COLLECTION_TYPES}/${params.slug}`
            }),
            /*#__PURE__*/ jsxs(Flex, {
                width: "100%",
                justifyContent: "space-between",
                gap: "80px",
                alignItems: "flex-start",
                children: [
                    /*#__PURE__*/ jsx(Typography, {
                        variant: "alpha",
                        tag: "h1",
                        children: title
                    }),
                    /*#__PURE__*/ jsx(HeaderToolbar, {})
                ]
            }),
            status ? /*#__PURE__*/ jsx(Box, {
                marginTop: 1,
                children: /*#__PURE__*/ jsx(DocumentStatus, {
                    status: isCloning ? 'draft' : status
                })
            }) : null
        ]
    });
};
/**
 * @description Contains the document actions that have `position: header`, if there are
 * none we still render the menu because we render the information about the document there.
 */ const HeaderToolbar = ()=>{
    const { formatMessage } = useIntl();
    const isCloning = useMatch(CLONE_PATH) !== null;
    const [{ query: { status = 'draft' } }] = useQueryParams();
    const { model, id, document, meta, collectionType } = useDoc();
    const plugins = useStrapiApp('HeaderToolbar', (state)=>state.plugins);
    return /*#__PURE__*/ jsxs(Flex, {
        gap: 2,
        children: [
            /*#__PURE__*/ jsx(DescriptionComponentRenderer, {
                props: {
                    activeTab: status,
                    model,
                    documentId: id,
                    document: isCloning ? undefined : document,
                    meta: isCloning ? undefined : meta,
                    collectionType
                },
                descriptions: plugins['content-manager'].apis.getHeaderActions(),
                children: (actions)=>{
                    if (actions.length > 0) {
                        return /*#__PURE__*/ jsx(HeaderActions, {
                            actions: actions
                        });
                    } else {
                        return null;
                    }
                }
            }),
            /*#__PURE__*/ jsx(DescriptionComponentRenderer, {
                props: {
                    activeTab: status,
                    model,
                    documentId: id,
                    document: isCloning ? undefined : document,
                    meta: isCloning ? undefined : meta,
                    collectionType
                },
                descriptions: plugins['content-manager'].apis.getDocumentActions('header'),
                children: (actions)=>{
                    const headerActions = actions.filter((action)=>{
                        const positions = Array.isArray(action.position) ? action.position : [
                            action.position
                        ];
                        return positions.includes('header');
                    });
                    return /*#__PURE__*/ jsx(DocumentActionsMenu, {
                        actions: headerActions,
                        label: formatMessage({
                            id: 'content-manager.containers.edit.header.more-actions',
                            defaultMessage: 'More actions'
                        }),
                        children: /*#__PURE__*/ jsx(Information, {
                            activeTab: status
                        })
                    });
                }
            })
        ]
    });
};
const Information = ({ activeTab })=>{
    const { formatMessage } = useIntl();
    const { document, meta } = useDoc();
    if (!document || !document.id) {
        return null;
    }
    /**
   * Because in the backend separate entries are made for draft and published
   * documents, the creator fields are different for each of them. For example,
   * you could make your draft in January and then publish it for the first time
   * in Feb. This would make the createdAt value for the published entry in Feb
   * but really we want to show the document as a whole. The draft entry will also
   * never have the publishedAt values.
   *
   * So, we decipher which document to show the creator for based on the activeTab.
   */ const createAndUpdateDocument = activeTab === 'draft' ? document : meta?.availableStatus.find((status)=>status.publishedAt === null);
    const publishDocument = activeTab === 'published' ? document : meta?.availableStatus.find((status)=>status.publishedAt !== null);
    const creator = createAndUpdateDocument?.[CREATED_BY_ATTRIBUTE_NAME] ? getDisplayName(createAndUpdateDocument[CREATED_BY_ATTRIBUTE_NAME]) : null;
    const updator = createAndUpdateDocument?.[UPDATED_BY_ATTRIBUTE_NAME] ? getDisplayName(createAndUpdateDocument[UPDATED_BY_ATTRIBUTE_NAME]) : null;
    const information = [
        {
            isDisplayed: !!publishDocument?.[PUBLISHED_AT_ATTRIBUTE_NAME],
            label: formatMessage({
                id: 'content-manager.containers.edit.information.last-published.label',
                defaultMessage: 'Published'
            }),
            value: formatMessage({
                id: 'content-manager.containers.edit.information.last-published.value',
                defaultMessage: `{time}{isAnonymous, select, true {} other { by {author}}}`
            }, {
                time: /*#__PURE__*/ jsx(RelativeTime, {
                    timestamp: new Date(publishDocument?.[PUBLISHED_AT_ATTRIBUTE_NAME])
                }),
                isAnonymous: !publishDocument?.[PUBLISHED_BY_ATTRIBUTE_NAME],
                author: publishDocument?.[PUBLISHED_BY_ATTRIBUTE_NAME] ? getDisplayName(publishDocument?.[PUBLISHED_BY_ATTRIBUTE_NAME]) : null
            })
        },
        {
            isDisplayed: !!createAndUpdateDocument?.[UPDATED_AT_ATTRIBUTE_NAME],
            label: formatMessage({
                id: 'content-manager.containers.edit.information.last-draft.label',
                defaultMessage: 'Updated'
            }),
            value: formatMessage({
                id: 'content-manager.containers.edit.information.last-draft.value',
                defaultMessage: `{time}{isAnonymous, select, true {} other { by {author}}}`
            }, {
                time: /*#__PURE__*/ jsx(RelativeTime, {
                    timestamp: new Date(createAndUpdateDocument?.[UPDATED_AT_ATTRIBUTE_NAME])
                }),
                isAnonymous: !updator,
                author: updator
            })
        },
        {
            isDisplayed: !!createAndUpdateDocument?.[CREATED_AT_ATTRIBUTE_NAME],
            label: formatMessage({
                id: 'content-manager.containers.edit.information.document.label',
                defaultMessage: 'Created'
            }),
            value: formatMessage({
                id: 'content-manager.containers.edit.information.document.value',
                defaultMessage: `{time}{isAnonymous, select, true {} other { by {author}}}`
            }, {
                time: /*#__PURE__*/ jsx(RelativeTime, {
                    timestamp: new Date(createAndUpdateDocument?.[CREATED_AT_ATTRIBUTE_NAME])
                }),
                isAnonymous: !creator,
                author: creator
            })
        }
    ].filter((info)=>info.isDisplayed);
    return /*#__PURE__*/ jsx(Flex, {
        borderWidth: "1px 0 0 0",
        borderStyle: "solid",
        borderColor: "neutral150",
        direction: "column",
        marginTop: 2,
        tag: "dl",
        padding: 5,
        gap: 3,
        alignItems: "flex-start",
        /**
       * The menu content has a padding of 4px, but we want our divider (the border top applied) to
       * be flush with the menu content. So we need to adjust the margin & width to account for the padding.
       */ marginLeft: "-0.4rem",
        marginRight: "-0.4rem",
        width: "calc(100% + 8px)",
        children: information.map((info)=>/*#__PURE__*/ jsxs(Flex, {
                gap: 1,
                direction: "column",
                alignItems: "flex-start",
                children: [
                    /*#__PURE__*/ jsx(Typography, {
                        tag: "dt",
                        variant: "pi",
                        fontWeight: "bold",
                        children: info.label
                    }),
                    /*#__PURE__*/ jsx(Typography, {
                        tag: "dd",
                        variant: "pi",
                        textColor: "neutral600",
                        children: info.value
                    })
                ]
            }, info.label))
    });
};
const HeaderActions = ({ actions })=>{
    const [dialogId, setDialogId] = React.useState(null);
    const handleClick = (action)=>async (e)=>{
            if (!('options' in action)) {
                const { onClick = ()=>false, dialog, id } = action;
                const muteDialog = await onClick(e);
                if (dialog && !muteDialog) {
                    e.preventDefault();
                    setDialogId(id);
                }
            }
        };
    const handleClose = ()=>{
        setDialogId(null);
    };
    return /*#__PURE__*/ jsx(Flex, {
        gap: 1,
        children: actions.map((action)=>{
            if (action.options) {
                return /*#__PURE__*/ jsx(SingleSelect, {
                    size: "S",
                    // @ts-expect-error – the DS will handle numbers, but we're not allowing the API.
                    onChange: action.onSelect,
                    "aria-label": action.label,
                    ...action,
                    children: action.options.map(({ label, ...option })=>/*#__PURE__*/ jsx(SingleSelectOption, {
                            ...option,
                            children: label
                        }, option.value))
                }, action.id);
            } else {
                if (action.type === 'icon') {
                    return /*#__PURE__*/ jsxs(React.Fragment, {
                        children: [
                            /*#__PURE__*/ jsx(IconButton, {
                                disabled: action.disabled,
                                label: action.label,
                                size: "S",
                                onClick: handleClick(action),
                                children: action.icon
                            }),
                            action.dialog ? /*#__PURE__*/ jsx(HeaderActionDialog, {
                                ...action.dialog,
                                isOpen: dialogId === action.id,
                                onClose: handleClose
                            }) : null
                        ]
                    }, action.id);
                }
            }
        })
    });
};
const HeaderActionDialog = ({ onClose, onCancel, title, content: Content, isOpen })=>{
    const handleClose = async ()=>{
        if (onCancel) {
            await onCancel();
        }
        onClose();
    };
    return /*#__PURE__*/ jsx(Dialog.Root, {
        open: isOpen,
        onOpenChange: handleClose,
        children: /*#__PURE__*/ jsxs(Dialog.Content, {
            children: [
                /*#__PURE__*/ jsx(Dialog.Header, {
                    children: title
                }),
                typeof Content === 'function' ? /*#__PURE__*/ jsx(Content, {
                    onClose: handleClose
                }) : Content
            ]
        })
    });
};
/* -------------------------------------------------------------------------------------------------
 * DocumentActionComponents
 * -----------------------------------------------------------------------------------------------*/ const ConfigureTheViewAction = ({ collectionType, model })=>{
    const navigate = useNavigate();
    const { formatMessage } = useIntl();
    return {
        label: formatMessage({
            id: 'app.links.configure-view',
            defaultMessage: 'Configure the view'
        }),
        icon: /*#__PURE__*/ jsx(ListPlus, {}),
        onClick: ()=>{
            navigate(`../${collectionType}/${model}/configurations/edit`);
        },
        position: 'header'
    };
};
ConfigureTheViewAction.type = 'configure-the-view';
ConfigureTheViewAction.position = 'header';
const EditTheModelAction = ({ model })=>{
    const navigate = useNavigate();
    const { formatMessage } = useIntl();
    return {
        label: formatMessage({
            id: 'content-manager.link-to-ctb',
            defaultMessage: 'Edit the model'
        }),
        icon: /*#__PURE__*/ jsx(Pencil, {}),
        onClick: ()=>{
            navigate(`/plugins/content-type-builder/content-types/${model}`);
        },
        position: 'header'
    };
};
EditTheModelAction.type = 'edit-the-model';
EditTheModelAction.position = 'header';
const DeleteAction$1 = ({ documentId, model, collectionType, document })=>{
    const navigate = useNavigate();
    const { formatMessage } = useIntl();
    const listViewPathMatch = useMatch(LIST_PATH);
    const canDelete = useDocumentRBAC('DeleteAction', (state)=>state.canDelete);
    const { delete: deleteAction, isLoading } = useDocumentActions();
    const { toggleNotification } = useNotification();
    const setSubmitting = useForm('DeleteAction', (state)=>state.setSubmitting);
    const isLocalized = document?.locale != null;
    return {
        disabled: !canDelete || !document,
        label: formatMessage({
            id: 'content-manager.actions.delete.label',
            defaultMessage: 'Delete entry{isLocalized, select, true { (all locales)} other {}}'
        }, {
            isLocalized
        }),
        icon: /*#__PURE__*/ jsx(Trash, {}),
        dialog: {
            type: 'dialog',
            title: formatMessage({
                id: 'app.components.ConfirmDialog.title',
                defaultMessage: 'Confirmation'
            }),
            content: /*#__PURE__*/ jsxs(Flex, {
                direction: "column",
                gap: 2,
                children: [
                    /*#__PURE__*/ jsx(WarningCircle, {
                        width: "24px",
                        height: "24px",
                        fill: "danger600"
                    }),
                    /*#__PURE__*/ jsx(Typography, {
                        tag: "p",
                        variant: "omega",
                        textAlign: "center",
                        children: formatMessage({
                            id: 'content-manager.actions.delete.dialog.body',
                            defaultMessage: 'Are you sure?'
                        })
                    })
                ]
            }),
            loading: isLoading,
            onConfirm: async ()=>{
                /**
         * If we have a match, we're in the list view
         * and therefore not in a form and shouldn't be
         * trying to set the submitting value.
         */ if (!listViewPathMatch) {
                    setSubmitting(true);
                }
                try {
                    if (!documentId && collectionType !== SINGLE_TYPES) {
                        console.error("You're trying to delete a document without an id, this is likely a bug with Strapi. Please open an issue.");
                        toggleNotification({
                            message: formatMessage({
                                id: 'content-manager.actions.delete.error',
                                defaultMessage: 'An error occurred while trying to delete the document.'
                            }),
                            type: 'danger'
                        });
                        return;
                    }
                    const res = await deleteAction({
                        documentId,
                        model,
                        collectionType,
                        params: {
                            locale: '*'
                        }
                    });
                    if (!('error' in res)) {
                        navigate({
                            pathname: `../${collectionType}/${model}`
                        }, {
                            replace: true
                        });
                    }
                } finally{
                    if (!listViewPathMatch) {
                        setSubmitting(false);
                    }
                }
            }
        },
        variant: 'danger',
        position: [
            'header',
            'table-row'
        ]
    };
};
DeleteAction$1.type = 'delete';
DeleteAction$1.position = [
    'header',
    'table-row'
];
const DEFAULT_HEADER_ACTIONS = [
    EditTheModelAction,
    ConfigureTheViewAction,
    DeleteAction$1
];

/* -------------------------------------------------------------------------------------------------
 * Panels
 * -----------------------------------------------------------------------------------------------*/ const Panels = ()=>{
    const isCloning = useMatch(CLONE_PATH) !== null;
    const [{ query: { status } }] = useQueryParams({
        status: 'draft'
    });
    const { model, id, document, meta, collectionType } = useDoc();
    const plugins = useStrapiApp('Panels', (state)=>state.plugins);
    const props = {
        activeTab: status,
        model,
        documentId: id,
        document: isCloning ? undefined : document,
        meta: isCloning ? undefined : meta,
        collectionType
    };
    return /*#__PURE__*/ jsx(Flex, {
        direction: "column",
        alignItems: "stretch",
        gap: 2,
        children: /*#__PURE__*/ jsx(DescriptionComponentRenderer, {
            props: props,
            descriptions: plugins['content-manager'].apis.getEditViewSidePanels(),
            children: (panels)=>panels.map(({ content, id, ...description })=>/*#__PURE__*/ jsx(Panel, {
                        ...description,
                        children: content
                    }, id))
        })
    });
};
/* -------------------------------------------------------------------------------------------------
 * Default Action Panels (CE)
 * -----------------------------------------------------------------------------------------------*/ const ActionsPanel = ()=>{
    const { formatMessage } = useIntl();
    return {
        title: formatMessage({
            id: 'content-manager.containers.edit.panels.default.title',
            defaultMessage: 'Entry'
        }),
        content: /*#__PURE__*/ jsx(ActionsPanelContent, {})
    };
};
ActionsPanel.type = 'actions';
const ActionsPanelContent = ()=>{
    const isCloning = useMatch(CLONE_PATH) !== null;
    const [{ query: { status = 'draft' } }] = useQueryParams();
    const { model, id, document, meta, collectionType } = useDoc();
    const plugins = useStrapiApp('ActionsPanel', (state)=>state.plugins);
    const props = {
        activeTab: status,
        model,
        documentId: id,
        document: isCloning ? undefined : document,
        meta: isCloning ? undefined : meta,
        collectionType
    };
    return /*#__PURE__*/ jsxs(Flex, {
        direction: "column",
        gap: 2,
        width: "100%",
        children: [
            /*#__PURE__*/ jsx(DescriptionComponentRenderer, {
                props: props,
                descriptions: plugins['content-manager'].apis.getDocumentActions('panel'),
                children: (actions)=>/*#__PURE__*/ jsx(DocumentActions, {
                        actions: actions
                    })
            }),
            /*#__PURE__*/ jsx(InjectionZone, {
                area: "editView.right-links",
                slug: model
            })
        ]
    });
};
const Panel = /*#__PURE__*/ React.forwardRef(({ children, title }, ref)=>{
    return /*#__PURE__*/ jsxs(Flex, {
        ref: ref,
        tag: "aside",
        "aria-labelledby": "additional-information",
        background: "neutral0",
        borderColor: "neutral150",
        hasRadius: true,
        paddingBottom: 4,
        paddingLeft: 4,
        paddingRight: 4,
        paddingTop: 4,
        shadow: "tableShadow",
        gap: 3,
        direction: "column",
        justifyContent: "stretch",
        alignItems: "flex-start",
        children: [
            /*#__PURE__*/ jsx(Typography, {
                tag: "h2",
                variant: "sigma",
                textTransform: "uppercase",
                textColor: "neutral600",
                children: title
            }),
            children
        ]
    });
});

const ConfirmBulkActionDialog = ({ onToggleDialog, isOpen = false, dialogBody, endAction })=>{
    const { formatMessage } = useIntl();
    return /*#__PURE__*/ jsx(Dialog.Root, {
        open: isOpen,
        children: /*#__PURE__*/ jsxs(Dialog.Content, {
            children: [
                /*#__PURE__*/ jsx(Dialog.Header, {
                    children: formatMessage({
                        id: 'app.components.ConfirmDialog.title',
                        defaultMessage: 'Confirmation'
                    })
                }),
                /*#__PURE__*/ jsx(Dialog.Body, {
                    children: /*#__PURE__*/ jsxs(Flex, {
                        direction: "column",
                        alignItems: "stretch",
                        gap: 2,
                        children: [
                            /*#__PURE__*/ jsx(Flex, {
                                justifyContent: "center",
                                children: /*#__PURE__*/ jsx(WarningCircle, {
                                    width: "24px",
                                    height: "24px",
                                    fill: "danger600"
                                })
                            }),
                            dialogBody
                        ]
                    })
                }),
                /*#__PURE__*/ jsxs(Dialog.Footer, {
                    children: [
                        /*#__PURE__*/ jsx(Dialog.Cancel, {
                            children: /*#__PURE__*/ jsx(Button, {
                                fullWidth: true,
                                onClick: onToggleDialog,
                                variant: "tertiary",
                                children: formatMessage({
                                    id: 'app.components.Button.cancel',
                                    defaultMessage: 'Cancel'
                                })
                            })
                        }),
                        endAction
                    ]
                })
            ]
        })
    });
};
/* -------------------------------------------------------------------------------------------------
 * BoldChunk
 * -----------------------------------------------------------------------------------------------*/ const BoldChunk = (chunks)=>/*#__PURE__*/ jsx(Typography, {
        fontWeight: "bold",
        children: chunks
    });
const ConfirmDialogPublishAll = ({ isOpen, onToggleDialog, isConfirmButtonLoading = false, onConfirm })=>{
    const { formatMessage } = useIntl();
    const selectedEntries = useTable('ConfirmDialogPublishAll', (state)=>state.selectedRows);
    const { toggleNotification } = useNotification();
    const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler(getTranslation);
    const { model, schema } = useDoc();
    const [{ query }] = useQueryParams();
    // TODO skipping this for now as there is a bug with the draft relation count that will be worked on separately
    // see RFC "Count draft relations" in Notion
    const enableDraftRelationsCount = false;
    const { data: countDraftRelations = 0, isLoading, error } = useGetManyDraftRelationCountQuery({
        model,
        documentIds: selectedEntries.map((entry)=>entry.documentId),
        locale: query?.plugins?.i18n?.locale
    }, {
        skip: !enableDraftRelationsCount
    });
    React.useEffect(()=>{
        if (error) {
            toggleNotification({
                type: 'danger',
                message: formatAPIError(error)
            });
        }
    }, [
        error,
        formatAPIError,
        toggleNotification
    ]);
    if (error) {
        return null;
    }
    return /*#__PURE__*/ jsx(ConfirmBulkActionDialog, {
        isOpen: isOpen && !isLoading,
        onToggleDialog: onToggleDialog,
        dialogBody: /*#__PURE__*/ jsxs(Fragment, {
            children: [
                /*#__PURE__*/ jsxs(Typography, {
                    id: "confirm-description",
                    textAlign: "center",
                    children: [
                        countDraftRelations > 0 && formatMessage({
                            id: getTranslation(`popUpwarning.warning.bulk-has-draft-relations.message`),
                            defaultMessage: '<b>{count} {count, plural, one { relation } other { relations } } out of {entities} { entities, plural, one { entry } other { entries } } {count, plural, one { is } other { are } }</b> not published yet and might lead to unexpected behavior. '
                        }, {
                            b: BoldChunk,
                            count: countDraftRelations,
                            entities: selectedEntries.length
                        }),
                        formatMessage({
                            id: getTranslation('popUpWarning.bodyMessage.contentType.publish.all'),
                            defaultMessage: 'Are you sure you want to publish these entries?'
                        })
                    ]
                }),
                schema?.pluginOptions && 'i18n' in schema.pluginOptions && schema?.pluginOptions.i18n && /*#__PURE__*/ jsx(Typography, {
                    textColor: "danger500",
                    textAlign: "center",
                    children: formatMessage({
                        id: getTranslation('Settings.list.actions.publishAdditionalInfos'),
                        defaultMessage: 'This will publish the active locale versions <em>(from Internationalization)</em>'
                    }, {
                        em: Emphasis
                    })
                })
            ]
        }),
        endAction: /*#__PURE__*/ jsx(Button, {
            onClick: onConfirm,
            variant: "secondary",
            startIcon: /*#__PURE__*/ jsx(Check, {}),
            loading: isConfirmButtonLoading,
            children: formatMessage({
                id: 'app.utils.publish',
                defaultMessage: 'Publish'
            })
        })
    });
};

const TypographyMaxWidth = styled(Typography)`
  max-width: 300px;
`;
const TableComponent = styled(RawTable)`
  width: 100%;
  table-layout: fixed;
  td:first-child {
    border-right: 1px solid ${({ theme })=>theme.colors.neutral150};
  }
  td:first-of-type {
    padding: ${({ theme })=>theme.spaces[4]};
  }
`;
/* -------------------------------------------------------------------------------------------------
 * EntryValidationText
 * -----------------------------------------------------------------------------------------------*/ const formatErrorMessages = (errors, parentKey, formatMessage)=>{
    const messages = [];
    Object.entries(errors).forEach(([key, value])=>{
        const currentKey = parentKey ? `${parentKey}.${key}` : key;
        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
            if ('id' in value && 'defaultMessage' in value) {
                messages.push(formatMessage({
                    id: `${value.id}.withField`,
                    defaultMessage: value.defaultMessage
                }, {
                    field: currentKey
                }));
            } else {
                messages.push(...formatErrorMessages(// @ts-expect-error TODO: check why value is not compatible with FormErrors
                value, currentKey, formatMessage));
            }
        } else {
            messages.push(formatMessage({
                id: `${value}.withField`,
                defaultMessage: value
            }, {
                field: currentKey
            }));
        }
    });
    return messages;
};
const EntryValidationText = ({ validationErrors, status })=>{
    const { formatMessage } = useIntl();
    if (validationErrors) {
        const validationErrorsMessages = formatErrorMessages(validationErrors, '', formatMessage).join(' ');
        return /*#__PURE__*/ jsxs(Flex, {
            gap: 2,
            children: [
                /*#__PURE__*/ jsx(CrossCircle, {
                    fill: "danger600"
                }),
                /*#__PURE__*/ jsx(Tooltip, {
                    description: validationErrorsMessages,
                    children: /*#__PURE__*/ jsx(TypographyMaxWidth, {
                        textColor: "danger600",
                        variant: "omega",
                        fontWeight: "semiBold",
                        ellipsis: true,
                        children: validationErrorsMessages
                    })
                })
            ]
        });
    }
    if (status === 'published') {
        return /*#__PURE__*/ jsxs(Flex, {
            gap: 2,
            children: [
                /*#__PURE__*/ jsx(CheckCircle, {
                    fill: "success600"
                }),
                /*#__PURE__*/ jsx(Typography, {
                    textColor: "success600",
                    fontWeight: "bold",
                    children: formatMessage({
                        id: 'content-manager.bulk-publish.already-published',
                        defaultMessage: 'Already Published'
                    })
                })
            ]
        });
    }
    if (status === 'modified') {
        return /*#__PURE__*/ jsxs(Flex, {
            gap: 2,
            children: [
                /*#__PURE__*/ jsx(ArrowsCounterClockwise, {
                    fill: "alternative600"
                }),
                /*#__PURE__*/ jsx(Typography, {
                    children: formatMessage({
                        id: 'content-manager.bulk-publish.modified',
                        defaultMessage: 'Ready to publish changes'
                    })
                })
            ]
        });
    }
    return /*#__PURE__*/ jsxs(Flex, {
        gap: 2,
        children: [
            /*#__PURE__*/ jsx(CheckCircle, {
                fill: "success600"
            }),
            /*#__PURE__*/ jsx(Typography, {
                children: formatMessage({
                    id: 'app.utils.ready-to-publish',
                    defaultMessage: 'Ready to publish'
                })
            })
        ]
    });
};
const TABLE_HEADERS = [
    {
        name: 'id',
        label: 'id'
    },
    {
        name: 'name',
        label: 'name'
    },
    {
        name: 'status',
        label: 'status'
    },
    {
        name: 'publicationStatus',
        label: 'Publication status'
    }
];
const SelectedEntriesTableContent = ({ isPublishing, rowsToDisplay = [], entriesToPublish = [], validationErrors = {} })=>{
    const { pathname } = useLocation();
    const { formatMessage } = useIntl();
    const { list: { settings: { mainField } } } = useDocLayout();
    const shouldDisplayMainField = mainField != null && mainField !== 'id';
    return /*#__PURE__*/ jsxs(Table.Content, {
        children: [
            /*#__PURE__*/ jsxs(Table.Head, {
                children: [
                    /*#__PURE__*/ jsx(Table.HeaderCheckboxCell, {}),
                    TABLE_HEADERS.filter((head)=>head.name !== 'name' || shouldDisplayMainField).map((head)=>/*#__PURE__*/ jsx(Table.HeaderCell, {
                            ...head
                        }, head.name))
                ]
            }),
            /*#__PURE__*/ jsx(Table.Loading, {}),
            /*#__PURE__*/ jsx(Table.Body, {
                children: rowsToDisplay.map((row)=>/*#__PURE__*/ jsxs(Table.Row, {
                        children: [
                            /*#__PURE__*/ jsx(Table.CheckboxCell, {
                                id: row.id
                            }),
                            /*#__PURE__*/ jsx(Table.Cell, {
                                children: /*#__PURE__*/ jsx(Typography, {
                                    children: row.id
                                })
                            }),
                            shouldDisplayMainField && /*#__PURE__*/ jsx(Table.Cell, {
                                children: /*#__PURE__*/ jsx(Typography, {
                                    children: row[mainField]
                                })
                            }),
                            /*#__PURE__*/ jsx(Table.Cell, {
                                children: /*#__PURE__*/ jsx(DocumentStatus, {
                                    status: row.status,
                                    maxWidth: 'min-content'
                                })
                            }),
                            /*#__PURE__*/ jsx(Table.Cell, {
                                children: isPublishing && entriesToPublish.includes(row.documentId) ? /*#__PURE__*/ jsxs(Flex, {
                                    gap: 2,
                                    children: [
                                        /*#__PURE__*/ jsx(Typography, {
                                            children: formatMessage({
                                                id: 'content-manager.success.record.publishing',
                                                defaultMessage: 'Publishing...'
                                            })
                                        }),
                                        /*#__PURE__*/ jsx(Loader, {
                                            small: true
                                        })
                                    ]
                                }) : /*#__PURE__*/ jsx(EntryValidationText, {
                                    validationErrors: validationErrors[row.documentId],
                                    status: row.status
                                })
                            }),
                            /*#__PURE__*/ jsx(Table.Cell, {
                                children: /*#__PURE__*/ jsx(Flex, {
                                    children: /*#__PURE__*/ jsx(IconButton, {
                                        tag: Link,
                                        to: {
                                            pathname: `${pathname}/${row.documentId}`,
                                            search: row.locale && `?plugins[i18n][locale]=${row.locale}`
                                        },
                                        state: {
                                            from: pathname
                                        },
                                        label: formatMessage({
                                            id: 'content-manager.bulk-publish.edit',
                                            defaultMessage: 'Edit'
                                        }),
                                        target: "_blank",
                                        marginLeft: "auto",
                                        variant: "ghost",
                                        children: /*#__PURE__*/ jsx(Pencil, {
                                            width: '1.6rem',
                                            height: '1.6rem'
                                        })
                                    })
                                })
                            })
                        ]
                    }, row.id))
            })
        ]
    });
};
const PublicationStatusSummary = ({ count, icon, message })=>{
    return /*#__PURE__*/ jsxs(Flex, {
        justifyContent: "space-between",
        flex: 1,
        gap: 3,
        children: [
            /*#__PURE__*/ jsxs(Flex, {
                gap: 2,
                children: [
                    icon,
                    /*#__PURE__*/ jsx(Typography, {
                        children: message
                    })
                ]
            }),
            /*#__PURE__*/ jsx(Typography, {
                fontWeight: "bold",
                children: count
            })
        ]
    });
};
const PublicationStatusGrid = ({ entriesReadyToPublishCount, entriesPublishedCount, entriesModifiedCount, entriesWithErrorsCount })=>{
    const { formatMessage } = useIntl();
    return /*#__PURE__*/ jsx(Box, {
        hasRadius: true,
        borderColor: "neutral150",
        children: /*#__PURE__*/ jsx(TableComponent, {
            colCount: 2,
            rowCount: 2,
            children: /*#__PURE__*/ jsxs(Tbody, {
                children: [
                    /*#__PURE__*/ jsxs(Tr, {
                        children: [
                            /*#__PURE__*/ jsx(Td, {
                                children: /*#__PURE__*/ jsx(PublicationStatusSummary, {
                                    count: entriesReadyToPublishCount,
                                    icon: /*#__PURE__*/ jsx(CheckCircle, {
                                        fill: "success600"
                                    }),
                                    message: formatMessage({
                                        id: 'app.utils.ready-to-publish',
                                        defaultMessage: 'Ready to publish'
                                    })
                                })
                            }),
                            /*#__PURE__*/ jsx(Td, {
                                children: /*#__PURE__*/ jsx(PublicationStatusSummary, {
                                    count: entriesPublishedCount,
                                    icon: /*#__PURE__*/ jsx(CheckCircle, {
                                        fill: "success600"
                                    }),
                                    message: formatMessage({
                                        id: 'app.utils.already-published',
                                        defaultMessage: 'Already published'
                                    })
                                })
                            })
                        ]
                    }),
                    /*#__PURE__*/ jsxs(Tr, {
                        children: [
                            /*#__PURE__*/ jsx(Td, {
                                children: /*#__PURE__*/ jsx(PublicationStatusSummary, {
                                    count: entriesModifiedCount,
                                    icon: /*#__PURE__*/ jsx(ArrowsCounterClockwise, {
                                        fill: "alternative600"
                                    }),
                                    message: formatMessage({
                                        id: 'content-manager.bulk-publish.modified',
                                        defaultMessage: 'Ready to publish changes'
                                    })
                                })
                            }),
                            /*#__PURE__*/ jsx(Td, {
                                children: /*#__PURE__*/ jsx(PublicationStatusSummary, {
                                    count: entriesWithErrorsCount,
                                    icon: /*#__PURE__*/ jsx(CrossCircle, {
                                        fill: "danger600"
                                    }),
                                    message: formatMessage({
                                        id: 'content-manager.bulk-publish.waiting-for-action',
                                        defaultMessage: 'Waiting for action'
                                    })
                                })
                            })
                        ]
                    })
                ]
            })
        })
    });
};
const SelectedEntriesModalContent = ({ listViewSelectedEntries, toggleModal, setListViewSelectedDocuments, model })=>{
    const { formatMessage } = useIntl();
    const { schema, components } = useContentTypeSchema(model);
    const documentIds = listViewSelectedEntries.map(({ documentId })=>documentId);
    // We want to keep the selected entries order same as the list view
    const [{ query }] = useQueryParams();
    const params = React.useMemo(()=>buildValidParams(query), [
        query
    ]);
    // Fetch the documents based on the selected entries and update the modal table
    const { data, isLoading, isFetching, refetch } = useGetAllDocumentsQuery({
        model,
        params: {
            page: '1',
            pageSize: documentIds.length.toString(),
            sort: query.sort,
            filters: {
                documentId: {
                    $in: documentIds
                }
            },
            locale: query.plugins?.i18n?.locale
        }
    }, {
        selectFromResult: ({ data, ...restRes })=>({
                data: data?.results ?? [],
                ...restRes
            })
    });
    // Validate the entries based on the schema to show errors if any
    const { rows, validationErrors } = React.useMemo(()=>{
        if (data.length > 0 && schema) {
            const validate = createYupSchema(schema.attributes, components, // Since this is the "Publish" action, the validation
            // schema must enforce the rules for published entities
            {
                status: 'published'
            });
            const validationErrors = {};
            const rows = data.map((entry)=>{
                try {
                    validate.validateSync(entry, {
                        abortEarly: false
                    });
                    return entry;
                } catch (e) {
                    if (e instanceof ValidationError) {
                        validationErrors[entry.documentId] = getYupValidationErrors(e);
                    }
                    return entry;
                }
            });
            return {
                rows,
                validationErrors
            };
        }
        return {
            rows: [],
            validationErrors: {}
        };
    }, [
        components,
        data,
        schema
    ]);
    const [isDialogOpen, setIsDialogOpen] = React.useState(false);
    const { publishMany: bulkPublishAction, isLoading: isPublishing } = useDocumentActions();
    const [, { isLoading: isSubmittingForm }] = usePublishManyDocumentsMutation();
    const selectedRows = useTable('publishAction', (state)=>state.selectedRows);
    // Filter selected entries from the updated modal table rows
    const selectedEntries = rows.filter((entry)=>selectedRows.some((selectedEntry)=>selectedEntry.documentId === entry.documentId));
    const entriesToPublish = selectedEntries.filter((entry)=>!validationErrors[entry.documentId]).map((entry)=>entry.documentId);
    const selectedEntriesWithErrorsCount = selectedEntries.filter(({ documentId })=>validationErrors[documentId]).length;
    const selectedEntriesPublishedCount = selectedEntries.filter(({ status })=>status === 'published').length;
    const selectedEntriesModifiedCount = selectedEntries.filter(({ status, documentId })=>status === 'modified' && !validationErrors[documentId]).length;
    const selectedEntriesWithNoErrorsCount = selectedEntries.length - selectedEntriesWithErrorsCount - selectedEntriesPublishedCount;
    const toggleDialog = ()=>setIsDialogOpen((prev)=>!prev);
    const handleConfirmBulkPublish = async ()=>{
        toggleDialog();
        const res = await bulkPublishAction({
            model: model,
            documentIds: entriesToPublish,
            params
        });
        if (!('error' in res)) {
            const unpublishedEntries = rows.filter((row)=>{
                return !entriesToPublish.includes(row.documentId);
            });
            // Keep selection of the entries in list view that were not published
            setListViewSelectedDocuments(unpublishedEntries);
        }
    };
    return /*#__PURE__*/ jsxs(Fragment, {
        children: [
            /*#__PURE__*/ jsxs(Modal.Body, {
                children: [
                    /*#__PURE__*/ jsx(PublicationStatusGrid, {
                        entriesReadyToPublishCount: selectedEntriesWithNoErrorsCount - selectedEntriesModifiedCount,
                        entriesPublishedCount: selectedEntriesPublishedCount,
                        entriesModifiedCount: selectedEntriesModifiedCount,
                        entriesWithErrorsCount: selectedEntriesWithErrorsCount
                    }),
                    /*#__PURE__*/ jsx(Box, {
                        marginTop: 7,
                        children: /*#__PURE__*/ jsx(SelectedEntriesTableContent, {
                            isPublishing: isSubmittingForm,
                            rowsToDisplay: rows,
                            entriesToPublish: entriesToPublish,
                            validationErrors: validationErrors
                        })
                    })
                ]
            }),
            /*#__PURE__*/ jsxs(Modal.Footer, {
                children: [
                    /*#__PURE__*/ jsx(Button, {
                        onClick: toggleModal,
                        variant: "tertiary",
                        children: formatMessage({
                            id: 'app.components.Button.cancel',
                            defaultMessage: 'Cancel'
                        })
                    }),
                    /*#__PURE__*/ jsxs(Flex, {
                        gap: 2,
                        children: [
                            /*#__PURE__*/ jsx(Button, {
                                onClick: refetch,
                                variant: "tertiary",
                                loading: isFetching,
                                children: formatMessage({
                                    id: 'app.utils.refresh',
                                    defaultMessage: 'Refresh'
                                })
                            }),
                            /*#__PURE__*/ jsx(Button, {
                                onClick: toggleDialog,
                                disabled: selectedEntries.length === 0 || selectedEntries.length === selectedEntriesWithErrorsCount || selectedEntriesPublishedCount === selectedEntries.length || isLoading,
                                loading: isPublishing || isSubmittingForm,
                                children: formatMessage({
                                    id: 'app.utils.publish',
                                    defaultMessage: 'Publish'
                                })
                            })
                        ]
                    })
                ]
            }),
            /*#__PURE__*/ jsx(ConfirmDialogPublishAll, {
                isOpen: isDialogOpen,
                onToggleDialog: toggleDialog,
                isConfirmButtonLoading: isPublishing || isSubmittingForm,
                onConfirm: handleConfirmBulkPublish
            })
        ]
    });
};
/* -------------------------------------------------------------------------------------------------
 * PublishAction
 * -----------------------------------------------------------------------------------------------*/ const PublishAction = ({ documents, model })=>{
    const { formatMessage } = useIntl();
    // Publish button visibility
    const hasPublishPermission = useDocumentRBAC('unpublishAction', (state)=>state.canPublish);
    const showPublishButton = hasPublishPermission && documents.some(({ status })=>status !== 'published');
    const setListViewSelectedDocuments = useTable('publishAction', (state)=>state.selectRow);
    const refetchList = ()=>{
        contentManagerApi.util.invalidateTags([
            {
                type: 'Document',
                id: `${model}_LIST`
            }
        ]);
    };
    if (!showPublishButton) return null;
    return {
        actionType: 'publish',
        variant: 'tertiary',
        label: formatMessage({
            id: 'app.utils.publish',
            defaultMessage: 'Publish'
        }),
        dialog: {
            type: 'modal',
            title: formatMessage({
                id: getTranslation('containers.ListPage.selectedEntriesModal.title'),
                defaultMessage: 'Publish entries'
            }),
            content: ({ onClose })=>{
                return /*#__PURE__*/ jsx(Table.Root, {
                    rows: documents,
                    defaultSelectedRows: documents,
                    headers: TABLE_HEADERS,
                    children: /*#__PURE__*/ jsx(SelectedEntriesModalContent, {
                        listViewSelectedEntries: documents,
                        toggleModal: ()=>{
                            onClose();
                            refetchList();
                        },
                        setListViewSelectedDocuments: setListViewSelectedDocuments,
                        model: model
                    })
                });
            },
            onClose: ()=>{
                refetchList();
            }
        }
    };
};

/* -------------------------------------------------------------------------------------------------
 * BulkActionsRenderer
 * -----------------------------------------------------------------------------------------------*/ const BulkActionsRenderer = ()=>{
    const plugins = useStrapiApp('BulkActionsRenderer', (state)=>state.plugins);
    const { model, collectionType } = useDoc();
    const { selectedRows } = useTable('BulkActionsRenderer', (state)=>state);
    return /*#__PURE__*/ jsx(Flex, {
        gap: 2,
        children: /*#__PURE__*/ jsx(DescriptionComponentRenderer, {
            props: {
                model,
                collectionType,
                documents: selectedRows
            },
            descriptions: plugins['content-manager'].apis.getBulkActions(),
            children: (actions)=>actions.map((action)=>/*#__PURE__*/ jsx(DocumentActionButton, {
                        ...action
                    }, action.id))
        })
    });
};
/* -------------------------------------------------------------------------------------------------
 * DefaultBulkActions
 * -----------------------------------------------------------------------------------------------*/ const DeleteAction = ({ documents, model })=>{
    const { formatMessage } = useIntl();
    const { schema: contentType } = useDoc();
    const selectRow = useTable('DeleteAction', (state)=>state.selectRow);
    const hasI18nEnabled = Boolean(contentType?.pluginOptions?.i18n);
    const [{ query }] = useQueryParams();
    const params = React.useMemo(()=>buildValidParams(query), [
        query
    ]);
    const hasDeletePermission = useDocumentRBAC('deleteAction', (state)=>state.canDelete);
    const { deleteMany: bulkDeleteAction, isLoading } = useDocumentActions();
    const documentIds = documents.map(({ documentId })=>documentId);
    const handleConfirmBulkDelete = async ()=>{
        const res = await bulkDeleteAction({
            documentIds,
            model,
            params
        });
        if (!('error' in res)) {
            selectRow([]);
        }
    };
    if (!hasDeletePermission) return null;
    return {
        variant: 'danger-light',
        label: formatMessage({
            id: 'global.delete',
            defaultMessage: 'Delete'
        }),
        dialog: {
            type: 'dialog',
            title: formatMessage({
                id: 'app.components.ConfirmDialog.title',
                defaultMessage: 'Confirmation'
            }),
            loading: isLoading,
            content: /*#__PURE__*/ jsxs(Flex, {
                direction: "column",
                alignItems: "stretch",
                gap: 2,
                children: [
                    /*#__PURE__*/ jsx(Flex, {
                        justifyContent: "center",
                        children: /*#__PURE__*/ jsx(WarningCircle, {
                            width: "24px",
                            height: "24px",
                            fill: "danger600"
                        })
                    }),
                    /*#__PURE__*/ jsx(Typography, {
                        id: "confirm-description",
                        textAlign: "center",
                        children: formatMessage({
                            id: 'popUpWarning.bodyMessage.contentType.delete.all',
                            defaultMessage: 'Are you sure you want to delete these entries?'
                        })
                    }),
                    hasI18nEnabled && /*#__PURE__*/ jsx(Box, {
                        textAlign: "center",
                        padding: 3,
                        children: /*#__PURE__*/ jsx(Typography, {
                            textColor: "danger500",
                            children: formatMessage({
                                id: getTranslation('Settings.list.actions.deleteAdditionalInfos'),
                                defaultMessage: 'This will delete the active locale versions <em>(from Internationalization)</em>'
                            }, {
                                em: Emphasis
                            })
                        })
                    })
                ]
            }),
            onConfirm: handleConfirmBulkDelete
        }
    };
};
DeleteAction.type = 'delete';
const UnpublishAction = ({ documents, model })=>{
    const { formatMessage } = useIntl();
    const { schema } = useDoc();
    const selectRow = useTable('UnpublishAction', (state)=>state.selectRow);
    const hasPublishPermission = useDocumentRBAC('unpublishAction', (state)=>state.canPublish);
    const hasI18nEnabled = Boolean(schema?.pluginOptions?.i18n);
    const hasDraftAndPublishEnabled = Boolean(schema?.options?.draftAndPublish);
    const { unpublishMany: bulkUnpublishAction, isLoading } = useDocumentActions();
    const documentIds = documents.map(({ documentId })=>documentId);
    const [{ query }] = useQueryParams();
    const params = React.useMemo(()=>buildValidParams(query), [
        query
    ]);
    const handleConfirmBulkUnpublish = async ()=>{
        const data = await bulkUnpublishAction({
            documentIds,
            model,
            params
        });
        if (!('error' in data)) {
            selectRow([]);
        }
    };
    const showUnpublishButton = hasDraftAndPublishEnabled && hasPublishPermission && documents.some((entry)=>entry.status === 'published' || entry.status === 'modified');
    if (!showUnpublishButton) return null;
    return {
        variant: 'tertiary',
        label: formatMessage({
            id: 'app.utils.unpublish',
            defaultMessage: 'Unpublish'
        }),
        dialog: {
            type: 'dialog',
            title: formatMessage({
                id: 'app.components.ConfirmDialog.title',
                defaultMessage: 'Confirmation'
            }),
            loading: isLoading,
            content: /*#__PURE__*/ jsxs(Flex, {
                direction: "column",
                alignItems: "stretch",
                gap: 2,
                children: [
                    /*#__PURE__*/ jsx(Flex, {
                        justifyContent: "center",
                        children: /*#__PURE__*/ jsx(WarningCircle, {
                            width: "24px",
                            height: "24px",
                            fill: "danger600"
                        })
                    }),
                    /*#__PURE__*/ jsx(Typography, {
                        id: "confirm-description",
                        textAlign: "center",
                        children: formatMessage({
                            id: 'popUpWarning.bodyMessage.contentType.unpublish.all',
                            defaultMessage: 'Are you sure you want to unpublish these entries?'
                        })
                    }),
                    hasI18nEnabled && /*#__PURE__*/ jsx(Box, {
                        textAlign: "center",
                        padding: 3,
                        children: /*#__PURE__*/ jsx(Typography, {
                            textColor: "danger500",
                            children: formatMessage({
                                id: getTranslation('Settings.list.actions.unpublishAdditionalInfos'),
                                defaultMessage: 'This will unpublish the active locale versions <em>(from Internationalization)</em>'
                            }, {
                                em: Emphasis
                            })
                        })
                    })
                ]
            }),
            confirmButton: formatMessage({
                id: 'app.utils.unpublish',
                defaultMessage: 'Unpublish'
            }),
            onConfirm: handleConfirmBulkUnpublish
        }
    };
};
UnpublishAction.type = 'unpublish';
const Emphasis = (chunks)=>/*#__PURE__*/ jsx(Typography, {
        fontWeight: "semiBold",
        textColor: "danger500",
        children: chunks
    });
const DEFAULT_BULK_ACTIONS = [
    PublishAction,
    UnpublishAction,
    DeleteAction
];

const AutoCloneFailureModalBody = ({ prohibitedFields })=>{
    const { formatMessage } = useIntl();
    const getDefaultErrorMessage = (reason)=>{
        switch(reason){
            case 'relation':
                return 'Duplicating the relation could remove it from the original entry.';
            case 'unique':
                return 'Identical values in a unique field are not allowed';
            default:
                return reason;
        }
    };
    return /*#__PURE__*/ jsxs(Fragment, {
        children: [
            /*#__PURE__*/ jsx(Typography, {
                variant: "beta",
                children: formatMessage({
                    id: getTranslation('containers.list.autoCloneModal.title'),
                    defaultMessage: "This entry can't be duplicated directly."
                })
            }),
            /*#__PURE__*/ jsx(Box, {
                marginTop: 2,
                children: /*#__PURE__*/ jsx(Typography, {
                    textColor: "neutral600",
                    children: formatMessage({
                        id: getTranslation('containers.list.autoCloneModal.description'),
                        defaultMessage: "A new entry will be created with the same content, but you'll have to change the following fields to save it."
                    })
                })
            }),
            /*#__PURE__*/ jsx(Flex, {
                marginTop: 6,
                gap: 2,
                direction: "column",
                alignItems: "stretch",
                children: prohibitedFields.map(([fieldPath, reason])=>/*#__PURE__*/ jsxs(Flex, {
                        direction: "column",
                        gap: 2,
                        alignItems: "flex-start",
                        borderColor: "neutral200",
                        hasRadius: true,
                        padding: 6,
                        children: [
                            /*#__PURE__*/ jsx(Flex, {
                                direction: "row",
                                tag: "ol",
                                children: fieldPath.map((pathSegment, index)=>/*#__PURE__*/ jsxs(Typography, {
                                        fontWeight: "semiBold",
                                        tag: "li",
                                        children: [
                                            pathSegment,
                                            index !== fieldPath.length - 1 && /*#__PURE__*/ jsx(ChevronRight, {
                                                fill: "neutral500",
                                                height: "0.8rem",
                                                width: "0.8rem",
                                                style: {
                                                    margin: '0 0.8rem'
                                                }
                                            })
                                        ]
                                    }, index))
                            }),
                            /*#__PURE__*/ jsx(Typography, {
                                tag: "p",
                                textColor: "neutral600",
                                children: formatMessage({
                                    id: getTranslation(`containers.list.autoCloneModal.error.${reason}`),
                                    defaultMessage: getDefaultErrorMessage(reason)
                                })
                            })
                        ]
                    }, fieldPath.join()))
            })
        ]
    });
};

const TableActions = ({ document })=>{
    const { formatMessage } = useIntl();
    const { model, collectionType } = useDoc();
    const plugins = useStrapiApp('TableActions', (state)=>state.plugins);
    const props = {
        activeTab: null,
        model,
        documentId: document.documentId,
        collectionType,
        document
    };
    return /*#__PURE__*/ jsx(DescriptionComponentRenderer, {
        props: props,
        descriptions: plugins['content-manager'].apis.getDocumentActions('table-row')// We explicitly remove the PublishAction from description so we never render it and we don't make unnecessary requests.
        .filter((action)=>action.name !== 'PublishAction'),
        children: (actions)=>{
            const tableRowActions = actions.filter((action)=>{
                const positions = Array.isArray(action.position) ? action.position : [
                    action.position
                ];
                return positions.includes('table-row');
            });
            return /*#__PURE__*/ jsx(DocumentActionsMenu, {
                actions: tableRowActions,
                label: formatMessage({
                    id: 'content-manager.containers.list.table.row-actions',
                    defaultMessage: 'Row actions'
                }),
                variant: "ghost"
            });
        }
    });
};
/* -------------------------------------------------------------------------------------------------
 * TableActionComponents
 * -----------------------------------------------------------------------------------------------*/ const EditAction = ({ documentId })=>{
    const navigate = useNavigate();
    const { formatMessage } = useIntl();
    const { canRead } = useDocumentRBAC('EditAction', ({ canRead })=>({
            canRead
        }));
    const { toggleNotification } = useNotification();
    const [{ query }] = useQueryParams();
    return {
        disabled: !canRead,
        icon: /*#__PURE__*/ jsx(StyledPencil, {}),
        label: formatMessage({
            id: 'content-manager.actions.edit.label',
            defaultMessage: 'Edit'
        }),
        position: 'table-row',
        onClick: async ()=>{
            if (!documentId) {
                console.error("You're trying to edit a document without an id, this is likely a bug with Strapi. Please open an issue.");
                toggleNotification({
                    message: formatMessage({
                        id: 'content-manager.actions.edit.error',
                        defaultMessage: 'An error occurred while trying to edit the document.'
                    }),
                    type: 'danger'
                });
                return;
            }
            navigate({
                pathname: documentId,
                search: stringify({
                    plugins: query.plugins
                })
            });
        }
    };
};
EditAction.type = 'edit';
EditAction.position = 'table-row';
/**
 * Because the icon system is completely broken, we have to do
 * this to remove the fill from the cog.
 */ const StyledPencil = styled(Pencil)`
  path {
    fill: currentColor;
  }
`;
const CloneAction = ({ model, documentId })=>{
    const navigate = useNavigate();
    const { formatMessage } = useIntl();
    const { canCreate } = useDocumentRBAC('CloneAction', ({ canCreate })=>({
            canCreate
        }));
    const { toggleNotification } = useNotification();
    const { autoClone } = useDocumentActions();
    const [prohibitedFields, setProhibitedFields] = React.useState([]);
    return {
        disabled: !canCreate,
        icon: /*#__PURE__*/ jsx(StyledDuplicate, {}),
        label: formatMessage({
            id: 'content-manager.actions.clone.label',
            defaultMessage: 'Duplicate'
        }),
        position: 'table-row',
        onClick: async ()=>{
            if (!documentId) {
                console.error("You're trying to clone a document in the table without an id, this is likely a bug with Strapi. Please open an issue.");
                toggleNotification({
                    message: formatMessage({
                        id: 'content-manager.actions.clone.error',
                        defaultMessage: 'An error occurred while trying to clone the document.'
                    }),
                    type: 'danger'
                });
                return;
            }
            const res = await autoClone({
                model,
                sourceId: documentId
            });
            if ('data' in res) {
                navigate(res.data.documentId);
                /**
         * We return true because we don't need to show a modal anymore.
         */ return true;
            }
            if (isBaseQueryError(res.error) && res.error.details && typeof res.error.details === 'object' && 'prohibitedFields' in res.error.details && Array.isArray(res.error.details.prohibitedFields)) {
                const prohibitedFields = res.error.details.prohibitedFields;
                setProhibitedFields(prohibitedFields);
            }
        },
        dialog: {
            type: 'modal',
            title: formatMessage({
                id: 'content-manager.containers.list.autoCloneModal.header',
                defaultMessage: 'Duplicate'
            }),
            content: /*#__PURE__*/ jsx(AutoCloneFailureModalBody, {
                prohibitedFields: prohibitedFields
            }),
            footer: ({ onClose })=>{
                return /*#__PURE__*/ jsxs(Modal.Footer, {
                    children: [
                        /*#__PURE__*/ jsx(Button, {
                            onClick: onClose,
                            variant: "tertiary",
                            children: formatMessage({
                                id: 'cancel',
                                defaultMessage: 'Cancel'
                            })
                        }),
                        /*#__PURE__*/ jsx(LinkButton, {
                            tag: NavLink,
                            to: {
                                pathname: `clone/${documentId}`
                            },
                            children: formatMessage({
                                id: 'content-manager.containers.list.autoCloneModal.create',
                                defaultMessage: 'Create'
                            })
                        })
                    ]
                });
            }
        }
    };
};
CloneAction.type = 'clone';
CloneAction.position = 'table-row';
/**
 * Because the icon system is completely broken, we have to do
 * this to remove the fill from the cog.
 */ const StyledDuplicate = styled(Duplicate)`
  path {
    fill: currentColor;
  }
`;
const DEFAULT_TABLE_ROW_ACTIONS = [
    EditAction,
    CloneAction
];

/* -------------------------------------------------------------------------------------------------
 * ContentManager plugin
 * -----------------------------------------------------------------------------------------------*/ class ContentManagerPlugin {
    addEditViewSidePanel(panels) {
        if (Array.isArray(panels)) {
            this.editViewSidePanels = [
                ...this.editViewSidePanels,
                ...panels
            ];
        } else if (typeof panels === 'function') {
            this.editViewSidePanels = panels(this.editViewSidePanels);
        } else {
            throw new Error(`Expected the \`panels\` passed to \`addEditViewSidePanel\` to be an array or a function, but received ${getPrintableType(panels)}`);
        }
    }
    addDocumentAction(actions) {
        if (Array.isArray(actions)) {
            this.documentActions = [
                ...this.documentActions,
                ...actions
            ];
        } else if (typeof actions === 'function') {
            this.documentActions = actions(this.documentActions);
        } else {
            throw new Error(`Expected the \`actions\` passed to \`addDocumentAction\` to be an array or a function, but received ${getPrintableType(actions)}`);
        }
    }
    addDocumentHeaderAction(actions) {
        if (Array.isArray(actions)) {
            this.headerActions = [
                ...this.headerActions,
                ...actions
            ];
        } else if (typeof actions === 'function') {
            this.headerActions = actions(this.headerActions);
        } else {
            throw new Error(`Expected the \`actions\` passed to \`addDocumentHeaderAction\` to be an array or a function, but received ${getPrintableType(actions)}`);
        }
    }
    addBulkAction(actions) {
        if (Array.isArray(actions)) {
            this.bulkActions = [
                ...this.bulkActions,
                ...actions
            ];
        } else if (typeof actions === 'function') {
            this.bulkActions = actions(this.bulkActions);
        } else {
            throw new Error(`Expected the \`actions\` passed to \`addBulkAction\` to be an array or a function, but received ${getPrintableType(actions)}`);
        }
    }
    get config() {
        return {
            id: PLUGIN_ID,
            name: 'Content Manager',
            injectionZones: INJECTION_ZONES,
            apis: {
                addBulkAction: this.addBulkAction.bind(this),
                addDocumentAction: this.addDocumentAction.bind(this),
                addDocumentHeaderAction: this.addDocumentHeaderAction.bind(this),
                addEditViewSidePanel: this.addEditViewSidePanel.bind(this),
                getBulkActions: ()=>this.bulkActions,
                getDocumentActions: (position)=>{
                    /**
           * When possible, pre-filter the actions by the components static position property.
           * This avoids rendering the actions in multiple places where they weren't displayed,
           * which wasn't visible but created issues with useEffect for instance.
           * The response should still be filtered by the position, as the static property is new
           * and not mandatory to avoid a breaking change.
           */ if (position) {
                        return this.documentActions.filter((action)=>{
                            return action.position == undefined || [
                                action.position
                            ].flat().includes(position);
                        });
                    }
                    return this.documentActions;
                },
                getEditViewSidePanels: ()=>this.editViewSidePanels,
                getHeaderActions: ()=>this.headerActions
            }
        };
    }
    constructor(){
        /**
   * The following properties are the stored ones provided by any plugins registering with
   * the content-manager. The function calls however, need to be called at runtime in the
   * application, so instead we collate them and run them later with the complete list incl.
   * ones already registered & the context of the view.
   */ this.bulkActions = [
            ...DEFAULT_BULK_ACTIONS
        ];
        this.documentActions = [
            ...DEFAULT_ACTIONS,
            ...DEFAULT_TABLE_ROW_ACTIONS,
            ...DEFAULT_HEADER_ACTIONS
        ];
        this.editViewSidePanels = [
            ActionsPanel
        ];
        this.headerActions = [];
    }
}
/* -------------------------------------------------------------------------------------------------
 * getPrintableType
 * -----------------------------------------------------------------------------------------------*/ /**
 * @internal
 * @description Gets the human-friendly printable type name for the given value, for instance it will yield
 * `array` instead of `object`, as the native `typeof` operator would do.
 */ const getPrintableType = (value)=>{
    const nativeType = typeof value;
    if (nativeType === 'object') {
        if (value === null) return 'null';
        if (Array.isArray(value)) return 'array';
        if (value instanceof Object && value.constructor.name !== 'Object') {
            return value.constructor.name;
        }
    }
    return nativeType;
};

const HistoryAction = ({ model, document })=>{
    const { formatMessage } = useIntl();
    const [{ query }] = useQueryParams();
    const navigate = useNavigate();
    const { trackUsage } = useTracking();
    const { pathname } = useLocation();
    const pluginsQueryParams = stringify({
        plugins: query.plugins
    }, {
        encode: false
    });
    if (!window.strapi.features.isEnabled('cms-content-history')) {
        return null;
    }
    const handleOnClick = ()=>{
        const destination = {
            pathname: 'history',
            search: pluginsQueryParams
        };
        trackUsage('willNavigate', {
            from: pathname,
            to: `${pathname}/${destination.pathname}`
        });
        navigate(destination);
    };
    return {
        icon: /*#__PURE__*/ jsx(ClockCounterClockwise, {}),
        label: formatMessage({
            id: 'content-manager.history.document-action',
            defaultMessage: 'Content History'
        }),
        onClick: handleOnClick,
        disabled: /**
       * The user is creating a new document.
       * It hasn't been saved yet, so there's no history to go to
       */ !document || /**
       * The document has been created but the current dimension has never been saved.
       * For example, the user is creating a new locale in an existing document,
       * so there's no history for the document in that locale
       */ !document.id || /**
       * History is only available for content types created by the user.
       * These have the `api::` prefix, as opposed to the ones created by Strapi or plugins,
       * which start with `admin::` or `plugin::`
       */ !model.startsWith('api::'),
        position: 'header'
    };
};
HistoryAction.type = 'history';
HistoryAction.position = 'header';

const historyAdmin = {
    bootstrap (app) {
        const { addDocumentAction } = app.getPlugin('content-manager').apis;
        /**
     * Register the document action here using the public API, and not by setting the action in the
     * Content Manager directly, because this API lets us control the order of the actions array.
     * We want history to be the last non-delete action in the array.
     */ addDocumentAction((actions)=>{
            const indexOfDeleteAction = actions.findIndex((action)=>action.type === 'delete');
            actions.splice(indexOfDeleteAction, 0, HistoryAction);
            return actions;
        });
    }
};

const initialState = {
    collectionTypeLinks: [],
    components: [],
    fieldSizes: {},
    models: [],
    singleTypeLinks: [],
    isLoading: true
};
const appSlice = createSlice({
    name: 'app',
    initialState,
    reducers: {
        setInitialData (state, action) {
            const { authorizedCollectionTypeLinks, authorizedSingleTypeLinks, components, contentTypeSchemas, fieldSizes } = action.payload;
            state.collectionTypeLinks = authorizedCollectionTypeLinks.filter(({ isDisplayed })=>isDisplayed);
            state.singleTypeLinks = authorizedSingleTypeLinks.filter(({ isDisplayed })=>isDisplayed);
            state.components = components;
            state.models = contentTypeSchemas;
            state.fieldSizes = fieldSizes;
            state.isLoading = false;
        }
    }
});
const { actions, reducer: reducer$1 } = appSlice;
const { setInitialData } = actions;

const reducer = combineReducers({
    app: reducer$1
});

const previewApi = contentManagerApi.injectEndpoints({
    endpoints: (builder)=>({
            getPreviewUrl: builder.query({
                query ({ query, params }) {
                    return {
                        url: `/content-manager/preview/url/${params.contentType}`,
                        method: 'GET',
                        config: {
                            params: query
                        }
                    };
                }
            })
        })
});
const { useGetPreviewUrlQuery } = previewApi;

const ConditionalTooltip = ({ isShown, label, children })=>{
    if (isShown) {
        return /*#__PURE__*/ jsx(Tooltip, {
            label: label,
            children: children
        });
    }
    return children;
};
const PreviewSidePanel = ({ model, documentId, document })=>{
    const { formatMessage } = useIntl();
    const { trackUsage } = useTracking();
    const { pathname } = useLocation();
    const [{ query }] = useQueryParams();
    const isModified = useForm('PreviewSidePanel', (state)=>state.modified);
    /**
   * The preview URL isn't used in this component, we just fetch it to know if preview is enabled
   * for the content type. If it's not, the panel is not displayed. If it is, we display a link to
   * /preview, and the URL will already be loaded in the RTK query cache.
   */ const { data, error } = useGetPreviewUrlQuery({
        params: {
            contentType: model
        },
        query: {
            documentId,
            locale: document?.locale,
            status: document?.status
        }
    });
    if (!data?.data?.url || error) {
        return null;
    }
    const trackNavigation = ()=>{
        // Append /preview to the current URL
        const destinationPathname = pathname.replace(/\/$/, '') + '/preview';
        trackUsage('willNavigate', {
            from: pathname,
            to: destinationPathname
        });
    };
    return {
        title: formatMessage({
            id: 'content-manager.preview.panel.title',
            defaultMessage: 'Preview'
        }),
        content: /*#__PURE__*/ jsx(ConditionalTooltip, {
            label: formatMessage({
                id: 'content-manager.preview.panel.button-disabled-tooltip',
                defaultMessage: 'Please save to open the preview'
            }),
            isShown: isModified,
            children: /*#__PURE__*/ jsx(Box, {
                cursor: "not-allowed",
                width: "100%",
                children: /*#__PURE__*/ jsx(Button, {
                    variant: "tertiary",
                    tag: Link,
                    to: {
                        pathname: 'preview',
                        search: stringify(query, {
                            encode: false
                        })
                    },
                    onClick: trackNavigation,
                    width: "100%",
                    disabled: isModified,
                    pointerEvents: isModified ? 'none' : undefined,
                    tabIndex: isModified ? -1 : undefined,
                    children: formatMessage({
                        id: 'content-manager.preview.panel.button',
                        defaultMessage: 'Open preview'
                    })
                })
            })
        })
    };
};

const previewAdmin = {
    bootstrap (app) {
        const contentManagerPluginApis = app.getPlugin('content-manager').apis;
        contentManagerPluginApis.addEditViewSidePanel([
            PreviewSidePanel
        ]);
    }
};

function __variableDynamicImportRuntime1__(path) {
  switch (path) {
    case './translations/ar.json': return import('./ar-DckYq_WK.mjs');
    case './translations/ca.json': return import('./ca-DviY7mRj.mjs');
    case './translations/cs.json': return import('./cs-C7OSYFQ7.mjs');
    case './translations/de.json': return import('./de-5QRlDHyR.mjs');
    case './translations/en.json': return import('./en-CImiNxXE.mjs');
    case './translations/es.json': return import('./es-DkoWSExG.mjs');
    case './translations/eu.json': return import('./eu-BG1xX7HK.mjs');
    case './translations/fr.json': return import('./fr-CFdRaRVj.mjs');
    case './translations/gu.json': return import('./gu-D5MMMXRs.mjs');
    case './translations/hi.json': return import('./hi-lp17SCjr.mjs');
    case './translations/hu.json': return import('./hu-CLka1U2C.mjs');
    case './translations/id.json': return import('./id-USfY9m1g.mjs');
    case './translations/it.json': return import('./it-BAHrwmYS.mjs');
    case './translations/ja.json': return import('./ja-BWKmBJFT.mjs');
    case './translations/ko.json': return import('./ko-CgADGBNt.mjs');
    case './translations/ml.json': return import('./ml-CnhCfOn_.mjs');
    case './translations/ms.json': return import('./ms-Bh09NFff.mjs');
    case './translations/nl.json': return import('./nl-C8HYflTc.mjs');
    case './translations/pl.json': return import('./pl-MFCZJZuZ.mjs');
    case './translations/pt-BR.json': return import('./pt-BR-CcotyBGJ.mjs');
    case './translations/pt.json': return import('./pt-HbmgeiYO.mjs');
    case './translations/ru.json': return import('./ru-CB4BUyQp.mjs');
    case './translations/sa.json': return import('./sa-n_aPA-pU.mjs');
    case './translations/sk.json': return import('./sk-tn_BDjE2.mjs');
    case './translations/sv.json': return import('./sv-cq4ZrQRd.mjs');
    case './translations/th.json': return import('./th-mUH7hEtc.mjs');
    case './translations/tr.json': return import('./tr-Yt38daxh.mjs');
    case './translations/uk.json': return import('./uk-BtM6WnaE.mjs');
    case './translations/vi.json': return import('./vi-CvBGlTjr.mjs');
    case './translations/zh-Hans.json': return import('./zh-Hans-CI0HKio3.mjs');
    case './translations/zh.json': return import('./zh-BmF-sHaT.mjs');
    default: return new Promise(function(resolve, reject) {
      (typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
        reject.bind(null, new Error("Unknown variable dynamic import: " + path))
      );
    })
   }
 }
// eslint-disable-next-line import/no-default-export
var index = {
    register (app) {
        const cm = new ContentManagerPlugin();
        app.addReducers({
            [PLUGIN_ID]: reducer
        });
        app.addMenuLink({
            to: PLUGIN_ID,
            icon: Feather,
            intlLabel: {
                id: `content-manager.plugin.name`,
                defaultMessage: 'Content Manager'
            },
            permissions: [],
            position: 1
        });
        app.router.addRoute({
            path: 'content-manager/*',
            lazy: async ()=>{
                const { Layout } = await import('./layout-4nCaNnTs.mjs');
                return {
                    Component: Layout
                };
            },
            children: routes
        });
        app.registerPlugin(cm.config);
    },
    bootstrap (app) {
        if (typeof historyAdmin.bootstrap === 'function') {
            historyAdmin.bootstrap(app);
        }
        if (typeof previewAdmin.bootstrap === 'function') {
            previewAdmin.bootstrap(app);
        }
    },
    async registerTrads ({ locales }) {
        const importedTrads = await Promise.all(locales.map((locale)=>{
            return __variableDynamicImportRuntime1__(`./translations/${locale}.json`).then(({ default: data })=>{
                return {
                    data: prefixPluginTranslations(data, PLUGIN_ID),
                    locale
                };
            }).catch(()=>{
                return {
                    data: {},
                    locale
                };
            });
        }));
        return Promise.resolve(importedTrads);
    }
};

export { useUpdateContentTypeConfigurationMutation as A, BulkActionsRenderer as B, COLLECTION_TYPES as C, DocumentStatus as D, ATTRIBUTE_TYPES_THAT_CANNOT_BE_MAIN_FIELD as E, extractContentTypeComponents as F, DEFAULT_SETTINGS as G, HOOKS as H, InjectionZone as I, convertEditLayoutToFieldLayouts as J, removeFieldsThatDontExistOnSchema as K, prepareTempKeys as L, useDocument as M, DocumentActionButton as N, useGetPreviewUrlQuery as O, Panels as P, index as Q, RelativeTime as R, SINGLE_TYPES as S, TableActions as T, useContentManagerContext as U, useDocumentActions as V, useGetInitialDataQuery as a, useGetAllContentTypeSettingsQuery as b, useDoc as c, buildValidParams as d, contentManagerApi as e, useDocumentRBAC as f, getTranslation as g, useDocumentLayout as h, createYupSchema as i, Header as j, PERMISSIONS as k, DocumentRBAC as l, useDocLayout as m, createDefaultForm as n, CLONE_PATH as o, useGetContentTypeConfigurationQuery as p, CREATOR_FIELDS as q, getMainField as r, setInitialData as s, transformDocument as t, useContentTypeSchema as u, getDisplayName as v, checkIfAttributeIsDisplayable as w, useGetAllDocumentsQuery as x, convertListLayoutToFieldLayouts as y, capitalise as z };
//# sourceMappingURL=index-CcJLBLNf.mjs.map
