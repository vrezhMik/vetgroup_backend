{"version":3,"file":"index.js","sources":["../src/parse-type.ts","../src/env-helper.ts","../src/content-types.ts","../src/set-creator-fields.ts","../src/hooks.ts","../src/provider-factory.ts","../src/traverse-entity.ts","../src/import-default.ts","../src/machine-id.ts","../src/format-yup-error.ts","../src/errors.ts","../src/validators.ts","../src/operators.ts","../src/convert-query-params.ts","../src/async.ts","../src/sanitize/visitors/remove-password.ts","../src/sanitize/visitors/remove-private.ts","../src/relations.ts","../src/sanitize/visitors/remove-restricted-relations.ts","../src/sanitize/visitors/remove-morph-to-relations.ts","../src/sanitize/visitors/remove-dynamic-zones.ts","../src/sanitize/visitors/remove-disallowed-fields.ts","../src/sanitize/visitors/remove-restricted-fields.ts","../src/sanitize/visitors/expand-wildcard-populate.ts","../src/traverse/factory.ts","../src/traverse/query-filters.ts","../src/traverse/query-sort.ts","../src/traverse/query-populate.ts","../src/traverse/query-fields.ts","../src/sanitize/sanitizers.ts","../src/sanitize/index.ts","../src/validate/utils.ts","../src/validate/visitors/throw-password.ts","../src/validate/visitors/throw-private.ts","../src/validate/visitors/throw-restricted-relations.ts","../src/validate/visitors/throw-morph-to-relations.ts","../src/validate/visitors/throw-dynamic-zones.ts","../src/validate/visitors/throw-disallowed-fields.ts","../src/validate/visitors/throw-restricted-fields.ts","../src/validate/visitors/throw-unrecognized-fields.ts","../src/validate/validators.ts","../src/validate/index.ts","../src/pagination.ts","../src/package-manager.ts","../src/template.ts","../src/file.ts","../src/policy.ts","../src/primitives/strings.ts","../src/primitives/arrays.ts","../src/primitives/objects.ts","../src/primitives/dates.ts","../src/print-value.ts","../src/yup.ts","../src/zod.ts"],"sourcesContent":["import * as _ from 'lodash';\nimport * as dates from 'date-fns';\n\nconst timeRegex = /^(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]{1,3})?$/;\n\nconst isDate = (v: unknown): v is Date => {\n  return dates.isDate(v);\n};\n\nconst parseTime = (value: unknown): string => {\n  if (isDate(value)) {\n    return dates.format(value, 'HH:mm:ss.SSS');\n  }\n\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string, got a ${typeof value}`);\n  }\n  const result = value.match(timeRegex);\n\n  if (result === null) {\n    throw new Error('Invalid time format, expected HH:mm:ss.SSS');\n  }\n\n  const [, hours, minutes, seconds, fraction = '.000'] = result;\n  const fractionPart = _.padEnd(fraction.slice(1), 3, '0');\n\n  return `${hours}:${minutes}:${seconds}.${fractionPart}`;\n};\n\nconst parseDate = (value: unknown) => {\n  if (isDate(value)) {\n    return dates.format(value, 'yyyy-MM-dd');\n  }\n\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string, got a ${typeof value}`);\n  }\n\n  try {\n    const date = dates.parseISO(value);\n\n    if (dates.isValid(date)) return dates.format(date, 'yyyy-MM-dd');\n\n    throw new Error(`Invalid format, expected an ISO compatible date`);\n  } catch (error) {\n    throw new Error(`Invalid format, expected an ISO compatible date`);\n  }\n};\n\nconst parseDateTimeOrTimestamp = (value: unknown) => {\n  if (isDate(value)) {\n    return value;\n  }\n\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string, got a ${typeof value}`);\n  }\n\n  try {\n    const date = dates.parseISO(value);\n    if (dates.isValid(date)) return date;\n\n    const milliUnixDate = dates.parse(value, 'T', new Date());\n    if (dates.isValid(milliUnixDate)) return milliUnixDate;\n\n    throw new Error(`Invalid format, expected a timestamp or an ISO date`);\n  } catch (error) {\n    throw new Error(`Invalid format, expected a timestamp or an ISO date`);\n  }\n};\n\ntype TypeMap = {\n  boolean: boolean;\n  integer: number;\n  biginteger: number;\n  float: number;\n  decimal: number;\n  time: string;\n  date: string;\n  timestamp: Date;\n  datetime: Date;\n};\n\nexport interface ParseTypeOptions<T extends keyof TypeMap> {\n  type: T;\n  value: unknown;\n  forceCast?: boolean;\n}\n\nconst parseBoolean = (value: unknown, options: { forceCast?: boolean }): boolean => {\n  const { forceCast = false } = options;\n\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (typeof value === 'string' || typeof value === 'number') {\n    if (['true', 't', '1', 1].includes(value)) {\n      return true;\n    }\n\n    if (['false', 'f', '0', 0].includes(value)) {\n      return false;\n    }\n  }\n\n  if (forceCast) {\n    return Boolean(value);\n  }\n\n  throw new Error('Invalid boolean input. Expected \"t\",\"1\",\"true\",\"false\",\"0\",\"f\"');\n};\n\n/**\n * Cast basic values based on attribute type\n */\nconst parseType = <Type extends keyof TypeMap>(options: ParseTypeOptions<Type>): TypeMap[Type] => {\n  const { type, value, forceCast } = options;\n\n  switch (type) {\n    case 'boolean':\n      return parseBoolean(value, { forceCast }) as TypeMap[Type];\n    case 'integer':\n    case 'biginteger':\n    case 'float':\n    case 'decimal': {\n      return _.toNumber(value) as TypeMap[Type];\n    }\n    case 'time': {\n      return parseTime(value) as TypeMap[Type];\n    }\n    case 'date': {\n      return parseDate(value) as TypeMap[Type];\n    }\n    case 'timestamp':\n    case 'datetime': {\n      return parseDateTimeOrTimestamp(value) as TypeMap[Type];\n    }\n    default:\n      return value as TypeMap[Type];\n  }\n};\n\nexport default parseType;\n","import _ from 'lodash';\n\nexport type Env = typeof envFn & typeof utils;\n\nfunction envFn<T>(key: string, defaultValue?: T): string | T | undefined {\n  return _.has(process.env, key) ? process.env[key] : defaultValue;\n}\n\nfunction getKey(key: string) {\n  return process.env[key] ?? '';\n}\n\nconst utils = {\n  int(key: string, defaultValue?: number): number | undefined {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    return parseInt(getKey(key), 10);\n  },\n\n  float(key: string, defaultValue?: number): number | undefined {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    return parseFloat(getKey(key));\n  },\n\n  bool(key: string, defaultValue?: boolean): boolean | undefined {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    return getKey(key) === 'true';\n  },\n\n  json(key: string, defaultValue?: object) {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    try {\n      return JSON.parse(getKey(key));\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new Error(`Invalid json environment variable ${key}: ${error.message}`);\n      }\n\n      throw error;\n    }\n  },\n\n  array(key: string, defaultValue?: string[]): string[] | undefined {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    let value = getKey(key);\n\n    if (value.startsWith('[') && value.endsWith(']')) {\n      value = value.substring(1, value.length - 1);\n    }\n\n    return value.split(',').map((v) => {\n      return _.trim(_.trim(v, ' '), '\"');\n    });\n  },\n\n  date(key: string, defaultValue?: Date): Date | undefined {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    return new Date(getKey(key));\n  },\n\n  /**\n   * Gets a value from env that matches oneOf provided values\n   * @param {string} key\n   * @param {string[]} expectedValues\n   * @param {string|undefined} defaultValue\n   * @returns {string|undefined}\n   */\n  oneOf(key: string, expectedValues?: unknown[], defaultValue?: unknown) {\n    if (!expectedValues) {\n      throw new Error(`env.oneOf requires expectedValues`);\n    }\n\n    if (defaultValue && !expectedValues.includes(defaultValue)) {\n      throw new Error(`env.oneOf requires defaultValue to be included in expectedValues`);\n    }\n\n    const rawValue = env(key, defaultValue);\n    return expectedValues.includes(rawValue) ? rawValue : defaultValue;\n  },\n};\n\nconst env: Env = Object.assign(envFn, utils);\n\nexport default env;\n","import _ from 'lodash';\nimport { has, getOr, union } from 'lodash/fp';\nimport type {\n  Model,\n  Kind,\n  Attribute,\n  RelationalAttribute,\n  ComponentAttribute,\n  DynamicZoneAttribute,\n  WithRequired,\n} from './types';\n\nconst SINGLE_TYPE = 'singleType';\nconst COLLECTION_TYPE = 'collectionType';\n\nconst ID_ATTRIBUTE = 'id';\nconst DOC_ID_ATTRIBUTE = 'documentId';\n\nconst PUBLISHED_AT_ATTRIBUTE = 'publishedAt';\nconst CREATED_BY_ATTRIBUTE = 'createdBy';\nconst UPDATED_BY_ATTRIBUTE = 'updatedBy';\n\nconst CREATED_AT_ATTRIBUTE = 'createdAt';\nconst UPDATED_AT_ATTRIBUTE = 'updatedAt';\n\nconst constants = {\n  ID_ATTRIBUTE,\n  DOC_ID_ATTRIBUTE,\n  PUBLISHED_AT_ATTRIBUTE,\n  CREATED_BY_ATTRIBUTE,\n  UPDATED_BY_ATTRIBUTE,\n  CREATED_AT_ATTRIBUTE,\n  UPDATED_AT_ATTRIBUTE,\n  SINGLE_TYPE,\n  COLLECTION_TYPE,\n};\n\nconst getTimestamps = (model: Model) => {\n  const attributes: string[] = [];\n\n  if (has(CREATED_AT_ATTRIBUTE, model.attributes)) {\n    attributes.push(CREATED_AT_ATTRIBUTE);\n  }\n\n  if (has(UPDATED_AT_ATTRIBUTE, model.attributes)) {\n    attributes.push(UPDATED_AT_ATTRIBUTE);\n  }\n\n  return attributes;\n};\n\nconst getCreatorFields = (model: Model) => {\n  const attributes: string[] = [];\n\n  if (has(CREATED_BY_ATTRIBUTE, model.attributes)) {\n    attributes.push(CREATED_BY_ATTRIBUTE);\n  }\n\n  if (has(UPDATED_BY_ATTRIBUTE, model.attributes)) {\n    attributes.push(UPDATED_BY_ATTRIBUTE);\n  }\n\n  return attributes;\n};\n\nconst getNonWritableAttributes = (model: Model) => {\n  if (!model) return [];\n\n  const nonWritableAttributes = _.reduce(\n    model.attributes,\n    (acc, attr, attrName) => (attr.writable === false ? acc.concat(attrName) : acc),\n    [] as string[]\n  );\n\n  return _.uniq([\n    ID_ATTRIBUTE,\n    DOC_ID_ATTRIBUTE,\n    ...getTimestamps(model),\n    ...nonWritableAttributes,\n  ]);\n};\n\nconst getWritableAttributes = (model: Model) => {\n  if (!model) return [];\n\n  return _.difference(Object.keys(model.attributes), getNonWritableAttributes(model));\n};\n\nconst isWritableAttribute = (model: Model, attributeName: string) => {\n  return getWritableAttributes(model).includes(attributeName);\n};\n\nconst getNonVisibleAttributes = (model: Model) => {\n  const nonVisibleAttributes = _.reduce(\n    model.attributes,\n    (acc, attr, attrName) => (attr.visible === false ? acc.concat(attrName) : acc),\n    [] as string[]\n  );\n\n  return _.uniq([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, ...getTimestamps(model), ...nonVisibleAttributes]);\n};\n\nconst getVisibleAttributes = (model: Model) => {\n  return _.difference(_.keys(model.attributes), getNonVisibleAttributes(model));\n};\n\nconst isVisibleAttribute = (model: Model, attributeName: string) => {\n  return getVisibleAttributes(model).includes(attributeName);\n};\n\nconst getOptions = (model: Model) =>\n  _.assign({ draftAndPublish: false }, _.get(model, 'options', {}));\n\nconst hasDraftAndPublish = (model: Model) =>\n  _.get(model, 'options.draftAndPublish', false) === true;\n\nconst isDraft = <T extends object>(data: T, model: Model) =>\n  hasDraftAndPublish(model) && _.get(data, PUBLISHED_AT_ATTRIBUTE) === null;\n\nconst isSchema = (data: unknown): data is Model => {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'modelType' in data &&\n    typeof data.modelType === 'string' &&\n    ['component', 'contentType'].includes(data.modelType)\n  );\n};\n\nconst isComponentSchema = (data: unknown): data is Model & { modelType: 'component' } => {\n  return isSchema(data) && data.modelType === 'component';\n};\n\nconst isContentTypeSchema = (data: unknown): data is Model & { modelType: 'contentType' } => {\n  return isSchema(data) && data.modelType === 'contentType';\n};\n\nconst isSingleType = ({ kind = COLLECTION_TYPE }) => kind === SINGLE_TYPE;\nconst isCollectionType = ({ kind = COLLECTION_TYPE }) => kind === COLLECTION_TYPE;\nconst isKind = (kind: Kind) => (model: Model) => model.kind === kind;\n\nconst getStoredPrivateAttributes = (model: Model) =>\n  union(\n    (strapi?.config?.get('api.responses.privateAttributes', []) ?? []) as Array<string>,\n    getOr([], 'options.privateAttributes', model)\n  );\n\nconst getPrivateAttributes = (model: Model) => {\n  return _.union(\n    getStoredPrivateAttributes(model),\n    _.keys(_.pickBy(model.attributes, (attr) => !!attr.private))\n  );\n};\n\nconst isPrivateAttribute = (model: Model, attributeName: string) => {\n  if (model?.attributes?.[attributeName]?.private === true) {\n    return true;\n  }\n  return getStoredPrivateAttributes(model).includes(attributeName);\n};\n\nconst isScalarAttribute = (attribute?: Attribute) => {\n  return attribute && !['media', 'component', 'relation', 'dynamiczone'].includes(attribute.type);\n};\n\nconst getDoesAttributeRequireValidation = (attribute: Attribute) => {\n  return (\n    attribute.required ||\n    attribute.unique ||\n    Object.prototype.hasOwnProperty.call(attribute, 'max') ||\n    Object.prototype.hasOwnProperty.call(attribute, 'min') ||\n    Object.prototype.hasOwnProperty.call(attribute, 'maxLength') ||\n    Object.prototype.hasOwnProperty.call(attribute, 'minLength')\n  );\n};\nconst isMediaAttribute = (attribute?: Attribute) => attribute?.type === 'media';\nconst isRelationalAttribute = (attribute?: Attribute): attribute is RelationalAttribute =>\n  attribute?.type === 'relation';\n\nconst HAS_RELATION_REORDERING = ['manyToMany', 'manyToOne', 'oneToMany'];\nconst hasRelationReordering = (attribute?: Attribute) =>\n  isRelationalAttribute(attribute) && HAS_RELATION_REORDERING.includes(attribute.relation);\n\nconst isComponentAttribute = (\n  attribute: Attribute\n): attribute is ComponentAttribute | DynamicZoneAttribute =>\n  ['component', 'dynamiczone'].includes(attribute?.type);\n\nconst isDynamicZoneAttribute = (attribute?: Attribute): attribute is DynamicZoneAttribute =>\n  !!attribute && attribute.type === 'dynamiczone';\nconst isMorphToRelationalAttribute = (attribute?: Attribute) => {\n  return (\n    !!attribute && isRelationalAttribute(attribute) && attribute.relation?.startsWith?.('morphTo')\n  );\n};\n\nconst getComponentAttributes = (schema: Model) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isComponentAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    [] as string[]\n  );\n};\n\nconst getScalarAttributes = (schema: Model) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isScalarAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    [] as string[]\n  );\n};\n\nconst getRelationalAttributes = (schema: Model) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isRelationalAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    [] as string[]\n  );\n};\n\n/**\n * Checks if an attribute is of type `type`\n * @param {object} attribute\n * @param {string} type\n */\nconst isTypedAttribute = (attribute: Attribute, type: string) => {\n  return _.has(attribute, 'type') && attribute.type === type;\n};\n\n/**\n *  Returns a route prefix for a contentType\n * @param {object} contentType\n * @returns {string}\n */\nconst getContentTypeRoutePrefix = (contentType: WithRequired<Model, 'info'>) => {\n  return isSingleType(contentType)\n    ? _.kebabCase(contentType.info.singularName)\n    : _.kebabCase(contentType.info.pluralName);\n};\n\nexport {\n  isSchema,\n  isContentTypeSchema,\n  isComponentSchema,\n  isScalarAttribute,\n  isMediaAttribute,\n  isRelationalAttribute,\n  hasRelationReordering,\n  isComponentAttribute,\n  isDynamicZoneAttribute,\n  isMorphToRelationalAttribute,\n  isTypedAttribute,\n  getPrivateAttributes,\n  isPrivateAttribute,\n  constants,\n  getNonWritableAttributes,\n  getComponentAttributes,\n  getScalarAttributes,\n  getRelationalAttributes,\n  getWritableAttributes,\n  isWritableAttribute,\n  getNonVisibleAttributes,\n  getVisibleAttributes,\n  getTimestamps,\n  getCreatorFields,\n  isVisibleAttribute,\n  getOptions,\n  isDraft,\n  hasDraftAndPublish,\n  isSingleType,\n  isCollectionType,\n  isKind,\n  getContentTypeRoutePrefix,\n  getDoesAttributeRequireValidation,\n};\n","import { assign, assoc } from 'lodash/fp';\nimport * as contentTypes from './content-types';\n\nconst { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = contentTypes.constants;\n\nexport interface Options {\n  user: User;\n  isEdition?: boolean;\n}\n\ninterface User {\n  id: string | number;\n}\n\nconst setCreatorFields =\n  <TData extends object>({ user, isEdition = false }: Options) =>\n  <TDataInner extends object = TData>(data: TDataInner) => {\n    if (isEdition) {\n      return assoc(UPDATED_BY_ATTRIBUTE, user.id, data);\n    }\n\n    return assign(data, {\n      [CREATED_BY_ATTRIBUTE]: user.id,\n      [UPDATED_BY_ATTRIBUTE]: user.id,\n    });\n  };\n\nexport default setCreatorFields;\n","import { eq, remove, cloneDeep } from 'lodash/fp';\n\nexport type Handler = (...args: any[]) => any;\n\nexport interface Hook<T extends Handler = Handler> {\n  getHandlers(): Handler[];\n  register(handler: T): Hook<T>;\n  delete(handler: T): Hook<T>;\n  call(...args: any[]): void;\n}\n\nexport interface AsyncSeriesHook extends Hook {\n  call(...args: any[]): Promise<void>;\n}\nexport interface AsyncSeriesWaterfallHook extends Hook {\n  call(...args: any[]): Promise<any>;\n}\n\nexport interface AsyncParallelHook extends Hook {\n  call(...args: any[]): Promise<any[]>;\n}\n\nexport interface AsyncBailHook extends Hook {\n  call(...args: any[]): Promise<any>;\n}\n\n/**\n * Create a default Strapi hook\n */\nconst createHook = <T extends Handler = Handler>(): Hook<T> => {\n  type State = {\n    handlers: T[];\n  };\n\n  const state: State = {\n    handlers: [],\n  };\n\n  return {\n    getHandlers() {\n      return state.handlers;\n    },\n\n    register(handler: T) {\n      state.handlers.push(handler);\n\n      return this;\n    },\n\n    delete(handler: T) {\n      state.handlers = remove(eq(handler), state.handlers);\n\n      return this;\n    },\n\n    call() {\n      throw new Error('Method not implemented');\n    },\n  };\n};\n\n/**\n * Create an async series hook.\n * Upon execution, it will execute every handler in order with the same context\n */\nconst createAsyncSeriesHook = <T extends Handler = Handler>() => ({\n  ...createHook<T>(),\n\n  async call(context: unknown) {\n    for (const handler of this.getHandlers()) {\n      await handler(context);\n    }\n  },\n});\n\n/**\n * Create an async series waterfall hook.\n * Upon execution, it will execute every handler in order and pass the return value of the last handler to the next one\n */\nconst createAsyncSeriesWaterfallHook = <T extends Handler = Handler>() => ({\n  ...createHook<T>(),\n\n  async call(param: unknown) {\n    let res = param;\n\n    for (const handler of this.getHandlers()) {\n      res = await handler(res);\n    }\n\n    return res;\n  },\n});\n\n/**\n * Create an async parallel hook.\n * Upon execution, it will execute every registered handler in band.\n */\nconst createAsyncParallelHook = <T extends Handler = Handler>() => ({\n  ...createHook<T>(),\n\n  async call(context: unknown) {\n    const promises = this.getHandlers().map((handler) => handler(cloneDeep(context)));\n\n    return Promise.all(promises);\n  },\n});\n\n/**\n * Create an async parallel hook.\n * Upon execution, it will execute every registered handler in serie and return the first result found.\n */\nconst createAsyncBailHook = <T extends Handler = Handler>() => ({\n  ...createHook<T>(),\n\n  async call(context: unknown) {\n    for (const handler of this.getHandlers()) {\n      const result = await handler(context);\n\n      if (result !== undefined) {\n        return result;\n      }\n    }\n  },\n});\n\nexport const internals = {\n  // Internal utils\n  createHook,\n};\n\nexport {\n  createAsyncSeriesHook,\n  createAsyncSeriesWaterfallHook,\n  createAsyncParallelHook,\n  createAsyncBailHook,\n};\n","import { cloneDeep } from 'lodash/fp';\nimport {\n  createAsyncSeriesHook,\n  createAsyncParallelHook,\n  AsyncSeriesHook,\n  AsyncParallelHook,\n} from './hooks';\n\nexport interface ProviderHooksMap {\n  willRegister: AsyncSeriesHook;\n  didRegister: AsyncParallelHook;\n  willDelete: AsyncParallelHook;\n  didDelete: AsyncParallelHook;\n}\n\n/**\n * Creates a new object containing various hooks used by the providers\n */\nconst createProviderHooksMap = (): ProviderHooksMap => ({\n  // Register events\n  willRegister: createAsyncSeriesHook(),\n  didRegister: createAsyncParallelHook(),\n  // Delete events\n  willDelete: createAsyncParallelHook(),\n  didDelete: createAsyncParallelHook(),\n});\n\nexport interface Options {\n  throwOnDuplicates?: boolean;\n}\n\ntype Item = Record<string, unknown>;\n\nexport interface Provider<T = unknown> {\n  hooks: ProviderHooksMap;\n  register(key: string, item: T): Promise<Provider>;\n  delete(key: string): Promise<Provider>;\n  get(key: string): T | undefined;\n  values(): T[];\n  keys(): string[];\n  has(key: string): boolean;\n  size(): number;\n  clear(): Promise<Provider<T>>;\n}\n\nexport type ProviderFactory<T> = (options?: Options) => Provider<T>;\n\n/**\n * A Provider factory\n */\nconst providerFactory = <T = Item>(options: Options = {}): Provider<T> => {\n  const { throwOnDuplicates = true } = options;\n\n  const state = {\n    hooks: createProviderHooksMap(),\n    registry: new Map<string, T>(),\n  };\n\n  return {\n    hooks: state.hooks,\n\n    async register(key: string, item: T) {\n      if (throwOnDuplicates && this.has(key)) {\n        throw new Error(`Duplicated item key: ${key}`);\n      }\n\n      await state.hooks.willRegister.call({ key, value: item });\n\n      state.registry.set(key, item);\n\n      await state.hooks.didRegister.call({ key, value: cloneDeep(item) });\n\n      return this;\n    },\n\n    async delete(key: string) {\n      if (this.has(key)) {\n        const item = this.get(key);\n\n        await state.hooks.willDelete.call({ key, value: cloneDeep(item) });\n\n        state.registry.delete(key);\n\n        await state.hooks.didDelete.call({ key, value: cloneDeep(item) });\n      }\n\n      return this;\n    },\n\n    get(key: string) {\n      return state.registry.get(key);\n    },\n\n    values() {\n      return Array.from(state.registry.values());\n    },\n\n    keys() {\n      return Array.from(state.registry.keys());\n    },\n\n    has(key: string) {\n      return state.registry.has(key);\n    },\n\n    size() {\n      return state.registry.size;\n    },\n\n    async clear() {\n      const keys = this.keys();\n\n      for (const key of keys) {\n        await this.delete(key);\n      }\n\n      return this;\n    },\n  };\n};\n\nexport default providerFactory;\n","import { clone, isObject, isArray, isNil, curry } from 'lodash/fp';\n\nimport type { Attribute, AnyAttribute, Model, Data } from './types';\nimport { isRelationalAttribute, isMediaAttribute } from './content-types';\n\nexport type VisitorUtils = ReturnType<typeof createVisitorUtils>;\n\nexport interface VisitorOptions {\n  data: Record<string, unknown>;\n  schema: Model;\n  key: string;\n  value: Data[keyof Data];\n  attribute?: AnyAttribute;\n  path: Path;\n  getModel(uid: string): Model;\n  parent?: Parent;\n}\n\nexport type Visitor = (visitorOptions: VisitorOptions, visitorUtils: VisitorUtils) => void;\n\nexport interface Path {\n  raw: string | null;\n  attribute: string | null;\n}\n\nexport interface TraverseOptions {\n  schema: Model;\n  path?: Path;\n  parent?: Parent;\n  getModel(uid: string): Model;\n}\n\nexport interface Parent {\n  attribute?: Attribute;\n  key: string | null;\n  path: Path;\n  schema: Model;\n}\n\nconst traverseEntity = async (visitor: Visitor, options: TraverseOptions, entity: Data) => {\n  const { path = { raw: null, attribute: null }, schema, getModel } = options;\n\n  let parent = options.parent;\n\n  const traverseMorphRelationTarget = async (visitor: Visitor, path: Path, entry: Data) => {\n    const targetSchema = getModel(entry.__type!);\n\n    const traverseOptions: TraverseOptions = { schema: targetSchema, path, getModel, parent };\n\n    return traverseEntity(visitor, traverseOptions, entry);\n  };\n\n  const traverseRelationTarget =\n    (schema: Model) => async (visitor: Visitor, path: Path, entry: Data) => {\n      const traverseOptions: TraverseOptions = { schema, path, getModel, parent };\n\n      return traverseEntity(visitor, traverseOptions, entry);\n    };\n\n  const traverseMediaTarget = async (visitor: Visitor, path: Path, entry: Data) => {\n    const targetSchemaUID = 'plugin::upload.file';\n    const targetSchema = getModel(targetSchemaUID);\n\n    const traverseOptions: TraverseOptions = { schema: targetSchema, path, getModel, parent };\n\n    return traverseEntity(visitor, traverseOptions, entry);\n  };\n\n  const traverseComponent = async (visitor: Visitor, path: Path, schema: Model, entry: Data) => {\n    const traverseOptions: TraverseOptions = { schema, path, getModel, parent };\n\n    return traverseEntity(visitor, traverseOptions, entry);\n  };\n\n  const visitDynamicZoneEntry = async (visitor: Visitor, path: Path, entry: Data) => {\n    const targetSchema = getModel(entry.__component!);\n    const traverseOptions: TraverseOptions = { schema: targetSchema, path, getModel, parent };\n\n    return traverseEntity(visitor, traverseOptions, entry);\n  };\n\n  // End recursion\n  if (!isObject(entity) || isNil(schema)) {\n    return entity;\n  }\n\n  // Don't mutate the original entity object\n  // only clone at 1st level as the next level will get clone when traversed\n  const copy = clone(entity);\n  const visitorUtils = createVisitorUtils({ data: copy });\n\n  const keys = Object.keys(copy);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    // Retrieve the attribute definition associated to the key from the schema\n    const attribute = schema.attributes[key] as AnyAttribute | undefined;\n\n    const newPath = { ...path };\n\n    newPath.raw = isNil(path.raw) ? key : `${path.raw}.${key}`;\n\n    if (!isNil(attribute)) {\n      newPath.attribute = isNil(path.attribute) ? key : `${path.attribute}.${key}`;\n    }\n\n    // Visit the current attribute\n    const visitorOptions: VisitorOptions = {\n      data: copy,\n      schema,\n      key,\n      value: copy[key],\n      attribute,\n      path: newPath,\n      getModel,\n      parent,\n    };\n\n    await visitor(visitorOptions, visitorUtils);\n\n    // Extract the value for the current key (after calling the visitor)\n    const value = copy[key];\n\n    // Ignore Nil values or attributes\n    if (isNil(value) || isNil(attribute)) {\n      continue;\n    }\n\n    // The current attribute becomes the parent once visited\n    parent = { schema, key, attribute, path: newPath };\n\n    if (isRelationalAttribute(attribute)) {\n      const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n\n      const method = isMorphRelation\n        ? traverseMorphRelationTarget\n        : traverseRelationTarget(getModel(attribute.target!));\n\n      if (isArray(value)) {\n        const res = new Array(value.length);\n        for (let i = 0; i < value.length; i += 1) {\n          res[i] = await method(visitor, newPath, value[i]);\n        }\n        copy[key] = res;\n      } else {\n        copy[key] = await method(visitor, newPath, value as Data);\n      }\n\n      continue;\n    }\n\n    if (isMediaAttribute(attribute)) {\n      // need to update copy\n      if (isArray(value)) {\n        const res = new Array(value.length);\n        for (let i = 0; i < value.length; i += 1) {\n          res[i] = await traverseMediaTarget(visitor, newPath, value[i]);\n        }\n        copy[key] = res;\n      } else {\n        copy[key] = await traverseMediaTarget(visitor, newPath, value as Data);\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'component') {\n      const targetSchema = getModel(attribute.component);\n\n      if (isArray(value)) {\n        const res: Data[] = new Array(value.length);\n        for (let i = 0; i < value.length; i += 1) {\n          res[i] = await traverseComponent(visitor, newPath, targetSchema, value[i]);\n        }\n        copy[key] = res;\n      } else {\n        copy[key] = await traverseComponent(visitor, newPath, targetSchema, value as Data);\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'dynamiczone' && isArray(value)) {\n      const res = new Array(value.length);\n      for (let i = 0; i < value.length; i += 1) {\n        res[i] = await visitDynamicZoneEntry(visitor, newPath, value[i]);\n      }\n      copy[key] = res;\n\n      continue;\n    }\n  }\n\n  return copy;\n};\n\nconst createVisitorUtils = ({ data }: { data: Data }) => ({\n  remove(key: string) {\n    delete data[key];\n  },\n\n  set(key: string, value: Data) {\n    data[key] = value;\n  },\n});\n\nexport default curry(traverseEntity);\n","/* eslint-disable @typescript-eslint/no-var-requires */\n\nexport default function importDefault(modName: string) {\n  const mod = require(modName);\n  return mod && mod.__esModule ? mod.default : mod;\n}\n","import { randomUUID } from 'crypto';\nimport { machineIdSync } from 'node-machine-id';\n\nexport default () => {\n  try {\n    const deviceId = machineIdSync();\n    return deviceId;\n  } catch (error) {\n    const deviceId = randomUUID();\n    return deviceId;\n  }\n};\n","import { isEmpty, toPath } from 'lodash/fp';\nimport { ValidationError } from 'yup';\n\nconst formatYupInnerError = (yupError: ValidationError) => ({\n  path: toPath(yupError.path),\n  message: yupError.message,\n  name: yupError.name,\n  value: yupError.value,\n});\n\nconst formatYupErrors = (yupError: ValidationError) => ({\n  errors: isEmpty(yupError.inner)\n    ? [formatYupInnerError(yupError)]\n    : yupError.inner.map(formatYupInnerError),\n  message: yupError.message,\n});\n\nexport { formatYupErrors };\n","/* eslint-disable max-classes-per-file */\n\nimport yup from 'yup';\nimport { HttpError } from 'http-errors';\nimport { formatYupErrors } from './format-yup-error';\n\n/* ApplicationError */\nclass ApplicationError<\n  TName extends string = 'ApplicationError',\n  TMessage extends string = string,\n  TDetails = unknown,\n> extends Error {\n  name: TName;\n\n  details: TDetails;\n\n  message: TMessage;\n\n  constructor(\n    message = 'An application error occured' as TMessage,\n    details: TDetails = {} as TDetails\n  ) {\n    super();\n    this.name = 'ApplicationError' as TName;\n    this.message = message;\n    this.details = details;\n  }\n}\n\nclass ValidationError<\n  TMessage extends string = string,\n  TDetails = unknown,\n> extends ApplicationError<'ValidationError', TMessage, TDetails> {\n  constructor(message: TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'ValidationError';\n  }\n}\n\ninterface YupFormattedError {\n  path: string[];\n  message: string;\n  name: string;\n  value: string;\n}\n\nclass YupValidationError<TMessage extends string = string> extends ValidationError<\n  TMessage,\n  { errors: YupFormattedError[] }\n> {\n  constructor(yupError: yup.ValidationError, message?: TMessage) {\n    super('Validation' as TMessage);\n    const { errors, message: yupMessage } = formatYupErrors(yupError);\n    this.message = message || (yupMessage as TMessage);\n    this.details = { errors };\n  }\n}\n\nclass PaginationError<\n  TMessage extends string = string,\n  TDetails = unknown,\n> extends ApplicationError<'PaginationError', TMessage, TDetails> {\n  constructor(message = 'Invalid pagination' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'PaginationError';\n    this.message = message;\n  }\n}\n\nclass NotFoundError<TMessage extends string = string, TDetails = unknown> extends ApplicationError<\n  'NotFoundError',\n  TMessage,\n  TDetails\n> {\n  constructor(message = 'Entity not found' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'NotFoundError';\n    this.message = message;\n  }\n}\n\nclass ForbiddenError<\n  TName extends string = 'ForbiddenError',\n  TMessage extends string = string,\n  TDetails = unknown,\n> extends ApplicationError<TName, TMessage, TDetails> {\n  constructor(message = 'Forbidden access' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'ForbiddenError' as TName;\n    this.message = message;\n  }\n}\n\nclass UnauthorizedError<\n  TMessage extends string = string,\n  TDetails = unknown,\n> extends ApplicationError<'UnauthorizedError', TMessage, TDetails> {\n  constructor(message = 'Unauthorized' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'UnauthorizedError';\n    this.message = message;\n  }\n}\n\nclass RateLimitError<TMessage extends string = string, TDetails = unknown> extends ApplicationError<\n  'RateLimitError',\n  TMessage,\n  TDetails\n> {\n  constructor(\n    message = 'Too many requests, please try again later.' as TMessage,\n    details?: TDetails\n  ) {\n    super(message, details);\n    this.name = 'RateLimitError';\n    this.message = message;\n    this.details = details || ({} as TDetails);\n  }\n}\n\nclass PayloadTooLargeError<\n  TMessage extends string = string,\n  TDetails = unknown,\n> extends ApplicationError<'PayloadTooLargeError', TMessage, TDetails> {\n  constructor(message = 'Entity too large' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'PayloadTooLargeError';\n    this.message = message;\n  }\n}\n\nclass PolicyError<TMessage extends string = string, TDetails = unknown> extends ForbiddenError<\n  'PolicyError',\n  TMessage,\n  TDetails\n> {\n  constructor(message = 'Policy Failed' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'PolicyError';\n    this.message = message;\n    this.details = details || ({} as TDetails);\n  }\n}\n\nclass NotImplementedError<\n  TMessage extends string = string,\n  TDetails = unknown,\n> extends ApplicationError<'NotImplementedError', TMessage, TDetails> {\n  constructor(message = 'This feature is not implemented yet' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'NotImplementedError';\n    this.message = message;\n  }\n}\n\nexport {\n  HttpError,\n  ApplicationError,\n  ValidationError,\n  YupValidationError,\n  PaginationError,\n  NotFoundError,\n  ForbiddenError,\n  UnauthorizedError,\n  RateLimitError,\n  PayloadTooLargeError,\n  PolicyError,\n  NotImplementedError,\n};\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\n/* eslint-disable no-template-curly-in-string */\nimport * as yup from 'yup';\nimport { defaults } from 'lodash/fp';\nimport { YupValidationError } from './errors';\n\nconst handleYupError = (error: yup.ValidationError, errorMessage?: string) => {\n  throw new YupValidationError(error, errorMessage);\n};\n\nconst defaultValidationParam = { strict: true, abortEarly: false };\n\nconst validateYupSchema =\n  <TSchema extends yup.AnySchema>(schema: TSchema, options = {}) =>\n  async (body: unknown, errorMessage?: string): Promise<yup.InferType<TSchema>> => {\n    try {\n      const optionsWithDefaults = defaults(defaultValidationParam, options);\n      const result = await schema.validate(body, optionsWithDefaults);\n      return result;\n    } catch (e) {\n      if (e instanceof yup.ValidationError) {\n        handleYupError(e, errorMessage);\n      }\n\n      throw e;\n    }\n  };\n\nconst validateYupSchemaSync =\n  <TSchema extends yup.AnySchema>(schema: yup.AnySchema, options = {}) =>\n  (body: unknown, errorMessage?: string): yup.InferType<TSchema> => {\n    try {\n      const optionsWithDefaults = defaults(defaultValidationParam, options);\n      return schema.validateSync(body, optionsWithDefaults);\n    } catch (e) {\n      if (e instanceof yup.ValidationError) {\n        handleYupError(e, errorMessage);\n      }\n\n      throw e;\n    }\n  };\n\nexport { handleYupError, validateYupSchema, validateYupSchemaSync };\n","const GROUP_OPERATORS = ['$and', '$or'];\n\nconst WHERE_OPERATORS = [\n  '$not',\n  '$in',\n  '$notIn',\n  '$eq',\n  '$eqi',\n  '$ne',\n  '$nei',\n  '$gt',\n  '$gte',\n  '$lt',\n  '$lte',\n  '$null',\n  '$notNull',\n  '$between',\n  '$startsWith',\n  '$endsWith',\n  '$startsWithi',\n  '$endsWithi',\n  '$contains',\n  '$notContains',\n  '$containsi',\n  '$notContainsi',\n  // Experimental, only for internal use\n  '$jsonSupersetOf',\n];\n\nconst CAST_OPERATORS = [\n  '$not',\n  '$in',\n  '$notIn',\n  '$eq',\n  '$ne',\n  '$gt',\n  '$gte',\n  '$lt',\n  '$lte',\n  '$between',\n];\n\nconst ARRAY_OPERATORS = ['$in', '$notIn', '$between'];\n\nconst OPERATORS = {\n  where: WHERE_OPERATORS,\n  cast: CAST_OPERATORS,\n  group: GROUP_OPERATORS,\n  array: ARRAY_OPERATORS,\n};\n\n// for performance, cache all operators in lowercase\nconst OPERATORS_LOWERCASE = Object.fromEntries(\n  Object.entries(OPERATORS).map(([key, values]) => [\n    key,\n    values.map((value) => value.toLowerCase()),\n  ])\n);\n\nconst isObjKey = <T extends object>(key: string | symbol | number, obj: T): key is keyof T => {\n  return key in obj;\n};\n\nexport const isOperatorOfType = (type: string, key: string, ignoreCase = false) => {\n  if (ignoreCase) {\n    return OPERATORS_LOWERCASE[type]?.includes(key.toLowerCase()) ?? false;\n  }\n\n  if (isObjKey(type, OPERATORS)) {\n    return OPERATORS[type]?.includes(key) ?? false;\n  }\n\n  return false;\n};\n\nexport const isOperator = (key: string, ignoreCase = false) => {\n  return Object.keys(OPERATORS).some((type) => isOperatorOfType(type, key, ignoreCase));\n};\n","/* eslint-disable max-classes-per-file */\n\n/**\n * Converts the standard Strapi REST query params to a more usable format for querying\n * You can read more here: https://docs.strapi.io/developer-docs/latest/developer-resources/database-apis-reference/rest-api.html#filters\n */\n\nimport _ from 'lodash';\nimport {\n  cloneDeep,\n  get,\n  isArray,\n  isEmpty,\n  isInteger,\n  isNil,\n  isObject,\n  isString,\n  toNumber,\n} from 'lodash/fp';\nimport {\n  constants,\n  hasDraftAndPublish,\n  isDynamicZoneAttribute,\n  isMorphToRelationalAttribute,\n} from './content-types';\nimport { PaginationError } from './errors';\nimport { isOperator } from './operators';\n\nimport parseType from './parse-type';\nimport { Model } from './types';\n\nconst { ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, PUBLISHED_AT_ATTRIBUTE } = constants;\n\ntype SortOrder = 'asc' | 'desc';\n\nexport interface SortMap {\n  [key: string]: SortOrder | SortMap;\n}\n\nexport interface SortParamsObject {\n  [key: string]: SortOrder | SortParamsObject;\n}\n\ntype SortParams = string | string[] | SortParamsObject | SortParamsObject[];\ntype FieldsParams = string | string[];\n\ntype FiltersParams = unknown;\n\nexport interface PopulateAttributesParams {\n  [key: string]: boolean | PopulateObjectParams;\n}\n\nexport interface PopulateObjectParams {\n  sort?: SortParams;\n  fields?: FieldsParams;\n  filters?: FiltersParams;\n  populate?: string | string[] | PopulateAttributesParams;\n  on?: PopulateAttributesParams;\n  count?: boolean;\n  ordering?: unknown;\n  _q?: string;\n  limit?: number | string;\n  start?: number | string;\n  page?: number | string;\n  pageSize?: number | string;\n}\n\ntype PopulateParams = string | string[] | PopulateAttributesParams;\n\nexport interface Params {\n  sort?: SortParams;\n  fields?: FieldsParams;\n  filters?: FiltersParams;\n  populate?: PopulateParams;\n  count?: boolean;\n  ordering?: unknown;\n  _q?: string;\n  limit?: number | string;\n  start?: number | string;\n  page?: number | string;\n  pageSize?: number | string;\n  status?: 'draft' | 'published';\n}\n\ntype FiltersQuery = (options: { meta: Model }) => WhereQuery | undefined;\ntype OrderByQuery = SortMap | SortMap[];\ntype SelectQuery = string | string[];\n\nexport interface WhereQuery {\n  [key: string]: any;\n}\n\ntype PopulateQuery =\n  | boolean\n  | string[]\n  | {\n      [key: string]: PopulateQuery;\n    };\n\nexport interface Query {\n  orderBy?: OrderByQuery;\n  select?: SelectQuery;\n  where?: WhereQuery;\n  // NOTE: those are internal DB filters do not modify\n  filters?: FiltersQuery;\n  populate?: PopulateQuery;\n  count?: boolean;\n  ordering?: unknown;\n  _q?: string;\n  limit?: number;\n  offset?: number;\n  page?: number;\n  pageSize?: number;\n}\n\nclass InvalidOrderError extends Error {\n  constructor() {\n    super();\n    this.message = 'Invalid order. order can only be one of asc|desc|ASC|DESC';\n  }\n}\n\nclass InvalidSortError extends Error {\n  constructor() {\n    super();\n    this.message =\n      'Invalid sort parameter. Expected a string, an array of strings, a sort object or an array of sort objects';\n  }\n}\n\nfunction validateOrder(order: string): asserts order is SortOrder {\n  if (!isString(order) || !['asc', 'desc'].includes(order.toLocaleLowerCase())) {\n    throw new InvalidOrderError();\n  }\n}\n\nconst convertCountQueryParams = (countQuery: unknown): boolean => {\n  return parseType({ type: 'boolean', value: countQuery });\n};\n\nconst convertOrderingQueryParams = (ordering: unknown) => {\n  return ordering;\n};\n\nconst isPlainObject = (value: unknown): value is Record<string, unknown> => _.isPlainObject(value);\nconst isStringArray = (value: unknown): value is string[] =>\n  isArray(value) && value.every(isString);\n\ninterface TransformerOptions {\n  getModel: (uid: string) => Model | undefined;\n}\n\nconst createTransformer = ({ getModel }: TransformerOptions) => {\n  /**\n   * Sort query parser\n   */\n  const convertSortQueryParams = (sortQuery: SortParams): OrderByQuery => {\n    if (typeof sortQuery === 'string') {\n      return convertStringSortQueryParam(sortQuery);\n    }\n\n    if (isStringArray(sortQuery)) {\n      return sortQuery.flatMap((sortValue: string) => convertStringSortQueryParam(sortValue));\n    }\n\n    if (Array.isArray(sortQuery)) {\n      return sortQuery.map((sortValue) => convertNestedSortQueryParam(sortValue));\n    }\n\n    if (isPlainObject(sortQuery)) {\n      return convertNestedSortQueryParam(sortQuery);\n    }\n\n    throw new InvalidSortError();\n  };\n\n  const convertStringSortQueryParam = (sortQuery: string): SortMap[] => {\n    return sortQuery.split(',').map((value) => convertSingleSortQueryParam(value));\n  };\n\n  const convertSingleSortQueryParam = (sortQuery: string): SortMap => {\n    if (!sortQuery) {\n      return {};\n    }\n\n    if (!isString(sortQuery)) {\n      throw new Error('Invalid sort query');\n    }\n\n    // split field and order param with default order to ascending\n    const [field, order = 'asc'] = sortQuery.split(':');\n\n    if (field.length === 0) {\n      throw new Error('Field cannot be empty');\n    }\n\n    validateOrder(order);\n\n    // TODO: field should be a valid path on an object model\n\n    return _.set({}, field, order);\n  };\n\n  const convertNestedSortQueryParam = (sortQuery: SortParamsObject): SortMap => {\n    const transformedSort: SortMap = {};\n    for (const field of Object.keys(sortQuery)) {\n      const order = sortQuery[field];\n\n      // this is a deep sort\n      if (isPlainObject(order)) {\n        transformedSort[field] = convertNestedSortQueryParam(order);\n      } else if (typeof order === 'string') {\n        validateOrder(order);\n        transformedSort[field] = order;\n      } else {\n        throw Error(`Invalid sort type expected object or string got ${typeof order}`);\n      }\n    }\n\n    return transformedSort;\n  };\n\n  /**\n   * Start query parser\n   */\n  const convertStartQueryParams = (startQuery: unknown): number => {\n    const startAsANumber = toNumber(startQuery);\n\n    if (!_.isInteger(startAsANumber) || startAsANumber < 0) {\n      throw new Error(`convertStartQueryParams expected a positive integer got ${startAsANumber}`);\n    }\n\n    return startAsANumber;\n  };\n\n  /**\n   * Limit query parser\n   */\n  const convertLimitQueryParams = (limitQuery: unknown): number | undefined => {\n    const limitAsANumber = toNumber(limitQuery);\n\n    if (!_.isInteger(limitAsANumber) || (limitAsANumber !== -1 && limitAsANumber < 0)) {\n      throw new Error(`convertLimitQueryParams expected a positive integer got ${limitAsANumber}`);\n    }\n\n    if (limitAsANumber === -1) {\n      return undefined;\n    }\n\n    return limitAsANumber;\n  };\n\n  const convertPageQueryParams = (page: unknown): number => {\n    const pageVal = toNumber(page);\n\n    if (!isInteger(pageVal) || pageVal <= 0) {\n      throw new PaginationError(\n        `Invalid 'page' parameter. Expected an integer > 0, received: ${page}`\n      );\n    }\n\n    return pageVal;\n  };\n\n  const convertPageSizeQueryParams = (pageSize: unknown, page: unknown): number => {\n    const pageSizeVal = toNumber(pageSize);\n\n    if (!isInteger(pageSizeVal) || pageSizeVal <= 0) {\n      throw new PaginationError(\n        `Invalid 'pageSize' parameter. Expected an integer > 0, received: ${page}`\n      );\n    }\n\n    return pageSizeVal;\n  };\n\n  const validatePaginationParams = (\n    page: unknown,\n    pageSize: unknown,\n    start: unknown,\n    limit: unknown\n  ) => {\n    const isPagePagination = !isNil(page) || !isNil(pageSize);\n    const isOffsetPagination = !isNil(start) || !isNil(limit);\n\n    if (isPagePagination && isOffsetPagination) {\n      throw new PaginationError(\n        'Invalid pagination attributes. The page parameters are incorrect and must be in the pagination object'\n      );\n    }\n  };\n\n  class InvalidPopulateError extends Error {\n    constructor() {\n      super();\n      this.message =\n        'Invalid populate parameter. Expected a string, an array of strings, a populate object';\n    }\n  }\n\n  // NOTE: we could support foo.* or foo.bar.* etc later on\n  const convertPopulateQueryParams = (\n    populate: PopulateParams,\n    schema?: Model,\n    depth = 0\n  ): PopulateQuery => {\n    if (depth === 0 && populate === '*') {\n      return true;\n    }\n\n    if (typeof populate === 'string') {\n      return populate.split(',').map((value) => _.trim(value));\n    }\n\n    if (Array.isArray(populate)) {\n      // map convert\n      return _.uniq(\n        populate.flatMap((value) => {\n          if (typeof value !== 'string') {\n            throw new InvalidPopulateError();\n          }\n\n          return value.split(',').map((value) => _.trim(value));\n        })\n      );\n    }\n\n    if (_.isPlainObject(populate)) {\n      return convertPopulateObject(populate, schema);\n    }\n\n    throw new InvalidPopulateError();\n  };\n\n  const hasPopulateFragmentDefined = (\n    populate: PopulateObjectParams\n  ): populate is PopulateObjectParams & Required<Pick<PopulateObjectParams, 'on'>> => {\n    return typeof populate === 'object' && 'on' in populate && !isNil(populate.on);\n  };\n\n  const hasCountDefined = (\n    populate: PopulateObjectParams\n  ): populate is PopulateObjectParams & { count: boolean } => {\n    return (\n      typeof populate === 'object' && 'count' in populate && typeof populate.count === 'boolean'\n    );\n  };\n\n  const convertPopulateObject = (populate: PopulateAttributesParams, schema?: Model) => {\n    if (!schema) {\n      return {};\n    }\n\n    const { attributes } = schema;\n    return Object.entries(populate).reduce((acc, [key, subPopulate]) => {\n      // Try converting strings to regular booleans if possible\n      if (_.isString(subPopulate)) {\n        try {\n          const subPopulateAsBoolean = parseType({ type: 'boolean', value: subPopulate });\n          // Only true is accepted as a boolean populate value\n          return subPopulateAsBoolean ? { ...acc, [key]: true } : acc;\n        } catch {\n          // ignore\n        }\n      }\n\n      if (_.isBoolean(subPopulate)) {\n        // Only true is accepted as a boolean populate value\n        return subPopulate === true ? { ...acc, [key]: true } : acc;\n      }\n\n      const attribute = attributes[key];\n\n      if (!attribute) {\n        return acc;\n      }\n\n      // Allow adding an 'on' strategy to populate queries for morphTo relations and dynamic zones\n      const isMorphLikeRelationalAttribute =\n        isDynamicZoneAttribute(attribute) || isMorphToRelationalAttribute(attribute);\n\n      if (isMorphLikeRelationalAttribute) {\n        const hasInvalidProperties = Object.keys(subPopulate).some(\n          (key) => !['populate', 'on', 'count'].includes(key)\n        );\n\n        if (hasInvalidProperties) {\n          throw new Error(\n            `Invalid nested populate for ${schema.info?.singularName}.${key} (${schema.uid}). Expected a fragment (\"on\") or \"count\" but found ${JSON.stringify(subPopulate)}`\n          );\n        }\n\n        /**\n         * Validate nested population queries in the context of a polymorphic attribute (dynamic zone, morph relation).\n         *\n         * If 'populate' exists in subPopulate, its value should be constrained to a wildcard ('*').\n         */\n        if ('populate' in subPopulate && subPopulate.populate !== '*') {\n          throw new Error(\n            `Invalid nested population query detected. When using 'populate' within polymorphic structures, ` +\n              `its value must be '*' to indicate all second level links. Specific field targeting is not supported here. ` +\n              `Consider using the fragment API for more granular population control.`\n          );\n        }\n\n        // TODO: Remove the possibility to have multiple properties at the same time (on/count/populate)\n        const newSubPopulate = {};\n\n        // case: { populate: '*' }\n        if ('populate' in subPopulate) {\n          Object.assign(newSubPopulate, { populate: true });\n        }\n\n        // case: { on: { <clauses> } }\n        if (hasPopulateFragmentDefined(subPopulate)) {\n          // If the fragment API is used, it applies the transformation to every\n          // sub-populate, then assign the result to the new sub-populate\n          Object.assign(newSubPopulate, {\n            on: Object.entries(subPopulate.on).reduce(\n              (acc, [type, typeSubPopulate]) => ({\n                ...acc,\n                [type]: convertNestedPopulate(typeSubPopulate, getModel(type)),\n              }),\n              {}\n            ),\n          });\n        }\n\n        // case: { count: true | false }\n        if (hasCountDefined(subPopulate)) {\n          Object.assign(newSubPopulate, { count: subPopulate.count });\n        }\n\n        return { ...acc, [key]: newSubPopulate };\n      }\n\n      // Edge case when trying to use the fragment ('on') on a non-morph like attribute\n      if (!isMorphLikeRelationalAttribute && hasPopulateFragmentDefined(subPopulate)) {\n        throw new Error(`Using fragments is not permitted to populate \"${key}\" in \"${schema.uid}\"`);\n      }\n\n      // NOTE: Retrieve the target schema UID.\n      // Only handles basic relations, medias and component since it's not possible\n      // to populate with options for a dynamic zone or a polymorphic relation\n      let targetSchemaUID;\n\n      if (attribute.type === 'relation') {\n        targetSchemaUID = attribute.target;\n      } else if (attribute.type === 'component') {\n        targetSchemaUID = attribute.component;\n      } else if (attribute.type === 'media') {\n        targetSchemaUID = 'plugin::upload.file';\n      } else {\n        return acc;\n      }\n\n      const targetSchema = getModel(targetSchemaUID!);\n\n      // ignore the sub-populate for the current key if there is no schema associated\n      if (!targetSchema) {\n        return acc;\n      }\n\n      const populateObject = convertNestedPopulate(subPopulate, targetSchema);\n\n      if (!populateObject) {\n        return acc;\n      }\n\n      return {\n        ...acc,\n        [key]: populateObject,\n      };\n    }, {});\n  };\n\n  const convertNestedPopulate = (subPopulate: boolean | PopulateObjectParams, schema?: Model) => {\n    if (_.isString(subPopulate)) {\n      return parseType({ type: 'boolean', value: subPopulate, forceCast: true });\n    }\n\n    if (_.isBoolean(subPopulate)) {\n      return subPopulate;\n    }\n\n    if (!isPlainObject(subPopulate)) {\n      throw new Error(`Invalid nested populate. Expected '*' or an object`);\n    }\n\n    const { sort, filters, fields, populate, count, ordering, page, pageSize, start, limit } =\n      subPopulate as PopulateObjectParams;\n\n    const query: Query = {};\n\n    if (sort) {\n      query.orderBy = convertSortQueryParams(sort);\n    }\n\n    if (filters) {\n      query.where = convertFiltersQueryParams(filters, schema);\n    }\n\n    if (fields) {\n      query.select = convertFieldsQueryParams(fields, schema);\n    }\n\n    if (populate) {\n      query.populate = convertPopulateQueryParams(populate, schema);\n    }\n\n    if (count) {\n      query.count = convertCountQueryParams(count);\n    }\n\n    if (ordering) {\n      query.ordering = convertOrderingQueryParams(ordering);\n    }\n\n    validatePaginationParams(page, pageSize, start, limit);\n\n    if (!isNil(page)) {\n      query.page = convertPageQueryParams(page);\n    }\n\n    if (!isNil(pageSize)) {\n      query.pageSize = convertPageSizeQueryParams(pageSize, page);\n    }\n\n    if (!isNil(start)) {\n      query.offset = convertStartQueryParams(start);\n    }\n\n    if (!isNil(limit)) {\n      query.limit = convertLimitQueryParams(limit);\n    }\n\n    return query;\n  };\n\n  // TODO: ensure field is valid in content types (will probably have to check strapi.contentTypes since it can be a string.path)\n  const convertFieldsQueryParams = (\n    fields: FieldsParams,\n    schema?: Model,\n    depth = 0\n  ): SelectQuery | undefined => {\n    if (depth === 0 && fields === '*') {\n      return undefined;\n    }\n\n    if (typeof fields === 'string') {\n      const fieldsValues = fields.split(',').map((value) => _.trim(value));\n\n      // NOTE: Only include the doc id if it's a content type\n      if (schema?.modelType === 'contentType') {\n        return _.uniq([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, ...fieldsValues]);\n      }\n      return _.uniq([ID_ATTRIBUTE, ...fieldsValues]);\n    }\n\n    if (isStringArray(fields)) {\n      // map convert\n      const fieldsValues = fields\n        .flatMap((value) => convertFieldsQueryParams(value, schema, depth + 1))\n        .filter((v) => !isNil(v)) as string[];\n\n      // NOTE: Only include the doc id if it's a content type\n      if (schema?.modelType === 'contentType') {\n        return _.uniq([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, ...fieldsValues]);\n      }\n      return _.uniq([ID_ATTRIBUTE, ...fieldsValues]);\n    }\n\n    throw new Error('Invalid fields parameter. Expected a string or an array of strings');\n  };\n\n  const isValidSchemaAttribute = (key: string, schema?: Model) => {\n    if ([DOC_ID_ATTRIBUTE, ID_ATTRIBUTE].includes(key)) {\n      return true;\n    }\n\n    if (!schema) {\n      return false;\n    }\n\n    return Object.keys(schema.attributes).includes(key);\n  };\n\n  const convertFiltersQueryParams = (filters: FiltersParams, schema?: Model): WhereQuery => {\n    // Filters need to be either an array or an object\n    // Here we're only checking for 'object' type since typeof [] => object and typeof {} => object\n    if (!isObject(filters)) {\n      throw new Error('The filters parameter must be an object or an array');\n    }\n\n    // Don't mutate the original object\n    const filtersCopy = cloneDeep(filters);\n\n    return convertAndSanitizeFilters(filtersCopy, schema);\n  };\n\n  const convertAndSanitizeFilters = (filters: FiltersParams, schema?: Model): WhereQuery => {\n    if (Array.isArray(filters)) {\n      return (\n        filters\n          // Sanitize each filter\n          .map((filter) => convertAndSanitizeFilters(filter, schema))\n          // Filter out empty filters\n          .filter((filter) => !isPlainObject(filter) || !isEmpty(filter))\n      );\n    }\n\n    if (!isPlainObject(filters)) {\n      return filters as WhereQuery;\n    }\n\n    const removeOperator = (operator: string) => delete filters[operator];\n\n    // Here, `key` can either be an operator or an attribute name\n    for (const [key, value] of Object.entries(filters)) {\n      const attribute = get(key, schema?.attributes);\n      const validKey = isOperator(key) || isValidSchemaAttribute(key, schema);\n\n      if (!validKey) {\n        removeOperator(key);\n      }\n      // Handle attributes\n      else if (attribute) {\n        // Relations\n        if (attribute.type === 'relation') {\n          filters[key] = convertAndSanitizeFilters(value, getModel(attribute.target!));\n        }\n\n        // Components\n        else if (attribute.type === 'component') {\n          filters[key] = convertAndSanitizeFilters(value, getModel(attribute.component));\n        }\n\n        // Media\n        else if (attribute.type === 'media') {\n          filters[key] = convertAndSanitizeFilters(value, getModel('plugin::upload.file'));\n        }\n\n        // Dynamic Zones\n        else if (attribute.type === 'dynamiczone') {\n          removeOperator(key);\n        }\n\n        // Password attributes\n        else if (attribute.type === 'password') {\n          // Always remove password attributes from filters object\n          removeOperator(key);\n        }\n\n        // Scalar attributes\n        else {\n          filters[key] = convertAndSanitizeFilters(value, schema);\n        }\n      }\n\n      // Handle operators\n      else if (['$null', '$notNull'].includes(key)) {\n        filters[key] = parseType({ type: 'boolean', value: filters[key], forceCast: true });\n      } else if (isObject(value)) {\n        filters[key] = convertAndSanitizeFilters(value, schema);\n      }\n\n      // Remove empty objects & arrays\n      if (isPlainObject(filters[key]) && isEmpty(filters[key])) {\n        removeOperator(key);\n      }\n    }\n\n    return filters;\n  };\n\n  const convertStatusParams = (status?: 'draft' | 'published', query: Query = {}) => {\n    // NOTE: this is the query layer filters not the document/entity service filters\n    query.filters = ({ meta }: { meta: Model }) => {\n      const contentType = getModel(meta.uid);\n\n      // Ignore if target model has disabled DP, as it doesn't make sense to filter by its status\n      if (!contentType || !hasDraftAndPublish(contentType)) {\n        return {};\n      }\n\n      return { [PUBLISHED_AT_ATTRIBUTE]: { $null: status === 'draft' } };\n    };\n  };\n\n  const transformQueryParams = (uid: string, params: Params): Query => {\n    // NOTE: can be a CT, a Compo or nothing in the case of polymorphism (DZ & morph relations)\n    const schema = getModel(uid);\n\n    const query: Query = {};\n\n    const { _q, sort, filters, fields, populate, page, pageSize, start, limit, status, ...rest } =\n      params;\n\n    if (!isNil(status)) {\n      convertStatusParams(status, query);\n    }\n\n    if (!isNil(_q)) {\n      query._q = _q;\n    }\n\n    if (!isNil(sort)) {\n      query.orderBy = convertSortQueryParams(sort);\n    }\n\n    if (!isNil(filters)) {\n      query.where = convertFiltersQueryParams(filters, schema);\n    }\n\n    if (!isNil(fields)) {\n      query.select = convertFieldsQueryParams(fields, schema);\n    }\n\n    if (!isNil(populate)) {\n      query.populate = convertPopulateQueryParams(populate, schema);\n    }\n\n    validatePaginationParams(page, pageSize, start, limit);\n\n    if (!isNil(page)) {\n      query.page = convertPageQueryParams(page);\n    }\n\n    if (!isNil(pageSize)) {\n      query.pageSize = convertPageSizeQueryParams(pageSize, page);\n    }\n\n    if (!isNil(start)) {\n      query.offset = convertStartQueryParams(start);\n    }\n\n    if (!isNil(limit)) {\n      query.limit = convertLimitQueryParams(limit);\n    }\n\n    return {\n      ...rest,\n      ...query,\n    };\n  };\n\n  return {\n    private_convertSortQueryParams: convertSortQueryParams,\n    private_convertStartQueryParams: convertStartQueryParams,\n    private_convertLimitQueryParams: convertLimitQueryParams,\n    private_convertPopulateQueryParams: convertPopulateQueryParams,\n    private_convertFiltersQueryParams: convertFiltersQueryParams,\n    private_convertFieldsQueryParams: convertFieldsQueryParams,\n    transformQueryParams,\n  };\n};\n\nexport { createTransformer };\n","import pMap from 'p-map';\nimport { curry } from 'lodash/fp';\n\ntype AnyFunc<TA extends any[] = any[], TR = any> = (...args: TA) => TR;\n\ntype MakeProm<T> = Promise<T extends PromiseLike<infer I> ? I : T>;\n\ntype PipedFunc<T extends AnyFunc[]> =\n  PipeReturn<T> extends never ? never : (...args: Parameters<T[0]>) => PipeReturn<T>;\n\ntype PipeReturn<F extends AnyFunc[]> = MakeProm<ReturnType<F[0]>>;\n\nexport function pipe<T extends AnyFunc[]>(...fns: PipeReturn<T> extends never ? never : T) {\n  const [firstFn, ...fnRest] = fns;\n\n  return (async (...args: any[]) => {\n    let res = await firstFn.apply(firstFn, args);\n\n    for (let i = 0; i < fnRest.length; i += 1) {\n      res = await fnRest[i](res);\n    }\n\n    return res;\n  }) as PipedFunc<T>;\n}\n\nexport const map = curry(pMap);\n\nexport const reduce =\n  (mixedArray: any[]) =>\n  async <T>(iteratee: AnyFunc, initialValue?: T) => {\n    let acc = initialValue;\n    for (let i = 0; i < mixedArray.length; i += 1) {\n      acc = await iteratee(acc, await mixedArray[i], i);\n    }\n    return acc;\n  };\n","import type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute }, { remove }) => {\n  if (attribute?.type === 'password') {\n    remove(key);\n  }\n};\n\nexport default visitor;\n","import { isPrivateAttribute } from '../../content-types';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ schema, key, attribute }, { remove }) => {\n  if (!attribute) {\n    return;\n  }\n\n  const isPrivate = attribute.private === true || isPrivateAttribute(schema, key);\n\n  if (isPrivate) {\n    remove(key);\n  }\n};\n\nexport default visitor;\n","import { isBoolean } from 'lodash/fp';\nimport type { Attribute, Model } from './types';\n\nimport { isRelationalAttribute } from './content-types';\n\nconst MANY_RELATIONS = ['oneToMany', 'manyToMany'];\n\nexport const getRelationalFields = (contentType: Model) => {\n  return Object.keys(contentType.attributes).filter((attributeName) => {\n    return contentType.attributes[attributeName].type === 'relation';\n  });\n};\n\nexport const isOneToAny = (attribute: Attribute) =>\n  isRelationalAttribute(attribute) && ['oneToOne', 'oneToMany'].includes(attribute.relation);\n\nexport const isManyToAny = (attribute: Attribute) =>\n  isRelationalAttribute(attribute) && ['manyToMany', 'manyToOne'].includes(attribute.relation);\n\nexport const isAnyToOne = (attribute: Attribute) =>\n  isRelationalAttribute(attribute) && ['oneToOne', 'manyToOne'].includes(attribute.relation);\n\nexport const isAnyToMany = (attribute: Attribute) =>\n  isRelationalAttribute(attribute) && ['oneToMany', 'manyToMany'].includes(attribute.relation);\n\nexport const isPolymorphic = (attribute: any): any =>\n  ['morphOne', 'morphMany', 'morphToOne', 'morphToMany'].includes(attribute.relation);\n\nexport const constants = {\n  MANY_RELATIONS,\n};\n\n// Valid keys in the `options` property of relations reordering\n// The value for each key must be a function that returns true if it is a valid value\nexport const VALID_RELATION_ORDERING_KEYS: { [key: string]: (value: any) => boolean } = {\n  strict: isBoolean,\n};\n","import { isArray, isObject } from 'lodash/fp';\nimport * as contentTypeUtils from '../../content-types';\nimport type { Visitor } from '../../traverse/factory';\nimport { RelationOrderingOptions } from '../../types';\nimport { VALID_RELATION_ORDERING_KEYS } from '../../relations';\n\nconst ACTIONS_TO_VERIFY = ['find'];\nconst { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = contentTypeUtils.constants;\n\ntype MorphArray = Array<{ __type: string }>;\n\nexport default (auth: unknown): Visitor =>\n  async ({ data, key, attribute, schema }, { remove, set }) => {\n    if (!attribute) {\n      return;\n    }\n\n    const isRelation = attribute.type === 'relation';\n\n    if (!isRelation) {\n      return;\n    }\n\n    const handleMorphRelation = async () => {\n      const elements: any = (data as Record<string, MorphArray>)[key];\n\n      if ('connect' in elements || 'set' in elements || 'disconnect' in elements) {\n        const newValue: Record<string, unknown> = {};\n\n        const connect = await handleMorphElements(elements.connect || []);\n        const relSet = await handleMorphElements(elements.set || []);\n        const disconnect = await handleMorphElements(elements.disconnect || []);\n\n        if (connect.length > 0) {\n          newValue.connect = connect;\n        }\n\n        if (relSet.length > 0) {\n          newValue.set = relSet;\n        }\n\n        if (disconnect.length > 0) {\n          newValue.disconnect = disconnect;\n        }\n\n        // TODO: this should technically be in its own visitor to check morph options, but for now we'll handle it here\n        if (\n          'options' in elements &&\n          typeof elements.options === 'object' &&\n          elements.options !== null\n        ) {\n          const filteredOptions: RelationOrderingOptions = {};\n\n          // Iterate through the keys of elements.options\n          Object.keys(elements.options).forEach((key) => {\n            const validator = VALID_RELATION_ORDERING_KEYS[key as keyof RelationOrderingOptions];\n\n            // Ensure the key exists in VALID_RELATION_ORDERING_KEYS and the validator is defined before calling it\n            if (validator && validator(elements.options[key])) {\n              filteredOptions[key as keyof RelationOrderingOptions] = elements.options[key];\n            }\n          });\n\n          // Assign the filtered options back to newValue\n          newValue.options = filteredOptions;\n        } else {\n          newValue.options = {};\n        }\n\n        set(key, newValue);\n      } else {\n        const newMorphValue = await handleMorphElements(elements);\n\n        if (newMorphValue.length) {\n          set(key, newMorphValue);\n        }\n      }\n    };\n\n    const handleMorphElements = async (elements: any[]) => {\n      const allowedElements: Record<string, unknown>[] = [];\n\n      if (!isArray(elements)) {\n        return allowedElements;\n      }\n\n      for (const element of elements) {\n        if (!isObject(element) || !('__type' in element)) {\n          continue;\n        }\n\n        const scopes = ACTIONS_TO_VERIFY.map((action) => `${element.__type}.${action}`);\n        const isAllowed = await hasAccessToSomeScopes(scopes, auth);\n\n        if (isAllowed) {\n          allowedElements.push(element);\n        }\n      }\n\n      return allowedElements;\n    };\n\n    const handleRegularRelation = async () => {\n      const scopes = ACTIONS_TO_VERIFY.map((action) => `${attribute.target}.${action}`);\n\n      const isAllowed = await hasAccessToSomeScopes(scopes, auth);\n\n      // If the authenticated user don't have access to any of the scopes, then remove the field\n      if (!isAllowed) {\n        remove(key);\n      }\n    };\n\n    const isCreatorRelation = [CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE].includes(key);\n\n    // Polymorphic relations\n    if (contentTypeUtils.isMorphToRelationalAttribute(attribute)) {\n      await handleMorphRelation();\n      return;\n    }\n\n    // Creator relations\n    if (isCreatorRelation && schema.options?.populateCreatorFields) {\n      // do nothing\n      return;\n    }\n\n    // Regular relations\n    await handleRegularRelation();\n  };\n\nconst hasAccessToSomeScopes = async (scopes: string[], auth: unknown) => {\n  for (const scope of scopes) {\n    try {\n      await strapi.auth.verify(auth, { scope });\n      return true;\n    } catch {\n      continue;\n    }\n  }\n\n  return false;\n};\n","import { isMorphToRelationalAttribute } from '../../content-types';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute }, { remove }) => {\n  if (isMorphToRelationalAttribute(attribute)) {\n    remove(key);\n  }\n};\n\nexport default visitor;\n","import { isDynamicZoneAttribute } from '../../content-types';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute }, { remove }) => {\n  if (isDynamicZoneAttribute(attribute)) {\n    remove(key);\n  }\n};\n\nexport default visitor;\n","import { isArray, isNil, isString, toPath } from 'lodash/fp';\nimport type { Visitor } from '../../traverse/factory';\n\nexport default (allowedFields: string[] | null = null): Visitor =>\n  ({ key, path: { attribute: path } }, { remove }) => {\n    // All fields are allowed\n    if (allowedFields === null) {\n      return;\n    }\n\n    // Throw on invalid formats\n    if (!(isArray(allowedFields) && allowedFields.every(isString))) {\n      throw new TypeError(\n        `Expected array of strings for allowedFields but got \"${typeof allowedFields}\"`\n      );\n    }\n\n    if (isNil(path)) {\n      return;\n    }\n\n    const containedPaths = getContainedPaths(path);\n\n    /**\n     * Tells if the current path should be kept or not based\n     * on the success of the check functions for any of the allowed paths.\n     *\n     * The check functions are defined as follow:\n     *\n     * `containedPaths.includes(p)`\n     * @example\n     * ```js\n     * const path = 'foo.bar.field';\n     * const p = 'foo.bar';\n     * // it should match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'bar.foo';\n     * // it shouldn't match\n     *\n     * const path = 'foo.bar';\n     * const p = 'foo.bar.field';\n     * // it should match but isn't handled by this check\n     * ```\n     *\n     * `p.startsWith(`${path}.`)`\n     * @example\n     * ```js\n     * const path = 'foo.bar';\n     * const p = 'foo.bar.field';\n     * // it should match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'bar.foo';\n     * // it shouldn't match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'foo.bar';\n     * // it should match but isn't handled by this check\n     * ```\n     */\n    const isPathAllowed = allowedFields.some(\n      (p) => containedPaths.includes(p) || p.startsWith(`${path}.`)\n    );\n\n    if (isPathAllowed) {\n      return;\n    }\n\n    // Remove otherwise\n    remove(key);\n  };\n\n/**\n * Retrieve the list of allowed paths based on the given path\n *\n * @example\n * ```js\n * const containedPaths = getContainedPaths('foo');\n * // ['foo']\n *\n *  * const containedPaths = getContainedPaths('foo.bar');\n * // ['foo', 'foo.bar']\n *\n *  * const containedPaths = getContainedPaths('foo.bar.field');\n * // ['foo', 'foo.bar', 'foo.bar.field']\n * ```\n */\nconst getContainedPaths = (path: string) => {\n  const parts = toPath(path);\n\n  return parts.reduce((acc, value, index, list) => {\n    return [...acc, list.slice(0, index + 1).join('.')];\n  }, [] as string[]);\n};\n","import { isArray, isString } from 'lodash/fp';\nimport type { Visitor } from '../../traverse/factory';\n\nexport default (restrictedFields: string[] | null = null): Visitor =>\n  ({ key, path: { attribute: path } }, { remove }) => {\n    // Remove all fields\n    if (restrictedFields === null) {\n      remove(key);\n      return;\n    }\n\n    // Throw on invalid formats\n    if (!(isArray(restrictedFields) && restrictedFields.every(isString))) {\n      throw new TypeError(\n        `Expected array of strings for restrictedFields but got \"${typeof restrictedFields}\"`\n      );\n    }\n\n    // Remove if an exact match was found\n    if (restrictedFields.includes(path as string)) {\n      remove(key);\n      return;\n    }\n\n    // Remove nested matches\n    const isRestrictedNested = restrictedFields.some((allowedPath) =>\n      path?.toString().startsWith(`${allowedPath}.`)\n    );\n    if (isRestrictedNested) {\n      remove(key);\n    }\n  };\n","import type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ schema, key, value }, { set }) => {\n  if (key === '' && value === '*') {\n    const { attributes } = schema;\n\n    const newPopulateQuery = Object.entries(attributes)\n      .filter(([, attribute]) =>\n        ['relation', 'component', 'media', 'dynamiczone'].includes(attribute.type)\n      )\n      .reduce<Record<string, true>>((acc, [key]) => ({ ...acc, [key]: true }), {});\n\n    set('', newPopulateQuery);\n  }\n};\n\nexport default visitor;\n","/* eslint-disable @typescript-eslint/no-loop-func */\nimport { isNil, pick } from 'lodash/fp';\n\nimport {\n  AnyAttribute,\n  Attribute,\n  ComponentAttribute,\n  DynamicZoneAttribute,\n  Model,\n  RelationalAttribute,\n} from '../types';\n\nexport interface Path {\n  raw: string | null;\n  attribute: string | null;\n}\n\nexport interface Parent {\n  attribute?: Attribute;\n  key: string | null;\n  path: Path;\n  schema: Model;\n}\n\nexport interface TraverseOptions {\n  schema: Model;\n  path?: Path;\n  parent?: Parent;\n  getModel(uid: string): Model;\n}\n\nexport interface VisitorOptions {\n  data: unknown;\n  value: unknown;\n  schema: Model;\n  key: string;\n  attribute?: AnyAttribute;\n  path: Path;\n  parent?: Parent;\n  getModel(uid: string): Model;\n}\n\nexport type Traverse = (\n  visitor: Visitor,\n  options: TraverseOptions,\n  data: unknown\n) => Promise<unknown>;\n\nexport interface Visitor {\n  (visitorOptions: VisitorOptions, opts: Pick<TransformUtils, 'set' | 'remove'>): void;\n}\n\ninterface Interceptor<T = unknown> {\n  predicate(data: unknown): data is T;\n  handler(\n    visitor: Visitor,\n    options: TraverseOptions,\n    data: T,\n    recurseOptions: { recurse: Traverse }\n  ): void;\n}\n\ninterface ParseUtils<T> {\n  transform(data: T): unknown;\n  remove(key: string, data: T): unknown;\n  set(key: string, value: unknown, data: T): unknown;\n  keys(data: T): string[];\n  get(key: string, data: T): unknown;\n}\n\ninterface Parser<T = unknown> {\n  predicate(data: unknown): data is T;\n  parser(data: T): ParseUtils<T>;\n}\n\ninterface Ignore {\n  (ctx: Context): boolean;\n}\n\ninterface AttributeHandler<AttributeType = Attribute> {\n  predicate(ctx: Context<AttributeType>): boolean;\n  handler(ctx: Context<AttributeType>, opts: Pick<TransformUtils, 'set' | 'recurse'>): void;\n}\ninterface CommonHandler<AttributeType = Attribute> {\n  predicate(ctx: Context<AttributeType>): boolean;\n  handler(ctx: Context<AttributeType>, opts: Pick<TransformUtils, 'set' | 'recurse'>): void;\n}\n\nexport interface TransformUtils {\n  remove(key: string): void;\n  set(key: string, value: unknown): void;\n  recurse: Traverse;\n}\n\ninterface Context<AttributeType = Attribute> {\n  key: string;\n  value: unknown;\n  attribute: AttributeType;\n  schema: Model;\n  path: Path;\n  data: unknown;\n  visitor: Visitor;\n  parent?: Parent;\n  getModel(uid: string): Model;\n}\n\ninterface State {\n  parsers: Parser[];\n  interceptors: Interceptor[];\n  ignore: Ignore[];\n  handlers: {\n    attributes: AttributeHandler[];\n    common: CommonHandler[];\n  };\n}\n\nconst DEFAULT_PATH = { raw: null, attribute: null } satisfies Path;\n\nexport default () => {\n  const state: State = {\n    parsers: [],\n    interceptors: [],\n    ignore: [],\n    handlers: {\n      attributes: [],\n      common: [],\n    },\n  };\n\n  const traverse: Traverse = async (visitor, options, data) => {\n    const { path = DEFAULT_PATH, parent, schema, getModel } = options ?? {};\n\n    // interceptors\n    for (const { predicate, handler } of state.interceptors) {\n      if (predicate(data)) {\n        return handler(visitor, options, data, { recurse: traverse });\n      }\n    }\n\n    // parsers\n    const parser = state.parsers.find((parser) => parser.predicate(data))?.parser;\n    const utils = parser?.(data);\n\n    // Return the data untouched if we don't know how to traverse it\n    if (!utils) {\n      return data;\n    }\n\n    // main loop\n    let out = utils.transform(data);\n    const keys = utils.keys(out);\n\n    for (const key of keys) {\n      const attribute = schema?.attributes?.[key];\n\n      const newPath = { ...path };\n\n      newPath.raw = isNil(path.raw) ? key : `${path.raw}.${key}`;\n\n      if (!isNil(attribute)) {\n        newPath.attribute = isNil(path.attribute) ? key : `${path.attribute}.${key}`;\n      }\n\n      // visitors\n      const visitorOptions: VisitorOptions = {\n        key,\n        value: utils.get(key, out),\n        attribute,\n        schema,\n        path: newPath,\n        data: out,\n        getModel,\n        parent,\n      };\n\n      const transformUtils: TransformUtils = {\n        remove(key) {\n          out = utils.remove(key, out);\n        },\n        set(key, value) {\n          out = utils.set(key, value, out);\n        },\n        recurse: traverse,\n      };\n\n      await visitor(visitorOptions, pick(['remove', 'set'], transformUtils));\n\n      const value = utils.get(key, out);\n\n      const createContext = (): Context => ({\n        key,\n        value,\n        attribute,\n        schema,\n        path: newPath,\n        data: out,\n        visitor,\n        getModel,\n        parent,\n      });\n\n      // ignore\n      const ignoreCtx = createContext();\n      const shouldIgnore = state.ignore.some((predicate) => predicate(ignoreCtx));\n\n      if (shouldIgnore) {\n        continue;\n      }\n\n      // handlers\n      const handlers = [...state.handlers.common, ...state.handlers.attributes];\n\n      for await (const handler of handlers) {\n        const ctx = createContext();\n        const pass = await handler.predicate(ctx);\n\n        if (pass) {\n          await handler.handler(ctx, pick(['recurse', 'set'], transformUtils));\n        }\n      }\n    }\n\n    return out;\n  };\n\n  return {\n    traverse,\n\n    intercept<T>(predicate: Interceptor<T>['predicate'], handler: Interceptor<T>['handler']) {\n      state.interceptors.push({ predicate, handler });\n      return this;\n    },\n\n    parse<T>(predicate: Parser<T>['predicate'], parser: Parser<T>['parser']) {\n      state.parsers.push({ predicate, parser });\n      return this;\n    },\n\n    ignore(predicate: Ignore) {\n      state.ignore.push(predicate);\n      return this;\n    },\n\n    on(predicate: CommonHandler['predicate'], handler: CommonHandler['handler']) {\n      state.handlers.common.push({ predicate, handler });\n      return this;\n    },\n\n    onAttribute(predicate: AttributeHandler['predicate'], handler: AttributeHandler['handler']) {\n      state.handlers.attributes.push({ predicate, handler });\n      return this;\n    },\n\n    onRelation(handler: AttributeHandler<RelationalAttribute>['handler']) {\n      return this.onAttribute(({ attribute }) => attribute?.type === 'relation', handler);\n    },\n\n    onMedia(handler: AttributeHandler<RelationalAttribute>['handler']) {\n      return this.onAttribute(({ attribute }) => attribute?.type === 'media', handler);\n    },\n\n    onComponent(handler: AttributeHandler<ComponentAttribute>['handler']) {\n      return this.onAttribute(({ attribute }) => attribute?.type === 'component', handler);\n    },\n\n    onDynamicZone(handler: AttributeHandler<DynamicZoneAttribute>['handler']) {\n      return this.onAttribute(({ attribute }) => attribute?.type === 'dynamiczone', handler);\n    },\n  };\n};\n","import { curry, isObject, isEmpty, isArray, isNil, cloneDeep, omit } from 'lodash/fp';\n\nimport traverseFactory, { type Parent } from './factory';\n\nconst isObj = (value: unknown): value is Record<string, unknown> => isObject(value);\n\nconst filters = traverseFactory()\n  .intercept(\n    // Intercept filters arrays and apply the traversal to each one individually\n    isArray,\n    async (visitor, options, filters, { recurse }) => {\n      return Promise.all(\n        filters.map((filter, i) => {\n          // In filters, only operators such as $and, $in, $notIn or $or and implicit operators like [...]\n          // can have a value array, thus we can update the raw path but not the attribute one\n          const newPath = options.path\n            ? { ...options.path, raw: `${options.path.raw}[${i}]` }\n            : options.path;\n\n          return recurse(visitor, { ...options, path: newPath }, filter);\n        })\n        // todo: move that to the visitors\n      ).then((res) => res.filter((val) => !(isObject(val) && isEmpty(val))));\n    }\n  )\n  .intercept(\n    // Ignore non object filters and return the value as-is\n    (filters): filters is unknown => !isObject(filters),\n    (_, __, filters) => {\n      return filters;\n    }\n  )\n  // Parse object values\n  .parse(isObj, () => ({\n    transform: cloneDeep,\n\n    remove(key, data) {\n      return omit(key, data);\n    },\n\n    set(key, value, data) {\n      return { ...data, [key]: value };\n    },\n\n    keys(data) {\n      return Object.keys(data);\n    },\n\n    get(key, data) {\n      return data[key];\n    },\n  }))\n  // Ignore null or undefined values\n  .ignore(({ value }) => isNil(value))\n  // Recursion on operators (non attributes)\n  .on(\n    ({ attribute }) => isNil(attribute),\n    async ({ key, visitor, path, value, schema, getModel, attribute }, { set, recurse }) => {\n      const parent: Parent = { key, path, schema, attribute };\n\n      set(key, await recurse(visitor, { schema, path, getModel, parent }, value));\n    }\n  )\n  // Handle relation recursion\n  .onRelation(\n    async ({ key, attribute, visitor, path, value, schema, getModel }, { set, recurse }) => {\n      const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n\n      if (isMorphRelation) {\n        return;\n      }\n\n      const parent: Parent = { key, path, schema, attribute };\n\n      const targetSchemaUID = attribute.target;\n      const targetSchema = getModel(targetSchemaUID!);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  )\n  .onComponent(\n    async ({ key, attribute, visitor, path, schema, value, getModel }, { set, recurse }) => {\n      const parent: Parent = { key, path, schema, attribute };\n      const targetSchema = getModel(attribute.component);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  )\n  // Handle media recursion\n  .onMedia(async ({ key, visitor, path, schema, attribute, value, getModel }, { set, recurse }) => {\n    const parent: Parent = { key, path, schema, attribute };\n\n    const targetSchemaUID = 'plugin::upload.file';\n    const targetSchema = getModel(targetSchemaUID);\n\n    const newValue = await recurse(\n      visitor,\n      { schema: targetSchema, path, getModel, parent },\n      value\n    );\n\n    set(key, newValue);\n  });\n\nexport default curry(filters.traverse);\n","import {\n  curry,\n  isString,\n  isObject,\n  map,\n  trim,\n  split,\n  isEmpty,\n  flatten,\n  pipe,\n  isNil,\n  first,\n  cloneDeep,\n} from 'lodash/fp';\n\nimport traverseFactory, { type Parent } from './factory';\n\nconst ORDERS = { asc: 'asc', desc: 'desc' };\nconst ORDER_VALUES = Object.values(ORDERS);\n\nconst isSortOrder = (value: string) => ORDER_VALUES.includes(value.toLowerCase());\nconst isStringArray = (value: unknown): value is string[] =>\n  Array.isArray(value) && value.every(isString);\nconst isObjectArray = (value: unknown): value is object[] =>\n  Array.isArray(value) && value.every(isObject);\nconst isNestedSorts = (value: unknown): value is string =>\n  isString(value) && value.split(',').length > 1;\n\nconst isObj = (value: unknown): value is Record<string, unknown> => isObject(value);\n\nconst sort = traverseFactory()\n  .intercept(\n    // String with chained sorts (foo,bar,foobar) => split, map(recurse), then recompose\n    isNestedSorts,\n    async (visitor, options, sort, { recurse }) => {\n      return Promise.all(\n        sort\n          .split(',')\n          .map(trim)\n          .map((nestedSort) => recurse(visitor, options, nestedSort))\n      ).then((res) => res.filter((part) => !isEmpty(part)).join(','));\n    }\n  )\n  .intercept(\n    // Array of strings ['foo', 'foo,bar'] => map(recurse), then filter out empty items\n    isStringArray,\n    async (visitor, options, sort, { recurse }) => {\n      return Promise.all(sort.map((nestedSort) => recurse(visitor, options, nestedSort))).then(\n        (res) => res.filter((nestedSort) => !isEmpty(nestedSort))\n      );\n    }\n  )\n  .intercept(\n    // Array of objects [{ foo: 'asc' }, { bar: 'desc', baz: 'asc' }] => map(recurse), then filter out empty items\n    isObjectArray,\n    async (visitor, options, sort, { recurse }) => {\n      return Promise.all(sort.map((nestedSort) => recurse(visitor, options, nestedSort))).then(\n        (res) => res.filter((nestedSort) => !isEmpty(nestedSort))\n      );\n    }\n  )\n  // Parse string values\n  .parse(isString, () => {\n    const tokenize = pipe(split('.'), map(split(':')), flatten);\n    const recompose = (parts: string[]) => {\n      if (parts.length === 0) {\n        return undefined;\n      }\n\n      return parts.reduce((acc, part) => {\n        if (isEmpty(part)) {\n          return acc;\n        }\n\n        if (acc === '') {\n          return part;\n        }\n\n        return isSortOrder(part) ? `${acc}:${part}` : `${acc}.${part}`;\n      }, '');\n    };\n\n    return {\n      transform: trim,\n\n      remove(key, data) {\n        const [root] = tokenize(data);\n\n        return root === key ? undefined : data;\n      },\n\n      set(key, value, data) {\n        const [root] = tokenize(data);\n\n        if (root !== key) {\n          return data;\n        }\n\n        return isNil(value) ? root : `${root}.${value}`;\n      },\n\n      keys(data) {\n        const v = first(tokenize(data));\n        return v ? [v] : [];\n      },\n\n      get(key, data) {\n        const [root, ...rest] = tokenize(data);\n\n        return key === root ? recompose(rest) : undefined;\n      },\n    };\n  })\n  // Parse object values\n  .parse(isObj, () => ({\n    transform: cloneDeep,\n\n    remove(key, data) {\n      // eslint-disable-next-line no-unused-vars\n      const { [key]: ignored, ...rest } = data;\n\n      return rest;\n    },\n\n    set(key, value, data) {\n      return { ...data, [key]: value };\n    },\n\n    keys(data) {\n      return Object.keys(data);\n    },\n\n    get(key, data) {\n      return data[key];\n    },\n  }))\n  // Handle deep sort on relation\n  .onRelation(\n    async ({ key, value, attribute, visitor, path, getModel, schema }, { set, recurse }) => {\n      const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n\n      if (isMorphRelation) {\n        return;\n      }\n\n      const parent: Parent = { key, path, schema, attribute };\n\n      const targetSchemaUID = attribute.target;\n      const targetSchema = getModel(targetSchemaUID!);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  )\n  // Handle deep sort on media\n  .onMedia(async ({ key, path, schema, attribute, visitor, value, getModel }, { recurse, set }) => {\n    const parent: Parent = { key, path, schema, attribute };\n\n    const targetSchemaUID = 'plugin::upload.file';\n    const targetSchema = getModel(targetSchemaUID);\n\n    const newValue = await recurse(\n      visitor,\n      { schema: targetSchema, path, getModel, parent },\n      value\n    );\n\n    set(key, newValue);\n  })\n  // Handle deep sort on components\n  .onComponent(\n    async ({ key, value, visitor, path, schema, attribute, getModel }, { recurse, set }) => {\n      const parent: Parent = { key, path, schema, attribute };\n\n      const targetSchema = getModel(attribute.component);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  );\n\nexport default curry(sort.traverse);\n","import {\n  curry,\n  isString,\n  isArray,\n  isEmpty,\n  split,\n  isObject,\n  trim,\n  constant,\n  isNil,\n  identity,\n  cloneDeep,\n  join,\n  first,\n} from 'lodash/fp';\n\nimport traverseFactory, { type Parent } from './factory';\nimport { Attribute } from '../types';\nimport { isMorphToRelationalAttribute } from '../content-types';\n\nconst isKeyword = (keyword: string) => {\n  return ({ key, attribute }: { key: string; attribute: Attribute }) => {\n    return !attribute && keyword === key;\n  };\n};\n\nconst isWildcard = (value: unknown): value is '*' => value === '*';\n\nconst isPopulateString = (value: unknown): value is string => {\n  return isString(value) && !isWildcard(value);\n};\n\nconst isStringArray = (value: unknown): value is string[] =>\n  isArray(value) && value.every(isString);\n\nconst isObj = (value: unknown): value is Record<string, unknown> => isObject(value);\n\nconst populate = traverseFactory()\n  .intercept(isPopulateString, async (visitor, options, populate, { recurse }) => {\n    /**\n     * Ensure the populate clause its in the extended format ( { populate: { ... } }, and not just a string)\n     * This gives a consistent structure to track the \"parent\" node of each nested populate clause\n     */\n    const populateObject = pathsToObjectPopulate([populate]);\n    const traversedPopulate = (await recurse(visitor, options, populateObject)) as PopulateObject;\n    const [result] = objectPopulateToPaths(traversedPopulate);\n\n    return result;\n  })\n  // Array of strings ['foo', 'bar.baz'] => map(recurse), then filter out empty items\n  .intercept(isStringArray, async (visitor, options, populate, { recurse }) => {\n    const paths = await Promise.all(\n      populate.map((subClause) => recurse(visitor, options, subClause))\n    );\n\n    return paths.filter((item) => !isNil(item));\n  })\n  // for wildcard, generate custom utilities to modify the values\n  .parse(isWildcard, () => ({\n    /**\n     * Since value is '*', we don't need to transform it\n     */\n    transform: identity,\n\n    /**\n     * '*' isn't a key/value structure, so regardless\n     *  of the given key, it returns the data ('*')\n     */\n    get: (_key, data) => data,\n\n    /**\n     * '*' isn't a key/value structure, so regardless\n     * of the given `key`, use `value` as the new `data`\n     */\n    set: (_key, value) => value,\n\n    /**\n     * '*' isn't a key/value structure, but we need to simulate at least one to enable\n     * the data traversal. We're using '' since it represents a falsy string value\n     */\n    keys: constant(['']),\n\n    /**\n     * Removing '*' means setting it to undefined, regardless of the given key\n     */\n    remove: constant(undefined),\n  }))\n\n  // Parse string values\n  .parse(isString, () => {\n    const tokenize = split('.');\n    const recompose = join('.');\n\n    return {\n      transform: trim,\n\n      remove(key, data) {\n        const [root] = tokenize(data);\n\n        return root === key ? undefined : data;\n      },\n\n      set(key, value, data) {\n        const [root] = tokenize(data);\n\n        if (root !== key) {\n          return data;\n        }\n\n        return isNil(value) || isEmpty(value) ? root : `${root}.${value}`;\n      },\n\n      keys(data) {\n        const v = first(tokenize(data));\n        return v ? [v] : [];\n      },\n\n      get(key, data) {\n        const [root, ...rest] = tokenize(data);\n\n        return key === root ? recompose(rest) : undefined;\n      },\n    };\n  })\n  // Parse object values\n  .parse(isObj, () => ({\n    transform: cloneDeep,\n\n    remove(key, data) {\n      // eslint-disable-next-line no-unused-vars\n      const { [key]: ignored, ...rest } = data;\n\n      return rest;\n    },\n\n    set(key, value, data) {\n      return { ...data, [key]: value };\n    },\n\n    keys(data) {\n      return Object.keys(data);\n    },\n\n    get(key, data) {\n      return data[key];\n    },\n  }))\n  .ignore(({ key, attribute }) => {\n    // we don't want to recurse using traversePopulate and instead let\n    // the visitors recurse with the appropriate traversal (sort, filters, etc...)\n    return ['sort', 'filters', 'fields'].includes(key) && !attribute;\n  })\n  .on(\n    // Handle recursion on populate.\"populate\"\n    isKeyword('populate'),\n    async ({ key, visitor, path, value, schema, getModel, attribute }, { set, recurse }) => {\n      const parent: Parent = { key, path, schema, attribute };\n\n      const newValue = await recurse(visitor, { schema, path, getModel, parent }, value);\n\n      set(key, newValue);\n    }\n  )\n  .on(\n    isKeyword('on'),\n    async ({ key, visitor, path, value, getModel, parent }, { set, recurse }) => {\n      const newOn: Record<string, unknown> = {};\n\n      if (!isObj(value)) {\n        return;\n      }\n\n      for (const [uid, subPopulate] of Object.entries(value)) {\n        const model = getModel(uid);\n        const newPath = { ...path, raw: `${path.raw}[${uid}]` };\n\n        newOn[uid] = await recurse(\n          visitor,\n          { schema: model, path: newPath, getModel, parent },\n          subPopulate\n        );\n      }\n\n      set(key, newOn);\n    }\n  )\n  // Handle populate on relation\n  .onRelation(\n    async ({ key, value, attribute, visitor, path, schema, getModel }, { set, recurse }) => {\n      if (isNil(value)) {\n        return;\n      }\n\n      const parent: Parent = { key, path, schema, attribute };\n\n      if (isMorphToRelationalAttribute(attribute)) {\n        // Don't traverse values that cannot be parsed\n        if (!isObject(value) || !('on' in value && isObject(value?.on))) {\n          return;\n        }\n\n        // If there is a populate fragment defined, traverse it\n        const newValue = await recurse(\n          visitor,\n          { schema, path, getModel, parent },\n          { on: value?.on }\n        );\n\n        set(key, newValue);\n\n        return;\n      }\n\n      const targetSchemaUID = attribute.target;\n      const targetSchema = getModel(targetSchemaUID!);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  )\n  // Handle populate on media\n  .onMedia(async ({ key, path, schema, attribute, visitor, value, getModel }, { recurse, set }) => {\n    if (isNil(value)) {\n      return;\n    }\n\n    const parent: Parent = { key, path, schema, attribute };\n\n    const targetSchemaUID = 'plugin::upload.file';\n    const targetSchema = getModel(targetSchemaUID);\n\n    const newValue = await recurse(\n      visitor,\n      { schema: targetSchema, path, getModel, parent },\n      value\n    );\n\n    set(key, newValue);\n  })\n  // Handle populate on components\n  .onComponent(\n    async ({ key, value, schema, visitor, path, attribute, getModel }, { recurse, set }) => {\n      if (isNil(value)) {\n        return;\n      }\n\n      const parent: Parent = { key, path, schema, attribute };\n\n      const targetSchema = getModel(attribute.component);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  )\n  // Handle populate on dynamic zones\n  .onDynamicZone(\n    async ({ key, value, schema, visitor, path, attribute, getModel }, { set, recurse }) => {\n      if (isNil(value) || !isObject(value)) {\n        return;\n      }\n\n      const parent: Parent = { key, path, schema, attribute };\n\n      // Handle fragment syntax\n      if ('on' in value && value.on) {\n        const newOn = await recurse(visitor, { schema, path, getModel, parent }, { on: value.on });\n\n        set(key, newOn);\n      }\n    }\n  );\n\nexport default curry(populate.traverse);\n\ntype PopulateObject = {\n  [key: string]: true | { populate: PopulateObject };\n};\n\nconst objectPopulateToPaths = (input: PopulateObject): string[] => {\n  const paths: string[] = [];\n\n  function traverse(currentObj: PopulateObject, parentPath: string) {\n    for (const [key, value] of Object.entries(currentObj)) {\n      const currentPath = parentPath ? `${parentPath}.${key}` : key;\n      if (value === true) {\n        paths.push(currentPath);\n      } else {\n        traverse((value as { populate: PopulateObject }).populate, currentPath);\n      }\n    }\n  }\n\n  traverse(input, '');\n\n  return paths;\n};\n\nconst pathsToObjectPopulate = (input: string[]): PopulateObject => {\n  const result: PopulateObject = {};\n\n  function traverse(object: PopulateObject, keys: string[]): void {\n    const [first, ...rest] = keys;\n    if (rest.length === 0) {\n      object[first] = true;\n    } else {\n      if (!object[first] || typeof object[first] === 'boolean') {\n        object[first] = { populate: {} };\n      }\n      traverse((object[first] as { populate: PopulateObject }).populate, rest);\n    }\n  }\n\n  input.forEach((clause) => traverse(result, clause.split('.')));\n\n  return result;\n};\n","import { curry, isArray, isString, eq, trim, constant } from 'lodash/fp';\n\nimport traverseFactory from './factory';\n\nconst isStringArray = (value: unknown): value is string[] => {\n  return isArray(value) && value.every(isString);\n};\n\nconst fields = traverseFactory()\n  // Intercept array of strings\n  // e.g. fields=['title', 'description']\n  .intercept(isStringArray, async (visitor, options, fields, { recurse }) => {\n    return Promise.all(fields.map((field) => recurse(visitor, options, field)));\n  })\n  // Intercept comma separated fields (as string)\n  // e.g. fields='title,description'\n  .intercept(\n    (value): value is string => isString(value) && value.includes(','),\n    (visitor, options, fields, { recurse }) => {\n      return Promise.all(fields.split(',').map((field) => recurse(visitor, options, field)));\n    }\n  )\n  // Return wildcards as is\n  .intercept((value): value is string => eq('*', value), constant('*'))\n  // Parse string values\n  // Since we're parsing strings only, each value should be an attribute name (and it's value, undefined),\n  // thus it shouldn't be possible to set a new value, and get should return the whole data if key === data\n  .parse(isString, () => ({\n    transform: trim,\n\n    remove(key, data) {\n      return data === key ? undefined : data;\n    },\n\n    set(_key, _value, data) {\n      return data;\n    },\n\n    keys(data) {\n      return [data];\n    },\n\n    get(key, data) {\n      return key === data ? data : undefined;\n    },\n  }));\n\nexport default curry(fields.traverse);\n","import { curry, isEmpty, isNil, isArray, isObject } from 'lodash/fp';\n\nimport { pipe as pipeAsync } from '../async';\nimport traverseEntity from '../traverse-entity';\nimport { isScalarAttribute, constants } from '../content-types';\n\nimport {\n  traverseQueryFilters,\n  traverseQuerySort,\n  traverseQueryPopulate,\n  traverseQueryFields,\n} from '../traverse';\n\nimport {\n  removePassword,\n  removePrivate,\n  removeDynamicZones,\n  removeMorphToRelations,\n  expandWildcardPopulate,\n} from './visitors';\nimport { isOperator } from '../operators';\n\nimport type { Model, Data } from '../types';\nimport type { Parent } from '../traverse/factory';\n\ninterface Context {\n  schema: Model;\n  getModel: (model: string) => Model;\n  parent?: Parent;\n}\n\nconst { ID_ATTRIBUTE, DOC_ID_ATTRIBUTE } = constants;\n\nconst sanitizePasswords = (ctx: Context) => async (entity: Data) => {\n  if (!ctx.schema) {\n    throw new Error('Missing schema in sanitizePasswords');\n  }\n\n  return traverseEntity(removePassword, ctx, entity);\n};\n\nconst defaultSanitizeOutput = async (ctx: Context, entity: Data) => {\n  if (!ctx.schema) {\n    throw new Error('Missing schema in defaultSanitizeOutput');\n  }\n\n  return traverseEntity(\n    (...args) => {\n      removePassword(...args);\n      removePrivate(...args);\n    },\n    ctx,\n    entity\n  );\n};\n\nconst defaultSanitizeFilters = curry((ctx: Context, filters: unknown) => {\n  if (!ctx.schema) {\n    throw new Error('Missing schema in defaultSanitizeFilters');\n  }\n\n  return pipeAsync(\n    // Remove keys that are not attributes or valid operators\n    traverseQueryFilters(({ key, attribute }, { remove }) => {\n      const isAttribute = !!attribute;\n\n      // ID is not an attribute per se, so we need to make\n      // an extra check to ensure we're not checking it\n      if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n        return;\n      }\n\n      if (!isAttribute && !isOperator(key)) {\n        remove(key);\n      }\n    }, ctx),\n    // Remove dynamic zones from filters\n    traverseQueryFilters(removeDynamicZones, ctx),\n    // Remove morpTo relations from filters\n    traverseQueryFilters(removeMorphToRelations, ctx),\n    // Remove passwords from filters\n    traverseQueryFilters(removePassword, ctx),\n    // Remove private from filters\n    traverseQueryFilters(removePrivate, ctx),\n    // Remove empty objects\n    traverseQueryFilters(({ key, value }, { remove }) => {\n      if (isObject(value) && isEmpty(value)) {\n        remove(key);\n      }\n    }, ctx)\n  )(filters);\n});\n\nconst defaultSanitizeSort = curry((ctx: Context, sort: unknown) => {\n  if (!ctx.schema) {\n    throw new Error('Missing schema in defaultSanitizeSort');\n  }\n\n  return pipeAsync(\n    // Remove non attribute keys\n    traverseQuerySort(({ key, attribute }, { remove }) => {\n      // ID is not an attribute per se, so we need to make\n      // an extra check to ensure we're not checking it\n      if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n        return;\n      }\n\n      if (!attribute) {\n        remove(key);\n      }\n    }, ctx),\n    // Remove dynamic zones from sort\n    traverseQuerySort(removeDynamicZones, ctx),\n    // Remove morpTo relations from sort\n    traverseQuerySort(removeMorphToRelations, ctx),\n    // Remove private from sort\n    traverseQuerySort(removePrivate, ctx),\n    // Remove passwords from filters\n    traverseQuerySort(removePassword, ctx),\n    // Remove keys for empty non-scalar values\n    traverseQuerySort(({ key, attribute, value }, { remove }) => {\n      // ID is not an attribute per se, so we need to make\n      // an extra check to ensure we're not removing it\n      if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n        return;\n      }\n\n      if (!isScalarAttribute(attribute) && isEmpty(value)) {\n        remove(key);\n      }\n    }, ctx)\n  )(sort);\n});\n\nconst defaultSanitizeFields = curry((ctx: Context, fields: unknown) => {\n  if (!ctx.schema) {\n    throw new Error('Missing schema in defaultSanitizeFields');\n  }\n\n  return pipeAsync(\n    // Only keep scalar attributes\n    traverseQueryFields(({ key, attribute }, { remove }) => {\n      // ID is not an attribute per se, so we need to make\n      // an extra check to ensure we're not checking it\n      if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n        return;\n      }\n\n      if (isNil(attribute) || !isScalarAttribute(attribute)) {\n        remove(key);\n      }\n    }, ctx),\n    // Remove private fields\n    traverseQueryFields(removePrivate, ctx),\n    // Remove password fields\n    traverseQueryFields(removePassword, ctx),\n    // Remove nil values from fields array\n    (value) => (isArray(value) ? value.filter((field) => !isNil(field)) : value)\n  )(fields);\n});\n\nconst defaultSanitizePopulate = curry((ctx: Context, populate: unknown) => {\n  if (!ctx.schema) {\n    throw new Error('Missing schema in defaultSanitizePopulate');\n  }\n\n  return pipeAsync(\n    traverseQueryPopulate(expandWildcardPopulate, ctx),\n    traverseQueryPopulate(async ({ key, value, schema, attribute, getModel, path }, { set }) => {\n      if (attribute) {\n        return;\n      }\n\n      const parent = { key, path, schema, attribute } satisfies Parent;\n\n      if (key === 'sort') {\n        set(key, await defaultSanitizeSort({ schema, getModel, parent }, value));\n      }\n\n      if (key === 'filters') {\n        set(key, await defaultSanitizeFilters({ schema, getModel, parent }, value));\n      }\n\n      if (key === 'fields') {\n        set(key, await defaultSanitizeFields({ schema, getModel, parent }, value));\n      }\n\n      if (key === 'populate') {\n        set(key, await defaultSanitizePopulate({ schema, getModel, parent }, value));\n      }\n    }, ctx),\n    // Remove private fields\n    traverseQueryPopulate(removePrivate, ctx)\n  )(populate);\n});\n\nexport {\n  sanitizePasswords,\n  defaultSanitizeOutput,\n  defaultSanitizeFilters,\n  defaultSanitizeSort,\n  defaultSanitizeFields,\n  defaultSanitizePopulate,\n};\n","import { CurriedFunction1 } from 'lodash';\nimport { isArray, cloneDeep, omit } from 'lodash/fp';\n\nimport { constants, getNonWritableAttributes } from '../content-types';\nimport { pipe as pipeAsync } from '../async';\n\nimport * as visitors from './visitors';\nimport * as sanitizers from './sanitizers';\nimport traverseEntity from '../traverse-entity';\n\nimport { traverseQueryFilters, traverseQuerySort, traverseQueryPopulate } from '../traverse';\nimport type { Model, Data } from '../types';\n\nexport interface Options {\n  auth?: unknown;\n}\n\nexport interface Sanitizer {\n  (schema: Model): CurriedFunction1<Data, Promise<Data>>;\n}\nexport interface SanitizeFunc {\n  (data: unknown, schema: Model, options?: Options): Promise<unknown>;\n}\n\nexport interface APIOptions {\n  sanitizers?: Sanitizers;\n  getModel: (model: string) => Model;\n}\n\nexport interface Sanitizers {\n  input?: Sanitizer[];\n  output?: Sanitizer[];\n}\n\nconst createAPISanitizers = (opts: APIOptions) => {\n  const { getModel } = opts;\n\n  const sanitizeInput: SanitizeFunc = (data: unknown, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeInput');\n    }\n    if (isArray(data)) {\n      return Promise.all(data.map((entry) => sanitizeInput(entry, schema, { auth })));\n    }\n\n    const nonWritableAttributes = getNonWritableAttributes(schema);\n\n    const transforms = [\n      // Remove first level ID in inputs\n      omit(constants.ID_ATTRIBUTE),\n      omit(constants.DOC_ID_ATTRIBUTE),\n      // Remove non-writable attributes\n      traverseEntity(visitors.removeRestrictedFields(nonWritableAttributes), { schema, getModel }),\n    ];\n\n    if (auth) {\n      // Remove restricted relations\n      transforms.push(\n        traverseEntity(visitors.removeRestrictedRelations(auth), { schema, getModel })\n      );\n    }\n\n    // Apply sanitizers from registry if exists\n    opts?.sanitizers?.input?.forEach((sanitizer: Sanitizer) => transforms.push(sanitizer(schema)));\n\n    return pipeAsync(...transforms)(data as Data);\n  };\n\n  const sanitizeOutput: SanitizeFunc = async (data, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeOutput');\n    }\n    if (isArray(data)) {\n      const res = new Array(data.length);\n      for (let i = 0; i < data.length; i += 1) {\n        res[i] = await sanitizeOutput(data[i], schema, { auth });\n      }\n      return res;\n    }\n\n    const transforms = [\n      (data: Data) => sanitizers.defaultSanitizeOutput({ schema, getModel }, data),\n    ];\n\n    if (auth) {\n      transforms.push(\n        traverseEntity(visitors.removeRestrictedRelations(auth), { schema, getModel })\n      );\n    }\n\n    // Apply sanitizers from registry if exists\n    opts?.sanitizers?.output?.forEach((sanitizer: Sanitizer) => transforms.push(sanitizer(schema)));\n\n    return pipeAsync(...transforms)(data as Data);\n  };\n\n  const sanitizeQuery = async (\n    query: Record<string, unknown>,\n    schema: Model,\n    { auth }: Options = {}\n  ) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeQuery');\n    }\n    const { filters, sort, fields, populate } = query;\n\n    const sanitizedQuery = cloneDeep(query);\n\n    if (filters) {\n      Object.assign(sanitizedQuery, { filters: await sanitizeFilters(filters, schema, { auth }) });\n    }\n\n    if (sort) {\n      Object.assign(sanitizedQuery, { sort: await sanitizeSort(sort, schema, { auth }) });\n    }\n\n    if (fields) {\n      Object.assign(sanitizedQuery, { fields: await sanitizeFields(fields, schema) });\n    }\n\n    if (populate) {\n      Object.assign(sanitizedQuery, { populate: await sanitizePopulate(populate, schema) });\n    }\n\n    return sanitizedQuery;\n  };\n\n  const sanitizeFilters: SanitizeFunc = (filters, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeFilters');\n    }\n    if (isArray(filters)) {\n      return Promise.all(filters.map((filter) => sanitizeFilters(filter, schema, { auth })));\n    }\n\n    const transforms = [sanitizers.defaultSanitizeFilters({ schema, getModel })];\n\n    if (auth) {\n      transforms.push(\n        traverseQueryFilters(visitors.removeRestrictedRelations(auth), { schema, getModel })\n      );\n    }\n\n    return pipeAsync(...transforms)(filters);\n  };\n\n  const sanitizeSort: SanitizeFunc = (sort, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeSort');\n    }\n    const transforms = [sanitizers.defaultSanitizeSort({ schema, getModel })];\n\n    if (auth) {\n      transforms.push(\n        traverseQuerySort(visitors.removeRestrictedRelations(auth), { schema, getModel })\n      );\n    }\n\n    return pipeAsync(...transforms)(sort);\n  };\n\n  const sanitizeFields: SanitizeFunc = (fields, schema: Model) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeFields');\n    }\n    const transforms = [sanitizers.defaultSanitizeFields({ schema, getModel })];\n\n    return pipeAsync(...transforms)(fields);\n  };\n\n  const sanitizePopulate: SanitizeFunc = (populate, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizePopulate');\n    }\n    const transforms = [sanitizers.defaultSanitizePopulate({ schema, getModel })];\n\n    if (auth) {\n      transforms.push(\n        traverseQueryPopulate(visitors.removeRestrictedRelations(auth), { schema, getModel })\n      );\n    }\n\n    return pipeAsync(...transforms)(populate);\n  };\n\n  return {\n    input: sanitizeInput,\n    output: sanitizeOutput,\n    query: sanitizeQuery,\n    filters: sanitizeFilters,\n    sort: sanitizeSort,\n    fields: sanitizeFields,\n    populate: sanitizePopulate,\n  };\n};\n\nexport { createAPISanitizers, sanitizers, visitors };\n\nexport type APISanitiers = ReturnType<typeof createAPISanitizers>;\n","// lodash/fp curry does not handle async functions properly, and creates very \"ugly\" types,\n// so we will use our own version to ensure curried functions are typed correctly\n// TODO: Export this from root @strapi/utils so we don't have copies of it between packages\n\nimport { ValidationError } from '../errors';\n\nexport const throwInvalidKey = ({ key, path }: { key: string; path?: string | null }): never => {\n  const msg = path && path !== key ? `Invalid key ${key} at ${path}` : `Invalid key ${key}`;\n\n  throw new ValidationError(msg, {\n    key,\n    path,\n  });\n};\n\nexport const asyncCurry = <A extends unknown[], R>(\n  fn: (...args: A) => Promise<R>\n): ((...args: Partial<A>) => any) => {\n  const curried = (...args: unknown[]): unknown => {\n    if (args.length >= fn.length) {\n      return fn(...(args as A));\n    }\n    return (...moreArgs: unknown[]) => curried(...args, ...moreArgs);\n  };\n\n  return curried;\n};\n","import { throwInvalidKey } from '../utils';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute, path }) => {\n  if (attribute?.type === 'password') {\n    throwInvalidKey({ key, path: path.attribute });\n  }\n};\n\nexport default visitor;\n","import { isPrivateAttribute } from '../../content-types';\nimport { throwInvalidKey } from '../utils';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ schema, key, attribute, path }) => {\n  if (!attribute) {\n    return;\n  }\n\n  const isPrivate = attribute.private === true || isPrivateAttribute(schema, key);\n\n  if (isPrivate) {\n    throwInvalidKey({ key, path: path.attribute });\n  }\n};\n\nexport default visitor;\n","import { isArray, isObject } from 'lodash/fp';\nimport * as contentTypeUtils from '../../content-types';\nimport { throwInvalidKey } from '../utils';\nimport type { Visitor } from '../../traverse/factory';\nimport { VALID_RELATION_ORDERING_KEYS } from '../../relations';\n\nconst ACTIONS_TO_VERIFY = ['find'];\nconst { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = contentTypeUtils.constants;\n\ntype MorphArray = Array<{ __type: string }>;\n\nexport default (auth: unknown): Visitor =>\n  async ({ data, key, attribute, schema, path }) => {\n    if (!attribute) {\n      return;\n    }\n\n    const isRelation = attribute.type === 'relation';\n\n    if (!isRelation) {\n      return;\n    }\n\n    const handleMorphRelation = async () => {\n      const elements: any = (data as Record<string, MorphArray>)[key];\n\n      if (\n        'connect' in elements ||\n        'set' in elements ||\n        'disconnect' in elements ||\n        'options' in elements\n      ) {\n        await handleMorphElements(elements.connect || []);\n        await handleMorphElements(elements.set || []);\n        await handleMorphElements(elements.disconnect || []);\n\n        // TODO: this should technically be in its own visitor to check morph options, but for now we'll handle it here\n        if ('options' in elements) {\n          if (elements.options === null || elements.options === undefined) {\n            return;\n          }\n\n          if (typeof elements.options !== 'object') {\n            throwInvalidKey({ key, path: path.attribute });\n          }\n\n          const optionKeys = Object.keys(elements.options);\n\n          // Validate each key based on its validator function\n          for (const key of optionKeys) {\n            if (!(key in VALID_RELATION_ORDERING_KEYS)) {\n              throwInvalidKey({ key, path: path.attribute });\n            }\n            if (!VALID_RELATION_ORDERING_KEYS[key](elements.options[key])) {\n              throwInvalidKey({ key, path: path.attribute });\n            }\n          }\n        }\n      } else {\n        await handleMorphElements(elements);\n      }\n    };\n\n    const handleMorphElements = async (elements: any[]) => {\n      if (!isArray(elements)) {\n        throwInvalidKey({ key, path: path.attribute });\n      }\n\n      for (const element of elements) {\n        if (!isObject(element) || !('__type' in element)) {\n          throwInvalidKey({ key, path: path.attribute });\n        }\n\n        const scopes = ACTIONS_TO_VERIFY.map((action) => `${element.__type}.${action}`);\n        const isAllowed = await hasAccessToSomeScopes(scopes, auth);\n\n        if (!isAllowed) {\n          throwInvalidKey({ key, path: path.attribute });\n        }\n      }\n    };\n\n    const handleRegularRelation = async () => {\n      const scopes = ACTIONS_TO_VERIFY.map((action) => `${attribute.target}.${action}`);\n\n      const isAllowed = await hasAccessToSomeScopes(scopes, auth);\n\n      // If the authenticated user don't have access to any of the scopes\n      if (!isAllowed) {\n        throwInvalidKey({ key, path: path.attribute });\n      }\n    };\n\n    const isCreatorRelation = [CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE].includes(key);\n\n    // Polymorphic relations\n    if (contentTypeUtils.isMorphToRelationalAttribute(attribute)) {\n      await handleMorphRelation();\n      return;\n    }\n\n    // Creator relations\n    if (isCreatorRelation && schema.options?.populateCreatorFields) {\n      // do nothing\n      return;\n    }\n\n    // Regular relations\n    await handleRegularRelation();\n  };\n\nconst hasAccessToSomeScopes = async (scopes: string[], auth: unknown) => {\n  for (const scope of scopes) {\n    try {\n      await strapi.auth.verify(auth, { scope });\n      return true;\n    } catch {\n      continue;\n    }\n  }\n\n  return false;\n};\n","import { isMorphToRelationalAttribute } from '../../content-types';\nimport { throwInvalidKey } from '../utils';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute, path }) => {\n  if (isMorphToRelationalAttribute(attribute)) {\n    throwInvalidKey({ key, path: path.attribute });\n  }\n};\n\nexport default visitor;\n","import { isDynamicZoneAttribute } from '../../content-types';\nimport { throwInvalidKey } from '../utils';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute, path }) => {\n  if (isDynamicZoneAttribute(attribute)) {\n    throwInvalidKey({ key, path: path.attribute });\n  }\n};\n\nexport default visitor;\n","import { isArray, isNil, isString, toPath } from 'lodash/fp';\nimport type { Visitor } from '../../traverse/factory';\nimport { throwInvalidKey } from '../utils';\n\nexport default (allowedFields: string[] | null = null): Visitor =>\n  ({ key, path: { attribute: path } }) => {\n    // All fields are allowed\n    if (allowedFields === null) {\n      return;\n    }\n\n    // Throw on invalid formats\n    if (!(isArray(allowedFields) && allowedFields.every(isString))) {\n      throw new TypeError(\n        `Expected array of strings for allowedFields but got \"${typeof allowedFields}\"`\n      );\n    }\n\n    if (isNil(path)) {\n      return;\n    }\n\n    const containedPaths = getContainedPaths(path);\n\n    /**\n     * Tells if the current path should be kept or not based\n     * on the success of the check functions for any of the allowed paths.\n     *\n     * The check functions are defined as follow:\n     *\n     * `containedPaths.includes(p)`\n     * @example\n     * ```js\n     * const path = 'foo.bar.field';\n     * const p = 'foo.bar';\n     * // it should match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'bar.foo';\n     * // it shouldn't match\n     *\n     * const path = 'foo.bar';\n     * const p = 'foo.bar.field';\n     * // it should match but isn't handled by this check\n     * ```\n     *\n     * `p.startsWith(`${path}.`)`\n     * @example\n     * ```js\n     * const path = 'foo.bar';\n     * const p = 'foo.bar.field';\n     * // it should match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'bar.foo';\n     * // it shouldn't match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'foo.bar';\n     * // it should match but isn't handled by this check\n     * ```\n     */\n    const isPathAllowed = allowedFields.some(\n      (p) => containedPaths.includes(p) || p.startsWith(`${path}.`)\n    );\n\n    if (isPathAllowed) {\n      return;\n    }\n\n    // throw otherwise\n    throwInvalidKey({ key, path });\n  };\n\n/**\n * Retrieve the list of allowed paths based on the given path\n *\n * @example\n * ```js\n * const containedPaths = getContainedPaths('foo');\n * // ['foo']\n *\n *  * const containedPaths = getContainedPaths('foo.bar');\n * // ['foo', 'foo.bar']\n *\n *  * const containedPaths = getContainedPaths('foo.bar.field');\n * // ['foo', 'foo.bar', 'foo.bar.field']\n * ```\n */\nconst getContainedPaths = (path: string) => {\n  const parts = toPath(path);\n\n  return parts.reduce((acc, value, index, list) => {\n    return [...acc, list.slice(0, index + 1).join('.')];\n  }, [] as string[]);\n};\n","import { isArray, isString } from 'lodash/fp';\nimport type { Visitor } from '../../traverse/factory';\nimport { throwInvalidKey } from '../utils';\n\nexport default (restrictedFields: string[] | null = null): Visitor =>\n  ({ key, path: { attribute: path } }) => {\n    // all fields\n    if (restrictedFields === null) {\n      throwInvalidKey({ key, path });\n    }\n\n    // Throw on invalid formats\n    if (!(isArray(restrictedFields) && restrictedFields.every(isString))) {\n      throw new TypeError(\n        `Expected array of strings for restrictedFields but got \"${typeof restrictedFields}\"`\n      );\n    }\n\n    // if an exact match was found\n    if (restrictedFields.includes(path as string)) {\n      throwInvalidKey({ key, path });\n    }\n\n    // nested matches\n    const isRestrictedNested = restrictedFields.some((allowedPath) =>\n      path?.toString().startsWith(`${allowedPath}.`)\n    );\n    if (isRestrictedNested) {\n      throwInvalidKey({ key, path });\n    }\n  };\n","import {\n  isDynamicZoneAttribute,\n  isMorphToRelationalAttribute,\n  isRelationalAttribute,\n  constants,\n  isComponentSchema,\n  isMediaAttribute,\n  hasRelationReordering,\n} from '../../content-types';\nimport type { Visitor } from '../../traverse-entity';\nimport { throwInvalidKey } from '../utils';\n\n// TODO these should all be centralized somewhere instead of maintaining a list\nconst ID_FIELDS = [constants.DOC_ID_ATTRIBUTE, constants.DOC_ID_ATTRIBUTE];\nconst ALLOWED_ROOT_LEVEL_FIELDS = [...ID_FIELDS];\nconst MORPH_TO_ALLOWED_FIELDS = ['__type'];\nconst DYNAMIC_ZONE_ALLOWED_FIELDS = ['__component'];\nconst RELATION_REORDERING_FIELDS = ['connect', 'disconnect', 'set', 'options'];\n\nconst throwUnrecognizedFields: Visitor = ({ key, attribute, path, schema, parent }) => {\n  // We only look at properties that are not attributes\n  if (attribute) {\n    return;\n  }\n\n  // At root level (path.attribute === null), only accept allowed fields\n  if (path.attribute === null) {\n    if (ALLOWED_ROOT_LEVEL_FIELDS.includes(key)) {\n      return;\n    }\n\n    return throwInvalidKey({ key, path: attribute });\n  }\n\n  // allow special morphTo keys\n  if (isMorphToRelationalAttribute(parent?.attribute) && MORPH_TO_ALLOWED_FIELDS.includes(key)) {\n    return;\n  }\n\n  // allow special dz keys\n  if (\n    isComponentSchema(schema) &&\n    isDynamicZoneAttribute(parent?.attribute) &&\n    DYNAMIC_ZONE_ALLOWED_FIELDS.includes(key)\n  ) {\n    return;\n  }\n\n  // allow special relation reordering keys in manyToX and XtoMany relations\n  if (hasRelationReordering(parent?.attribute) && RELATION_REORDERING_FIELDS.includes(key)) {\n    return;\n  }\n\n  // allow id fields where it is needed for setting a relational id rather than trying to create with a given id\n  const canUseID = isRelationalAttribute(parent?.attribute) || isMediaAttribute(parent?.attribute);\n  if (canUseID && !ID_FIELDS.includes(key)) {\n    return;\n  }\n\n  // if we couldn't find any reason for it to be here, throw\n  throwInvalidKey({ key, path: attribute });\n};\n\nexport default throwUnrecognizedFields;\n","import { isEmpty, isNil, isObject } from 'lodash/fp';\n\nimport { pipe as pipeAsync } from '../async';\nimport { isScalarAttribute, constants } from '../content-types';\nimport {\n  traverseQueryFilters,\n  traverseQuerySort,\n  traverseQueryFields,\n  traverseQueryPopulate,\n} from '../traverse';\nimport { throwPassword, throwPrivate, throwDynamicZones, throwMorphToRelations } from './visitors';\nimport { isOperator } from '../operators';\nimport { asyncCurry, throwInvalidKey } from './utils';\nimport type { Model } from '../types';\nimport parseType from '../parse-type';\nimport type { Parent, Path } from '../traverse/factory';\n\nconst { ID_ATTRIBUTE, DOC_ID_ATTRIBUTE } = constants;\n\ninterface Context {\n  schema: Model;\n  getModel: (model: string) => Model;\n}\n\ninterface PopulateContext extends Context {\n  path?: Path;\n  parent?: Parent;\n}\n\ntype AnyFunc = (...args: any[]) => any;\n\nexport const FILTER_TRAVERSALS = [\n  'nonAttributesOperators',\n  'dynamicZones',\n  'morphRelations',\n  'passwords',\n  'private',\n];\n\nexport const validateFilters = asyncCurry(\n  async (ctx: Context, filters: unknown, include: (typeof FILTER_TRAVERSALS)[number][]) => {\n    // TODO: schema checks should check that it is a valid schema with yup\n    if (!ctx.schema) {\n      throw new Error('Missing schema in defaultValidateFilters');\n    }\n\n    // Build the list of functions conditionally\n    const functionsToApply: Array<AnyFunc> = [];\n\n    // keys that are not attributes or valid operators\n    if (include.includes('nonAttributesOperators')) {\n      functionsToApply.push(\n        traverseQueryFilters(({ key, attribute, path }) => {\n          // ID is not an attribute per se, so we need to make\n          // an extra check to ensure we're not removing it\n          if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n            return;\n          }\n\n          const isAttribute = !!attribute;\n\n          if (!isAttribute && !isOperator(key)) {\n            throwInvalidKey({ key, path: path.attribute });\n          }\n        }, ctx)\n      );\n    }\n\n    if (include.includes('dynamicZones')) {\n      functionsToApply.push(traverseQueryFilters(throwDynamicZones, ctx));\n    }\n\n    if (include.includes('morphRelations')) {\n      functionsToApply.push(traverseQueryFilters(throwMorphToRelations, ctx));\n    }\n\n    if (include.includes('passwords')) {\n      functionsToApply.push(traverseQueryFilters(throwPassword, ctx));\n    }\n\n    if (include.includes('private')) {\n      functionsToApply.push(traverseQueryFilters(throwPrivate, ctx));\n    }\n\n    // Return directly if no validation functions are provided\n    if (functionsToApply.length === 0) {\n      return filters;\n    }\n\n    return pipeAsync(...functionsToApply)(filters);\n  }\n);\n\nexport const defaultValidateFilters = asyncCurry(async (ctx: Context, filters: unknown) => {\n  return validateFilters(ctx, filters, FILTER_TRAVERSALS);\n});\n\nexport const SORT_TRAVERSALS = [\n  'nonAttributesOperators',\n  'dynamicZones',\n  'morphRelations',\n  'passwords',\n  'private',\n  'nonScalarEmptyKeys',\n];\n\nexport const validateSort = asyncCurry(\n  async (ctx: Context, sort: unknown, include: (typeof SORT_TRAVERSALS)[number][]) => {\n    if (!ctx.schema) {\n      throw new Error('Missing schema in defaultValidateSort');\n    }\n\n    // Build the list of functions conditionally based on the include array\n    const functionsToApply: Array<AnyFunc> = [];\n\n    // Validate non attribute keys\n    if (include.includes('nonAttributesOperators')) {\n      functionsToApply.push(\n        traverseQuerySort(({ key, attribute, path }) => {\n          // ID is not an attribute per se, so we need to make\n          // an extra check to ensure we're not removing it\n          if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n            return;\n          }\n\n          if (!attribute) {\n            throwInvalidKey({ key, path: path.attribute });\n          }\n        }, ctx)\n      );\n    }\n\n    // Validate dynamic zones from sort\n    if (include.includes('dynamicZones')) {\n      functionsToApply.push(traverseQuerySort(throwDynamicZones, ctx));\n    }\n\n    // Validate morphTo relations from sort\n    if (include.includes('morphRelations')) {\n      functionsToApply.push(traverseQuerySort(throwMorphToRelations, ctx));\n    }\n\n    // Validate passwords from sort\n    if (include.includes('passwords')) {\n      functionsToApply.push(traverseQuerySort(throwPassword, ctx));\n    }\n\n    // Validate private from sort\n    if (include.includes('private')) {\n      functionsToApply.push(traverseQuerySort(throwPrivate, ctx));\n    }\n\n    // Validate non-scalar empty keys\n    if (include.includes('nonScalarEmptyKeys')) {\n      functionsToApply.push(\n        traverseQuerySort(({ key, attribute, value, path }) => {\n          // ID is not an attribute per se, so we need to make\n          // an extra check to ensure we're not removing it\n          if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n            return;\n          }\n\n          if (!isScalarAttribute(attribute) && isEmpty(value)) {\n            throwInvalidKey({ key, path: path.attribute });\n          }\n        }, ctx)\n      );\n    }\n\n    // Return directly if no validation functions are provided\n    if (functionsToApply.length === 0) {\n      return sort;\n    }\n\n    return pipeAsync(...functionsToApply)(sort);\n  }\n);\n\nexport const defaultValidateSort = asyncCurry(async (ctx: Context, sort: unknown) => {\n  return validateSort(ctx, sort, SORT_TRAVERSALS);\n});\n\nexport const FIELDS_TRAVERSALS = ['scalarAttributes', 'privateFields', 'passwordFields'];\n\nexport const validateFields = asyncCurry(\n  async (ctx: Context, fields: unknown, include: (typeof FIELDS_TRAVERSALS)[number][]) => {\n    if (!ctx.schema) {\n      throw new Error('Missing schema in defaultValidateFields');\n    }\n    // Build the list of functions conditionally based on the include array\n    const functionsToApply: Array<AnyFunc> = [];\n\n    // Only allow scalar attributes\n    if (include.includes('scalarAttributes')) {\n      functionsToApply.push(\n        traverseQueryFields(({ key, attribute, path }) => {\n          // ID is not an attribute per se, so we need to make\n          // an extra check to ensure we're not throwing because of it\n          if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n            return;\n          }\n\n          if (isNil(attribute) || !isScalarAttribute(attribute)) {\n            throwInvalidKey({ key, path: path.attribute });\n          }\n        }, ctx)\n      );\n    }\n\n    // Private fields\n    if (include.includes('privateFields')) {\n      functionsToApply.push(traverseQueryFields(throwPrivate, ctx));\n    }\n\n    // Password fields\n    if (include.includes('passwordFields')) {\n      functionsToApply.push(traverseQueryFields(throwPassword, ctx));\n    }\n\n    // Return directly if no validation functions are provided\n    if (functionsToApply.length === 0) {\n      return fields;\n    }\n\n    return pipeAsync(...functionsToApply)(fields);\n  }\n);\n\nexport const defaultValidateFields = asyncCurry(async (ctx: Context, fields: unknown) => {\n  return validateFields(ctx, fields, FIELDS_TRAVERSALS);\n});\n\nexport const POPULATE_TRAVERSALS = ['nonAttributesOperators', 'private'];\n\nexport const validatePopulate = asyncCurry(\n  async (\n    ctx: PopulateContext,\n    populate: unknown,\n    includes: {\n      fields?: (typeof FIELDS_TRAVERSALS)[number][];\n      sort?: (typeof SORT_TRAVERSALS)[number][];\n      filters?: (typeof FILTER_TRAVERSALS)[number][];\n      populate?: (typeof POPULATE_TRAVERSALS)[number][];\n    }\n  ) => {\n    if (!ctx.schema) {\n      throw new Error('Missing schema in defaultValidatePopulate');\n    }\n    // Build the list of functions conditionally based on the include array\n    const functionsToApply: Array<AnyFunc> = [];\n\n    // Always include the main traversal function\n    functionsToApply.push(\n      traverseQueryPopulate(\n        async ({ key, path, value, schema, attribute, getModel, parent }, { set }) => {\n          /**\n           * NOTE: The parent check is done to support \"filters\" (and the rest of keys) as valid attribute names.\n           *\n           * The parent will not be an attribute when its a \"populate\" / \"filters\" / \"sort\" ... key.\n           * Only in those scenarios the node will be an attribute.\n           */\n          if (!parent?.attribute && attribute) {\n            const isPopulatableAttribute = [\n              'relation',\n              'dynamiczone',\n              'component',\n              'media',\n            ].includes(attribute.type);\n\n            // Throw on non-populate attributes\n            if (!isPopulatableAttribute) {\n              throwInvalidKey({ key, path: path.raw });\n            }\n\n            // Valid populatable attribute, so return\n            return;\n          }\n\n          // If we're looking at a populate fragment, ensure its target is valid\n          if (key === 'on') {\n            // Populate fragment should always be an object\n            if (!isObject(value)) {\n              return throwInvalidKey({ key, path: path.raw });\n            }\n\n            const targets = Object.keys(value);\n\n            for (const target of targets) {\n              const model = getModel(target);\n\n              // If a target is invalid (no matching model), then raise an error\n              if (!model) {\n                throwInvalidKey({ key: target, path: `${path.raw}.${target}` });\n              }\n            }\n\n            // If the fragment's target is fine, then let it pass\n            return;\n          }\n\n          // Ignore plain wildcards\n          if (key === '' && value === '*') {\n            return;\n          }\n\n          // Ensure count is a boolean\n          if (key === 'count') {\n            try {\n              parseType({ type: 'boolean', value });\n              return;\n            } catch {\n              throwInvalidKey({ key, path: path.attribute });\n            }\n          }\n\n          // Allowed boolean-like keywords should be ignored\n          try {\n            parseType({ type: 'boolean', value: key });\n            // Key is an allowed boolean-like keyword, skipping validation...\n            return;\n          } catch {\n            // Continue, because it's not a boolean-like\n          }\n\n          // Handle nested `sort` validation with custom or default traversals\n          if (key === 'sort') {\n            set(\n              key,\n              await validateSort(\n                {\n                  schema,\n                  getModel,\n                },\n                value, // pass the sort value\n                includes?.sort || SORT_TRAVERSALS\n              )\n            );\n            return;\n          }\n\n          // Handle nested `filters` validation with custom or default traversals\n          if (key === 'filters') {\n            set(\n              key,\n              await validateFilters(\n                {\n                  schema,\n                  getModel,\n                },\n                value, // pass the filters value\n                includes?.filters || FILTER_TRAVERSALS\n              )\n            );\n            return;\n          }\n\n          // Handle nested `fields` validation with custom or default traversals\n          if (key === 'fields') {\n            set(\n              key,\n              await validateFields(\n                {\n                  schema,\n                  getModel,\n                },\n                value, // pass the fields value\n                includes?.fields || FIELDS_TRAVERSALS\n              )\n            );\n            return;\n          }\n\n          // Handle recursive nested `populate` validation with the same include object\n          if (key === 'populate') {\n            set(\n              key,\n              await validatePopulate(\n                {\n                  schema,\n                  getModel,\n                  parent: { key, path, schema, attribute },\n                  path,\n                },\n                value, // pass the nested populate value\n                includes // pass down the same includes object\n              )\n            );\n            return;\n          }\n\n          // Throw an error if non-attribute operators are included in the populate array\n          if (includes?.populate?.includes('nonAttributesOperators')) {\n            throwInvalidKey({ key, path: path.attribute });\n          }\n        },\n        ctx\n      )\n    );\n\n    // Conditionally traverse for private fields only if 'private' is included\n    if (includes?.populate?.includes('private')) {\n      functionsToApply.push(traverseQueryPopulate(throwPrivate, ctx));\n    }\n\n    // Return directly if no validation functions are provided\n    if (functionsToApply.length === 0) {\n      return populate;\n    }\n\n    return pipeAsync(...functionsToApply)(populate);\n  }\n);\n\nexport const defaultValidatePopulate = asyncCurry(async (ctx: Context, populate: unknown) => {\n  if (!ctx.schema) {\n    throw new Error('Missing schema in defaultValidatePopulate');\n  }\n\n  // Call validatePopulate and include all validations by passing in full traversal arrays\n  return validatePopulate(ctx, populate, {\n    filters: FILTER_TRAVERSALS,\n    sort: SORT_TRAVERSALS,\n    fields: FIELDS_TRAVERSALS,\n    populate: POPULATE_TRAVERSALS,\n  });\n});\n","import { CurriedFunction1 } from 'lodash';\nimport { isArray, isObject } from 'lodash/fp';\n\nimport { getNonWritableAttributes, constants } from '../content-types';\nimport { pipe as pipeAsync } from '../async';\nimport { throwInvalidKey } from './utils';\n\nimport * as visitors from './visitors';\nimport * as validators from './validators';\nimport traverseEntity from '../traverse-entity';\n\nimport { traverseQueryFilters, traverseQuerySort, traverseQueryPopulate } from '../traverse';\n\nimport { Model, Data } from '../types';\nimport { ValidationError } from '../errors';\n\nconst { ID_ATTRIBUTE, DOC_ID_ATTRIBUTE } = constants;\n\nexport interface Options {\n  auth?: unknown;\n}\n\nexport interface Validator {\n  (schema: Model): CurriedFunction1<Data, Promise<Data>>;\n}\nexport interface ValidateFunc {\n  (data: unknown, schema: Model, options?: Options): Promise<void>;\n}\n\ninterface APIOptions {\n  validators?: Validators;\n  getModel: (model: string) => Model;\n}\n\nexport interface Validators {\n  input?: Validator[];\n}\n\nconst createAPIValidators = (opts: APIOptions) => {\n  const { getModel } = opts || {};\n\n  const validateInput: ValidateFunc = async (data: unknown, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in validateInput');\n    }\n\n    if (isArray(data)) {\n      await Promise.all(data.map((entry) => validateInput(entry, schema, { auth })));\n      return;\n    }\n\n    const nonWritableAttributes = getNonWritableAttributes(schema);\n\n    const transforms = [\n      (data: unknown) => {\n        if (isObject(data)) {\n          if (ID_ATTRIBUTE in data) {\n            throwInvalidKey({ key: ID_ATTRIBUTE });\n          }\n\n          if (DOC_ID_ATTRIBUTE in data) {\n            throwInvalidKey({ key: DOC_ID_ATTRIBUTE });\n          }\n        }\n        return data;\n      },\n      // non-writable attributes\n      traverseEntity(visitors.throwRestrictedFields(nonWritableAttributes), { schema, getModel }),\n      // unrecognized attributes\n      traverseEntity(visitors.throwUnrecognizedFields, { schema, getModel }),\n    ];\n\n    if (auth) {\n      // restricted relations\n      transforms.push(\n        traverseEntity(visitors.throwRestrictedRelations(auth), {\n          schema,\n          getModel,\n        })\n      );\n    }\n\n    // Apply validators from registry if exists\n    opts?.validators?.input?.forEach((validator: Validator) => transforms.push(validator(schema)));\n\n    try {\n      await pipeAsync(...transforms)(data as Data);\n    } catch (e) {\n      if (e instanceof ValidationError) {\n        e.details.source = 'body';\n      }\n      throw e;\n    }\n  };\n\n  const validateQuery = async (\n    query: Record<string, unknown>,\n    schema: Model,\n    { auth }: Options = {}\n  ) => {\n    if (!schema) {\n      throw new Error('Missing schema in validateQuery');\n    }\n    const { filters, sort, fields, populate } = query;\n\n    if (filters) {\n      await validateFilters(filters, schema, { auth });\n    }\n\n    if (sort) {\n      await validateSort(sort, schema, { auth });\n    }\n\n    if (fields) {\n      await validateFields(fields, schema);\n    }\n\n    // a wildcard is always valid; its conversion will be handled by the entity service and can be optimized with sanitizer\n    if (populate && populate !== '*') {\n      await validatePopulate(populate, schema);\n    }\n  };\n\n  const validateFilters: ValidateFunc = async (filters, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in validateFilters');\n    }\n    if (isArray(filters)) {\n      await Promise.all(filters.map((filter) => validateFilters(filter, schema, { auth })));\n      return;\n    }\n\n    const transforms = [validators.defaultValidateFilters({ schema, getModel })];\n\n    if (auth) {\n      transforms.push(\n        traverseQueryFilters(visitors.throwRestrictedRelations(auth), {\n          schema,\n          getModel,\n        })\n      );\n    }\n\n    try {\n      await pipeAsync(...transforms)(filters);\n    } catch (e) {\n      if (e instanceof ValidationError) {\n        e.details.source = 'query';\n        e.details.param = 'filters';\n      }\n      throw e;\n    }\n  };\n\n  const validateSort: ValidateFunc = async (sort, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in validateSort');\n    }\n    const transforms = [validators.defaultValidateSort({ schema, getModel })];\n\n    if (auth) {\n      transforms.push(\n        traverseQuerySort(visitors.throwRestrictedRelations(auth), {\n          schema,\n          getModel,\n        })\n      );\n    }\n\n    try {\n      await pipeAsync(...transforms)(sort);\n    } catch (e) {\n      if (e instanceof ValidationError) {\n        e.details.source = 'query';\n        e.details.param = 'sort';\n      }\n      throw e;\n    }\n  };\n\n  const validateFields: ValidateFunc = async (fields, schema: Model) => {\n    if (!schema) {\n      throw new Error('Missing schema in validateFields');\n    }\n    const transforms = [validators.defaultValidateFields({ schema, getModel })];\n\n    try {\n      await pipeAsync(...transforms)(fields);\n    } catch (e) {\n      if (e instanceof ValidationError) {\n        e.details.source = 'query';\n        e.details.param = 'fields';\n      }\n      throw e;\n    }\n  };\n\n  const validatePopulate: ValidateFunc = async (populate, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizePopulate');\n    }\n    const transforms = [validators.defaultValidatePopulate({ schema, getModel })];\n\n    if (auth) {\n      transforms.push(\n        traverseQueryPopulate(visitors.throwRestrictedRelations(auth), {\n          schema,\n          getModel,\n        })\n      );\n    }\n\n    try {\n      await pipeAsync(...transforms)(populate);\n    } catch (e) {\n      if (e instanceof ValidationError) {\n        e.details.source = 'query';\n        e.details.param = 'populate';\n      }\n      throw e;\n    }\n  };\n\n  return {\n    input: validateInput,\n    query: validateQuery,\n    filters: validateFilters,\n    sort: validateSort,\n    fields: validateFields,\n    populate: validatePopulate,\n  };\n};\n\nexport { createAPIValidators, validators, visitors };\n\nexport type APIValidators = ReturnType<typeof createAPIValidators>;\n","import { merge, pipe, omit, isNil } from 'lodash/fp';\nimport { PaginationError } from './errors';\n\ninterface PaginationArgs {\n  page: number;\n  pageSize: number;\n  start: number;\n  limit: number;\n}\n\nexport interface Pagination {\n  start: number;\n  limit: number;\n}\n\nexport interface PagePatinationInformation {\n  page: number;\n  pageSize: number;\n  pageCount: number;\n  total: number;\n}\n\nexport interface OffsetPaginationInformation {\n  start: number;\n  limit: number;\n  total: number;\n}\n\nconst STRAPI_DEFAULTS = {\n  offset: {\n    start: 0,\n    limit: 10,\n  },\n  page: {\n    page: 1,\n    pageSize: 10,\n  },\n};\n\nconst paginationAttributes = ['start', 'limit', 'page', 'pageSize'];\n\nconst withMaxLimit = (limit: number, maxLimit = -1) => {\n  if (maxLimit === -1 || limit < maxLimit) {\n    return limit;\n  }\n\n  return maxLimit;\n};\n\n// Ensure minimum page & pageSize values (page >= 1, pageSize >= 0, start >= 0, limit >= 0)\nconst ensureMinValues = ({ start, limit }: Pagination) => ({\n  start: Math.max(start, 0),\n  limit: limit === -1 ? limit : Math.max(limit, 1),\n});\n\nconst ensureMaxValues =\n  (maxLimit = -1) =>\n  ({ start, limit }: { start: number; limit: number }) => ({\n    start,\n    limit: withMaxLimit(limit, maxLimit),\n  });\n\n// Apply maxLimit as the limit when limit is -1\nconst withNoLimit = (pagination: Pagination, maxLimit = -1) => ({\n  ...pagination,\n  limit: pagination.limit === -1 ? maxLimit : pagination.limit,\n});\n\nconst withDefaultPagination = <T extends Partial<PaginationArgs>>(\n  args: T,\n  { defaults = {}, maxLimit = -1 } = {}\n) => {\n  const defaultValues = merge(STRAPI_DEFAULTS, defaults);\n\n  const usePagePagination = !isNil(args.page) || !isNil(args.pageSize);\n  const useOffsetPagination = !isNil(args.start) || !isNil(args.limit);\n\n  const ensureValidValues = pipe(ensureMinValues, ensureMaxValues(maxLimit));\n\n  // If there is no pagination attribute, don't modify the payload\n  if (!usePagePagination && !useOffsetPagination) {\n    return merge(args, ensureValidValues(defaultValues.offset));\n  }\n\n  // If there is page & offset pagination attributes, throw an error\n  if (usePagePagination && useOffsetPagination) {\n    throw new PaginationError('Cannot use both page & offset pagination in the same query');\n  }\n\n  const pagination: Pagination = {\n    start: 0,\n    limit: 0,\n  };\n\n  // Start / Limit\n  if (useOffsetPagination) {\n    const { start, limit } = merge(defaultValues.offset, args);\n\n    Object.assign(pagination, { start, limit });\n  }\n\n  // Page / PageSize\n  if (usePagePagination) {\n    const { page, pageSize } = merge(defaultValues.page, {\n      ...args,\n      pageSize: Math.max(1, args.pageSize ?? 0),\n    });\n\n    Object.assign(pagination, {\n      start: (page - 1) * pageSize,\n      limit: pageSize,\n    });\n  }\n\n  // Handle -1 limit\n  Object.assign(pagination, withNoLimit(pagination, maxLimit));\n\n  const replacePaginationAttributes = pipe(\n    // Remove pagination attributes\n    omit(paginationAttributes),\n    // Merge the object with the new pagination + ensure minimum & maximum values\n    merge(ensureValidValues(pagination))\n  );\n\n  return replacePaginationAttributes(args);\n};\n\n/**\n * Transform pagination information into a paginated response:\n * {\n *    page: number,\n *    pageSize: number,\n *    pageCount: number,\n *    total: number\n * }\n */\nconst transformPagedPaginationInfo = (\n  paginationInfo: Partial<PaginationArgs>,\n  total: number\n): PagePatinationInformation => {\n  if (!isNil(paginationInfo.page)) {\n    const page = paginationInfo.page;\n    const pageSize = paginationInfo.pageSize ?? total;\n\n    return {\n      page,\n      pageSize,\n      pageCount: pageSize > 0 ? Math.ceil(total / pageSize) : 0,\n      total,\n    };\n  }\n\n  if (!isNil(paginationInfo.start)) {\n    const start = paginationInfo.start;\n    const limit = paginationInfo.limit ?? total;\n\n    // Start limit to page page size\n    return {\n      page: Math.floor(start / limit) + 1,\n      pageSize: limit,\n      pageCount: limit > 0 ? Math.ceil(total / limit) : 0,\n      total,\n    };\n  }\n\n  // Default pagination\n  return {\n    ...paginationInfo,\n    page: 1,\n    pageSize: 10,\n    pageCount: 1,\n    total,\n  };\n};\n\n/**\n * Transform pagination information into a offset response:\n * {\n *    start: number,\n *    limit: number,\n *    total: number\n * }\n */\nconst transformOffsetPaginationInfo = (\n  paginationInfo: Partial<PaginationArgs>,\n  total: number\n): OffsetPaginationInformation => {\n  if (!isNil(paginationInfo.page)) {\n    const limit = paginationInfo.pageSize ?? total;\n    const start = (paginationInfo.page - 1) * limit;\n\n    return { start, limit, total };\n  }\n\n  if (!isNil(paginationInfo.start)) {\n    const start = paginationInfo.start;\n    const limit = paginationInfo.limit ?? total;\n\n    // Start limit to page page size\n    return { start, limit, total };\n  }\n\n  // Default pagination\n  return {\n    ...paginationInfo,\n    start: 0,\n    limit: 10,\n    total,\n  };\n};\n\nexport { withDefaultPagination, transformPagedPaginationInfo, transformOffsetPaginationInfo };\n","import execa from 'execa';\nimport preferredPM from 'preferred-pm';\n\nimport type { Options as ProcessOptions } from 'execa';\n\nconst SUPPORTED_PACKAGE_MANAGERS = ['npm', 'yarn'];\nconst DEFAULT_PACKAGE_MANAGER = 'npm' as const;\n\ntype SupportedPackageManagerName = 'npm' | 'yarn';\n\nexport const getPreferred = async (pkgPath: string): Promise<SupportedPackageManagerName> => {\n  const pm = await preferredPM(pkgPath);\n\n  const hasPackageManager = pm !== undefined;\n  if (!hasPackageManager) {\n    throw new Error(`Couldn't find a package manager in your project.`);\n  }\n\n  const isPackageManagerSupported = SUPPORTED_PACKAGE_MANAGERS.includes(pm.name);\n  if (!isPackageManagerSupported) {\n    process.emitWarning(\n      `We detected your package manager (${pm.name} v${pm.version}), but it's not officially supported by Strapi yet. Defaulting to npm instead.`\n    );\n\n    return DEFAULT_PACKAGE_MANAGER;\n  }\n\n  return pm.name as SupportedPackageManagerName;\n};\n\nexport const installDependencies = (\n  path: string,\n  packageManager: SupportedPackageManagerName,\n  options: ProcessOptions<string> = {}\n) => {\n  return execa(packageManager, ['install'], { ...options, cwd: path, stdin: 'ignore' });\n};\n","/**\n * Create a strict interpolation RegExp based on the given variables' name\n */\nconst createStrictInterpolationRegExp = (allowedVariableNames: string[], flags: string) => {\n  const oneOfVariables = allowedVariableNames.join('|');\n\n  // 1. We need to match the delimiters: <%= ... %>\n  // 2. We accept any number of whitespaces characters before and/or after the variable name: \\s* ... \\s*\n  // 3. We only accept values from the variable list as interpolation variables' name: : (${oneOfVariables})\n  return new RegExp(`<%=\\\\s*(${oneOfVariables})\\\\s*%>`, flags);\n};\n\n/**\n * Create a loose interpolation RegExp to match as many groups as possible\n */\nconst createLooseInterpolationRegExp = (flags: string) => new RegExp(/<%=([\\s\\S]+?)%>/, flags);\n\nexport { createStrictInterpolationRegExp, createLooseInterpolationRegExp };\n","/**\n * Utils file containing file treatment utils\n */\nimport { Writable, WritableOptions } from 'node:stream';\n\nconst kbytesToBytes = (kbytes: number) => kbytes * 1000;\nconst bytesToKbytes = (bytes: number) => Math.round((bytes / 1000) * 100) / 100;\nconst bytesToHumanReadable = (bytes: number) => {\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\n  if (bytes === 0) return '0 Bytes';\n  const i = parseInt(`${Math.floor(Math.log(bytes) / Math.log(1000))}`, 10);\n  return `${Math.round(bytes / 1000 ** i)} ${sizes[i]}`;\n};\n\nconst streamToBuffer = (stream: NodeJS.ReadableStream): Promise<Buffer> =>\n  new Promise((resolve, reject) => {\n    const chunks: Uint8Array[] = [];\n    stream.on('data', (chunk) => {\n      chunks.push(chunk);\n    });\n    stream.on('end', () => {\n      resolve(Buffer.concat(chunks));\n    });\n    stream.on('error', reject);\n  });\n\nconst getStreamSize = (stream: NodeJS.ReadableStream) =>\n  new Promise((resolve, reject) => {\n    let size = 0;\n    stream.on('data', (chunk) => {\n      size += Buffer.byteLength(chunk);\n    });\n    stream.on('close', () => resolve(size));\n    stream.on('error', reject);\n    stream.resume();\n  });\n\n/**\n * Create a writeable Node.js stream that discards received data.\n * Useful for testing, draining a stream of data, etc.\n */\nfunction writableDiscardStream(options?: WritableOptions) {\n  return new Writable({\n    ...options,\n    write(chunk, encding, callback) {\n      setImmediate(callback);\n    },\n  });\n}\n\nexport {\n  streamToBuffer,\n  bytesToHumanReadable,\n  bytesToKbytes,\n  kbytesToBytes,\n  getStreamSize,\n  writableDiscardStream,\n};\n","import { eq } from 'lodash/fp';\n\ninterface Options {\n  name: string;\n  validator?(config: unknown): void;\n  handler(...args: any[]): any;\n}\n\nconst createPolicy = (options: Options) => {\n  const { name = 'unnamed', validator, handler } = options;\n\n  const wrappedValidator = (config: unknown) => {\n    if (validator) {\n      try {\n        validator(config);\n      } catch (e) {\n        throw new Error(`Invalid config passed to \"${name}\" policy.`);\n      }\n    }\n  };\n\n  return {\n    name,\n    validator: wrappedValidator,\n    handler,\n  };\n};\n\nconst createPolicyContext = (type: string, ctx: object) => {\n  return Object.assign(\n    {\n      is: eq(type),\n      get type() {\n        return type;\n      },\n    },\n    ctx\n  );\n};\n\nexport { createPolicy, createPolicyContext };\n","import _, { kebabCase } from 'lodash';\nimport { trimChars, trimCharsEnd, trimCharsStart } from 'lodash/fp';\nimport slugify from '@sindresorhus/slugify';\n\nconst nameToSlug = (name: string, options: slugify.Options = { separator: '-' }) =>\n  slugify(name, options);\n\nconst nameToCollectionName = (name: string) => slugify(name, { separator: '_' });\n\nconst toRegressedEnumValue = (value: string) =>\n  slugify(value, {\n    decamelize: false,\n    lowercase: false,\n    separator: '_',\n  });\n\nconst getCommonPath = (...paths: string[]) => {\n  const [segments, ...otherSegments] = paths.map((it) => _.split(it, '/'));\n  return _.join(\n    _.takeWhile(segments, (str, index) => otherSegments.every((it) => it[index] === str)),\n    '/'\n  );\n};\n\nconst isEqual = (a: unknown, b: unknown) => String(a) === String(b);\nconst isCamelCase = (value: string) => /^[a-z][a-zA-Z0-9]+$/.test(value);\nconst isKebabCase = (value: string) => /^([a-z][a-z0-9]*)(-[a-z0-9]+)*$/.test(value);\nconst startsWithANumber = (value: string) => /^[0-9]/.test(value);\n\nconst joinBy = (joint: string, ...args: string[]) => {\n  const trim = trimChars(joint);\n  const trimEnd = trimCharsEnd(joint);\n  const trimStart = trimCharsStart(joint);\n\n  return args.reduce((url, path, index) => {\n    if (args.length === 1) return path;\n    if (index === 0) return trimEnd(path);\n    if (index === args.length - 1) return url + joint + trimStart(path);\n    return url + joint + trim(path);\n  }, '');\n};\n\nconst toKebabCase = (value: string) => kebabCase(value);\n\nexport {\n  nameToSlug,\n  nameToCollectionName,\n  getCommonPath,\n  isEqual,\n  isCamelCase,\n  isKebabCase,\n  toKebabCase,\n  toRegressedEnumValue,\n  startsWithANumber,\n  joinBy,\n};\n","const castIncludes = (arr: unknown[], val: unknown, cast: (val: unknown) => unknown): boolean =>\n  arr.map((val) => cast(val)).includes(cast(val));\n\nconst includesString = (arr: unknown[], val: unknown) => castIncludes(arr, val, String);\n\nexport { includesString };\n","import _ from 'lodash';\n\nconst keysDeep = (obj: object, path: string[] = []): string[] =>\n  !_.isObject(obj)\n    ? [path.join('.')]\n    : _.reduce(\n        obj,\n        (acc, next, key) => _.concat(acc, keysDeep(next, [...path, key])),\n        [] as string[]\n      );\n\nexport { keysDeep };\n","// Using timestamp (milliseconds) to be sure it is unique\n// + converting timestamp to base 36 for better readibility\nconst timestampCode = (date?: Date) => {\n  const referDate = date ?? new Date();\n\n  return referDate.getTime().toString(36);\n};\n\nexport { timestampCode };\n","// Code copied from the yup library (https://github.com/jquense/yup)\n// https://github.com/jquense/yup/blob/2778b88bdacd5260d593c6468793da2e77daf21f/src/util/printValue.ts\n\nconst { toString } = Object.prototype;\nconst errorToString = Error.prototype.toString;\nconst regExpToString = RegExp.prototype.toString;\nconst symbolToString = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : () => '';\n\nconst SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\n\nfunction printNumber(val: number) {\n  // eslint-disable-next-line eqeqeq\n  if (val != +val) return 'NaN';\n  const isNegativeZero = val === 0 && 1 / val < 0;\n  return isNegativeZero ? '-0' : `${val}`;\n}\n\nfunction printSimpleValue(val: unknown, quoteStrings = false) {\n  if (val == null || val === true || val === false) return `${val}`;\n\n  if (typeof val === 'number') return printNumber(val);\n  if (typeof val === 'string') return quoteStrings ? `\"${val}\"` : val;\n  if (typeof val === 'function') return `[Function ${val.name || 'anonymous'}]`;\n  if (typeof val === 'symbol') return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');\n\n  const tag = toString.call(val).slice(8, -1);\n\n  if (tag === 'Date') {\n    const v = val as Date;\n    return Number.isNaN(v.getTime()) ? `${v}` : v.toISOString();\n  }\n  if (tag === 'Error' || val instanceof Error) return `[${errorToString.call(val)}]`;\n  if (tag === 'RegExp') return regExpToString.call(val);\n\n  return null;\n}\n\nfunction printValue(value: unknown, quoteStrings: boolean) {\n  const result = printSimpleValue(value, quoteStrings);\n  if (result !== null) return result;\n\n  return JSON.stringify(\n    value,\n    function replacer(key, value) {\n      const result = printSimpleValue(this[key], quoteStrings);\n      if (result !== null) return result;\n      return value;\n    },\n    2\n  );\n}\n\nexport { printValue };\n","/* eslint-disable no-template-curly-in-string */\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport * as yup from 'yup';\nimport _ from 'lodash';\nimport { isNumber, isInteger, get } from 'lodash/fp';\nimport { strings } from './primitives';\nimport { printValue } from './print-value';\n\nexport * from 'yup';\n\nexport const strapiID = (): InstanceType<typeof StrapiIDSchema> => new StrapiIDSchema();\n\nconst isNotNilTest = (value: unknown) => !_.isNil(value);\n\nconst isNotNullTest = (value: unknown) => !_.isNull(value);\n\nyup.addMethod(yup.mixed, 'notNil', function isNotNill(msg = '${path} must be defined.') {\n  return this.test('defined', msg, isNotNilTest);\n});\n\nyup.addMethod(yup.mixed, 'notNull', function isNotNull(msg = '${path} cannot be null.') {\n  return this.test('defined', msg, isNotNullTest);\n});\n\nyup.addMethod(yup.mixed, 'isFunction', function isFunction(message = '${path} is not a function') {\n  return this.test(\n    'is a function',\n    message,\n    (value) => _.isUndefined(value) || _.isFunction(value)\n  );\n});\n\nyup.addMethod(\n  yup.string,\n  'isCamelCase',\n  function isCamelCase(message = '${path} is not in camel case (anExampleOfCamelCase)') {\n    return this.test('is in camelCase', message, (value) =>\n      value ? strings.isCamelCase(value) : true\n    );\n  }\n);\n\nyup.addMethod(\n  yup.string,\n  'isKebabCase',\n  function isKebabCase(message = '${path} is not in kebab case (an-example-of-kebab-case)') {\n    return this.test('is in kebab-case', message, (value) =>\n      value ? strings.isKebabCase(value) : true\n    );\n  }\n);\n\nyup.addMethod(\n  yup.object,\n  'onlyContainsFunctions',\n  function onlyContainsFunctions(message = '${path} contains values that are not functions') {\n    return this.test(\n      'only contains functions',\n      message,\n      (value) => _.isUndefined(value) || (value && Object.values(value).every(_.isFunction))\n    );\n  }\n);\n\nyup.addMethod(\n  yup.array,\n  'uniqueProperty',\n  function uniqueProperty(propertyName: string, message: string) {\n    return this.test('unique', message, function unique(list) {\n      const errors: yup.ValidationError[] = [];\n\n      list?.forEach((element, index) => {\n        const sameElements = list.filter(\n          (e) => get(propertyName, e) === get(propertyName, element)\n        );\n        if (sameElements.length > 1) {\n          errors.push(\n            this.createError({\n              path: `${this.path}[${index}].${propertyName}`,\n              message,\n            })\n          );\n        }\n      });\n\n      if (errors.length) {\n        throw new yup.ValidationError(errors);\n      }\n      return true;\n    });\n  }\n);\n\nexport class StrapiIDSchema extends yup.MixedSchema {\n  constructor() {\n    super({ type: 'strapiID' });\n  }\n\n  _typeCheck(value: unknown): value is string | number {\n    return typeof value === 'string' || (isNumber(value) && isInteger(value) && value >= 0);\n  }\n}\n\ndeclare module 'yup' {\n  // const strapiID: () => InstanceType<typeof StrapiIDSchema>;\n\n  export interface BaseSchema {\n    isFunction(message?: string): this;\n    notNil(message?: string): this;\n    notNull(message?: string): this;\n  }\n\n  export interface StringSchema {\n    isCamelCase(message?: string): this;\n    isKebabCase(message?: string): this;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  export interface ObjectSchema<TShape> {\n    onlyContainsFunctions(message?: string): this;\n  }\n}\n\ninterface NoTypeOptions {\n  path: string;\n  type: string;\n  value: unknown;\n  originalValue: unknown;\n}\n\n// Temporary fix of this issue : https://github.com/jquense/yup/issues/616\nyup.setLocale({\n  mixed: {\n    notType(options: NoTypeOptions) {\n      const { path, type, value, originalValue } = options;\n      const isCast = originalValue != null && originalValue !== value;\n      const msg =\n        `${path} must be a \\`${type}\\` type, ` +\n        `but the final value was: \\`${printValue(value, true)}\\`${\n          isCast ? ` (cast from the value \\`${printValue(originalValue, true)}\\`).` : '.'\n        }`;\n\n      /* Remove comment that is not supposed to be seen by the enduser\n      if (value === null) {\n        msg += `\\n If \"null\" is intended as an empty value be sure to mark the schema as \\`.nullable()\\``;\n      }\n      */\n      return msg;\n    },\n  },\n});\n","import { z } from 'zod';\n\nimport { ValidationError } from './errors';\n\nexport const validateZod =\n  <T extends z.ZodTypeAny>(schema: T) =>\n  (data: unknown): z.TypeOf<T> => {\n    try {\n      return schema.parse(data);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        const { message, errors } = formatZodErrors(error);\n        throw new ValidationError(message, { errors });\n      }\n\n      throw error;\n    }\n  };\n\nconst formatZodErrors = (zodError: z.ZodError) => ({\n  errors: zodError.errors.map((error) => {\n    return {\n      path: error.path,\n      message: error.message,\n      name: 'ValidationError',\n    };\n  }),\n  message: 'Validation error',\n});\n"],"names":["timeRegex","isDate","v","dates","parseTime","value","format","Error","result","match","hours","minutes","seconds","fraction","fractionPart","_","padEnd","slice","parseDate","date","parseISO","isValid","error","parseDateTimeOrTimestamp","milliUnixDate","parse","Date","parseBoolean","options","forceCast","includes","Boolean","parseType","type","toNumber","envFn","key","defaultValue","has","process","env","getKey","utils","int","parseInt","float","parseFloat","bool","json","JSON","message","array","startsWith","endsWith","substring","length","split","map","trim","oneOf","expectedValues","rawValue","Object","assign","SINGLE_TYPE","COLLECTION_TYPE","ID_ATTRIBUTE","DOC_ID_ATTRIBUTE","PUBLISHED_AT_ATTRIBUTE","CREATED_BY_ATTRIBUTE","UPDATED_BY_ATTRIBUTE","CREATED_AT_ATTRIBUTE","UPDATED_AT_ATTRIBUTE","constants","getTimestamps","model","attributes","push","getCreatorFields","getNonWritableAttributes","nonWritableAttributes","reduce","acc","attr","attrName","writable","concat","uniq","getWritableAttributes","difference","keys","isWritableAttribute","attributeName","getNonVisibleAttributes","nonVisibleAttributes","visible","getVisibleAttributes","isVisibleAttribute","getOptions","draftAndPublish","get","hasDraftAndPublish","isDraft","data","isSchema","modelType","isComponentSchema","isContentTypeSchema","isSingleType","kind","isCollectionType","isKind","getStoredPrivateAttributes","union","strapi","config","getOr","getPrivateAttributes","pickBy","private","isPrivateAttribute","isScalarAttribute","attribute","getDoesAttributeRequireValidation","required","unique","prototype","hasOwnProperty","call","isMediaAttribute","isRelationalAttribute","HAS_RELATION_REORDERING","hasRelationReordering","relation","isComponentAttribute","isDynamicZoneAttribute","isMorphToRelationalAttribute","getComponentAttributes","schema","getScalarAttributes","getRelationalAttributes","isTypedAttribute","getContentTypeRoutePrefix","contentType","kebabCase","info","singularName","pluralName","contentTypes","setCreatorFields","user","isEdition","assoc","id","createHook","state","handlers","getHandlers","register","handler","delete","remove","eq","createAsyncSeriesHook","context","createAsyncSeriesWaterfallHook","param","res","createAsyncParallelHook","promises","cloneDeep","Promise","all","createAsyncBailHook","undefined","internals","createProviderHooksMap","willRegister","didRegister","willDelete","didDelete","providerFactory","throwOnDuplicates","hooks","registry","Map","item","set","values","Array","from","size","clear","traverseEntity","visitor","entity","path","raw","getModel","parent","traverseMorphRelationTarget","entry","targetSchema","__type","traverseOptions","traverseRelationTarget","traverseMediaTarget","targetSchemaUID","traverseComponent","visitDynamicZoneEntry","__component","isObject","isNil","copy","clone","visitorUtils","createVisitorUtils","i","newPath","visitorOptions","isMorphRelation","toLowerCase","method","target","isArray","component","curry","importDefault","modName","mod","require","__esModule","default","deviceId","machineIdSync","randomUUID","formatYupInnerError","yupError","toPath","name","formatYupErrors","errors","isEmpty","inner","ApplicationError","constructor","details","ValidationError","YupValidationError","yupMessage","PaginationError","NotFoundError","ForbiddenError","UnauthorizedError","RateLimitError","PayloadTooLargeError","PolicyError","NotImplementedError","handleYupError","errorMessage","defaultValidationParam","strict","abortEarly","validateYupSchema","body","optionsWithDefaults","defaults","validate","e","yup","validateYupSchemaSync","validateSync","GROUP_OPERATORS","WHERE_OPERATORS","CAST_OPERATORS","ARRAY_OPERATORS","OPERATORS","where","cast","group","OPERATORS_LOWERCASE","fromEntries","entries","isObjKey","obj","isOperatorOfType","ignoreCase","isOperator","some","InvalidOrderError","InvalidSortError","validateOrder","order","isString","toLocaleLowerCase","convertCountQueryParams","countQuery","convertOrderingQueryParams","ordering","isPlainObject","isStringArray","every","createTransformer","convertSortQueryParams","sortQuery","convertStringSortQueryParam","flatMap","sortValue","convertNestedSortQueryParam","convertSingleSortQueryParam","field","transformedSort","convertStartQueryParams","startQuery","startAsANumber","isInteger","convertLimitQueryParams","limitQuery","limitAsANumber","convertPageQueryParams","page","pageVal","convertPageSizeQueryParams","pageSize","pageSizeVal","validatePaginationParams","start","limit","isPagePagination","isOffsetPagination","InvalidPopulateError","convertPopulateQueryParams","populate","depth","convertPopulateObject","hasPopulateFragmentDefined","on","hasCountDefined","count","subPopulate","subPopulateAsBoolean","isBoolean","isMorphLikeRelationalAttribute","hasInvalidProperties","uid","stringify","newSubPopulate","typeSubPopulate","convertNestedPopulate","populateObject","sort","filters","fields","query","orderBy","convertFiltersQueryParams","select","convertFieldsQueryParams","offset","fieldsValues","filter","isValidSchemaAttribute","filtersCopy","convertAndSanitizeFilters","removeOperator","operator","validKey","convertStatusParams","status","meta","$null","transformQueryParams","params","_q","rest","private_convertSortQueryParams","private_convertStartQueryParams","private_convertLimitQueryParams","private_convertPopulateQueryParams","private_convertFiltersQueryParams","private_convertFieldsQueryParams","pipe","fns","firstFn","fnRest","args","apply","pMap","mixedArray","iteratee","initialValue","isPrivate","MANY_RELATIONS","getRelationalFields","isOneToAny","isManyToAny","isAnyToOne","isAnyToMany","isPolymorphic","VALID_RELATION_ORDERING_KEYS","ACTIONS_TO_VERIFY","contentTypeUtils","auth","isRelation","handleMorphRelation","elements","newValue","connect","handleMorphElements","relSet","disconnect","filteredOptions","forEach","validator","newMorphValue","allowedElements","element","scopes","action","isAllowed","hasAccessToSomeScopes","handleRegularRelation","isCreatorRelation","populateCreatorFields","scope","verify","allowedFields","TypeError","containedPaths","getContainedPaths","isPathAllowed","p","parts","index","list","join","restrictedFields","isRestrictedNested","allowedPath","toString","newPopulateQuery","DEFAULT_PATH","parsers","interceptors","ignore","common","traverse","predicate","recurse","parser","find","out","transform","transformUtils","pick","createContext","ignoreCtx","shouldIgnore","ctx","pass","intercept","onAttribute","onRelation","onMedia","onComponent","onDynamicZone","isObj","traverseFactory","then","val","__","omit","ORDERS","asc","desc","ORDER_VALUES","isSortOrder","isObjectArray","isNestedSorts","nestedSort","part","tokenize","flatten","recompose","root","first","ignored","isKeyword","keyword","isWildcard","isPopulateString","pathsToObjectPopulate","traversedPopulate","objectPopulateToPaths","paths","subClause","identity","_key","constant","newOn","input","currentObj","parentPath","currentPath","object","clause","_value","sanitizePasswords","removePassword","defaultSanitizeOutput","removePrivate","defaultSanitizeFilters","pipeAsync","traverseQueryFilters","isAttribute","removeDynamicZones","removeMorphToRelations","defaultSanitizeSort","traverseQuerySort","defaultSanitizeFields","traverseQueryFields","defaultSanitizePopulate","traverseQueryPopulate","expandWildcardPopulate","createAPISanitizers","opts","sanitizeInput","transforms","visitors","sanitizers","sanitizer","sanitizeOutput","output","sanitizeQuery","sanitizedQuery","sanitizeFilters","sanitizeSort","sanitizeFields","sanitizePopulate","throwInvalidKey","msg","asyncCurry","fn","curried","moreArgs","optionKeys","ID_FIELDS","ALLOWED_ROOT_LEVEL_FIELDS","MORPH_TO_ALLOWED_FIELDS","DYNAMIC_ZONE_ALLOWED_FIELDS","RELATION_REORDERING_FIELDS","throwUnrecognizedFields","canUseID","FILTER_TRAVERSALS","validateFilters","include","functionsToApply","throwDynamicZones","throwMorphToRelations","throwPassword","throwPrivate","defaultValidateFilters","SORT_TRAVERSALS","validateSort","defaultValidateSort","FIELDS_TRAVERSALS","validateFields","defaultValidateFields","POPULATE_TRAVERSALS","validatePopulate","isPopulatableAttribute","targets","defaultValidatePopulate","createAPIValidators","validateInput","validators","source","validateQuery","STRAPI_DEFAULTS","paginationAttributes","withMaxLimit","maxLimit","ensureMinValues","Math","max","ensureMaxValues","withNoLimit","pagination","withDefaultPagination","defaultValues","merge","usePagePagination","useOffsetPagination","ensureValidValues","replacePaginationAttributes","transformPagedPaginationInfo","paginationInfo","total","pageCount","ceil","floor","transformOffsetPaginationInfo","SUPPORTED_PACKAGE_MANAGERS","DEFAULT_PACKAGE_MANAGER","getPreferred","pkgPath","pm","preferredPM","hasPackageManager","isPackageManagerSupported","emitWarning","version","installDependencies","packageManager","execa","cwd","stdin","createStrictInterpolationRegExp","allowedVariableNames","flags","oneOfVariables","RegExp","createLooseInterpolationRegExp","kbytesToBytes","kbytes","bytesToKbytes","bytes","round","bytesToHumanReadable","sizes","log","streamToBuffer","stream","resolve","reject","chunks","chunk","Buffer","getStreamSize","byteLength","resume","writableDiscardStream","Writable","write","encding","callback","setImmediate","createPolicy","wrappedValidator","createPolicyContext","is","nameToSlug","separator","slugify","nameToCollectionName","toRegressedEnumValue","decamelize","lowercase","getCommonPath","segments","otherSegments","it","takeWhile","str","isEqual","a","b","String","isCamelCase","test","isKebabCase","startsWithANumber","joinBy","joint","trimChars","trimEnd","trimCharsEnd","trimStart","trimCharsStart","url","toKebabCase","castIncludes","arr","includesString","keysDeep","next","timestampCode","referDate","getTime","errorToString","regExpToString","symbolToString","Symbol","SYMBOL_REGEXP","printNumber","isNegativeZero","printSimpleValue","quoteStrings","replace","tag","Number","isNaN","toISOString","printValue","replacer","strapiID","StrapiIDSchema","isNotNilTest","isNotNullTest","isNull","addMethod","mixed","isNotNill","isNotNull","isFunction","isUndefined","string","strings","onlyContainsFunctions","uniqueProperty","propertyName","sameElements","createError","MixedSchema","_typeCheck","isNumber","setLocale","notType","originalValue","isCast","validateZod","z","ZodError","formatZodErrors","zodError"],"mappings":"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"}