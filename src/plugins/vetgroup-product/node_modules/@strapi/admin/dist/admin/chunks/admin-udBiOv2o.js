'use strict';

var trimEnd = require('lodash/trimEnd');
var react = require('@reduxjs/toolkit/query/react');
var pipe = require('lodash/fp/pipe');
var qs = require('qs');

const STORAGE_KEYS = {
    TOKEN: 'jwtToken',
    USER: 'userInfo'
};
class FetchError extends Error {
    constructor(message, response){
        super(message);
        this.name = 'FetchError';
        this.message = message;
        this.response = response;
        this.code = response?.data?.error?.status;
        this.status = response?.data?.error?.status;
        // Ensure correct stack trace in error object
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, FetchError);
        }
    }
}
const isFetchError = (error)=>{
    return error instanceof FetchError;
};
const getToken = ()=>JSON.parse(localStorage.getItem(STORAGE_KEYS.TOKEN) ?? sessionStorage.getItem(STORAGE_KEYS.TOKEN) ?? '""');
/**
 * @public
 * @param {FetchConfig} [defaultOptions={}] - Fetch Configs.
 * @returns {FetchClient} A fetch client object with methods for making HTTP requests.
 * @description This is an abstraction around the native fetch exposed by a function. It provides a simple interface to handle API calls
 * to the Strapi backend.
 * @example
 * ```tsx
 * import { getFetchClient } from '@strapi/admin/admin';
 *
 * const myFunct = () => {
 *   const { get } = getFetchClient();
 *   const requestURL = "/some-endpoint";
 *
 *   const { data } = await get(requestURL);
 *
 *   return data;
 * };
 * ```
 */ const getFetchClient = (defaultOptions = {})=>{
    const backendURL = window.strapi.backendURL;
    const defaultHeader = {
        Accept: 'application/json',
        'Content-Type': 'application/json',
        Authorization: `Bearer ${getToken()}`
    };
    const isFormDataRequest = (body)=>body instanceof FormData;
    const addPrependingSlash = (url)=>url.charAt(0) !== '/' ? `/${url}` : url;
    // This regular expression matches a string that starts with either "http://" or "https://" or any other protocol name in lower case letters, followed by "://" and ends with anything else
    const hasProtocol = (url)=>new RegExp('^(?:[a-z+]+:)?//', 'i').test(url);
    // Check if the url has a prepending slash, if not add a slash
    const normalizeUrl = (url)=>hasProtocol(url) ? url : addPrependingSlash(url);
    // Add a response interceptor to return the response
    const responseInterceptor = async (response, validateStatus)=>{
        try {
            const result = await response.json();
            /**
       * validateStatus allows us to customize when a response should throw an error
       * In native Fetch API, a response is considered "not ok"
       * when the status code falls in the 200 to 299 (inclusive) range
       */ if (!response.ok && result.error && !validateStatus?.(response.status)) {
                throw new FetchError(result.error.message, {
                    data: result
                });
            }
            if (!response.ok && !validateStatus?.(response.status)) {
                throw new FetchError('Unknown Server Error');
            }
            return {
                data: result
            };
        } catch (error) {
            if (error instanceof SyntaxError && response.ok) {
                // Making sure that a SyntaxError doesn't throw if it's successful
                return {
                    data: [],
                    status: response.status
                };
            } else {
                throw error;
            }
        }
    };
    const paramsSerializer = (params)=>(url)=>{
            if (params) {
                if (typeof params === 'string') {
                    return `${url}?${params}`;
                }
                /**
         * TODO V6: Encoding should be enabled in this step
         * So the rest of the app doesn't have to worry about it,
         * It's considered a breaking change because it impacts any API request, including the user's custom code
         */ const serializedParams = qs.stringify(params, {
                    encode: false
                });
                return `${url}?${serializedParams}`;
            }
            return url;
        };
    const addBaseUrl = (url)=>{
        return `${backendURL}${url}`;
    };
    /**
   * We use the factory method because the options
   * are unique to the individual request
   */ const makeCreateRequestUrl = (options)=>pipe(normalizeUrl, addBaseUrl, paramsSerializer(options?.params));
    const fetchClient = {
        get: async (url, options)=>{
            const headers = new Headers({
                ...defaultHeader,
                ...options?.headers
            });
            /**
       * this applies all our transformations to the URL
       * - normalizing (making sure it has the correct slash)
       * - appending our BaseURL which comes from the window.strapi object
       * - serializing our params with QS
       */ const createRequestUrl = makeCreateRequestUrl(options);
            const response = await fetch(createRequestUrl(url), {
                signal: options?.signal ?? defaultOptions.signal,
                method: 'GET',
                headers
            });
            return responseInterceptor(response, options?.validateStatus);
        },
        post: async (url, data, options)=>{
            const headers = new Headers({
                ...defaultHeader,
                ...options?.headers
            });
            const createRequestUrl = makeCreateRequestUrl(options);
            /**
       * we have to remove the Content-Type value if it was a formData request
       * the browser will automatically set the header value
       */ if (isFormDataRequest(data)) {
                headers.delete('Content-Type');
            }
            const response = await fetch(createRequestUrl(url), {
                signal: options?.signal ?? defaultOptions.signal,
                method: 'POST',
                headers,
                body: isFormDataRequest(data) ? data : JSON.stringify(data)
            });
            return responseInterceptor(response, options?.validateStatus);
        },
        put: async (url, data, options)=>{
            const headers = new Headers({
                ...defaultHeader,
                ...options?.headers
            });
            const createRequestUrl = makeCreateRequestUrl(options);
            /**
       * we have to remove the Content-Type value if it was a formData request
       * the browser will automatically set the header value
       */ if (isFormDataRequest(data)) {
                headers.delete('Content-Type');
            }
            const response = await fetch(createRequestUrl(url), {
                signal: options?.signal ?? defaultOptions.signal,
                method: 'PUT',
                headers,
                body: isFormDataRequest(data) ? data : JSON.stringify(data)
            });
            return responseInterceptor(response, options?.validateStatus);
        },
        del: async (url, options)=>{
            const headers = new Headers({
                ...defaultHeader,
                ...options?.headers
            });
            const createRequestUrl = makeCreateRequestUrl(options);
            const response = await fetch(createRequestUrl(url), {
                signal: options?.signal ?? defaultOptions.signal,
                method: 'DELETE',
                headers
            });
            return responseInterceptor(response, options?.validateStatus);
        }
    };
    return fetchClient;
};

const simpleQuery = async (query, { signal })=>{
    try {
        const { get, post, del, put } = getFetchClient();
        if (typeof query === 'string') {
            const result = await get(query, {
                signal
            });
            return {
                data: result.data
            };
        } else {
            const { url, method = 'GET', data, config } = query;
            if (method === 'POST') {
                const result = await post(url, data, {
                    ...config,
                    signal
                });
                return {
                    data: result.data
                };
            }
            if (method === 'DELETE') {
                const result = await del(url, {
                    ...config,
                    signal
                });
                return {
                    data: result.data
                };
            }
            if (method === 'PUT') {
                const result = await put(url, data, {
                    ...config,
                    signal
                });
                return {
                    data: result.data
                };
            }
            /**
       * Default is GET.
       */ const result = await get(url, {
                ...config,
                signal
            });
            return {
                data: result.data
            };
        }
    } catch (err) {
        // Handle error of type FetchError
        if (isFetchError(err)) {
            if (typeof err.response?.data === 'object' && err.response?.data !== null && 'error' in err.response?.data) {
                /**
         * This will most likely be ApiError
         */ return {
                    data: undefined,
                    error: err.response?.data.error
                };
            } else {
                return {
                    data: undefined,
                    error: {
                        name: 'UnknownError',
                        message: err.message,
                        details: err.response,
                        status: err.status
                    }
                };
            }
        }
        const error = err;
        return {
            data: undefined,
            error: {
                name: error.name,
                message: error.message,
                stack: error.stack
            }
        };
    }
};
const fetchBaseQuery = ()=>simpleQuery;
const isBaseQueryError = (error)=>{
    return error.name !== undefined;
};

/**
 * @public
 * @description This is the redux toolkit api for the admin panel, users
 * should use a combination of `enhanceEndpoints` to add their TagTypes
 * to utilise in their `injectEndpoints` construction for automatic cache
 * re-validation. We specifically do not store any tagTypes by default leaving
 * the API surface as small as possible. None of the data-fetching looks for the
 * StrapiApp are stored here either.
 */ const adminApi = react.createApi({
    reducerPath: 'adminApi',
    baseQuery: fetchBaseQuery(),
    tagTypes: [],
    endpoints: ()=>({})
});

const prefixFileUrlWithBackendUrl = (fileURL)=>{
    return !!fileURL && fileURL.startsWith('/') ? `${window.strapi.backendURL}${fileURL}` : fileURL;
};
/**
 * @description Creates an absolute URL, if there is no URL or it
 * is relative, we use the `window.location.origin` as a fallback.
 * IF it's an absolute URL, we return it as is.
 */ const createAbsoluteUrl = (url)=>{
    if (!url) {
        return window.location.origin;
    }
    if (url.startsWith('/')) {
        /**
     * This will also manage protocol relative URLs which is fine because
     * as we can see from the test, we still get the expected result.
     */ return trimEnd(new URL(url, window.location.origin).toString(), '/');
    } else {
        return url;
    }
};

const admin = adminApi.enhanceEndpoints({
    addTagTypes: [
        'ProjectSettings',
        'LicenseLimits'
    ]
}).injectEndpoints({
    endpoints: (builder)=>({
            init: builder.query({
                query: ()=>({
                        url: '/admin/init',
                        method: 'GET'
                    }),
                transformResponse (res) {
                    return res.data;
                }
            }),
            information: builder.query({
                query: ()=>({
                        url: '/admin/information',
                        method: 'GET'
                    }),
                transformResponse (res) {
                    return res.data;
                }
            }),
            telemetryProperties: builder.query({
                query: ()=>({
                        url: '/admin/telemetry-properties',
                        method: 'GET',
                        config: {
                            validateStatus: (status)=>status < 500
                        }
                    }),
                transformResponse (res) {
                    return res.data;
                }
            }),
            projectSettings: builder.query({
                query: ()=>({
                        url: '/admin/project-settings',
                        method: 'GET'
                    }),
                providesTags: [
                    'ProjectSettings'
                ],
                transformResponse (data) {
                    return {
                        authLogo: data.authLogo ? {
                            name: data.authLogo.name,
                            url: prefixFileUrlWithBackendUrl(data.authLogo.url)
                        } : undefined,
                        menuLogo: data.menuLogo ? {
                            name: data.menuLogo.name,
                            url: prefixFileUrlWithBackendUrl(data.menuLogo.url)
                        } : undefined
                    };
                }
            }),
            updateProjectSettings: builder.mutation({
                query: (data)=>({
                        url: '/admin/project-settings',
                        method: 'POST',
                        data,
                        config: {
                            headers: {
                                'Content-Type': 'multipart/form-data'
                            }
                        }
                    }),
                invalidatesTags: [
                    'ProjectSettings'
                ]
            }),
            getPlugins: builder.query({
                query: ()=>({
                        url: '/admin/plugins',
                        method: 'GET'
                    })
            }),
            getLicenseLimits: builder.query({
                query: ()=>({
                        url: '/admin/license-limit-information',
                        method: 'GET'
                    }),
                providesTags: [
                    'LicenseLimits'
                ]
            })
        }),
    overrideExisting: false
});
const { useInitQuery, useTelemetryPropertiesQuery, useInformationQuery, useProjectSettingsQuery, useUpdateProjectSettingsMutation, useGetPluginsQuery, useGetLicenseLimitsQuery } = admin;

exports.FetchError = FetchError;
exports.adminApi = adminApi;
exports.createAbsoluteUrl = createAbsoluteUrl;
exports.fetchBaseQuery = fetchBaseQuery;
exports.getFetchClient = getFetchClient;
exports.isBaseQueryError = isBaseQueryError;
exports.isFetchError = isFetchError;
exports.useGetLicenseLimitsQuery = useGetLicenseLimitsQuery;
exports.useGetPluginsQuery = useGetPluginsQuery;
exports.useInformationQuery = useInformationQuery;
exports.useInitQuery = useInitQuery;
exports.useProjectSettingsQuery = useProjectSettingsQuery;
exports.useTelemetryPropertiesQuery = useTelemetryPropertiesQuery;
exports.useUpdateProjectSettingsMutation = useUpdateProjectSettingsMutation;
//# sourceMappingURL=admin-udBiOv2o.js.map
