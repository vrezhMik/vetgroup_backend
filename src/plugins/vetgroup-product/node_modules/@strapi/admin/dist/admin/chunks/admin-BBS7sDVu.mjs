import trimEnd from 'lodash/trimEnd';
import { createApi } from '@reduxjs/toolkit/query/react';
import pipe from 'lodash/fp/pipe';
import qs__default from 'qs';

const STORAGE_KEYS = {
    TOKEN: 'jwtToken',
    USER: 'userInfo'
};
class FetchError extends Error {
    constructor(message, response){
        super(message);
        this.name = 'FetchError';
        this.message = message;
        this.response = response;
        this.code = response?.data?.error?.status;
        this.status = response?.data?.error?.status;
        // Ensure correct stack trace in error object
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, FetchError);
        }
    }
}
const isFetchError = (error)=>{
    return error instanceof FetchError;
};
const getToken = ()=>JSON.parse(localStorage.getItem(STORAGE_KEYS.TOKEN) ?? sessionStorage.getItem(STORAGE_KEYS.TOKEN) ?? '""');
/**
 * @public
 * @param {FetchConfig} [defaultOptions={}] - Fetch Configs.
 * @returns {FetchClient} A fetch client object with methods for making HTTP requests.
 * @description This is an abstraction around the native fetch exposed by a function. It provides a simple interface to handle API calls
 * to the Strapi backend.
 * @example
 * ```tsx
 * import { getFetchClient } from '@strapi/admin/admin';
 *
 * const myFunct = () => {
 *   const { get } = getFetchClient();
 *   const requestURL = "/some-endpoint";
 *
 *   const { data } = await get(requestURL);
 *
 *   return data;
 * };
 * ```
 */ const getFetchClient = (defaultOptions = {})=>{
    const backendURL = window.strapi.backendURL;
    const defaultHeader = {
        Accept: 'application/json',
        'Content-Type': 'application/json',
        Authorization: `Bearer ${getToken()}`
    };
    const isFormDataRequest = (body)=>body instanceof FormData;
    const addPrependingSlash = (url)=>url.charAt(0) !== '/' ? `/${url}` : url;
    // This regular expression matches a string that starts with either "http://" or "https://" or any other protocol name in lower case letters, followed by "://" and ends with anything else
    const hasProtocol = (url)=>new RegExp('^(?:[a-z+]+:)?//', 'i').test(url);
    // Check if the url has a prepending slash, if not add a slash
    const normalizeUrl = (url)=>hasProtocol(url) ? url : addPrependingSlash(url);
    // Add a response interceptor to return the response
    const responseInterceptor = async (response, validateStatus)=>{
        try {
            const result = await response.json();
            /**
       * validateStatus allows us to customize when a response should throw an error
       * In native Fetch API, a response is considered "not ok"
       * when the status code falls in the 200 to 299 (inclusive) range
       */ if (!response.ok && result.error && !validateStatus?.(response.status)) {
                throw new FetchError(result.error.message, {
                    data: result
                });
            }
            if (!response.ok && !validateStatus?.(response.status)) {
                throw new FetchError('Unknown Server Error');
            }
            return {
                data: result
            };
        } catch (error) {
            if (error instanceof SyntaxError && response.ok) {
                // Making sure that a SyntaxError doesn't throw if it's successful
                return {
                    data: [],
                    status: response.status
                };
            } else {
                throw error;
            }
        }
    };
    const paramsSerializer = (params)=>(url)=>{
            if (params) {
                if (typeof params === 'string') {
                    return `${url}?${params}`;
                }
                /**
         * TODO V6: Encoding should be enabled in this step
         * So the rest of the app doesn't have to worry about it,
         * It's considered a breaking change because it impacts any API request, including the user's custom code
         */ const serializedParams = qs__default.stringify(params, {
                    encode: false
                });
                return `${url}?${serializedParams}`;
            }
            return url;
        };
    const addBaseUrl = (url)=>{
        return `${backendURL}${url}`;
    };
    /**
   * We use the factory method because the options
   * are unique to the individual request
   */ const makeCreateRequestUrl = (options)=>pipe(normalizeUrl, addBaseUrl, paramsSerializer(options?.params));
    const fetchClient = {
        get: async (url, options)=>{
            const headers = new Headers({
                ...defaultHeader,
                ...options?.headers
            });
            /**
       * this applies all our transformations to the URL
       * - normalizing (making sure it has the correct slash)
       * - appending our BaseURL which comes from the window.strapi object
       * - serializing our params with QS
       */ const createRequestUrl = makeCreateRequestUrl(options);
            const response = await fetch(createRequestUrl(url), {
                signal: options?.signal ?? defaultOptions.signal,
                method: 'GET',
                headers
            });
            return responseInterceptor(response, options?.validateStatus);
        },
        post: async (url, data, options)=>{
            const headers = new Headers({
                ...defaultHeader,
                ...options?.headers
            });
            const createRequestUrl = makeCreateRequestUrl(options);
            /**
       * we have to remove the Content-Type value if it was a formData request
       * the browser will automatically set the header value
       */ if (isFormDataRequest(data)) {
                headers.delete('Content-Type');
            }
            const response = await fetch(createRequestUrl(url), {
                signal: options?.signal ?? defaultOptions.signal,
                method: 'POST',
                headers,
                body: isFormDataRequest(data) ? data : JSON.stringify(data)
            });
            return responseInterceptor(response, options?.validateStatus);
        },
        put: async (url, data, options)=>{
            const headers = new Headers({
                ...defaultHeader,
                ...options?.headers
            });
            const createRequestUrl = makeCreateRequestUrl(options);
            /**
       * we have to remove the Content-Type value if it was a formData request
       * the browser will automatically set the header value
       */ if (isFormDataRequest(data)) {
                headers.delete('Content-Type');
            }
            const response = await fetch(createRequestUrl(url), {
                signal: options?.signal ?? defaultOptions.signal,
                method: 'PUT',
                headers,
                body: isFormDataRequest(data) ? data : JSON.stringify(data)
            });
            return responseInterceptor(response, options?.validateStatus);
        },
        del: async (url, options)=>{
            const headers = new Headers({
                ...defaultHeader,
                ...options?.headers
            });
            const createRequestUrl = makeCreateRequestUrl(options);
            const response = await fetch(createRequestUrl(url), {
                signal: options?.signal ?? defaultOptions.signal,
                method: 'DELETE',
                headers
            });
            return responseInterceptor(response, options?.validateStatus);
        }
    };
    return fetchClient;
};

const simpleQuery = async (query, { signal })=>{
    try {
        const { get, post, del, put } = getFetchClient();
        if (typeof query === 'string') {
            const result = await get(query, {
                signal
            });
            return {
                data: result.data
            };
        } else {
            const { url, method = 'GET', data, config } = query;
            if (method === 'POST') {
                const result = await post(url, data, {
                    ...config,
                    signal
                });
                return {
                    data: result.data
                };
            }
            if (method === 'DELETE') {
                const result = await del(url, {
                    ...config,
                    signal
                });
                return {
                    data: result.data
                };
            }
            if (method === 'PUT') {
                const result = await put(url, data, {
                    ...config,
                    signal
                });
                return {
                    data: result.data
                };
            }
            /**
       * Default is GET.
       */ const result = await get(url, {
                ...config,
                signal
            });
            return {
                data: result.data
            };
        }
    } catch (err) {
        // Handle error of type FetchError
        if (isFetchError(err)) {
            if (typeof err.response?.data === 'object' && err.response?.data !== null && 'error' in err.response?.data) {
                /**
         * This will most likely be ApiError
         */ return {
                    data: undefined,
                    error: err.response?.data.error
                };
            } else {
                return {
                    data: undefined,
                    error: {
                        name: 'UnknownError',
                        message: err.message,
                        details: err.response,
                        status: err.status
                    }
                };
            }
        }
        const error = err;
        return {
            data: undefined,
            error: {
                name: error.name,
                message: error.message,
                stack: error.stack
            }
        };
    }
};
const fetchBaseQuery = ()=>simpleQuery;
const isBaseQueryError = (error)=>{
    return error.name !== undefined;
};

/**
 * @public
 * @description This is the redux toolkit api for the admin panel, users
 * should use a combination of `enhanceEndpoints` to add their TagTypes
 * to utilise in their `injectEndpoints` construction for automatic cache
 * re-validation. We specifically do not store any tagTypes by default leaving
 * the API surface as small as possible. None of the data-fetching looks for the
 * StrapiApp are stored here either.
 */ const adminApi = createApi({
    reducerPath: 'adminApi',
    baseQuery: fetchBaseQuery(),
    tagTypes: [],
    endpoints: ()=>({})
});

const prefixFileUrlWithBackendUrl = (fileURL)=>{
    return !!fileURL && fileURL.startsWith('/') ? `${window.strapi.backendURL}${fileURL}` : fileURL;
};
/**
 * @description Creates an absolute URL, if there is no URL or it
 * is relative, we use the `window.location.origin` as a fallback.
 * IF it's an absolute URL, we return it as is.
 */ const createAbsoluteUrl = (url)=>{
    if (!url) {
        return window.location.origin;
    }
    if (url.startsWith('/')) {
        /**
     * This will also manage protocol relative URLs which is fine because
     * as we can see from the test, we still get the expected result.
     */ return trimEnd(new URL(url, window.location.origin).toString(), '/');
    } else {
        return url;
    }
};

const admin = adminApi.enhanceEndpoints({
    addTagTypes: [
        'ProjectSettings',
        'LicenseLimits'
    ]
}).injectEndpoints({
    endpoints: (builder)=>({
            init: builder.query({
                query: ()=>({
                        url: '/admin/init',
                        method: 'GET'
                    }),
                transformResponse (res) {
                    return res.data;
                }
            }),
            information: builder.query({
                query: ()=>({
                        url: '/admin/information',
                        method: 'GET'
                    }),
                transformResponse (res) {
                    return res.data;
                }
            }),
            telemetryProperties: builder.query({
                query: ()=>({
                        url: '/admin/telemetry-properties',
                        method: 'GET',
                        config: {
                            validateStatus: (status)=>status < 500
                        }
                    }),
                transformResponse (res) {
                    return res.data;
                }
            }),
            projectSettings: builder.query({
                query: ()=>({
                        url: '/admin/project-settings',
                        method: 'GET'
                    }),
                providesTags: [
                    'ProjectSettings'
                ],
                transformResponse (data) {
                    return {
                        authLogo: data.authLogo ? {
                            name: data.authLogo.name,
                            url: prefixFileUrlWithBackendUrl(data.authLogo.url)
                        } : undefined,
                        menuLogo: data.menuLogo ? {
                            name: data.menuLogo.name,
                            url: prefixFileUrlWithBackendUrl(data.menuLogo.url)
                        } : undefined
                    };
                }
            }),
            updateProjectSettings: builder.mutation({
                query: (data)=>({
                        url: '/admin/project-settings',
                        method: 'POST',
                        data,
                        config: {
                            headers: {
                                'Content-Type': 'multipart/form-data'
                            }
                        }
                    }),
                invalidatesTags: [
                    'ProjectSettings'
                ]
            }),
            getPlugins: builder.query({
                query: ()=>({
                        url: '/admin/plugins',
                        method: 'GET'
                    })
            }),
            getLicenseLimits: builder.query({
                query: ()=>({
                        url: '/admin/license-limit-information',
                        method: 'GET'
                    }),
                providesTags: [
                    'LicenseLimits'
                ]
            })
        }),
    overrideExisting: false
});
const { useInitQuery, useTelemetryPropertiesQuery, useInformationQuery, useProjectSettingsQuery, useUpdateProjectSettingsMutation, useGetPluginsQuery, useGetLicenseLimitsQuery } = admin;

export { FetchError as F, adminApi as a, useGetPluginsQuery as b, isFetchError as c, useInformationQuery as d, useInitQuery as e, useTelemetryPropertiesQuery as f, useProjectSettingsQuery as g, useUpdateProjectSettingsMutation as h, isBaseQueryError as i, createAbsoluteUrl as j, getFetchClient as k, fetchBaseQuery as l, useGetLicenseLimitsQuery as u };
//# sourceMappingURL=admin-BBS7sDVu.mjs.map
