import * as _ from 'lodash';
import ___default, { pick as pick$1 } from 'lodash';
import { merge, map, uniq, difference, isNil, castArray, pick, curry, pipe, prop, includes, isArray, set, omit, isEmpty, has, defaults, remove, eq, get, differenceWith, differenceBy, isEqual, toLower, isFunction, some, flatMap, isObject, cloneDeep, getOr, intersection, isPlainObject, matchesProperty, propEq, xor, startsWith, isString, isNumber, values, sumBy, trim, isUndefined, mapKeys, toString, toNumber, assign, reverse, take, drop, mapValues } from 'lodash/fp';
import utils$2, { async, errors, yup as yup$1, validateYupSchema, policy, arrays, hooks as hooks$1, dates, validateYupSchemaSync, providerFactory, sanitize, contentTypes as contentTypes$1, traverse, traverseEntity, validate, env, validateZod, strings } from '@strapi/utils';
import path, { resolve, basename, join, extname } from 'path';
import fse, { exists as exists$4 } from 'fs-extra';
import koaStatic from 'koa-static';
import { differenceInHours, parseISO } from 'date-fns';
import '@strapi/types';
import bcrypt from 'bcryptjs';
import passport$2 from 'koa-passport';
import { Strategy } from 'passport-local';
import crypto from 'crypto';
import jwt from 'jsonwebtoken';
import { detectSubjectType, subject as subject$1 } from '@casl/ability';
import { permittedFieldsOf, rulesToQuery } from '@casl/ability/extra';
import permissions$1 from '@strapi/permissions';
import pmap from 'p-map';
import assert from 'assert';
import fs from 'fs';
import tsUtils from '@strapi/typescript-utils';
import { z } from 'zod';
import compose from 'koa-compose';
import { strapi as strapi$1 } from '@strapi/data-transfer';
import isLocalhostIp from 'is-localhost-ip';
import punycode from 'punycode/';
import * as yup from 'yup';
import { scheduleJob } from 'node-schedule';

const getService$1 = (name)=>{
    return strapi.service(`admin::${name}`);
};

const actions$1 = [
    {
        uid: 'marketplace.read',
        displayName: 'Access the marketplace',
        pluginName: 'admin',
        section: 'settings',
        category: 'plugins and marketplace',
        subCategory: 'marketplace'
    },
    {
        uid: 'webhooks.create',
        displayName: 'Create',
        pluginName: 'admin',
        section: 'settings',
        category: 'webhooks'
    },
    {
        uid: 'webhooks.read',
        displayName: 'Read',
        pluginName: 'admin',
        section: 'settings',
        category: 'webhooks'
    },
    {
        uid: 'webhooks.update',
        displayName: 'Update',
        pluginName: 'admin',
        section: 'settings',
        category: 'webhooks'
    },
    {
        uid: 'webhooks.delete',
        displayName: 'Delete',
        pluginName: 'admin',
        section: 'settings',
        category: 'webhooks'
    },
    {
        uid: 'users.create',
        displayName: 'Create (invite)',
        pluginName: 'admin',
        section: 'settings',
        category: 'users and roles',
        subCategory: 'users'
    },
    {
        uid: 'users.read',
        displayName: 'Read',
        pluginName: 'admin',
        section: 'settings',
        category: 'users and roles',
        subCategory: 'users',
        aliases: [
            {
                actionId: 'plugin::content-manager.explorer.read',
                subjects: [
                    'admin::user'
                ]
            }
        ]
    },
    {
        uid: 'users.update',
        displayName: 'Update',
        pluginName: 'admin',
        section: 'settings',
        category: 'users and roles',
        subCategory: 'users'
    },
    {
        uid: 'users.delete',
        displayName: 'Delete',
        pluginName: 'admin',
        section: 'settings',
        category: 'users and roles',
        subCategory: 'users'
    },
    {
        uid: 'roles.create',
        displayName: 'Create',
        pluginName: 'admin',
        section: 'settings',
        category: 'users and roles',
        subCategory: 'roles'
    },
    {
        uid: 'roles.read',
        displayName: 'Read',
        pluginName: 'admin',
        section: 'settings',
        category: 'users and roles',
        subCategory: 'roles',
        aliases: [
            {
                actionId: 'plugin::content-manager.explorer.read',
                subjects: [
                    'admin::role'
                ]
            }
        ]
    },
    {
        uid: 'roles.update',
        displayName: 'Update',
        pluginName: 'admin',
        section: 'settings',
        category: 'users and roles',
        subCategory: 'roles'
    },
    {
        uid: 'roles.delete',
        displayName: 'Delete',
        pluginName: 'admin',
        section: 'settings',
        category: 'users and roles',
        subCategory: 'roles'
    },
    {
        uid: 'api-tokens.access',
        displayName: 'Access the API tokens settings page',
        pluginName: 'admin',
        section: 'settings',
        category: 'api tokens',
        subCategory: 'api Tokens'
    },
    {
        uid: 'api-tokens.create',
        displayName: 'Create (generate)',
        pluginName: 'admin',
        section: 'settings',
        category: 'api tokens',
        subCategory: 'general'
    },
    {
        uid: 'api-tokens.read',
        displayName: 'Read',
        pluginName: 'admin',
        section: 'settings',
        category: 'api tokens',
        subCategory: 'general'
    },
    {
        uid: 'api-tokens.update',
        displayName: 'Update',
        pluginName: 'admin',
        section: 'settings',
        category: 'api tokens',
        subCategory: 'general'
    },
    {
        uid: 'api-tokens.regenerate',
        displayName: 'Regenerate',
        pluginName: 'admin',
        section: 'settings',
        category: 'api tokens',
        subCategory: 'general'
    },
    {
        uid: 'api-tokens.delete',
        displayName: 'Delete (revoke)',
        pluginName: 'admin',
        section: 'settings',
        category: 'api tokens',
        subCategory: 'general'
    },
    {
        uid: 'project-settings.update',
        displayName: 'Update the project level settings',
        pluginName: 'admin',
        section: 'settings',
        category: 'project'
    },
    {
        uid: 'project-settings.read',
        displayName: 'Read the project level settings',
        pluginName: 'admin',
        section: 'settings',
        category: 'project'
    },
    {
        uid: 'transfer.tokens.access',
        displayName: 'Access the transfer tokens settings page',
        pluginName: 'admin',
        section: 'settings',
        category: 'transfer tokens',
        subCategory: 'transfer tokens'
    },
    {
        uid: 'transfer.tokens.create',
        displayName: 'Create (generate)',
        pluginName: 'admin',
        section: 'settings',
        category: 'transfer tokens',
        subCategory: 'general'
    },
    {
        uid: 'transfer.tokens.read',
        displayName: 'Read',
        pluginName: 'admin',
        section: 'settings',
        category: 'transfer tokens',
        subCategory: 'general'
    },
    {
        uid: 'transfer.tokens.update',
        displayName: 'Update',
        pluginName: 'admin',
        section: 'settings',
        category: 'transfer tokens',
        subCategory: 'general'
    },
    {
        uid: 'transfer.tokens.regenerate',
        displayName: 'Regenerate',
        pluginName: 'admin',
        section: 'settings',
        category: 'transfer tokens',
        subCategory: 'general'
    },
    {
        uid: 'transfer.tokens.delete',
        displayName: 'Delete (revoke)',
        pluginName: 'admin',
        section: 'settings',
        category: 'transfer tokens',
        subCategory: 'general'
    }
];
var adminActions = {
    actions: actions$1
};

// TODO: TS User and role type
const conditions = [
    {
        displayName: 'Is creator',
        name: 'is-creator',
        plugin: 'admin',
        handler: (user)=>({
                'createdBy.id': user.id
            })
    },
    {
        displayName: 'Has same role as creator',
        name: 'has-same-role-as-creator',
        plugin: 'admin',
        handler: (user)=>({
                'createdBy.roles': {
                    $elemMatch: {
                        id: {
                            $in: user.roles.map((r)=>r.id)
                        }
                    }
                }
            })
    }
];
var adminConditions = {
    conditions
};

const defaultAdminAuthSettings = {
    providers: {
        autoRegister: false,
        defaultRole: null,
        ssoLockedRoles: null
    }
};
const registerPermissionActions = async ()=>{
    await getService$1('permission').actionProvider.registerMany(adminActions.actions);
};
const registerAdminConditions = async ()=>{
    await getService$1('permission').conditionProvider.registerMany(adminConditions.conditions);
};
const registerModelHooks = ()=>{
    const { sendDidChangeInterfaceLanguage } = getService$1('metrics');
    strapi.db.lifecycles.subscribe({
        models: [
            'admin::user'
        ],
        afterCreate: sendDidChangeInterfaceLanguage,
        afterDelete: sendDidChangeInterfaceLanguage,
        afterUpdate ({ params }) {
            if (params.data.preferedLanguage) {
                sendDidChangeInterfaceLanguage();
            }
        }
    });
};
const syncAuthSettings = async ()=>{
    const adminStore = await strapi.store({
        type: 'core',
        name: 'admin'
    });
    const adminAuthSettings = await adminStore.get({
        key: 'auth'
    });
    const newAuthSettings = merge(defaultAdminAuthSettings, adminAuthSettings);
    const roleExists = await getService$1('role').exists({
        id: newAuthSettings.providers.defaultRole
    });
    // Reset the default SSO role if it has been deleted manually
    if (!roleExists) {
        newAuthSettings.providers.defaultRole = null;
    }
    await adminStore.set({
        key: 'auth',
        value: newAuthSettings
    });
};
const syncAPITokensPermissions = async ()=>{
    const validPermissions = strapi.contentAPI.permissions.providers.action.keys();
    const permissionsInDB = await async.pipe(strapi.db.query('admin::api-token-permission').findMany, map('action'))();
    const unknownPermissions = uniq(difference(permissionsInDB, validPermissions));
    if (unknownPermissions.length > 0) {
        await strapi.db.query('admin::api-token-permission').deleteMany({
            where: {
                action: {
                    $in: unknownPermissions
                }
            }
        });
    }
};
/**
 * Ensures the creation of default API tokens during the app creation.
 *
 * Checks the database for existing users and API tokens:
 * - If there are no users and no API tokens, it creates two default API tokens:
 *   1. A "Read Only" API token with permissions for accessing resources.
 *   2. A "Full Access" API token with permissions for accessing and modifying resources.
 *
 * @sideEffects Creates new API tokens in the database if conditions are met.
 */ const createDefaultAPITokensIfNeeded = async ()=>{
    const userService = getService$1('user');
    const apiTokenService = getService$1('api-token');
    const usersCount = await userService.count();
    const apiTokenCount = await apiTokenService.count();
    if (usersCount === 0 && apiTokenCount === 0) {
        await apiTokenService.create({
            name: 'Read Only',
            description: 'A default API token with read-only permissions, only used for accessing resources',
            type: 'read-only',
            lifespan: null
        });
        await apiTokenService.create({
            name: 'Full Access',
            description: 'A default API token with full access permissions, used for accessing or modifying resources',
            type: 'full-access',
            lifespan: null
        });
    }
};
var bootstrap$1 = (async ({ strapi: strapi1 })=>{
    await registerAdminConditions();
    await registerPermissionActions();
    registerModelHooks();
    const permissionService = getService$1('permission');
    const userService = getService$1('user');
    const roleService = getService$1('role');
    const apiTokenService = getService$1('api-token');
    const transferService = getService$1('transfer');
    const tokenService = getService$1('token');
    await roleService.createRolesIfNoneExist();
    await roleService.resetSuperAdminPermissions();
    await roleService.displayWarningIfNoSuperAdmin();
    await permissionService.cleanPermissionsInDatabase();
    await userService.displayWarningIfUsersDontHaveRole();
    await syncAuthSettings();
    await syncAPITokensPermissions();
    await getService$1('metrics').sendUpdateProjectInformation(strapi1);
    getService$1('metrics').startCron(strapi1);
    apiTokenService.checkSaltIsDefined();
    transferService.token.checkSaltIsDefined();
    tokenService.checkSecretIsDefined();
    await createDefaultAPITokensIfNeeded();
});

const registerAdminPanelRoute = ({ strapi })=>{
    let buildDir = resolve(strapi.dirs.dist.root, 'build');
    if (!fse.pathExistsSync(buildDir)) {
        buildDir = resolve(__dirname, '../../build');
    }
    const serveAdminMiddleware = async (ctx, next)=>{
        await next();
        if (ctx.method !== 'HEAD' && ctx.method !== 'GET') {
            return;
        }
        if (ctx.body != null || ctx.status !== 404) {
            return;
        }
        ctx.type = 'html';
        ctx.body = fse.createReadStream(join(buildDir, 'index.html'));
    };
    strapi.server.routes([
        {
            method: 'GET',
            path: `${strapi.config.admin.path}/:path*`,
            handler: [
                serveAdminMiddleware,
                serveStatic(buildDir, {
                    maxage: 31536000,
                    defer: false,
                    index: 'index.html',
                    setHeaders (res, path) {
                        const ext = extname(path);
                        // publicly cache static files to avoid unnecessary network & disk access
                        if (ext !== '.html') {
                            res.setHeader('cache-control', 'public, max-age=31536000, immutable');
                        }
                    }
                })
            ],
            config: {
                auth: false
            }
        }
    ]);
};
// serveStatic is not supposed to be used to serve a folder that have sub-folders
const serveStatic = (filesDir, koaStaticOptions = {})=>{
    const serve = koaStatic(filesDir, koaStaticOptions);
    return async (ctx, next)=>{
        const prev = ctx.path;
        const newPath = basename(ctx.path);
        ctx.path = newPath;
        await serve(ctx, async ()=>{
            ctx.path = prev;
            await next();
            ctx.path = newPath;
        });
        ctx.path = prev;
    };
};

/** @type {import('.').AuthenticateFunction} */ const authenticate$3 = async (ctx)=>{
    const { authorization } = ctx.request.header;
    if (!authorization) {
        return {
            authenticated: false
        };
    }
    const parts = authorization.split(/\s+/);
    if (parts[0].toLowerCase() !== 'bearer' || parts.length !== 2) {
        return {
            authenticated: false
        };
    }
    const token = parts[1];
    const { payload, isValid } = getService$1('token').decodeJwtToken(token);
    if (!isValid) {
        return {
            authenticated: false
        };
    }
    const user = await strapi.db.query('admin::user').findOne({
        where: {
            id: payload.id
        },
        populate: [
            'roles'
        ]
    });
    if (!user || !(user.isActive === true)) {
        return {
            authenticated: false
        };
    }
    const userAbility = await getService$1('permission').engine.generateUserAbility(user);
    // TODO: use the ability from ctx.state.auth instead of
    // ctx.state.userAbility, and remove the assign below
    ctx.state.userAbility = userAbility;
    ctx.state.user = user;
    return {
        authenticated: true,
        credentials: user,
        ability: userAbility
    };
};
const name$1 = 'admin';
/** @type {import('.').AuthStrategy} */ var adminAuthStrategy = {
    name: name$1,
    authenticate: authenticate$3
};

const DAY_IN_MS = 24 * 60 * 60 * 1000;
const constants$3 = {
    CONTENT_TYPE_SECTION: 'contentTypes',
    SUPER_ADMIN_CODE: 'strapi-super-admin',
    EDITOR_CODE: 'strapi-editor',
    AUTHOR_CODE: 'strapi-author',
    READ_ACTION: 'plugin::content-manager.explorer.read',
    CREATE_ACTION: 'plugin::content-manager.explorer.create',
    UPDATE_ACTION: 'plugin::content-manager.explorer.update',
    DELETE_ACTION: 'plugin::content-manager.explorer.delete',
    PUBLISH_ACTION: 'plugin::content-manager.explorer.publish',
    API_TOKEN_TYPE: {
        READ_ONLY: 'read-only',
        FULL_ACCESS: 'full-access',
        CUSTOM: 'custom'
    },
    // The front-end only displays these values
    API_TOKEN_LIFESPANS: {
        UNLIMITED: null,
        DAYS_7: 7 * DAY_IN_MS,
        DAYS_30: 30 * DAY_IN_MS,
        DAYS_90: 90 * DAY_IN_MS
    },
    TRANSFER_TOKEN_TYPE: {
        PUSH: 'push',
        PULL: 'pull'
    },
    TRANSFER_TOKEN_LIFESPANS: {
        UNLIMITED: null,
        DAYS_7: 7 * DAY_IN_MS,
        DAYS_30: 30 * DAY_IN_MS,
        DAYS_90: 90 * DAY_IN_MS
    }
};

var constants$4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  default: constants$3
});

const { UnauthorizedError: UnauthorizedError$3, ForbiddenError: ForbiddenError$2 } = errors;
const isReadScope = (scope)=>scope.endsWith('find') || scope.endsWith('findOne');
const extractToken$1 = (ctx)=>{
    if (ctx.request && ctx.request.header && ctx.request.header.authorization) {
        const parts = ctx.request.header.authorization.split(/\s+/);
        if (parts[0].toLowerCase() !== 'bearer' || parts.length !== 2) {
            return null;
        }
        return parts[1];
    }
    return null;
};
/**
 * Authenticate the validity of the token
 */ const authenticate$2 = async (ctx)=>{
    const apiTokenService = getService$1('api-token');
    const token = extractToken$1(ctx);
    if (!token) {
        return {
            authenticated: false
        };
    }
    const apiToken = await apiTokenService.getBy({
        accessKey: apiTokenService.hash(token)
    });
    // token not found
    if (!apiToken) {
        return {
            authenticated: false
        };
    }
    const currentDate = new Date();
    if (!isNil(apiToken.expiresAt)) {
        const expirationDate = new Date(apiToken.expiresAt);
        // token has expired
        if (expirationDate < currentDate) {
            return {
                authenticated: false,
                error: new UnauthorizedError$3('Token expired')
            };
        }
    }
    // update lastUsedAt if the token has not been used in the last hour
    // @ts-expect-error - FIXME: verify lastUsedAt is defined
    const hoursSinceLastUsed = differenceInHours(currentDate, parseISO(apiToken.lastUsedAt));
    if (hoursSinceLastUsed >= 1) {
        await strapi.db.query('admin::api-token').update({
            where: {
                id: apiToken.id
            },
            data: {
                lastUsedAt: currentDate
            }
        });
    }
    if (apiToken.type === constants$3.API_TOKEN_TYPE.CUSTOM) {
        const ability = await strapi.contentAPI.permissions.engine.generateAbility(apiToken.permissions.map((action)=>({
                action
            })));
        return {
            authenticated: true,
            ability,
            credentials: apiToken
        };
    }
    return {
        authenticated: true,
        credentials: apiToken
    };
};
/**
 * Verify the token has the required abilities for the requested scope
 *
 *  @type {import('.').VerifyFunction}
 */ const verify$2 = (auth, config)=>{
    const { credentials: apiToken, ability } = auth;
    if (!apiToken) {
        throw new UnauthorizedError$3('Token not found');
    }
    const currentDate = new Date();
    if (!isNil(apiToken.expiresAt)) {
        const expirationDate = new Date(apiToken.expiresAt);
        // token has expired
        if (expirationDate < currentDate) {
            throw new UnauthorizedError$3('Token expired');
        }
    }
    // Full access
    if (apiToken.type === constants$3.API_TOKEN_TYPE.FULL_ACCESS) {
        return;
    }
    // Read only
    if (apiToken.type === constants$3.API_TOKEN_TYPE.READ_ONLY) {
        /**
     * If you don't have `full-access` you can only access `find` and `findOne`
     * scopes. If the route has no scope, then you can't get access to it.
     */ const scopes = castArray(config.scope);
        if (config.scope && scopes.every(isReadScope)) {
            return;
        }
    } else if (apiToken.type === constants$3.API_TOKEN_TYPE.CUSTOM) {
        if (!ability) {
            throw new ForbiddenError$2();
        }
        const scopes = castArray(config.scope);
        const isAllowed = scopes.every((scope)=>ability.can(scope));
        if (isAllowed) {
            return;
        }
    }
    throw new ForbiddenError$2();
};
var apiTokenAuthStrategy = {
    name: 'api-token',
    authenticate: authenticate$2,
    verify: verify$2
};

var register$2 = (({ strapi })=>{
    const passportMiddleware = strapi.service('admin::passport').init();
    strapi.server.api('admin').use(passportMiddleware);
    strapi.get('auth').register('admin', adminAuthStrategy);
    strapi.get('auth').register('content-api', apiTokenAuthStrategy);
    if (strapi.config.get('admin.serveAdminPanel')) {
        registerAdminPanelRoute({
            strapi
        });
    }
});

var destroy$1 = (async ()=>{
    const { conditionProvider, actionProvider } = getService$1('permission');
    await conditionProvider.clear();
    await actionProvider.clear();
});

const subject = `Reset password`;
const html = `<p>We heard that you lost your password. Sorry about that!</p>

<p>But don’t worry! You can use the following link to reset your password:</p>

<p><%= url %></p>

<p>Thanks.</p>`;
const text = `We heard that you lost your password. Sorry about that!

But don’t worry! You can use the following link to reset your password:

<%= url %>

Thanks.`;
var forgotPasswordTemplate = {
    subject,
    text,
    html
};

const forgotPassword$2 = {
    emailTemplate: forgotPasswordTemplate
};
var config = {
    forgotPassword: forgotPassword$2
};

var isAuthenticatedAdmin = ((policyCtx)=>{
    return Boolean(policyCtx.state.isAuthenticated);
});

const hasPermissionsSchema = yup$1.object({
    actions: yup$1.array().of(// @ts-expect-error yup types
    yup$1.lazy((val)=>{
        if (___default.isArray(val)) {
            return yup$1.array().of(yup$1.string()).min(1).max(2);
        }
        if (___default.isString(val)) {
            return yup$1.string().required();
        }
        return yup$1.object().shape({
            action: yup$1.string().required(),
            subject: yup$1.string()
        });
    }))
});
const validateHasPermissionsInput = validateYupSchema(hasPermissionsSchema);

const { createPolicy: createPolicy$1 } = policy;
const inputModifiers = [
    {
        check: ___default.isString,
        transform: (action)=>({
                action
            })
    },
    {
        check: ___default.isArray,
        transform: (arr)=>({
                action: arr[0],
                subject: arr[1]
            })
    },
    {
        // Has to be after the isArray check since _.isObject also matches arrays
        check: ___default.isObject,
        transform: (perm)=>perm
    }
];
var hasPermissions = createPolicy$1({
    name: 'admin::hasPermissions',
    validator: validateHasPermissionsInput,
    handler (ctx, config) {
        const { actions } = config;
        const { userAbility: ability } = ctx.state;
        const permissions = actions.map((action)=>inputModifiers.find((modifier)=>modifier.check(action))?.transform(action));
        const isAuthorized = permissions.every(({ action, subject })=>ability.can(action, subject));
        return isAuthorized;
    }
});

// TODO: TS - Try to make { policy: { createPolicy } } from '@strapi/utils'; work
const { createPolicy } = policy;
/**
 * This policy is used for routes dealing with telemetry and analytics content.
 * It will fails when the telemetry has been disabled on the server.
 */ var isTelemetryEnabled = createPolicy({
    name: 'admin::isTelemetryEnabled',
    handler (_ctx, _config, { strapi }) {
        if (strapi.telemetry.isDisabled) {
            return false;
        }
    }
});

var policies = {
    isAuthenticatedAdmin,
    hasPermissions,
    isTelemetryEnabled
};

var admin$4 = [
    {
        method: 'GET',
        path: '/init',
        handler: 'admin.init',
        config: {
            auth: false
        }
    },
    {
        method: 'GET',
        path: '/project-settings',
        handler: 'admin.getProjectSettings',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::project-settings.read'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'POST',
        path: '/project-settings',
        handler: 'admin.updateProjectSettings',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::project-settings.update'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'GET',
        path: '/project-type',
        handler: 'admin.getProjectType',
        config: {
            auth: false
        }
    },
    {
        method: 'GET',
        path: '/information',
        handler: 'admin.information',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin'
            ]
        }
    },
    {
        method: 'GET',
        path: '/telemetry-properties',
        handler: 'admin.telemetryProperties',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin'
            ]
        }
    },
    {
        method: 'GET',
        path: '/plugins',
        handler: 'admin.plugins',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::marketplace.read'
                        ]
                    }
                }
            ]
        }
    }
];

var authentication$2 = [
    {
        method: 'POST',
        path: '/login',
        handler: 'authentication.login',
        config: {
            auth: false,
            middlewares: [
                'admin::rateLimit'
            ]
        }
    },
    {
        method: 'POST',
        path: '/renew-token',
        handler: 'authentication.renewToken',
        config: {
            auth: false
        }
    },
    {
        method: 'POST',
        path: '/register-admin',
        handler: 'authentication.registerAdmin',
        config: {
            auth: false
        }
    },
    {
        method: 'GET',
        path: '/registration-info',
        handler: 'authentication.registrationInfo',
        config: {
            auth: false
        }
    },
    {
        method: 'POST',
        path: '/register',
        handler: 'authentication.register',
        config: {
            auth: false
        }
    },
    {
        method: 'POST',
        path: '/forgot-password',
        handler: 'authentication.forgotPassword',
        config: {
            auth: false,
            middlewares: [
                'plugin::email.rateLimit'
            ]
        }
    },
    {
        method: 'POST',
        path: '/reset-password',
        handler: 'authentication.resetPassword',
        config: {
            auth: false
        }
    },
    {
        method: 'POST',
        path: '/logout',
        handler: 'authentication.logout',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin'
            ]
        }
    }
];

var permissions = [
    {
        method: 'GET',
        path: '/permissions',
        handler: 'permission.getAll',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin'
            ]
        }
    },
    {
        method: 'POST',
        path: '/permissions/check',
        handler: 'permission.check',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin'
            ]
        }
    }
];

var users = [
    {
        method: 'GET',
        path: '/users/me',
        handler: 'authenticated-user.getMe',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin'
            ]
        }
    },
    {
        method: 'PUT',
        path: '/users/me',
        handler: 'authenticated-user.updateMe',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin'
            ]
        }
    },
    {
        method: 'GET',
        path: '/users/me/permissions',
        handler: 'authenticated-user.getOwnPermissions',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin'
            ]
        }
    },
    {
        method: 'POST',
        path: '/users',
        handler: 'user.create',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::users.create'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'GET',
        path: '/users',
        handler: 'user.find',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::users.read'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'GET',
        path: '/users/:id',
        handler: 'user.findOne',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::users.read'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'PUT',
        path: '/users/:id',
        handler: 'user.update',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::users.update'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'DELETE',
        path: '/users/:id',
        handler: 'user.deleteOne',
        config: {
            policies: [
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::users.delete'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'POST',
        path: '/users/batch-delete',
        handler: 'user.deleteMany',
        config: {
            policies: [
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::users.delete'
                        ]
                    }
                }
            ]
        }
    }
];

var roles$1 = [
    {
        method: 'GET',
        path: '/roles/:id/permissions',
        handler: 'role.getPermissions',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::roles.read'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'PUT',
        path: '/roles/:id/permissions',
        handler: 'role.updatePermissions',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::roles.update'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'GET',
        path: '/roles/:id',
        handler: 'role.findOne',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::roles.read'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'GET',
        path: '/roles',
        handler: 'role.findAll',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::roles.read'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'POST',
        path: '/roles',
        handler: 'role.create',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::roles.create'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'PUT',
        path: '/roles/:id',
        handler: 'role.update',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::roles.update'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'DELETE',
        path: '/roles/:id',
        handler: 'role.deleteOne',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::roles.delete'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'POST',
        path: '/roles/batch-delete',
        handler: 'role.deleteMany',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::roles.delete'
                        ]
                    }
                }
            ]
        }
    }
];

var webhooks$1 = [
    {
        method: 'GET',
        path: '/webhooks',
        handler: 'webhooks.listWebhooks',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::webhooks.read'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'POST',
        path: '/webhooks',
        handler: 'webhooks.createWebhook',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::webhooks.create'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'GET',
        path: '/webhooks/:id',
        handler: 'webhooks.getWebhook',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::webhooks.read'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'PUT',
        path: '/webhooks/:id',
        handler: 'webhooks.updateWebhook',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::webhooks.update'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'DELETE',
        path: '/webhooks/:id',
        handler: 'webhooks.deleteWebhook',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::webhooks.delete'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'POST',
        path: '/webhooks/batch-delete',
        handler: 'webhooks.deleteWebhooks',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::webhooks.delete'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'POST',
        path: '/webhooks/:id/trigger',
        handler: 'webhooks.triggerWebhook',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::webhooks.update'
                        ]
                    }
                }
            ]
        }
    }
];

var apiTokens = [
    {
        method: 'POST',
        path: '/api-tokens',
        handler: 'api-token.create',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::api-tokens.create'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'GET',
        path: '/api-tokens',
        handler: 'api-token.list',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::api-tokens.read'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'DELETE',
        path: '/api-tokens/:id',
        handler: 'api-token.revoke',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::api-tokens.delete'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'GET',
        path: '/api-tokens/:id',
        handler: 'api-token.get',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::api-tokens.read'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'PUT',
        path: '/api-tokens/:id',
        handler: 'api-token.update',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::api-tokens.update'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'POST',
        path: '/api-tokens/:id/regenerate',
        handler: 'api-token.regenerate',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::api-tokens.regenerate'
                        ]
                    }
                }
            ]
        }
    }
];

var contentApi$1 = [
    {
        method: 'GET',
        path: '/content-api/permissions',
        handler: 'content-api.getPermissions',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin'
            ]
        }
    },
    {
        method: 'GET',
        path: '/content-api/routes',
        handler: 'content-api.getRoutes',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin'
            ]
        }
    }
];

const { UnauthorizedError: UnauthorizedError$2, ForbiddenError: ForbiddenError$1 } = errors;
const extractToken = (ctx)=>{
    if (ctx.request && ctx.request.header && ctx.request.header.authorization) {
        const parts = ctx.request.header.authorization.split(/\s+/);
        if (parts[0].toLowerCase() !== 'bearer' || parts.length !== 2) {
            return null;
        }
        return parts[1];
    }
    return null;
};
/**
 * Authenticate the validity of the token
 *
 *  @type {import('.').AuthenticateFunction}
 */ const authenticate$1 = async (ctx)=>{
    const { token: tokenService } = getService$1('transfer');
    const token = extractToken(ctx);
    if (!token) {
        return {
            authenticated: false
        };
    }
    const transferToken = await tokenService.getBy({
        accessKey: tokenService.hash(token)
    });
    // Check if the token exists
    if (!transferToken) {
        return {
            authenticated: false
        };
    }
    // Check if the token has expired
    const currentDate = new Date();
    if (!isNil(transferToken.expiresAt)) {
        const expirationDate = new Date(transferToken.expiresAt);
        if (expirationDate < currentDate) {
            return {
                authenticated: false,
                error: new UnauthorizedError$2('Token expired')
            };
        }
    }
    // Update token metadata if the token has not been used in the last hour
    // @ts-expect-error - FIXME: verify lastUsedAt is defined
    const hoursSinceLastUsed = differenceInHours(currentDate, parseISO(transferToken.lastUsedAt));
    if (hoursSinceLastUsed >= 1) {
        await strapi.db.query('admin::api-token').update({
            where: {
                id: transferToken.id
            },
            data: {
                lastUsedAt: currentDate
            }
        });
    }
    // Generate an ability based on the token permissions
    const ability = await getService$1('transfer').permission.engine.generateAbility(transferToken.permissions.map((action)=>({
            action
        })));
    return {
        authenticated: true,
        ability,
        credentials: transferToken
    };
};
/**
 * Verify the token has the required abilities for the requested scope
 *
 *  @type {import('.').VerifyFunction}
 */ const verify$1 = async (auth, config = {})=>{
    const { credentials: transferToken, ability } = auth;
    if (!transferToken) {
        throw new UnauthorizedError$2('Token not found');
    }
    const currentDate = new Date();
    if (!isNil(transferToken.expiresAt)) {
        const expirationDate = new Date(transferToken.expiresAt);
        // token has expired
        if (expirationDate < currentDate) {
            throw new UnauthorizedError$2('Token expired');
        }
    }
    if (!ability) {
        throw new ForbiddenError$1();
    }
    const scopes = castArray(config.scope ?? []);
    const isAllowed = scopes.every((scope)=>ability.can(scope));
    if (!isAllowed) {
        throw new ForbiddenError$1();
    }
};
const name = 'data-transfer';
/** @type {import('.').AuthStrategy} */ var dataTransferAuthStrategy = {
    name,
    authenticate: authenticate$1,
    verify: verify$1
};

var transfer$2 = [
    // Transfer Push
    {
        method: 'GET',
        path: '/transfer/runner/push',
        handler: 'transfer.runner-push',
        config: {
            middlewares: [
                'admin::data-transfer'
            ],
            auth: {
                strategies: [
                    dataTransferAuthStrategy
                ],
                scope: [
                    'push'
                ]
            }
        }
    },
    // Transfer Pull
    {
        method: 'GET',
        path: '/transfer/runner/pull',
        handler: 'transfer.runner-pull',
        config: {
            middlewares: [
                'admin::data-transfer'
            ],
            auth: {
                strategies: [
                    dataTransferAuthStrategy
                ],
                scope: [
                    'pull'
                ]
            }
        }
    },
    // Transfer Tokens
    {
        method: 'POST',
        path: '/transfer/tokens',
        handler: 'transfer.token-create',
        config: {
            middlewares: [
                'admin::data-transfer'
            ],
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::transfer.tokens.create'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'GET',
        path: '/transfer/tokens',
        handler: 'transfer.token-list',
        config: {
            middlewares: [
                'admin::data-transfer'
            ],
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::transfer.tokens.read'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'DELETE',
        path: '/transfer/tokens/:id',
        handler: 'transfer.token-revoke',
        config: {
            middlewares: [
                'admin::data-transfer'
            ],
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::transfer.tokens.delete'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'GET',
        path: '/transfer/tokens/:id',
        handler: 'transfer.token-getById',
        config: {
            middlewares: [
                'admin::data-transfer'
            ],
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::transfer.tokens.read'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'PUT',
        path: '/transfer/tokens/:id',
        handler: 'transfer.token-update',
        config: {
            middlewares: [
                'admin::data-transfer'
            ],
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::transfer.tokens.update'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'POST',
        path: '/transfer/tokens/:id/regenerate',
        handler: 'transfer.token-regenerate',
        config: {
            middlewares: [
                'admin::data-transfer'
            ],
            policies: [
                'admin::isAuthenticatedAdmin',
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'admin::transfer.tokens.regenerate'
                        ]
                    }
                }
            ]
        }
    }
];

const info = {
    pluginName: 'admin',
    type: 'admin'
};
var homepage = [
    {
        method: 'GET',
        info,
        path: '/homepage/recent-documents',
        handler: 'homepage.getRecentDocuments',
        config: {
            policies: [
                'admin::isAuthenticatedAdmin'
            ]
        }
    }
];

const routes$1 = {
    admin: {
        type: 'admin',
        routes: [
            ...admin$4,
            ...authentication$2,
            ...permissions,
            ...users,
            ...roles$1,
            ...webhooks$1,
            ...apiTokens,
            ...contentApi$1,
            ...transfer$2,
            ...homepage
        ]
    }
};

const { ApplicationError: ApplicationError$a } = errors;
/**
 * hashes a password
 * @param password - password to hash
 * @returns hashed password
 */ const hashPassword = (password)=>bcrypt.hash(password, 10);
/**
 * Validate a password
 * @param password
 * @param hash
 * @returns {Promise<boolean>} is the password valid
 */ const validatePassword = (password, hash)=>bcrypt.compare(password, hash);
/**
 * Check login credentials
 * @param email the users email address
 * @param password the users password
 */ const checkCredentials = async ({ email, password })=>{
    const user = await strapi.db.query('admin::user').findOne({
        where: {
            email
        }
    });
    if (!user || !user.password) {
        return [
            null,
            false,
            {
                message: 'Invalid credentials'
            }
        ];
    }
    const isValid = await validatePassword(password, user.password);
    if (!isValid) {
        return [
            null,
            false,
            {
                message: 'Invalid credentials'
            }
        ];
    }
    if (!(user.isActive === true)) {
        return [
            null,
            false,
            {
                message: 'User not active'
            }
        ];
    }
    return [
        null,
        user
    ];
};
/**
 * Send an email to the user if it exists or do nothing
 * @param email user email for which to reset the password
 */ const forgotPassword$1 = async ({ email } = {})=>{
    const user = await strapi.db.query('admin::user').findOne({
        where: {
            email,
            isActive: true
        }
    });
    if (!user) {
        return;
    }
    const resetPasswordToken = getService$1('token').createToken();
    await getService$1('user').updateById(user.id, {
        resetPasswordToken
    });
    // Send an email to the admin.
    const url = `${strapi.config.get('admin.absoluteUrl')}/auth/reset-password?code=${resetPasswordToken}`;
    return strapi.plugin('email').service('email').sendTemplatedEmail({
        to: user.email,
        from: strapi.config.get('admin.forgotPassword.from'),
        replyTo: strapi.config.get('admin.forgotPassword.replyTo')
    }, strapi.config.get('admin.forgotPassword.emailTemplate'), {
        url,
        user: ___default.pick(user, [
            'email',
            'firstname',
            'lastname',
            'username'
        ])
    }).catch((err)=>{
        // log error server side but do not disclose it to the user to avoid leaking informations
        strapi.log.error(err);
    });
};
/**
 * Reset a user password
 * @param resetPasswordToken token generated to request a password reset
 * @param password new user password
 */ const resetPassword$1 = async ({ resetPasswordToken, password } = {})=>{
    const matchingUser = await strapi.db.query('admin::user').findOne({
        where: {
            resetPasswordToken,
            isActive: true
        }
    });
    if (!matchingUser) {
        throw new ApplicationError$a();
    }
    return getService$1('user').updateById(matchingUser.id, {
        password,
        resetPasswordToken: null
    });
};
var auth$1 = {
    checkCredentials,
    validatePassword,
    hashPassword,
    forgotPassword: forgotPassword$1,
    resetPassword: resetPassword$1
};

const { SUPER_ADMIN_CODE: SUPER_ADMIN_CODE$5 } = constants$3;
/**
 * Create a new user model by merging default and specified attributes
 * @param attributes A partial user object
 */ function createUser(attributes) {
    return {
        roles: [],
        isActive: false,
        username: null,
        ...attributes
    };
}
const hasSuperAdminRole$1 = (user)=>{
    return user.roles.filter((role)=>role.code === SUPER_ADMIN_CODE$5).length > 0;
};
const ADMIN_USER_ALLOWED_FIELDS = [
    'id',
    'firstname',
    'lastname',
    'username'
];

/**
 * Return the default attributes of a new {@link Action}
 * @return Partial<Action>
 */ const getDefaultActionAttributes = ()=>({
        options: {
            applyToProperties: null
        }
    });
/**
 * Get the list of all the valid attributes of an {@link Action}
 */ const actionFields = [
    'section',
    'displayName',
    'category',
    'subCategory',
    'pluginName',
    'subjects',
    'options',
    'actionId',
    'aliases'
];
/**
 * Remove unwanted attributes from an {@link Action}
 */ const sanitizeActionAttributes = pick(actionFields);
/**
 * Create and return an identifier for an {@link CreateActionPayload}.
 * The format is based on the action's source ({@link CreateActionPayload.pluginName} or 'application') and {@link CreateActionPayload.uid}.
 * @param {CreateActionPayload} attributes
 * @return {string}
 */ // TODO: TS - Use Common.UID
const computeActionId = (attributes)=>{
    const { pluginName, uid } = attributes;
    if (!pluginName) {
        return `api::${uid}`;
    }
    if (pluginName === 'admin') {
        return `admin::${uid}`;
    }
    return `plugin::${pluginName}.${uid}`;
};
/**
 * Assign an actionId attribute to an {@link CreateActionPayload} object
 */ const assignActionId = (attrs)=>set('actionId', computeActionId(attrs), attrs);
/**
 * Transform an action by adding or removing the {@link Action.subCategory} attribute
 * @param {Action} action - The action to process
 * @return {Action}
 */ const assignOrOmitSubCategory = (action)=>{
    const shouldHaveSubCategory = [
        'settings',
        'plugins'
    ].includes(action.section);
    return shouldHaveSubCategory ? set('subCategory', action.subCategory || 'general', action) : omit('subCategory', action);
};
/**
 * Check if a property can be applied to an {@link Action}
 */ const appliesToProperty = curry((property, action)=>{
    return pipe(prop('options.applyToProperties'), includes(property))(action);
});
/**
 * Check if an action applies to a subject
 */ const appliesToSubject = curry((subject, action)=>{
    return isArray(action.subjects) && includes(subject, action.subjects);
});
/**
 * Transform the given attributes into a domain representation of an Action
 */ const create$6 = pipe(// Create and assign an action identifier to the action
// (need to be done before the sanitizeActionAttributes since we need the uid here)
assignActionId, // Add or remove the sub category field based on the pluginName attribute
assignOrOmitSubCategory, // Remove unwanted attributes from the payload
sanitizeActionAttributes, // Complete the action creation by adding default values for some attributes
merge(getDefaultActionAttributes()));
var actionDomain = {
    actionFields,
    appliesToProperty,
    appliesToSubject,
    assignActionId,
    assignOrOmitSubCategory,
    create: create$6,
    computeActionId,
    getDefaultActionAttributes,
    sanitizeActionAttributes
};

const checkFieldsAreCorrectlyNested = (fields)=>{
    if (___default.isNil(fields)) {
        // Only check if the fields exist
        return true;
    }
    if (!Array.isArray(fields)) {
        return false;
    }
    let failed = false;
    for(let indexA = 0; indexA < fields.length; indexA += 1){
        failed = fields.slice(indexA + 1).some((fieldB)=>fieldB.startsWith(`${fields[indexA]}.`) || fields[indexA].startsWith(`${fieldB}.`));
        if (failed) break;
    }
    return !failed;
};

const checkFieldsDontHaveDuplicates = (fields)=>{
    if (___default.isNil(fields)) {
        // Only check if the fields exist
        return true;
    }
    if (!Array.isArray(fields)) {
        return false;
    }
    return ___default.uniq(fields).length === fields.length;
};

const getActionFromProvider = (actionId)=>{
    return getService$1('permission').actionProvider.get(actionId);
};
const email = yup$1.string().email().lowercase();
const firstname = yup$1.string().trim().min(1);
const lastname = yup$1.string();
const username = yup$1.string().min(1);
const password = yup$1.string().min(8).test('required-byte-size', '${path} must be less than 73 bytes', function(value) {
    if (!value) return true;
    const byteSize = new TextEncoder().encode(value).length;
    return byteSize <= 72;
}).matches(/[a-z]/, '${path} must contain at least one lowercase character').matches(/[A-Z]/, '${path} must contain at least one uppercase character').matches(/\d/, '${path} must contain at least one number');
const roles = yup$1.array(yup$1.strapiID()).min(1);
const isAPluginName = yup$1.string().test('is-a-plugin-name', 'is not a plugin name', function(value) {
    return [
        undefined,
        'admin',
        ...Object.keys(strapi.plugins)
    ].includes(value) ? true : this.createError({
        path: this.path,
        message: `${this.path} is not an existing plugin`
    });
});
const arrayOfConditionNames = yup$1.array().of(yup$1.string()).test('is-an-array-of-conditions', 'is not a plugin name', function(value) {
    const ids = strapi.service('admin::permission').conditionProvider.keys();
    return ___default.isUndefined(value) || ___default.difference(value, ids).length === 0 ? true : this.createError({
        path: this.path,
        message: `contains conditions that don't exist`
    });
});
const permissionsAreEquals = (a, b)=>a.action === b.action && (a.subject === b.subject || ___default.isNil(a.subject) && ___default.isNil(b.subject));
const checkNoDuplicatedPermissions = (permissions)=>!Array.isArray(permissions) || permissions.every((permA, i)=>permissions.slice(i + 1).every((permB)=>!permissionsAreEquals(permA, permB)));
const checkNilFields = (action)=>function(fields) {
        // If the parent has no action field, then we ignore this test
        if (isNil(action)) {
            return true;
        }
        return actionDomain.appliesToProperty('fields', action) || isNil(fields);
    };
const fieldsPropertyValidation = (action)=>yup$1.array().of(yup$1.string()).nullable().test('field-nested', 'Fields format are incorrect (bad nesting).', checkFieldsAreCorrectlyNested).test('field-nested', 'Fields format are incorrect (duplicates).', checkFieldsDontHaveDuplicates).test('fields-restriction', 'The permission at ${path} must have fields set to null or undefined', // @ts-expect-error yup types
    checkNilFields(action));
const permission$3 = yup$1.object().shape({
    action: yup$1.string().required().test('action-validity', 'action is not an existing permission action', function(actionId) {
        // If the action field is Nil, ignore the test and let the required check handle the error
        if (isNil(actionId)) {
            return true;
        }
        return !!getActionFromProvider(actionId);
    }),
    actionParameters: yup$1.object().nullable(),
    subject: yup$1.string().nullable().test('subject-validity', 'Invalid subject submitted', function(subject) {
        // @ts-expect-error yup types
        const action = getActionFromProvider(this.options.parent.action);
        if (!action) {
            return true;
        }
        if (isNil(action.subjects)) {
            return isNil(subject);
        }
        if (isArray(action.subjects) && !isNil(subject)) {
            return action.subjects.includes(subject);
        }
        return false;
    }),
    properties: yup$1.object().test('properties-structure', 'Invalid property set at ${path}', function(properties) {
        // @ts-expect-error yup types
        const action = getActionFromProvider(this.options.parent.action);
        const hasNoProperties = isEmpty(properties) || isNil(properties);
        if (!has('options.applyToProperties', action)) {
            return hasNoProperties;
        }
        if (hasNoProperties) {
            return true;
        }
        const { applyToProperties } = action.options;
        if (!isArray(applyToProperties)) {
            return false;
        }
        return Object.keys(properties).every((property)=>applyToProperties.includes(property));
    }).test('fields-property', 'Invalid fields property at ${path}', async function(properties = {}) {
        // @ts-expect-error yup types
        const action = getActionFromProvider(this.options.parent.action);
        if (!action || !properties) {
            return true;
        }
        if (!actionDomain.appliesToProperty('fields', action)) {
            return true;
        }
        try {
            await fieldsPropertyValidation(action).validate(properties.fields, {
                strict: true,
                abortEarly: false
            });
            return true;
        } catch (e) {
            // Propagate fieldsPropertyValidation error with updated path
            throw this.createError({
                message: e.message,
                path: `${this.path}.fields`
            });
        }
    }),
    conditions: yup$1.array().of(yup$1.string())
}).noUnknown();
const updatePermissions = yup$1.object().shape({
    permissions: yup$1.array().required().of(permission$3).test('duplicated-permissions', 'Some permissions are duplicated (same action and subject)', checkNoDuplicatedPermissions)
}).required().noUnknown();
var validators = {
    email,
    firstname,
    lastname,
    username,
    password,
    roles,
    isAPluginName,
    arrayOfConditionNames,
    permission: permission$3,
    updatePermissions
};

const { SUPER_ADMIN_CODE: SUPER_ADMIN_CODE$4 } = constants$3;
const { ValidationError: ValidationError$6 } = errors;
const sanitizeUserRoles$1 = (role)=>___default.pick(role, [
        'id',
        'name',
        'description',
        'code'
    ]);
/**
 * Remove private user fields
 * @param  user - user to sanitize
 */ const sanitizeUser$1 = (user)=>{
    return {
        ...___default.omit(user, [
            'password',
            'resetPasswordToken',
            'registrationToken',
            'roles'
        ]),
        roles: user.roles && user.roles.map(sanitizeUserRoles$1)
    };
};
/**
 * Create and save a user in database
 * @param attributes A partial user object
 */ const create$5 = async (// isActive is added in the controller, it's not sent by the API.
attributes)=>{
    const userInfo = {
        registrationToken: getService$1('token').createToken(),
        ...attributes
    };
    if (___default.has(attributes, 'password')) {
        userInfo.password = await getService$1('auth').hashPassword(attributes.password);
    }
    const user = createUser(userInfo);
    const createdUser = await strapi.db.query('admin::user').create({
        data: user,
        populate: [
            'roles'
        ]
    });
    getService$1('metrics').sendDidInviteUser();
    strapi.eventHub.emit('user.create', {
        user: sanitizeUser$1(createdUser)
    });
    return createdUser;
};
/**
 * Update a user in database
 * @param id query params to find the user to update
 * @param attributes A partial user object
 */ const updateById$1 = async (id, attributes)=>{
    // Check at least one super admin remains
    if (___default.has(attributes, 'roles')) {
        const lastAdminUser = await isLastSuperAdminUser$1(id);
        const superAdminRole = await getService$1('role').getSuperAdminWithUsersCount();
        const willRemoveSuperAdminRole = !arrays.includesString(attributes.roles, superAdminRole.id);
        if (lastAdminUser && willRemoveSuperAdminRole) {
            throw new ValidationError$6('You must have at least one user with super admin role.');
        }
    }
    // cannot disable last super admin
    if (attributes.isActive === false) {
        const lastAdminUser = await isLastSuperAdminUser$1(id);
        if (lastAdminUser) {
            throw new ValidationError$6('You must have at least one user with super admin role.');
        }
    }
    // hash password if a new one is sent
    if (___default.has(attributes, 'password')) {
        const hashedPassword = await getService$1('auth').hashPassword(attributes.password);
        const updatedUser = await strapi.db.query('admin::user').update({
            where: {
                id
            },
            data: {
                ...attributes,
                password: hashedPassword
            },
            populate: [
                'roles'
            ]
        });
        strapi.eventHub.emit('user.update', {
            user: sanitizeUser$1(updatedUser)
        });
        return updatedUser;
    }
    const updatedUser = await strapi.db.query('admin::user').update({
        where: {
            id
        },
        data: attributes,
        populate: [
            'roles'
        ]
    });
    if (updatedUser) {
        strapi.eventHub.emit('user.update', {
            user: sanitizeUser$1(updatedUser)
        });
    }
    return updatedUser;
};
/**
 * Reset a user password by email. (Used in admin:reset CLI)
 * @param email - user email
 * @param password - new password
 */ const resetPasswordByEmail = async (email, password$1)=>{
    const user = await strapi.db.query('admin::user').findOne({
        where: {
            email
        },
        populate: [
            'roles'
        ]
    });
    if (!user) {
        throw new Error(`User not found for email: ${email}`);
    }
    try {
        await password.validate(password$1);
    } catch (error) {
        throw new ValidationError$6('Invalid password. Expected a minimum of 8 characters with at least one number and one uppercase letter');
    }
    await updateById$1(user.id, {
        password: password$1
    });
};
/**
 * Check if a user is the last super admin
 * @param userId user's id to look for
 */ const isLastSuperAdminUser$1 = async (userId)=>{
    const user = await findOne$2(userId);
    if (!user) return false;
    const superAdminRole = await getService$1('role').getSuperAdminWithUsersCount();
    return superAdminRole.usersCount === 1 && hasSuperAdminRole$1(user);
};
/**
 * Check if a user with specific attributes exists in the database
 * @param attributes A partial user object
 */ const exists$3 = async (attributes = {})=>{
    return await strapi.db.query('admin::user').count({
        where: attributes
    }) > 0;
};
/**
 * Returns a user registration info
 * @param registrationToken - a user registration token
 * @returns - Returns user email, firstname and lastname
 */ const findRegistrationInfo = async (registrationToken)=>{
    const user = await strapi.db.query('admin::user').findOne({
        where: {
            registrationToken
        }
    });
    if (!user) {
        return undefined;
    }
    return ___default.pick(user, [
        'email',
        'firstname',
        'lastname'
    ]);
};
/**
 * Registers a user based on a registrationToken and some informations to update
 * @param params
 * @param params.registrationToken registration token
 * @param params.userInfo user info
 */ const register$1 = async ({ registrationToken, userInfo })=>{
    const matchingUser = await strapi.db.query('admin::user').findOne({
        where: {
            registrationToken
        }
    });
    if (!matchingUser) {
        throw new ValidationError$6('Invalid registration info');
    }
    return getService$1('user').updateById(matchingUser.id, {
        password: userInfo.password,
        firstname: userInfo.firstname,
        lastname: userInfo.lastname,
        registrationToken: null,
        isActive: true
    });
};
/**
 * Find one user
 */ const findOne$2 = async (id, populate = [
    'roles'
])=>{
    return strapi.db.query('admin::user').findOne({
        where: {
            id
        },
        populate
    });
};
/**
 * Find one user by its email
 * @param email
 * @param populate
 * @returns
 */ const findOneByEmail = async (email, populate = [])=>{
    return strapi.db.query('admin::user').findOne({
        where: {
            email: {
                $eqi: email
            }
        },
        populate
    });
};
/** Find many users (paginated)
 * @param params
 */ const findPage = async (params = {})=>{
    const query = strapi.get('query-params').transform('admin::user', defaults({
        populate: [
            'roles'
        ]
    }, params));
    return strapi.db.query('admin::user').findPage(query);
};
/** Delete a user
 * @param id id of the user to delete
 */ const deleteById$1 = async (id)=>{
    // Check at least one super admin remains
    const userToDelete = await strapi.db.query('admin::user').findOne({
        where: {
            id
        },
        populate: [
            'roles'
        ]
    });
    if (!userToDelete) {
        return null;
    }
    if (userToDelete) {
        if (userToDelete.roles.some((r)=>r.code === SUPER_ADMIN_CODE$4)) {
            const superAdminRole = await getService$1('role').getSuperAdminWithUsersCount();
            if (superAdminRole.usersCount === 1) {
                throw new ValidationError$6('You must have at least one user with super admin role.');
            }
        }
    }
    const deletedUser = await strapi.db.query('admin::user').delete({
        where: {
            id
        },
        populate: [
            'roles'
        ]
    });
    strapi.eventHub.emit('user.delete', {
        user: sanitizeUser$1(deletedUser)
    });
    return deletedUser;
};
/** Delete a user
 * @param ids ids of the users to delete
 */ const deleteByIds$3 = async (ids)=>{
    // Check at least one super admin remains
    const superAdminRole = await getService$1('role').getSuperAdminWithUsersCount();
    const nbOfSuperAdminToDelete = await strapi.db.query('admin::user').count({
        where: {
            id: ids,
            roles: {
                id: superAdminRole.id
            }
        }
    });
    if (superAdminRole.usersCount === nbOfSuperAdminToDelete) {
        throw new ValidationError$6('You must have at least one user with super admin role.');
    }
    const deletedUsers = [];
    for (const id of ids){
        const deletedUser = await strapi.db.query('admin::user').delete({
            where: {
                id
            },
            populate: [
                'roles'
            ]
        });
        deletedUsers.push(deletedUser);
    }
    strapi.eventHub.emit('user.delete', {
        users: deletedUsers.map((deletedUser)=>sanitizeUser$1(deletedUser))
    });
    return deletedUsers;
};
/** Count the users that don't have any associated roles
 */ const countUsersWithoutRole = async ()=>{
    return strapi.db.query('admin::user').count({
        where: {
            roles: {
                id: {
                    $null: true
                }
            }
        }
    });
};
/**
 * Count the number of users based on search params
 * @param params params used for the query
 */ const count$2 = async (where = {})=>{
    return strapi.db.query('admin::user').count({
        where
    });
};
/**
 * Assign some roles to several users
 */ const assignARoleToAll = async (roleId)=>{
    const users = await strapi.db.query('admin::user').findMany({
        select: [
            'id'
        ],
        where: {
            roles: {
                id: {
                    $null: true
                }
            }
        }
    });
    await Promise.all(users.map((user)=>{
        return strapi.db.query('admin::user').update({
            where: {
                id: user.id
            },
            data: {
                roles: [
                    roleId
                ]
            }
        });
    }));
};
/** Display a warning if some users don't have at least one role
 */ const displayWarningIfUsersDontHaveRole = async ()=>{
    const count = await countUsersWithoutRole();
    if (count > 0) {
        strapi.log.warn(`Some users (${count}) don't have any role.`);
    }
};
/** Returns an array of interface languages currently used by users
 */ const getLanguagesInUse = async ()=>{
    const users = await strapi.db.query('admin::user').findMany({
        select: [
            'preferedLanguage'
        ]
    });
    return users.map((user)=>user.preferedLanguage || 'en');
};
var user$3 = {
    create: create$5,
    updateById: updateById$1,
    exists: exists$3,
    findRegistrationInfo,
    register: register$1,
    sanitizeUser: sanitizeUser$1,
    findOne: findOne$2,
    findOneByEmail,
    findPage,
    deleteById: deleteById$1,
    deleteByIds: deleteByIds$3,
    countUsersWithoutRole,
    count: count$2,
    assignARoleToAll,
    displayWarningIfUsersDontHaveRole,
    resetPasswordByEmail,
    getLanguagesInUse
};

const permissionFields = [
    'id',
    'action',
    'actionParameters',
    'subject',
    'properties',
    'conditions',
    'role'
];
const sanitizedPermissionFields = [
    'id',
    'action',
    'actionParameters',
    'subject',
    'properties',
    'conditions'
];
const sanitizePermissionFields = pick(sanitizedPermissionFields);
/**
 * Creates a permission with default values
 */ const getDefaultPermission = ()=>({
        actionParameters: {},
        conditions: [],
        properties: {},
        subject: null
    });
/**
 * Returns a new permission with the given condition
 * @param condition - The condition to add
 * @param permission - The permission on which we want to add the condition
 * @return
 */ const addCondition = curry((condition, permission)=>{
    const { conditions } = permission;
    const newConditions = Array.isArray(conditions) ? uniq(conditions.concat(condition)) : [
        condition
    ];
    return set('conditions', newConditions, permission);
});
/**
 * Returns a new permission without the given condition
 * @param condition - The condition to remove
 * @param permission - The permission on which we want to remove the condition
 */ const removeCondition = curry((condition, permission)=>{
    return set('conditions', remove(eq(condition), permission.conditions), permission);
});
/**
 * Gets a property or a part of a property from a permission.
 * @param property - The property to get
 * @param permission - The permission on which we want to access the property
 */ const getProperty = curry((property, permission)=>get(`properties.${property}`, permission));
/**
 * Set a value for a given property on a new permission object
 * @param property - The name of the property
 * @param value - The value of the property
 * @param permission - The permission on which we want to set the property
 */ const setProperty = (property, value, permission)=>{
    return set(`properties.${property}`, value, permission);
};
/**
 * Returns a new permission without the given property name set
 * @param property - The name of the property to delete
 * @param permission - The permission on which we want to remove the property
 */ const deleteProperty = (property, permission)=>omit(`properties.${property}`, permission);
/**
 * Creates a new {@link Permission} object from raw attributes. Set default values for certain fields
 * @param  attributes
 */ const create$4 = (attributes)=>{
    return pipe(pick(permissionFields), merge(getDefaultPermission()))(attributes);
};
/**
 * Using the given condition provider, check and remove invalid condition from the permission's condition array.
 * @param provider - The condition provider used to do the checks
 * @param permission - The condition to sanitize
 */ const sanitizeConditions = curry((provider, permission)=>{
    if (!isArray(permission.conditions)) {
        return permission;
    }
    return permission.conditions.filter((condition)=>!provider.has(condition)).reduce((perm, condition)=>removeCondition(condition, perm), permission);
});
function toPermission(payload) {
    if (isArray(payload)) {
        return map((value)=>create$4(value), payload);
    }
    return create$4(payload);
}
var permissionDomain = {
    addCondition,
    removeCondition,
    create: create$4,
    deleteProperty,
    permissionFields,
    getProperty,
    sanitizedPermissionFields,
    sanitizeConditions,
    sanitizePermissionFields,
    setProperty,
    toPermission
};

const checkPermissionsSchema = yup$1.object().shape({
    permissions: yup$1.array().of(yup$1.object().shape({
        action: yup$1.string().required(),
        subject: yup$1.string().nullable(),
        field: yup$1.string()
    }).noUnknown())
});
const checkPermissionsExist = function(permissions) {
    const existingActions = getService$1('permission').actionProvider.values();
    const failIndex = permissions.findIndex((permission)=>!existingActions.some((action)=>action.actionId === permission.action && (action.section !== 'contentTypes' || action.subjects.includes(permission.subject))));
    return failIndex === -1 ? true : this.createError({
        path: 'permissions',
        message: `[${failIndex}] is not an existing permission action`
    });
};
const actionsExistSchema = yup$1.array().of(yup$1.object().shape({
    conditions: yup$1.array().of(yup$1.string())
})).test('actions-exist', '', checkPermissionsExist);
const validatePermissionsExist = validateYupSchema(actionsExistSchema);
const validateCheckPermissionsInput = validateYupSchema(checkPermissionsSchema);
const validatedUpdatePermissionsInput = validateYupSchema(validators.updatePermissions);

/* eslint-disable @typescript-eslint/no-explicit-any */ // TODO: TS - Use database parameters interface when they are ready
const { SUPER_ADMIN_CODE: SUPER_ADMIN_CODE$3, CONTENT_TYPE_SECTION } = constants$3;
const { createAsyncSeriesWaterfallHook } = hooks$1;
const { ApplicationError: ApplicationError$9 } = errors;
const hooks = {
    willResetSuperAdminPermissions: createAsyncSeriesWaterfallHook()
};
const ACTIONS = {
    publish: 'plugin::content-manager.explorer.publish'
};
// @ts-expect-error lodash types
const sanitizeRole = omit([
    'users',
    'permissions'
]);
const COMPARABLE_FIELDS = [
    'conditions',
    'properties',
    'subject',
    'action',
    'actionParameters'
];
const pickComparableFields = pick(COMPARABLE_FIELDS);
const jsonClean = (data)=>JSON.parse(JSON.stringify(data));
/**
 * Compare two permissions
 */ const arePermissionsEqual = (p1, p2)=>{
    if (p1.action === p2.action) {
        return isEqual(jsonClean(pickComparableFields(p1)), jsonClean(pickComparableFields(p2)));
    }
    return false;
};
/**
 * Create and save a role in database
 * @param attributes A partial role object
 */ const create$3 = async (attributes)=>{
    const alreadyExists = await exists$2({
        name: attributes.name
    });
    if (alreadyExists) {
        throw new ApplicationError$9(`The name must be unique and a role with name \`${attributes.name}\` already exists.`);
    }
    const autoGeneratedCode = `${___default.kebabCase(attributes.name)}-${dates.timestampCode()}`;
    const rolesWithCode = {
        ...attributes,
        code: attributes.code || autoGeneratedCode
    };
    const result = await strapi.db.query('admin::role').create({
        data: rolesWithCode
    });
    strapi.eventHub.emit('role.create', {
        role: sanitizeRole(result)
    });
    return result;
};
/**
 * Find a role in database
 * @param params query params to find the role
 * @param populate
 */ const findOne$1 = (params = {}, populate)=>{
    return strapi.db.query('admin::role').findOne({
        where: params,
        populate
    });
};
/**
 * Find a role in database with usersCounts
 * @param params query params to find the role
 * @param populate
 */ const findOneWithUsersCount = async (params = {}, populate)=>{
    const role = await strapi.db.query('admin::role').findOne({
        where: params,
        populate
    });
    if (role) {
        role.usersCount = await getUsersCount(role.id);
    }
    return role;
};
/**
 * Find roles in database
 * @param params query params to find the roles
 * @param populate
 */ const find = (params = {}, populate)=>{
    return strapi.db.query('admin::role').findMany({
        where: params,
        populate
    });
};
/**
 * Find all roles in database
 */ const findAllWithUsersCount = async (params)=>{
    const roles = await strapi.db.query('admin::role').findMany(strapi.get('query-params').transform('admin::role', params));
    for (const role of roles){
        role.usersCount = await getUsersCount(role.id);
    }
    return roles;
};
/**
 * Update a role in database
 * @param params query params to find the role to update
 * @param attributes A partial role object
 */ const update$3 = async (params, attributes)=>{
    const sanitizedAttributes = ___default.omit(attributes, [
        'code'
    ]);
    if (___default.has(params, 'id') && ___default.has(sanitizedAttributes, 'name')) {
        const alreadyExists = await exists$2({
            name: sanitizedAttributes.name,
            id: {
                $ne: params.id
            }
        });
        if (alreadyExists) {
            throw new ApplicationError$9(`The name must be unique and a role with name \`${sanitizedAttributes.name}\` already exists.`);
        }
    }
    const result = await strapi.db.query('admin::role').update({
        where: params,
        data: sanitizedAttributes
    });
    strapi.eventHub.emit('role.update', {
        role: sanitizeRole(result)
    });
    return result;
};
/**
 * Check if a role exists in database
 * @param params query params to find the role
 */ const exists$2 = async (params = {})=>{
    const count = await strapi.db.query('admin::role').count({
        where: params
    });
    return count > 0;
};
/**
 * Count the number of roles based on search params
 * @param params params used for the query
 */ const count$1 = async (params = {})=>{
    return strapi.db.query('admin::role').count(params);
};
/**
 * Check if the given roles id can be deleted safely, throw otherwise
 * @param ids
 */ const checkRolesIdForDeletion = async (ids = [])=>{
    const superAdminRole = await getSuperAdmin();
    if (superAdminRole && arrays.includesString(ids, superAdminRole.id)) {
        throw new ApplicationError$9('You cannot delete the super admin role');
    }
    for (const roleId of ids){
        const usersCount = await getUsersCount(roleId);
        if (usersCount !== 0) {
            throw new ApplicationError$9('Some roles are still assigned to some users');
        }
    }
};
/**
 * Delete roles in database if they have no user assigned
 * @param ids query params to find the roles
 */ const deleteByIds$2 = async (ids = [])=>{
    await checkRolesIdForDeletion(ids);
    await getService$1('permission').deleteByRolesIds(ids);
    const deletedRoles = [];
    for (const id of ids){
        const deletedRole = await strapi.db.query('admin::role').delete({
            where: {
                id
            }
        });
        if (deletedRole) {
            strapi.eventHub.emit('role.delete', {
                role: deletedRole
            });
            deletedRoles.push(deletedRole);
        }
    }
    return deletedRoles;
};
/** Count the number of users for some roles
 */ const getUsersCount = async (roleId)=>{
    return strapi.db.query('admin::user').count({
        where: {
            roles: {
                id: roleId
            }
        }
    });
};
/** Returns admin role
 */ const getSuperAdmin = ()=>findOne$1({
        code: SUPER_ADMIN_CODE$3
    });
/** Returns admin role with userCount
 * @returns {Promise<role>}
 */ const getSuperAdminWithUsersCount = ()=>findOneWithUsersCount({
        code: SUPER_ADMIN_CODE$3
    });
/** Create superAdmin, Author and Editor role is no role already exist
 */ const createRolesIfNoneExist = async ()=>{
    const someRolesExist = await exists$2();
    if (someRolesExist) {
        return;
    }
    const { actionProvider } = getService$1('permission');
    const allActions = actionProvider.values();
    const contentTypesActions = allActions.filter((a)=>a.section === 'contentTypes');
    // create 3 roles
    const superAdminRole = await create$3({
        name: 'Super Admin',
        code: 'strapi-super-admin',
        description: 'Super Admins can access and manage all features and settings.'
    });
    await getService$1('user').assignARoleToAll(superAdminRole.id);
    const editorRole = await create$3({
        name: 'Editor',
        code: 'strapi-editor',
        description: 'Editors can manage and publish contents including those of other users.'
    });
    const authorRole = await create$3({
        name: 'Author',
        code: 'strapi-author',
        description: 'Authors can manage the content they have created.'
    });
    // create content-type permissions for each role
    const editorPermissions = getService$1('content-type').getPermissionsWithNestedFields(contentTypesActions, {
        restrictedSubjects: [
            'plugin::users-permissions.user'
        ]
    });
    const authorPermissions = editorPermissions.filter(({ action })=>action !== ACTIONS.publish).map((permission)=>permissionDomain.create({
            ...permission,
            conditions: [
                'admin::is-creator'
            ]
        }));
    editorPermissions.push(...getDefaultPluginPermissions());
    authorPermissions.push(...getDefaultPluginPermissions({
        isAuthor: true
    }));
    // assign permissions to roles
    await addPermissions(editorRole.id, editorPermissions);
    await addPermissions(authorRole.id, authorPermissions);
};
const getDefaultPluginPermissions = ({ isAuthor = false } = {})=>{
    const conditions = isAuthor ? [
        'admin::is-creator'
    ] : [];
    // add plugin permissions for each role
    return [
        {
            action: 'plugin::upload.read',
            conditions
        },
        {
            action: 'plugin::upload.configure-view'
        },
        {
            action: 'plugin::upload.assets.create'
        },
        {
            action: 'plugin::upload.assets.update',
            conditions
        },
        {
            action: 'plugin::upload.assets.download'
        },
        {
            action: 'plugin::upload.assets.copy-link'
        }
    ].map(permissionDomain.create);
};
/** Display a warning if the role superAdmin doesn't exist
 *  or if the role is not assigned to at least one user
 */ const displayWarningIfNoSuperAdmin = async ()=>{
    const superAdminRole = await getSuperAdminWithUsersCount();
    const someUsersExists = await getService$1('user').exists();
    if (!superAdminRole) {
        strapi.log.warn("Your application doesn't have a super admin role.");
    } else if (someUsersExists && superAdminRole.usersCount === 0) {
        strapi.log.warn("Your application doesn't have a super admin user.");
    }
};
/**
 * Assign permissions to a role
 * @param roleId - role Data.ID
 * @param {Array<Permission{action,subject,fields,conditions}>} permissions - permissions to assign to the role
 */ const assignPermissions = async (roleId, permissions = [])=>{
    await validatePermissionsExist(permissions);
    // Internal actions are not handled by the role service, so any permission
    // with an internal action is filtered out
    const internalActions = getService$1('permission').actionProvider.values().filter((action)=>action.section === 'internal').map((action)=>action.actionId);
    const superAdmin = await getService$1('role').getSuperAdmin();
    const isSuperAdmin = superAdmin && superAdmin.id === roleId;
    const assignRole = set('role', roleId);
    const permissionsWithRole = permissions// Add the role attribute to every permission
    .map(assignRole)// Transform each permission into a Permission instance
    // @ts-expect-error - lodash set doesn't resolve the type appropriately
    .map(permissionDomain.create);
    const existingPermissions = await getService$1('permission').findMany({
        where: {
            role: {
                id: roleId
            }
        },
        populate: [
            'role'
        ]
    });
    const permissionsToAdd = differenceWith(arePermissionsEqual, permissionsWithRole, existingPermissions).filter((permission)=>!internalActions.includes(permission.action));
    const permissionsToDelete = differenceWith(arePermissionsEqual, existingPermissions, permissionsWithRole).filter((permission)=>!internalActions.includes(permission.action));
    const permissionsToReturn = differenceBy('id', permissionsToDelete, existingPermissions);
    if (permissionsToDelete.length > 0) {
        // @ts-expect-error - lodash prop doesn't resolve the type appropriately
        await getService$1('permission').deleteByIds(permissionsToDelete.map(prop('id')));
    }
    if (permissionsToAdd.length > 0) {
        const newPermissions = await addPermissions(roleId, permissionsToAdd);
        permissionsToReturn.push(...newPermissions);
    }
    if (!isSuperAdmin && (permissionsToAdd.length || permissionsToDelete.length)) {
        await getService$1('metrics').sendDidUpdateRolePermissions();
    }
    return permissionsToReturn;
};
const addPermissions = async (roleId, permissions)=>{
    const { conditionProvider, createMany } = getService$1('permission');
    const { sanitizeConditions } = permissionDomain;
    const permissionsWithRole = permissions.map(set('role', roleId))// @ts-expect-error - refactor domain/permission Condition type, as it's now expecting
    // a string but it should be a Condition interface
    .map(sanitizeConditions(conditionProvider)).map(permissionDomain.create);
    return createMany(permissionsWithRole);
};
const isContentTypeAction = (action)=>action.section === CONTENT_TYPE_SECTION;
/**
 * Reset super admin permissions (giving it all permissions)
 */ const resetSuperAdminPermissions = async ()=>{
    const superAdminRole = await getService$1('role').getSuperAdmin();
    if (!superAdminRole) {
        return;
    }
    const permissionService = getService$1('permission');
    const contentTypeService = getService$1('content-type');
    const allActions = permissionService.actionProvider.values();
    const contentTypesActions = allActions.filter((action)=>isContentTypeAction(action));
    const otherActions = allActions.filter((action)=>!isContentTypeAction(action));
    // First, get the content-types permissions
    const permissions = contentTypeService.getPermissionsWithNestedFields(contentTypesActions);
    // Then add every other permission
    const otherPermissions = otherActions.reduce((acc, action)=>{
        const { actionId, subjects } = action;
        if (isArray(subjects)) {
            acc.push(...subjects.map((subject)=>permissionDomain.create({
                    action: actionId,
                    subject
                })));
        } else {
            acc.push(permissionDomain.create({
                action: actionId
            }));
        }
        return acc;
    }, []);
    permissions.push(...otherPermissions);
    const transformedPermissions = await hooks.willResetSuperAdminPermissions.call(permissions);
    await assignPermissions(superAdminRole.id, transformedPermissions);
};
/**
 * Check if a user object includes the super admin role
 */ const hasSuperAdminRole = (user)=>{
    const roles = ___default.get(user, 'roles', []);
    return roles.map(prop('code')).includes(SUPER_ADMIN_CODE$3);
};
const constants$2 = {
    superAdminCode: SUPER_ADMIN_CODE$3
};
var role$3 = {
    hooks,
    sanitizeRole,
    create: create$3,
    findOne: findOne$1,
    findOneWithUsersCount,
    find,
    findAllWithUsersCount,
    update: update$3,
    exists: exists$2,
    count: count$1,
    deleteByIds: deleteByIds$2,
    getUsersCount,
    getSuperAdmin,
    getSuperAdminWithUsersCount,
    createRolesIfNoneExist,
    displayWarningIfNoSuperAdmin,
    addPermissions,
    hasSuperAdminRole,
    assignPermissions,
    resetSuperAdminPermissions,
    checkRolesIdForDeletion,
    constants: constants$2
};

const createLocalStrategy = (strapi, middleware)=>{
    return new Strategy({
        usernameField: 'email',
        passwordField: 'password',
        session: false
    }, (email, password, done)=>{
        return getService$1('auth').checkCredentials({
            email: toLower(email),
            password
        }).then(async ([error, user, message])=>{
            if (middleware) {
                return middleware([
                    error,
                    user,
                    message
                ], done);
            }
            return done(error, user, message);
        }).catch((error)=>done(error));
    });
};

const authEventsMapper = {
    onConnectionSuccess: 'admin.auth.success',
    onConnectionError: 'admin.auth.error'
};
const valueIsFunctionType = ([, value])=>isFunction(value);
const keyIsValidEventName = ([key])=>{
    return Object.keys(strapi.service('admin::passport').authEventsMapper).includes(key);
};
const getPassportStrategies$1 = ()=>[
        createLocalStrategy(strapi)
    ];
const registerAuthEvents = ()=>{
    // @ts-expect-error - TODO: migrate auth service to TS
    const { events = {} } = strapi.config.get('admin.auth', {});
    const { authEventsMapper } = strapi.service('admin::passport');
    const eventList = Object.entries(events).filter(keyIsValidEventName).filter(valueIsFunctionType);
    for (const [eventName, handler] of eventList){
        // TODO - TS: ensure the handler is an EventHub.Listener
        strapi.eventHub.on(authEventsMapper[eventName], handler);
    }
};
const init = ()=>{
    strapi.service('admin::passport').getPassportStrategies().forEach((strategy)=>passport$2.use(strategy));
    registerAuthEvents();
    return passport$2.initialize();
};
var passport$1 = {
    init,
    getPassportStrategies: getPassportStrategies$1,
    authEventsMapper
};

const sendDidInviteUser = async ()=>{
    const numberOfUsers = await getService$1('user').count();
    const numberOfRoles = await getService$1('role').count();
    strapi.telemetry.send('didInviteUser', {
        groupProperties: {
            numberOfRoles,
            numberOfUsers
        }
    });
};
const sendDidUpdateRolePermissions = async ()=>{
    strapi.telemetry.send('didUpdateRolePermissions');
};
const sendDidChangeInterfaceLanguage = async ()=>{
    const languagesInUse = await getService$1('user').getLanguagesInUse();
    // This event is anonymous
    strapi.telemetry.send('didChangeInterfaceLanguage', {
        userProperties: {
            languagesInUse
        }
    });
};
const sendUpdateProjectInformation$1 = async (strapi1)=>{
    const numberOfActiveAdminUsers = await getService$1('user').count({
        isActive: true
    });
    const numberOfAdminUsers = await getService$1('user').count();
    strapi1.telemetry.send('didUpdateProjectInformation', {
        groupProperties: {
            numberOfActiveAdminUsers,
            numberOfAdminUsers
        }
    });
};
const startCron$1 = (strapi1)=>{
    strapi1.cron.add({
        sendProjectInformation: {
            task: ()=>sendUpdateProjectInformation$1(strapi1),
            options: '0 0 0 * * *'
        }
    });
};
var metrics$1 = {
    sendDidInviteUser,
    sendDidUpdateRolePermissions,
    sendDidChangeInterfaceLanguage,
    sendUpdateProjectInformation: sendUpdateProjectInformation$1,
    startCron: startCron$1
};

const defaultJwtOptions = {
    expiresIn: '30d'
};
const getTokenOptions = ()=>{
    const { options, secret } = strapi.config.get('admin.auth', {});
    return {
        secret,
        options: ___default.merge(defaultJwtOptions, options)
    };
};
/**
 * Create a random token
 */ const createToken = ()=>{
    return crypto.randomBytes(20).toString('hex');
};
/**
 * Creates a JWT token for an administration user
 * @param user - admin user
 */ const createJwtToken = (user)=>{
    const { options, secret } = getTokenOptions();
    return jwt.sign({
        id: user.id
    }, secret, options);
};
/**
 * Tries to decode a token an return its payload and if it is valid
 * @param token - a token to decode
 * @return decodeInfo - the decoded info
 */ const decodeJwtToken = (token)=>{
    const { secret } = getTokenOptions();
    try {
        const payload = jwt.verify(token, secret);
        return {
            payload,
            isValid: true
        };
    } catch (err) {
        return {
            payload: null,
            isValid: false
        };
    }
};
const checkSecretIsDefined = ()=>{
    if (strapi.config.get('admin.serveAdminPanel') && !strapi.config.get('admin.auth.secret')) {
        throw new Error(`Missing auth.secret. Please set auth.secret in config/admin.js (ex: you can generate one using Node with \`crypto.randomBytes(16).toString('base64')\`).
For security reasons, prefer storing the secret in an environment variable and read it in config/admin.js. See https://docs.strapi.io/developer-docs/latest/setup-deployment-guides/configurations/optional/environment.html#configuration-using-environment-variables.`);
    }
};

var token$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  checkSecretIsDefined: checkSecretIsDefined,
  createJwtToken: createJwtToken,
  createToken: createToken,
  decodeJwtToken: decodeJwtToken,
  getTokenOptions: getTokenOptions
});

const registerProviderActionSchema = yup$1.array().required().of(yup$1.object().shape({
    uid: yup$1.string().matches(/^[a-z]([a-z|.|-]+)[a-z]$/, (v)=>`${v.path}: The uid can only contain lowercase letters, dots and hyphens.`).required(),
    section: yup$1.string().oneOf([
        'contentTypes',
        'plugins',
        'settings',
        'internal'
    ]).required(),
    pluginName: yup$1.mixed().when('section', {
        is: 'plugins',
        then: validators.isAPluginName.required(),
        otherwise: validators.isAPluginName
    }),
    subjects: yup$1.mixed().when('section', {
        is: 'contentTypes',
        then: yup$1.array().of(yup$1.string()).required(),
        otherwise: yup$1.mixed().oneOf([
            undefined
        ], 'subjects should only be defined for the "contentTypes" section')
    }),
    displayName: yup$1.string().required(),
    category: yup$1.mixed().when('section', {
        is: 'settings',
        then: yup$1.string().required(),
        otherwise: yup$1.mixed().test('settingsCategory', 'category should only be defined for the "settings" section', (cat)=>cat === undefined)
    }),
    subCategory: yup$1.mixed().when('section', {
        is: (section)=>[
                'settings',
                'plugins'
            ].includes(section),
        then: yup$1.string(),
        otherwise: yup$1.mixed().test('settingsSubCategory', 'subCategory should only be defined for "plugins" and "settings" sections', (subCat)=>{
            return subCat === undefined;
        })
    }),
    options: yup$1.object({
        applyToProperties: yup$1.array().of(yup$1.string())
    }),
    aliases: yup$1.array(yup$1.object({
        actionId: yup$1.string(),
        subjects: yup$1.array(yup$1.string()).nullable()
    })).nullable()
}).noUnknown());
const validateRegisterProviderAction = validateYupSchemaSync(registerProviderActionSchema);

const { ApplicationError: ApplicationError$8 } = errors;
/**
 * Creates a new instance of an action provider
 */ const createActionProvider = (options)=>{
    const provider = providerFactory(options);
    const actionHooks = {
        appliesPropertyToSubject: hooks$1.createAsyncParallelHook()
    };
    return {
        ...provider,
        hooks: {
            ...provider.hooks,
            ...actionHooks
        },
        async register (actionAttributes) {
            if (strapi.isLoaded) {
                throw new Error(`You can't register new actions outside of the bootstrap function.`);
            }
            validateRegisterProviderAction([
                actionAttributes
            ]);
            const action = actionDomain.create(actionAttributes);
            return provider.register(action.actionId, action);
        },
        async registerMany (actionsAttributes) {
            validateRegisterProviderAction(actionsAttributes);
            for (const attributes of actionsAttributes){
                await this.register(attributes);
            }
            return this;
        },
        async appliesToProperty (property, actionId, subject) {
            const action = provider.get(actionId);
            if (!action) {
                throw new ApplicationError$8(`No action found with id "${actionId}"`);
            }
            const appliesToAction = actionDomain.appliesToProperty(property, action);
            // If the property isn't valid for this action, ignore the rest of the checks
            if (!appliesToAction) {
                return false;
            }
            // If the property is valid for this action and there isn't any subject
            if (!subject) {
                return true;
            }
            // If the property is valid for this action and the subject is not handled by the action
            if (!actionDomain.appliesToSubject(subject, action)) {
                return false;
            }
            const results = await actionHooks.appliesPropertyToSubject.call({
                property,
                action,
                subject
            });
            return results.every((result)=>result !== false);
        },
        /**
     * @experimental
     */ unstable_aliases (actionId, subject) {
            const isRegistered = this.has(actionId);
            if (!isRegistered) {
                return [];
            }
            return this.values().filter((action)=>action.aliases?.some((alias)=>{
                    // Only look at alias with the correct actionId
                    if (alias.actionId !== actionId) {
                        return false;
                    }
                    // If the alias don't have a list of required subjects, keep it
                    if (!Array.isArray(alias.subjects)) {
                        return true;
                    }
                    // If the alias require specific subjects but none is provided, skip it
                    if (!subject) {
                        return false;
                    }
                    // Else, make sure the given subject is allowed
                    return alias.subjects.includes(subject);
                })).map((action)=>action.actionId);
        }
    };
};

const DEFAULT_CATEGORY = 'default';
/**
 * Get the default value used for every condition
 * @return {Condition}
 */ const getDefaultConditionAttributes = ()=>({
        category: DEFAULT_CATEGORY
    });
/**
 * Get the list of all the valid attributes of a {@link Condition}
 * @return {string[]}
 */ const conditionFields = [
    'id',
    'displayName',
    'handler',
    'plugin',
    'category'
];
/**
 * Remove unwanted attributes from a {@link Condition}
 */ const sanitizeConditionAttributes = pick(conditionFields);
const computeConditionId = (condition)=>{
    const { name, plugin } = condition;
    if (!plugin) {
        return `api::${name}`;
    }
    if (plugin === 'admin') {
        return `admin::${name}`;
    }
    return `plugin::${plugin}.${name}`;
};
/**
 * Assign an id attribute to a {@link CreateConditionPayload} object
 * @param  attrs - Payload used to create a condition
 */ const assignConditionId = (attrs)=>{
    const condition = set('id', computeConditionId(attrs), attrs);
    return condition;
};
/**
 * Transform the given attributes into a domain representation of a Condition
 * @param payload - The condition payload containing the attributes needed to create a {@link Condition}
 */ const create$2 = pipe(assignConditionId, sanitizeConditionAttributes, merge(getDefaultConditionAttributes()));
var domain = {
    assignConditionId,
    computeConditionId,
    conditionFields,
    create: create$2,
    getDefaultConditionAttributes,
    sanitizeConditionAttributes
};

/**
 * @typedef ConditionProviderOverride
 * @property {function(CreateConditionPayload)} register
 * @property {function(attributes CreateConditionPayload[]): Promise<this>} registerMany
 */ /**
 * Creates a new instance of a condition provider
 * @return {Provider & ConditionProviderOverride}
 */ const createConditionProvider = ()=>{
    const provider = providerFactory();
    return {
        ...provider,
        async register (conditionAttributes) {
            if (strapi.isLoaded) {
                throw new Error(`You can't register new conditions outside of the bootstrap function.`);
            }
            const condition = domain.create(conditionAttributes);
            return provider.register(condition.id, condition);
        },
        async registerMany (conditionsAttributes) {
            for (const attributes of conditionsAttributes){
                await this.register(attributes);
            }
            return this;
        }
    };
};

const { visitors: { removePassword, expandWildcardPopulate } } = sanitize;
const { constants: constants$1, isScalarAttribute: isScalarAttribute$1, getNonVisibleAttributes: getNonVisibleAttributes$1, getNonWritableAttributes, getWritableAttributes: getWritableAttributes$1 } = contentTypes$1;
const { ID_ATTRIBUTE: ID_ATTRIBUTE$1, DOC_ID_ATTRIBUTE: DOC_ID_ATTRIBUTE$1, CREATED_AT_ATTRIBUTE: CREATED_AT_ATTRIBUTE$1, UPDATED_AT_ATTRIBUTE: UPDATED_AT_ATTRIBUTE$1, PUBLISHED_AT_ATTRIBUTE: PUBLISHED_AT_ATTRIBUTE$1, CREATED_BY_ATTRIBUTE: CREATED_BY_ATTRIBUTE$1, UPDATED_BY_ATTRIBUTE: UPDATED_BY_ATTRIBUTE$1 } = constants$1;
const COMPONENT_FIELDS$1 = [
    '__component'
];
const STATIC_FIELDS$1 = [
    ID_ATTRIBUTE$1,
    DOC_ID_ATTRIBUTE$1
];
var createSanitizeHelpers = (({ action, ability, model })=>{
    const schema = strapi.getModel(model);
    const { removeDisallowedFields } = sanitize.visitors;
    const ctx = {
        schema,
        getModel: strapi.getModel.bind(strapi)
    };
    const createSanitizeQuery = (options = {})=>{
        const { fields } = options;
        // TODO: sanitize relations to admin users in all sanitizers
        const permittedFields = fields.shouldIncludeAll ? null : getQueryFields(fields.permitted);
        const sanitizeFilters = async.pipe(traverse.traverseQueryFilters(removeDisallowedFields(permittedFields), ctx), traverse.traverseQueryFilters(omitDisallowedAdminUserFields, ctx), traverse.traverseQueryFilters(omitHiddenFields, ctx), traverse.traverseQueryFilters(removePassword, ctx), traverse.traverseQueryFilters(({ key, value }, { remove })=>{
            if (isObject(value) && isEmpty(value)) {
                remove(key);
            }
        }, ctx));
        const sanitizeSort = async.pipe(traverse.traverseQuerySort(removeDisallowedFields(permittedFields), ctx), traverse.traverseQuerySort(omitDisallowedAdminUserFields, ctx), traverse.traverseQuerySort(omitHiddenFields, ctx), traverse.traverseQuerySort(removePassword, ctx), traverse.traverseQuerySort(({ key, attribute, value }, { remove })=>{
            if (!isScalarAttribute$1(attribute) && isEmpty(value)) {
                remove(key);
            }
        }, ctx));
        const sanitizePopulate = async.pipe(traverse.traverseQueryPopulate(expandWildcardPopulate, ctx), traverse.traverseQueryPopulate(removeDisallowedFields(permittedFields), ctx), traverse.traverseQueryPopulate(omitDisallowedAdminUserFields, ctx), traverse.traverseQueryPopulate(omitHiddenFields, ctx), traverse.traverseQueryPopulate(removePassword, ctx));
        const sanitizeFields = async.pipe(traverse.traverseQueryFields(removeDisallowedFields(permittedFields), ctx), traverse.traverseQueryFields(omitHiddenFields, ctx), traverse.traverseQueryFields(removePassword, ctx));
        return async (query)=>{
            const sanitizedQuery = cloneDeep(query);
            if (query.filters) {
                Object.assign(sanitizedQuery, {
                    filters: await sanitizeFilters(query.filters)
                });
            }
            if (query.sort) {
                Object.assign(sanitizedQuery, {
                    sort: await sanitizeSort(query.sort)
                });
            }
            if (query.populate) {
                Object.assign(sanitizedQuery, {
                    populate: await sanitizePopulate(query.populate)
                });
            }
            if (query.fields) {
                Object.assign(sanitizedQuery, {
                    fields: await sanitizeFields(query.fields)
                });
            }
            return sanitizedQuery;
        };
    };
    const createSanitizeOutput = (options = {})=>{
        const { fields } = options;
        const permittedFields = fields.shouldIncludeAll ? null : getOutputFields(fields.permitted);
        return async.pipe(// Remove fields hidden from the admin
        traverseEntity(omitHiddenFields, ctx), // Remove unallowed fields from admin::user relations
        traverseEntity(pickAllowedAdminUserFields, ctx), // Remove not allowed fields (RBAC)
        traverseEntity(removeDisallowedFields(permittedFields), ctx), // Remove all fields of type 'password'
        sanitize.sanitizers.sanitizePasswords({
            schema,
            getModel (uid) {
                return strapi.getModel(uid);
            }
        }));
    };
    const createSanitizeInput = (options = {})=>{
        const { fields } = options;
        const permittedFields = fields.shouldIncludeAll ? null : getInputFields(fields.permitted);
        return async.pipe(// Remove fields hidden from the admin
        traverseEntity(omitHiddenFields, ctx), // Remove not allowed fields (RBAC)
        traverseEntity(removeDisallowedFields(permittedFields), ctx), // Remove roles from createdBy & updatedBy fields
        omitCreatorRoles);
    };
    const wrapSanitize = (createSanitizeFunction)=>{
        // TODO
        // @ts-expect-error define the correct return type
        const wrappedSanitize = async (data, options = {})=>{
            if (isArray(data)) {
                return Promise.all(data.map((entity)=>wrappedSanitize(entity, options)));
            }
            const { subject, action: actionOverride } = getDefaultOptions(data, options);
            const permittedFields = permittedFieldsOf(ability, actionOverride, subject, {
                fieldsFrom: (rule)=>rule.fields || []
            });
            const hasAtLeastOneRegistered = some((fields)=>!isNil(fields), flatMap(prop('fields'), ability.rulesFor(actionOverride, detectSubjectType(subject))));
            const shouldIncludeAllFields = isEmpty(permittedFields) && !hasAtLeastOneRegistered;
            const sanitizeOptions = {
                ...options,
                fields: {
                    shouldIncludeAll: shouldIncludeAllFields,
                    permitted: permittedFields,
                    hasAtLeastOneRegistered
                }
            };
            const sanitizeFunction = createSanitizeFunction(sanitizeOptions);
            return sanitizeFunction(data);
        };
        return wrappedSanitize;
    };
    const getDefaultOptions = (data, options)=>{
        return defaults({
            subject: subject$1(model, data),
            action
        }, options);
    };
    /**
   * Omit creator fields' (createdBy & updatedBy) roles from the admin API responses
   */ const omitCreatorRoles = omit([
        `${CREATED_BY_ATTRIBUTE$1}.roles`,
        `${UPDATED_BY_ATTRIBUTE$1}.roles`
    ]);
    /**
   * Visitor used to remove hidden fields from the admin API responses
   */ const omitHiddenFields = ({ key, schema }, { remove })=>{
        const isHidden = getOr(false, [
            'config',
            'attributes',
            key,
            'hidden'
        ], schema);
        if (isHidden) {
            remove(key);
        }
    };
    /**
   * Visitor used to only select needed fields from the admin users entities & avoid leaking sensitive information
   */ const pickAllowedAdminUserFields = ({ attribute, key, value }, { set })=>{
        const pickAllowedFields = pick(ADMIN_USER_ALLOWED_FIELDS);
        if (!attribute) {
            return;
        }
        if (attribute.type === 'relation' && attribute.target === 'admin::user' && value) {
            if (Array.isArray(value)) {
                set(key, value.map(pickAllowedFields));
            } else {
                set(key, pickAllowedFields(value));
            }
        }
    };
    /**
   * Visitor used to omit disallowed fields from the admin users entities & avoid leaking sensitive information
   */ const omitDisallowedAdminUserFields = ({ key, attribute, schema }, { remove })=>{
        if (schema.uid === 'admin::user' && attribute && !ADMIN_USER_ALLOWED_FIELDS.includes(key)) {
            remove(key);
        }
    };
    const getInputFields = (fields = [])=>{
        const nonVisibleAttributes = getNonVisibleAttributes$1(schema);
        const writableAttributes = getWritableAttributes$1(schema);
        const nonVisibleWritableAttributes = intersection(nonVisibleAttributes, writableAttributes);
        return uniq([
            ...fields,
            ...COMPONENT_FIELDS$1,
            ...nonVisibleWritableAttributes
        ]);
    };
    const getOutputFields = (fields = [])=>{
        const nonWritableAttributes = getNonWritableAttributes(schema);
        const nonVisibleAttributes = getNonVisibleAttributes$1(schema);
        return uniq([
            ...fields,
            ...STATIC_FIELDS$1,
            ...COMPONENT_FIELDS$1,
            ...nonWritableAttributes,
            ...nonVisibleAttributes,
            CREATED_AT_ATTRIBUTE$1,
            UPDATED_AT_ATTRIBUTE$1
        ]);
    };
    const getQueryFields = (fields = [])=>{
        const nonVisibleAttributes = getNonVisibleAttributes$1(schema);
        const writableAttributes = getWritableAttributes$1(schema);
        const nonVisibleWritableAttributes = intersection(nonVisibleAttributes, writableAttributes);
        return uniq([
            ...fields,
            ...STATIC_FIELDS$1,
            ...COMPONENT_FIELDS$1,
            ...nonVisibleWritableAttributes,
            CREATED_AT_ATTRIBUTE$1,
            UPDATED_AT_ATTRIBUTE$1,
            PUBLISHED_AT_ATTRIBUTE$1,
            CREATED_BY_ATTRIBUTE$1,
            UPDATED_BY_ATTRIBUTE$1
        ]);
    };
    return {
        sanitizeOutput: wrapSanitize(createSanitizeOutput),
        sanitizeInput: wrapSanitize(createSanitizeInput),
        sanitizeQuery: wrapSanitize(createSanitizeQuery)
    };
});

const { ValidationError: ValidationError$5 } = errors;
const { throwPassword, throwDisallowedFields } = validate.visitors;
const { constants, isScalarAttribute, getNonVisibleAttributes, getWritableAttributes } = contentTypes$1;
const { ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, CREATED_AT_ATTRIBUTE, UPDATED_AT_ATTRIBUTE, PUBLISHED_AT_ATTRIBUTE, CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = constants;
const COMPONENT_FIELDS = [
    '__component'
];
const STATIC_FIELDS = [
    ID_ATTRIBUTE,
    DOC_ID_ATTRIBUTE
];
const throwInvalidKey = ({ key, path })=>{
    const msg = path && path !== key ? `Invalid key ${key} at ${path}` : `Invalid key ${key}`;
    throw new ValidationError$5(msg);
};
var createValidateHelpers = (({ action, ability, model })=>{
    const schema = strapi.getModel(model);
    const ctx = {
        schema,
        getModel: strapi.getModel.bind(strapi)
    };
    const createValidateQuery = (options = {})=>{
        const { fields } = options;
        // TODO: validate relations to admin users in all validators
        const permittedFields = fields.shouldIncludeAll ? null : getQueryFields(fields.permitted);
        const validateFilters = async.pipe(traverse.traverseQueryFilters(throwDisallowedFields(permittedFields), ctx), traverse.traverseQueryFilters(throwDisallowedAdminUserFields, ctx), traverse.traverseQueryFilters(throwPassword, ctx), traverse.traverseQueryFilters(({ key, value, path })=>{
            if (isObject(value) && isEmpty(value)) {
                throwInvalidKey({
                    key,
                    path: path.attribute
                });
            }
        }, ctx));
        const validateSort = async.pipe(traverse.traverseQuerySort(throwDisallowedFields(permittedFields), ctx), traverse.traverseQuerySort(throwDisallowedAdminUserFields, ctx), traverse.traverseQuerySort(throwPassword, ctx), traverse.traverseQuerySort(({ key, attribute, value, path })=>{
            if (!isScalarAttribute(attribute) && isEmpty(value)) {
                throwInvalidKey({
                    key,
                    path: path.attribute
                });
            }
        }, ctx));
        const validateFields = async.pipe(traverse.traverseQueryFields(throwDisallowedFields(permittedFields), ctx), traverse.traverseQueryFields(throwPassword, ctx));
        const validatePopulate = async.pipe(traverse.traverseQueryPopulate(throwDisallowedFields(permittedFields), ctx), traverse.traverseQueryPopulate(throwDisallowedAdminUserFields, ctx), traverse.traverseQueryPopulate(throwHiddenFields, ctx), traverse.traverseQueryPopulate(throwPassword, ctx));
        return async (query)=>{
            if (query.filters) {
                await validateFilters(query.filters);
            }
            if (query.sort) {
                await validateSort(query.sort);
            }
            if (query.fields) {
                await validateFields(query.fields);
            }
            // a wildcard is always valid; its conversion will be handled by the entity service and can be optimized with sanitizer
            if (query.populate && query.populate !== '*') {
                await validatePopulate(query.populate);
            }
            return true;
        };
    };
    const createValidateInput = (options = {})=>{
        const { fields } = options;
        const permittedFields = fields.shouldIncludeAll ? null : getInputFields(fields.permitted);
        return async.pipe(// Remove fields hidden from the admin
        traverseEntity(throwHiddenFields, ctx), // Remove not allowed fields (RBAC)
        traverseEntity(throwDisallowedFields(permittedFields), ctx), // Remove roles from createdBy & updatedBy fields
        omitCreatorRoles);
    };
    const wrapValidate = (createValidateFunction)=>{
        // TODO
        // @ts-expect-error define the correct return type
        const wrappedValidate = async (data, options = {})=>{
            if (isArray(data)) {
                return Promise.all(data.map((entity)=>wrappedValidate(entity, options)));
            }
            const { subject, action: actionOverride } = getDefaultOptions(data, options);
            const permittedFields = permittedFieldsOf(ability, actionOverride, subject, {
                fieldsFrom: (rule)=>rule.fields || []
            });
            const hasAtLeastOneRegistered = some((fields)=>!isNil(fields), flatMap(prop('fields'), ability.rulesFor(actionOverride, detectSubjectType(subject))));
            const shouldIncludeAllFields = isEmpty(permittedFields) && !hasAtLeastOneRegistered;
            const validateOptions = {
                ...options,
                fields: {
                    shouldIncludeAll: shouldIncludeAllFields,
                    permitted: permittedFields,
                    hasAtLeastOneRegistered
                }
            };
            const validateFunction = createValidateFunction(validateOptions);
            return validateFunction(data);
        };
        return wrappedValidate;
    };
    const getDefaultOptions = (data, options)=>{
        return defaults({
            subject: subject$1(model, data),
            action
        }, options);
    };
    /**
   * Omit creator fields' (createdBy & updatedBy) roles from the admin API responses
   */ const omitCreatorRoles = omit([
        `${CREATED_BY_ATTRIBUTE}.roles`,
        `${UPDATED_BY_ATTRIBUTE}.roles`
    ]);
    /**
   * Visitor used to remove hidden fields from the admin API responses
   */ const throwHiddenFields = ({ key, schema, path })=>{
        const isHidden = getOr(false, [
            'config',
            'attributes',
            key,
            'hidden'
        ], schema);
        if (isHidden) {
            throwInvalidKey({
                key,
                path: path.attribute
            });
        }
    };
    /**
   * Visitor used to omit disallowed fields from the admin users entities & avoid leaking sensitive information
   */ const throwDisallowedAdminUserFields = ({ key, attribute, schema, path })=>{
        if (schema.uid === 'admin::user' && attribute && !ADMIN_USER_ALLOWED_FIELDS.includes(key)) {
            throwInvalidKey({
                key,
                path: path.attribute
            });
        }
    };
    const getInputFields = (fields = [])=>{
        const nonVisibleAttributes = getNonVisibleAttributes(schema);
        const writableAttributes = getWritableAttributes(schema);
        const nonVisibleWritableAttributes = intersection(nonVisibleAttributes, writableAttributes);
        return uniq([
            ...fields,
            ...COMPONENT_FIELDS,
            ...nonVisibleWritableAttributes
        ]);
    };
    const getQueryFields = (fields = [])=>{
        return uniq([
            ...fields,
            ...STATIC_FIELDS,
            ...COMPONENT_FIELDS,
            CREATED_AT_ATTRIBUTE,
            UPDATED_AT_ATTRIBUTE,
            PUBLISHED_AT_ATTRIBUTE
        ]);
    };
    return {
        validateQuery: wrapValidate(createValidateQuery),
        validateInput: wrapValidate(createValidateInput)
    };
});

// TODO: migration
const operatorsMap = {
    $in: '$in',
    $nin: '$notIn',
    $exists: '$notNull',
    $gte: '$gte',
    $gt: '$gt',
    $lte: '$lte',
    $lt: '$lt',
    $eq: '$eq',
    $ne: '$ne',
    $and: '$and',
    $or: '$or',
    $not: '$not'
};
const mapKey = (key)=>{
    if (___default.isString(key) && key.startsWith('$') && key in operatorsMap) {
        return operatorsMap[key];
    }
    return key;
};
const buildCaslQuery = (ability, action, model)=>{
    // @ts-expect-error casl types
    return rulesToQuery(ability, action, model, (o)=>o.conditions);
};
const buildStrapiQuery = (caslQuery)=>{
    return unwrapDeep(caslQuery);
};
const unwrapDeep = (obj)=>{
    if (!___default.isPlainObject(obj) && !___default.isArray(obj)) {
        return obj;
    }
    if (___default.isArray(obj)) {
        return obj.map((v)=>unwrapDeep(v));
    }
    return ___default.reduce(obj, (acc, v, k)=>{
        const key = mapKey(k);
        if (___default.isPlainObject(v)) {
            if ('$elemMatch' in v) {
                ___default.setWith(acc, key, unwrapDeep(v.$elemMatch));
            } else {
                ___default.setWith(acc, key, unwrapDeep(v));
            }
        } else if (___default.isArray(v)) {
            // prettier-ignore
            ___default.setWith(acc, key, v.map((v)=>unwrapDeep(v)));
        } else {
            ___default.setWith(acc, key, v);
        }
        return acc;
    }, {});
};

var index = (({ ability, action, model })=>({
        ability,
        action,
        model,
        get isAllowed () {
            return this.ability.can(action, model);
        },
        toSubject (target, subjectType = model) {
            return subject$1(subjectType, target);
        },
        pickPermittedFieldsOf (data, options = {}) {
            return this.sanitizeInput(data, options);
        },
        getQuery (queryAction = action) {
            if (___default.isUndefined(queryAction)) {
                throw new Error('Action must be defined to build a permission query');
            }
            return buildStrapiQuery(buildCaslQuery(ability, queryAction, model));
        },
        // eslint-disable-next-line @typescript-eslint/default-param-last
        addPermissionsQueryTo (query = {}, action) {
            const newQuery = cloneDeep(query);
            const permissionQuery = this.getQuery(action) ?? undefined;
            if (isPlainObject(query.filters)) {
                newQuery.filters = permissionQuery ? {
                    $and: [
                        query.filters,
                        permissionQuery
                    ]
                } : query.filters;
            } else {
                newQuery.filters = permissionQuery;
            }
            return newQuery;
        },
        ...createSanitizeHelpers({
            action,
            ability,
            model
        }),
        ...createValidateHelpers({
            action,
            ability,
            model
        })
    }));

var createPermissionEngine = ((params)=>{
    const { providers } = params;
    const engine = permissions$1.engine.new({
        providers
    })/**
     * Validate the permission's action exists in the action registry
     */ .on('before-format::validate.permission', ({ permission })=>{
        const action = providers.action.get(permission.action);
        // If the action isn't registered into the action provider, then ignore the permission
        if (!action) {
            strapi.log.debug(`Unknown action "${permission.action}" supplied when registering a new permission in engine`);
            return false;
        }
    })/**
     * Remove invalid properties from the permission based on the action (applyToProperties)
     */ .on('format.permission', (permission)=>{
        const action = providers.action.get(permission.action);
        const properties = permission.properties || {};
        // Only keep the properties allowed by the action (action.applyToProperties)
        const propertiesName = Object.keys(properties);
        const invalidProperties = difference(propertiesName, // @ts-expect-error - applyToProperties is defined inside the options of an action
        action.applyToProperties || propertiesName);
        const permissionWithSanitizedProperties = invalidProperties.reduce(// @ts-expect-error - fix reduce, property should be a string but it's actually the permission object
        (property)=>permissionDomain.deleteProperty(property, permission), permission);
        return permissionWithSanitizedProperties;
    })/**
     * Ignore the permission if the fields property is an empty array (access to no field)
     */ .on('after-format::validate.permission', ({ permission })=>{
        const { fields } = permission.properties;
        if (isArray(fields) && isEmpty(fields)) {
            return false;
        }
    });
    return {
        get hooks () {
            return engine.hooks;
        },
        /**
     * Generate an ability based on the given user (using associated roles & permissions)
     * @param user
     */ async generateUserAbility (user) {
            const permissions = await getService$1('permission').findUserPermissions(user);
            return engine.generateAbility(permissions, user);
        },
        /**
     * Check many permissions based on an ability
     */ checkMany: curry((ability, permissions)=>{
            // @ts-expect-error - Permissions does not contain any field property
            return permissions.map(({ action, subject, field })=>ability.can(action, subject, field));
        })
    };
});

const emptyObjectFactory = ()=>({});
/**
 * Upon call, creates a new section object
 */ const createSection = ({ initialStateFactory = emptyObjectFactory, handlers = [], matchers = [] } = {})=>{
    const state = {
        hooks: {
            handlers: hooks$1.createAsyncSeriesHook(),
            matchers: hooks$1.createAsyncParallelHook()
        }
    };
    // Register initial hooks
    handlers.forEach((handler)=>state.hooks.handlers.register(handler));
    matchers.forEach((matcher)=>state.hooks.matchers.register(matcher));
    return {
        hooks: state.hooks,
        /**
     * Verifies if an action can be applied to the section by running the matchers hook.
     * If any of the registered matcher functions returns true, then the condition applies.
     */ async appliesToAction (action) {
            const results = await state.hooks.matchers.call(action);
            return results.some(eq(true));
        },
        /**
     * Init, build and returns a section object based on the given actions
     * @param  actions - A list of actions used to populate the section
     */ async build (actions = []) {
            const section = initialStateFactory();
            for (const action of actions){
                const applies = await this.appliesToAction(action);
                if (applies) {
                    await state.hooks.handlers.call({
                        action,
                        section
                    });
                }
            }
            return section;
        }
    };
};

/**
 * Create a new section builder with its own sections registry
 */ const createSectionBuilder = ()=>{
    const state = {
        sections: new Map()
    };
    return {
        /**
     * Create & add a section to the builder's registry
     * @param sectionName - The unique name of the section
     * @param options - The options used to build a {@link Section}
     */ createSection (sectionName, options) {
            const section = createSection(options);
            state.sections.set(sectionName, section);
            return this;
        },
        /**
     * Removes a section from the builder's registry using its unique name
     * @param sectionName - The name of the section to delete
     */ deleteSection (sectionName) {
            state.sections.delete(sectionName);
            return this;
        },
        /**
     * Register a handler function for a given section
     * @param  sectionName - The name of the section
     * @param  handler - The handler to register
     */ addHandler (sectionName, handler) {
            if (state.sections.has(sectionName)) {
                state.sections.get(sectionName).hooks.handlers.register(handler);
            }
            return this;
        },
        /**
     * Register a matcher function for a given section
     * @param sectionName - The name of the section
     * @param matcher - The handler to register

     */ addMatcher (sectionName, matcher) {
            if (state.sections.has(sectionName)) {
                state.sections.get(sectionName).hooks.matchers.register(matcher);
            }
            return this;
        },
        /**
     * Build a section tree based on the registered actions and the given actions
     * @param actions - The actions used to build each section
     */ async build (actions = []) {
            const sections = {};
            for (const [sectionName, section] of state.sections.entries()){
                sections[sectionName] = await section.build(actions);
            }
            return sections;
        }
    };
};

const isOfKind = (kind)=>matchesProperty('kind', kind);
const resolveContentType = (uid)=>{
    return strapi.contentTypes[uid];
};
const isNotInSubjects = (subjects)=>(uid)=>!subjects.find((subject)=>subject.uid === uid);
const hasProperty = curry((property, subject)=>{
    return !!subject.properties.find((prop)=>prop.value === property);
});
const getValidOptions = pick([
    'applyToProperties'
]);
const toSubjectTemplate = (ct)=>({
        uid: ct.uid,
        label: ct.info.singularName,
        properties: []
    });

const { isVisibleAttribute } = contentTypes$1;
/**
 * Transforms & adds the given  setting action to the section
 * Note: The action is transformed to a setting specific format
 * @param options
 * @param options.action
 * @param section
 */ const settings = ({ action, section })=>{
    const { category, subCategory, displayName, actionId } = action;
    section.push({
        displayName,
        category,
        subCategory,
        // TODO: Investigate at which point the action property is transformed to actionId
        // @ts-expect-error - action should be actionID
        action: actionId
    });
};
/**
 * Transforms & adds the given plugin action to the section
 * Note: The action is transformed to a plugin specific format
 * @param {object} options
 * @param {Action} options.action
 * @param {ActionArraySection} section
 */ const plugins = ({ action, section })=>{
    const { pluginName, subCategory, displayName, actionId } = action;
    section.push({
        displayName,
        // @ts-expect-error - plugin should be pluginName, TODO: Investigate at which point the plugin property
        plugin: pluginName,
        subCategory,
        action: actionId
    });
};
/**
 * Transforms & adds the given action to the section's actions field
 * Note: The action is transformed to a content-type specific format
 * @param {object} options
 * @param {Action} options.action
 * @param {ContentTypesSection} section
 */ const contentTypesBase = ({ action, section })=>{
    const { displayName, actionId, subjects, options } = action;
    section.actions.push({
        // @ts-expect-error - label should be displayName, TODO: Investigate at which point the label property
        label: displayName,
        actionId,
        subjects,
        ...getValidOptions(options)
    });
};
/**
 * Initialize the subjects array of a section based on the action's subjects
 */ const subjectsHandlerFor = (kind)=>({ action, section: contentTypesSection })=>{
        // TODO: add a type guard for UID.ContentType
        const subjects = action.subjects;
        if (!subjects?.length) {
            return;
        }
        const newSubjects = subjects// Ignore already added subjects
        .filter(isNotInSubjects(contentTypesSection.subjects))// Transform UIDs into content-types
        .map(resolveContentType)// Only keep specific kind of content-types
        .filter(isOfKind(kind))// Transform the content-types into section's subjects
        .map(toSubjectTemplate);
        contentTypesSection.subjects.push(...newSubjects);
    };
const buildNode = (model, attributeName, attribute)=>{
    if (!isVisibleAttribute(model, attributeName)) {
        return null;
    }
    const node = {
        label: attributeName,
        value: attributeName
    };
    if (attribute.required) {
        Object.assign(node, {
            required: true
        });
    }
    if (attribute.type === 'component') {
        const component = strapi.components[attribute.component];
        return {
            ...node,
            children: buildDeepAttributesCollection(component)
        };
    }
    return node;
};
const buildDeepAttributesCollection = (model)=>{
    return Object.entries(model.attributes).map(([attributeName, attribute])=>buildNode(model, attributeName, attribute)).filter((node)=>node !== null);
};
/**
 * Create and populate the fields property for section's subjects based on the action's subjects list
 */ const fieldsProperty = ({ action, section })=>{
    const { subjects } = action;
    section.subjects.filter((subject)=>subjects?.includes(subject.uid)).forEach((subject)=>{
        const { uid } = subject;
        const contentType = resolveContentType(uid);
        if (hasProperty('fields', subject)) {
            return;
        }
        const fields = buildDeepAttributesCollection(contentType);
        const fieldsProp = {
            label: 'Fields',
            value: 'fields',
            children: fields
        };
        subject.properties.push(fieldsProp);
    });
};

const sectionPropMatcher = propEq('section');
const createContentTypesInitialState = ()=>({
        actions: [],
        subjects: []
    });
const createDefaultSectionBuilder = ()=>{
    const builder = createSectionBuilder();
    builder.createSection('plugins', {
        initialStateFactory: ()=>[],
        handlers: [
            plugins
        ],
        matchers: [
            sectionPropMatcher('plugins')
        ]
    });
    builder.createSection('settings', {
        initialStateFactory: ()=>[],
        handlers: [
            settings
        ],
        matchers: [
            sectionPropMatcher('settings')
        ]
    });
    builder.createSection('singleTypes', {
        initialStateFactory: createContentTypesInitialState,
        handlers: [
            contentTypesBase,
            subjectsHandlerFor('singleType'),
            fieldsProperty
        ],
        matchers: [
            sectionPropMatcher('contentTypes')
        ]
    });
    builder.createSection('collectionTypes', {
        initialStateFactory: createContentTypesInitialState,
        handlers: [
            contentTypesBase,
            subjectsHandlerFor('collectionType'),
            fieldsProperty
        ],
        matchers: [
            sectionPropMatcher('contentTypes')
        ]
    });
    return builder;
};

/**
 * Delete permissions of roles in database
 * @param rolesIds ids of roles
 */ const deleteByRolesIds = async (rolesIds)=>{
    const permissionsToDelete = await strapi.db.query('admin::permission').findMany({
        select: [
            'id'
        ],
        where: {
            role: {
                id: rolesIds
            }
        }
    });
    if (permissionsToDelete.length > 0) {
        await deleteByIds$1(permissionsToDelete.map(prop('id')));
    }
};
/**
 * Delete permissions
 * @param ids ids of permissions
 */ const deleteByIds$1 = async (ids)=>{
    const result = [];
    for (const id of ids){
        const queryResult = await strapi.db.query('admin::permission').delete({
            where: {
                id
            }
        });
        result.push(queryResult);
    }
    strapi.eventHub.emit('permission.delete', {
        permissions: result
    });
};
/**
 * Create many permissions
 * @param permissions
 */ const createMany = async (permissions)=>{
    const createdPermissions = [];
    for (const permission of permissions){
        const newPerm = await strapi.db.query('admin::permission').create({
            data: permission
        });
        createdPermissions.push(newPerm);
    }
    const permissionsToReturn = permissionDomain.toPermission(createdPermissions);
    strapi.eventHub.emit('permission.create', {
        permissions: permissionsToReturn
    });
    return permissionsToReturn;
};
/**
 * Update a permission
 * @param params
 * @param attributes
 */ const update$2 = async (params, attributes)=>{
    const updatedPermission = await strapi.db.query('admin::permission').update({
        where: params,
        data: attributes
    });
    const permissionToReturn = permissionDomain.toPermission(updatedPermission);
    strapi.eventHub.emit('permission.update', {
        permissions: permissionToReturn
    });
    return permissionToReturn;
};
/**
 * Find assigned permissions in the database
 * @param params query params to find the permissions
 */ const findMany = async (params = {})=>{
    const rawPermissions = await strapi.db.query('admin::permission').findMany(params);
    return permissionDomain.toPermission(rawPermissions);
};
/**
 * Find all permissions for a user
 * @param user - user
 */ const findUserPermissions = async (user)=>{
    return findMany({
        where: {
            role: {
                users: {
                    id: user.id
                }
            }
        }
    });
};
const filterPermissionsToRemove = async (permissions)=>{
    const { actionProvider } = getService$1('permission');
    const permissionsToRemove = [];
    for (const permission of permissions){
        const { subjects, options = {} } = actionProvider.get(permission.action) || {};
        const { applyToProperties } = options;
        const invalidProperties = await Promise.all((applyToProperties || []).map(async (property)=>{
            const applies = await actionProvider.appliesToProperty(property, permission.action, permission.subject);
            return applies && isNil(permissionDomain.getProperty(property, permission));
        }));
        const isRegisteredAction = actionProvider.has(permission.action);
        const hasInvalidProperties = isArray(applyToProperties) && invalidProperties.every(eq(true));
        const isInvalidSubject = isArray(subjects) && !subjects.includes(permission.subject);
        // If the permission has an invalid action, an invalid subject or invalid properties, then add it to the toBeRemoved collection
        if (!isRegisteredAction || isInvalidSubject || hasInvalidProperties) {
            permissionsToRemove.push(permission);
        }
    }
    return permissionsToRemove;
};
/**
 * Removes permissions in database that don't exist anymore
 */ const cleanPermissionsInDatabase = async ()=>{
    const pageSize = 200;
    const contentTypeService = getService$1('content-type');
    const total = await strapi.db.query('admin::permission').count();
    const pageCount = Math.ceil(total / pageSize);
    for(let page = 0; page < pageCount; page += 1){
        // 1. Find invalid permissions and collect their ID to delete them later
        const results = await strapi.db.query('admin::permission').findMany({
            limit: pageSize,
            offset: page * pageSize
        });
        const permissions = permissionDomain.toPermission(results);
        const permissionsToRemove = await filterPermissionsToRemove(permissions);
        const permissionsIdToRemove = map(prop('id'), permissionsToRemove);
        // 2. Clean permissions' fields (add required ones, remove the non-existing ones)
        const remainingPermissions = permissions.filter((permission)=>!permissionsIdToRemove.includes(permission.id));
        const permissionsWithCleanFields = contentTypeService.cleanPermissionFields(remainingPermissions);
        // Update only the ones that need to be updated
        const permissionsNeedingToBeUpdated = differenceWith((a, b)=>{
            return a.id === b.id && xor(a.properties.fields, b.properties.fields).length === 0;
        }, permissionsWithCleanFields, remainingPermissions);
        const updatePromiseProvider = (permission)=>{
            return update$2({
                id: permission.id
            }, permission);
        };
        // Execute all the queries, update the database
        await Promise.all([
            deleteByIds$1(permissionsIdToRemove),
            pmap(permissionsNeedingToBeUpdated, updatePromiseProvider, {
                concurrency: 100,
                stopOnError: true
            })
        ]);
    }
};

const actionProvider = createActionProvider();
const conditionProvider = createConditionProvider();
const sectionsBuilder = createDefaultSectionBuilder();
const sanitizePermission = permissionDomain.sanitizePermissionFields;
const engine$1 = createPermissionEngine({
    providers: {
        action: actionProvider,
        condition: conditionProvider
    }
});

var permission$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  actionProvider: actionProvider,
  cleanPermissionsInDatabase: cleanPermissionsInDatabase,
  conditionProvider: conditionProvider,
  createMany: createMany,
  createPermissionsManager: index,
  deleteByIds: deleteByIds$1,
  deleteByRolesIds: deleteByRolesIds,
  engine: engine$1,
  findMany: findMany,
  findUserPermissions: findUserPermissions,
  sanitizePermission: sanitizePermission,
  sectionsBuilder: sectionsBuilder
});

/**
 * Creates an array of paths to the fields and nested fields, without path nodes
 */ const getNestedFields = (model, { prefix = '', nestingLevel = 15, components = {}, requiredOnly = false, existingFields = [] })=>{
    if (nestingLevel === 0) {
        return prefix ? [
            prefix
        ] : [];
    }
    const nonAuthorizableFields = contentTypes$1.getNonVisibleAttributes(model);
    return ___default.reduce(model.attributes, (fields, attr, key)=>{
        if (nonAuthorizableFields.includes(key)) return fields;
        const fieldPath = prefix ? `${prefix}.${key}` : key;
        const shouldBeIncluded = !requiredOnly || attr.required === true;
        const insideExistingFields = existingFields && existingFields.some(startsWith(fieldPath));
        if (attr.type === 'component') {
            if (shouldBeIncluded || insideExistingFields) {
                const compoFields = getNestedFields(components[attr.component], {
                    nestingLevel: nestingLevel - 1,
                    prefix: fieldPath,
                    components,
                    requiredOnly,
                    existingFields
                });
                if (compoFields.length === 0 && shouldBeIncluded) {
                    return fields.concat(fieldPath);
                }
                return fields.concat(compoFields);
            }
            return fields;
        }
        if (shouldBeIncluded) {
            return fields.concat(fieldPath);
        }
        return fields;
    }, []);
};
/**
 * Creates an array of paths to the fields and nested fields, with path nodes
 */ const getNestedFieldsWithIntermediate = (model, { prefix = '', nestingLevel = 15, components = {} })=>{
    if (nestingLevel === 0) {
        return [];
    }
    const nonAuthorizableFields = contentTypes$1.getNonVisibleAttributes(model);
    return ___default.reduce(model.attributes, (fields, attr, key)=>{
        if (nonAuthorizableFields.includes(key)) return fields;
        const fieldPath = prefix ? `${prefix}.${key}` : key;
        fields.push(fieldPath);
        if (attr.type === 'component') {
            const compoFields = getNestedFieldsWithIntermediate(components[attr.component], {
                nestingLevel: nestingLevel - 1,
                prefix: fieldPath,
                components
            });
            fields.push(...compoFields);
        }
        return fields;
    }, []);
};
/**
 * Creates an array of permissions with the "properties.fields" attribute filled
 */ const getPermissionsWithNestedFields = (actions, { nestingLevel, restrictedSubjects = [] } = {})=>{
    return actions.reduce((permissions, action)=>{
        const validSubjects = action.subjects.filter((subject)=>!restrictedSubjects.includes(subject));
        // Create a Permission for each subject (content-type uid) within the action
        for (const subject of validSubjects){
            const fields = actionDomain.appliesToProperty('fields', action) ? getNestedFields(strapi.contentTypes[subject], {
                components: strapi.components,
                nestingLevel
            }) : undefined;
            const permission = permissionDomain.create({
                action: action.actionId,
                subject,
                properties: {
                    fields
                }
            });
            permissions.push(permission);
        }
        return permissions;
    }, []);
};
/**
 * Cleans permissions' fields (add required ones, remove the non-existing ones)
 */ const cleanPermissionFields = (permissions, { nestingLevel } = {})=>{
    const { actionProvider } = getService$1('permission');
    return permissions.map((permission)=>{
        const { action: actionId, subject, properties: { fields } } = permission;
        const action = actionProvider.get(actionId);
        // todo see if it's possible to check property on action + subject (async)
        if (!actionDomain.appliesToProperty('fields', action)) {
            return permissionDomain.deleteProperty('fields', permission);
        }
        if (!subject || !strapi.contentTypes[subject]) {
            return permission;
        }
        const possibleFields = getNestedFieldsWithIntermediate(strapi.contentTypes[subject], {
            components: strapi.components,
            nestingLevel
        });
        const requiredFields = getNestedFields(strapi.contentTypes[subject], {
            components: strapi.components,
            requiredOnly: true,
            nestingLevel,
            existingFields: fields
        });
        // @ts-expect-error lodash types
        const badNestedFields = uniq([
            ...intersection(fields, possibleFields),
            ...requiredFields
        ]);
        const newFields = badNestedFields.filter((field)=>!badNestedFields.some(startsWith(`${field}.`)));
        return permissionDomain.setProperty('fields', newFields, permission);
    }, []);
};

var contentType = /*#__PURE__*/Object.freeze({
  __proto__: null,
  cleanPermissionFields: cleanPermissionFields,
  getNestedFields: getNestedFields,
  getNestedFieldsWithIntermediate: getNestedFieldsWithIntermediate,
  getPermissionsWithNestedFields: getPermissionsWithNestedFields
});

const isValidCondition = (condition)=>{
    const { conditionProvider } = getService$1('permission');
    return isString(condition) && conditionProvider.has(condition);
};

var condition = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isValidCondition: isValidCondition
});

const { AUTHOR_CODE, PUBLISH_ACTION } = constants$3;
const { NotFoundError: NotFoundError$2 } = errors;
// TODO: move actionProvider here instead of in the permission service
/**
 * Returns actions available for a role.
 * @param {string|number} roleId
 * @returns {object[]}
 */ const getAllowedActionsForRole = async (roleId)=>{
    const { actionProvider } = getService$1('permission');
    if (!isNil(roleId)) {
        const role = await getService$1('role').findOne({
            id: roleId
        });
        if (!role) {
            throw new NotFoundError$2('role.notFound');
        }
        if (role.code === AUTHOR_CODE) {
            return actionProvider.values().filter(({ actionId })=>actionId !== PUBLISH_ACTION);
        }
    }
    return actionProvider.values();
};

var action = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getAllowedActionsForRole: getAllowedActionsForRole
});

const { ValidationError: ValidationError$4, NotFoundError: NotFoundError$1 } = errors;
const SELECT_FIELDS$1 = [
    'id',
    'name',
    'description',
    'lastUsedAt',
    'type',
    'lifespan',
    'expiresAt',
    'createdAt',
    'updatedAt'
];
const POPULATE_FIELDS$1 = [
    'permissions'
];
// TODO: we need to ensure the permissions are actually valid registered permissions!
/**
 * Assert that a token's permissions attribute is valid for its type
 */ const assertCustomTokenPermissionsValidity = (type, permissions)=>{
    // Ensure non-custom tokens doesn't have permissions
    if (type !== constants$3.API_TOKEN_TYPE.CUSTOM && !isEmpty(permissions)) {
        throw new ValidationError$4('Non-custom tokens should not reference permissions');
    }
    // Custom type tokens should always have permissions attached to them
    if (type === constants$3.API_TOKEN_TYPE.CUSTOM && !isArray(permissions)) {
        throw new ValidationError$4('Missing permissions attribute for custom token');
    }
    // Permissions provided for a custom type token should be valid/registered permissions UID
    if (type === constants$3.API_TOKEN_TYPE.CUSTOM) {
        const validPermissions = strapi.contentAPI.permissions.providers.action.keys();
        const invalidPermissions = difference(permissions, validPermissions);
        if (!isEmpty(invalidPermissions)) {
            throw new ValidationError$4(`Unknown permissions provided: ${invalidPermissions.join(', ')}`);
        }
    }
};
/**
 * Check if a token's lifespan is valid
 */ const isValidLifespan$1 = (lifespan)=>{
    if (isNil(lifespan)) {
        return true;
    }
    if (!isNumber(lifespan) || !Object.values(constants$3.API_TOKEN_LIFESPANS).includes(lifespan)) {
        return false;
    }
    return true;
};
/**
 * Assert that a token's lifespan is valid
 */ const assertValidLifespan$1 = (lifespan)=>{
    if (!isValidLifespan$1(lifespan)) {
        throw new ValidationError$4(`lifespan must be one of the following values:
      ${Object.values(constants$3.API_TOKEN_LIFESPANS).join(', ')}`);
    }
};
/**
 * Flatten a token's database permissions objects to an array of strings
 */ const flattenTokenPermissions$1 = (token)=>{
    if (!token) {
        return token;
    }
    return {
        ...token,
        permissions: isArray(token.permissions) ? map('action', token.permissions) : token.permissions
    };
};
/**
 *  Get a token
 */ const getBy$1 = async (whereParams = {})=>{
    if (Object.keys(whereParams).length === 0) {
        return null;
    }
    const token = await strapi.db.query('admin::api-token').findOne({
        select: SELECT_FIELDS$1,
        populate: POPULATE_FIELDS$1,
        where: whereParams
    });
    if (!token) {
        return token;
    }
    return flattenTokenPermissions$1(token);
};
/**
 * Check if token exists
 */ const exists$1 = async (whereParams = {})=>{
    const apiToken = await getBy$1(whereParams);
    return !!apiToken;
};
/**
 * Return a secure sha512 hash of an accessKey
 */ const hash$1 = (accessKey)=>{
    return crypto.createHmac('sha512', strapi.config.get('admin.apiToken.salt')).update(accessKey).digest('hex');
};
const getExpirationFields$1 = (lifespan)=>{
    // it must be nil or a finite number >= 0
    const isValidNumber = isNumber(lifespan) && Number.isFinite(lifespan) && lifespan > 0;
    if (!isValidNumber && !isNil(lifespan)) {
        throw new ValidationError$4('lifespan must be a positive number or null');
    }
    return {
        lifespan: lifespan || null,
        expiresAt: lifespan ? Date.now() + lifespan : null
    };
};
/**
 * Create a token and its permissions
 */ const create$1 = async (attributes)=>{
    const accessKey = crypto.randomBytes(128).toString('hex');
    assertCustomTokenPermissionsValidity(attributes.type, attributes.permissions);
    assertValidLifespan$1(attributes.lifespan);
    // Create the token
    const apiToken = await strapi.db.query('admin::api-token').create({
        select: SELECT_FIELDS$1,
        populate: POPULATE_FIELDS$1,
        data: {
            ...omit('permissions', attributes),
            accessKey: hash$1(accessKey),
            ...getExpirationFields$1(attributes.lifespan)
        }
    });
    const result = {
        ...apiToken,
        accessKey
    };
    // If this is a custom type token, create and the related permissions
    if (attributes.type === constants$3.API_TOKEN_TYPE.CUSTOM) {
        // TODO: createMany doesn't seem to create relation properly, implement a better way rather than a ton of queries
        // const permissionsCount = await strapi.db.query('admin::api-token-permission').createMany({
        //   populate: POPULATE_FIELDS,
        //   data: attributes.permissions.map(action => ({ action, token: apiToken })),
        // });
        await Promise.all(uniq(attributes.permissions).map((action)=>strapi.db.query('admin::api-token-permission').create({
                data: {
                    action,
                    token: apiToken
                }
            })));
        const currentPermissions = await strapi.db.query('admin::api-token').load(apiToken, 'permissions');
        if (currentPermissions) {
            Object.assign(result, {
                permissions: map('action', currentPermissions)
            });
        }
    }
    return result;
};
const regenerate$1 = async (id)=>{
    const accessKey = crypto.randomBytes(128).toString('hex');
    const apiToken = await strapi.db.query('admin::api-token').update({
        select: [
            'id',
            'accessKey'
        ],
        where: {
            id
        },
        data: {
            accessKey: hash$1(accessKey)
        }
    });
    if (!apiToken) {
        throw new NotFoundError$1('The provided token id does not exist');
    }
    return {
        ...apiToken,
        accessKey
    };
};
const checkSaltIsDefined$1 = ()=>{
    if (!strapi.config.get('admin.apiToken.salt')) {
        // TODO V5: stop reading API_TOKEN_SALT
        if (process.env.API_TOKEN_SALT) {
            process.emitWarning(`[deprecated] In future versions, Strapi will stop reading directly from the environment variable API_TOKEN_SALT. Please set apiToken.salt in config/admin.js instead.
For security reasons, keep storing the secret in an environment variable and use env() to read it in config/admin.js (ex: \`apiToken: { salt: env('API_TOKEN_SALT') }\`). See https://docs.strapi.io/developer-docs/latest/setup-deployment-guides/configurations/optional/environment.html#configuration-using-environment-variables.`);
            strapi.config.set('admin.apiToken.salt', process.env.API_TOKEN_SALT);
        } else {
            throw new Error(`Missing apiToken.salt. Please set apiToken.salt in config/admin.js (ex: you can generate one using Node with \`crypto.randomBytes(16).toString('base64')\`).
For security reasons, prefer storing the secret in an environment variable and read it in config/admin.js. See https://docs.strapi.io/developer-docs/latest/setup-deployment-guides/configurations/optional/environment.html#configuration-using-environment-variables.`);
        }
    }
};
/**
 * Return a list of all tokens and their permissions
 */ const list$1 = async ()=>{
    const tokens = await strapi.db.query('admin::api-token').findMany({
        select: SELECT_FIELDS$1,
        populate: POPULATE_FIELDS$1,
        orderBy: {
            name: 'ASC'
        }
    });
    if (!tokens) {
        return tokens;
    }
    return tokens.map((token)=>flattenTokenPermissions$1(token));
};
/**
 * Revoke (delete) a token
 */ const revoke$1 = async (id)=>{
    return strapi.db.query('admin::api-token').delete({
        select: SELECT_FIELDS$1,
        populate: POPULATE_FIELDS$1,
        where: {
            id
        }
    });
};
/**
 * Retrieve a token by id
 */ const getById$1 = async (id)=>{
    return getBy$1({
        id
    });
};
/**
 * Retrieve a token by name
 */ const getByName$1 = async (name)=>{
    return getBy$1({
        name
    });
};
/**
 * Update a token and its permissions
 */ const update$1 = async (id, attributes)=>{
    // retrieve token without permissions
    const originalToken = await strapi.db.query('admin::api-token').findOne({
        where: {
            id
        }
    });
    if (!originalToken) {
        throw new NotFoundError$1('Token not found');
    }
    const changingTypeToCustom = attributes.type === constants$3.API_TOKEN_TYPE.CUSTOM && originalToken.type !== constants$3.API_TOKEN_TYPE.CUSTOM;
    // if we're updating the permissions on any token type, or changing from non-custom to custom, ensure they're still valid
    // if neither type nor permissions are changing, we don't need to validate again or else we can't allow partial update
    if (attributes.permissions || changingTypeToCustom) {
        assertCustomTokenPermissionsValidity(attributes.type || originalToken.type, attributes.permissions || originalToken.permissions);
    }
    assertValidLifespan$1(attributes.lifespan);
    const updatedToken = await strapi.db.query('admin::api-token').update({
        select: SELECT_FIELDS$1,
        where: {
            id
        },
        data: omit('permissions', attributes)
    });
    // custom tokens need to have their permissions updated as well
    if (updatedToken.type === constants$3.API_TOKEN_TYPE.CUSTOM && attributes.permissions) {
        const currentPermissionsResult = await strapi.db.query('admin::api-token').load(updatedToken, 'permissions');
        const currentPermissions = map('action', currentPermissionsResult || []);
        const newPermissions = uniq(attributes.permissions);
        const actionsToDelete = difference(currentPermissions, newPermissions);
        const actionsToAdd = difference(newPermissions, currentPermissions);
        // TODO: improve efficiency here
        // method using a loop -- works but very inefficient
        await Promise.all(actionsToDelete.map((action)=>strapi.db.query('admin::api-token-permission').delete({
                where: {
                    action,
                    token: id
                }
            })));
        // TODO: improve efficiency here
        // using a loop -- works but very inefficient
        await Promise.all(actionsToAdd.map((action)=>strapi.db.query('admin::api-token-permission').create({
                data: {
                    action,
                    token: id
                }
            })));
    } else if (updatedToken.type !== constants$3.API_TOKEN_TYPE.CUSTOM) {
        await strapi.db.query('admin::api-token-permission').delete({
            where: {
                token: id
            }
        });
    }
    // retrieve permissions
    const permissionsFromDb = await strapi.db.query('admin::api-token').load(updatedToken, 'permissions');
    return {
        ...updatedToken,
        permissions: permissionsFromDb ? permissionsFromDb.map((p)=>p.action) : undefined
    };
};
const count = async (where = {})=>{
    return strapi.db.query('admin::api-token').count({
        where
    });
};

var apiToken$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  checkSaltIsDefined: checkSaltIsDefined$1,
  count: count,
  create: create$1,
  exists: exists$1,
  getBy: getBy$1,
  getById: getById$1,
  getByName: getByName$1,
  hash: hash$1,
  list: list$1,
  regenerate: regenerate$1,
  revoke: revoke$1,
  update: update$1
});

const DEFAULT_TRANSFER_ACTIONS = [
    'push',
    'pull'
];
const providers = {
    action: providerFactory(),
    condition: providerFactory()
};
DEFAULT_TRANSFER_ACTIONS.forEach((action)=>{
    providers.action.register(action, {
        action
    });
});
const engine = permissions$1.engine.new({
    providers
});

var permission$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  engine: engine,
  providers: providers
});

const { ValidationError: ValidationError$3, NotFoundError } = errors;
const TRANSFER_TOKEN_UID = 'admin::transfer-token';
const TRANSFER_TOKEN_PERMISSION_UID = 'admin::transfer-token-permission';
const SELECT_FIELDS = [
    'id',
    'name',
    'description',
    'lastUsedAt',
    'lifespan',
    'expiresAt',
    'createdAt',
    'updatedAt'
];
const POPULATE_FIELDS = [
    'permissions'
];
/**
 * Return a list of all tokens and their permissions
 */ const list = async ()=>{
    const tokens = await strapi.db.query(TRANSFER_TOKEN_UID).findMany({
        select: SELECT_FIELDS,
        populate: POPULATE_FIELDS,
        orderBy: {
            name: 'ASC'
        }
    });
    if (!tokens) return tokens;
    return tokens.map((token)=>flattenTokenPermissions(token));
};
/**
 * Create a random token's access key
 */ const generateRandomAccessKey = ()=>crypto.randomBytes(128).toString('hex');
/**
 * Validate the given access key's format and returns it if valid
 */ const validateAccessKey = (accessKey)=>{
    assert(typeof accessKey === 'string', 'Access key needs to be a string');
    assert(accessKey.length >= 15, 'Access key needs to have at least 15 characters');
    return accessKey;
};
const hasAccessKey = (attributes)=>{
    return 'accessKey' in attributes;
};
/**
 * Create a token and its permissions
 */ const create = async (attributes)=>{
    const accessKey = hasAccessKey(attributes) ? validateAccessKey(attributes.accessKey) : generateRandomAccessKey();
    // Make sure the access key isn't picked up directly from the attributes for the next steps
    delete attributes.accessKey;
    assertTokenPermissionsValidity(attributes);
    assertValidLifespan(attributes.lifespan);
    const result = await strapi.db.transaction(async ()=>{
        const transferToken = await strapi.db.query(TRANSFER_TOKEN_UID).create({
            select: SELECT_FIELDS,
            populate: POPULATE_FIELDS,
            data: {
                ...omit('permissions', attributes),
                accessKey: hash(accessKey),
                ...getExpirationFields(attributes.lifespan)
            }
        });
        await Promise.all(uniq(attributes.permissions).map((action)=>strapi.db.query(TRANSFER_TOKEN_PERMISSION_UID).create({
                data: {
                    action,
                    token: transferToken
                }
            })));
        const currentPermissions = await strapi.db.query(TRANSFER_TOKEN_UID).load(transferToken, 'permissions');
        if (currentPermissions) {
            Object.assign(transferToken, {
                permissions: map('action', currentPermissions)
            });
        }
        return transferToken;
    });
    return {
        ...result,
        accessKey
    };
};
/**
 * Update a token and its permissions
 */ const update = async (id, attributes)=>{
    // retrieve token without permissions
    const originalToken = await strapi.db.query(TRANSFER_TOKEN_UID).findOne({
        where: {
            id
        }
    });
    if (!originalToken) {
        throw new NotFoundError('Token not found');
    }
    assertTokenPermissionsValidity(attributes);
    assertValidLifespan(attributes.lifespan);
    return strapi.db.transaction(async ()=>{
        const updatedToken = await strapi.db.query(TRANSFER_TOKEN_UID).update({
            select: SELECT_FIELDS,
            where: {
                id
            },
            data: {
                ...omit('permissions', attributes)
            }
        });
        if (attributes.permissions) {
            const currentPermissionsResult = await strapi.db.query(TRANSFER_TOKEN_UID).load(updatedToken, 'permissions');
            const currentPermissions = map('action', currentPermissionsResult || []);
            const newPermissions = uniq(attributes.permissions);
            const actionsToDelete = difference(currentPermissions, newPermissions);
            const actionsToAdd = difference(newPermissions, currentPermissions);
            // TODO: improve efficiency here
            // method using a loop -- works but very inefficient
            await Promise.all(actionsToDelete.map((action)=>strapi.db.query(TRANSFER_TOKEN_PERMISSION_UID).delete({
                    where: {
                        action,
                        token: id
                    }
                })));
            // TODO: improve efficiency here
            // using a loop -- works but very inefficient
            await Promise.all(actionsToAdd.map((action)=>strapi.db.query(TRANSFER_TOKEN_PERMISSION_UID).create({
                    data: {
                        action,
                        token: id
                    }
                })));
        }
        // retrieve permissions
        const permissionsFromDb = await strapi.db.query(TRANSFER_TOKEN_UID).load(updatedToken, 'permissions');
        return {
            ...updatedToken,
            permissions: permissionsFromDb ? permissionsFromDb.map((p)=>p.action) : undefined
        };
    });
};
/**
 * Revoke (delete) a token
 */ const revoke = async (id)=>{
    return strapi.db.transaction(async ()=>strapi.db.query(TRANSFER_TOKEN_UID).delete({
            select: SELECT_FIELDS,
            populate: POPULATE_FIELDS,
            where: {
                id
            }
        }));
};
/**
 *  Get a token
 */ const getBy = async (whereParams = {})=>{
    if (Object.keys(whereParams).length === 0) {
        return null;
    }
    const token = await strapi.db.query(TRANSFER_TOKEN_UID).findOne({
        select: SELECT_FIELDS,
        populate: POPULATE_FIELDS,
        where: whereParams
    });
    if (!token) {
        return token;
    }
    return flattenTokenPermissions(token);
};
/**
 * Retrieve a token by id
 */ const getById = async (id)=>{
    return getBy({
        id
    });
};
/**
 * Retrieve a token by name
 */ const getByName = async (name)=>{
    return getBy({
        name
    });
};
/**
 * Check if token exists
 */ const exists = async (whereParams = {})=>{
    const transferToken = await getBy(whereParams);
    return !!transferToken;
};
const regenerate = async (id)=>{
    const accessKey = crypto.randomBytes(128).toString('hex');
    const transferToken = await strapi.db.transaction(async ()=>strapi.db.query(TRANSFER_TOKEN_UID).update({
            select: [
                'id',
                'accessKey'
            ],
            where: {
                id
            },
            data: {
                accessKey: hash(accessKey)
            }
        }));
    if (!transferToken) {
        throw new NotFoundError('The provided token id does not exist');
    }
    return {
        ...transferToken,
        accessKey
    };
};
const getExpirationFields = (lifespan)=>{
    // it must be nil or a finite number >= 0
    const isValidNumber = isNumber(lifespan) && Number.isFinite(lifespan) && lifespan > 0;
    if (!isValidNumber && !isNil(lifespan)) {
        throw new ValidationError$3('lifespan must be a positive number or null');
    }
    return {
        lifespan: lifespan || null,
        expiresAt: lifespan ? Date.now() + lifespan : null
    };
};
/**
 * Return a secure sha512 hash of an accessKey
 */ const hash = (accessKey)=>{
    const { hasValidTokenSalt } = getService$1('transfer').utils;
    if (!hasValidTokenSalt()) {
        throw new TypeError('Required token salt is not defined');
    }
    return crypto.createHmac('sha512', strapi.config.get('admin.transfer.token.salt')).update(accessKey).digest('hex');
};
const checkSaltIsDefined = ()=>{
    const { hasValidTokenSalt } = getService$1('transfer').utils;
    // Ignore the check if the data-transfer feature is manually disabled
    if (!strapi.config.get('server.transfer.remote.enabled')) {
        return;
    }
    if (!hasValidTokenSalt()) {
        process.emitWarning(`Missing transfer.token.salt: Data transfer features have been disabled.
Please set transfer.token.salt in config/admin.js (ex: you can generate one using Node with \`crypto.randomBytes(16).toString('base64')\`)
For security reasons, prefer storing the secret in an environment variable and read it in config/admin.js. See https://docs.strapi.io/developer-docs/latest/setup-deployment-guides/configurations/optional/environment.html#configuration-using-environment-variables.`);
    }
};
/**
 * Flatten a token's database permissions objects to an array of strings
 */ const flattenTokenPermissions = (token)=>{
    if (!token) {
        return token;
    }
    return {
        ...token,
        permissions: isArray(token.permissions) ? map('action', token.permissions) : token.permissions
    };
};
/**
 * Assert that a token's permissions are valid
 */ const assertTokenPermissionsValidity = (attributes)=>{
    const permissionService = strapi.service('admin::transfer').permission;
    const validPermissions = permissionService.providers.action.keys();
    const invalidPermissions = difference(attributes.permissions, validPermissions);
    if (!isEmpty(invalidPermissions)) {
        throw new ValidationError$3(`Unknown permissions provided: ${invalidPermissions.join(', ')}`);
    }
};
/**
 * Check if a token's lifespan is valid
 */ const isValidLifespan = (lifespan)=>{
    if (isNil(lifespan)) {
        return true;
    }
    if (!isNumber(lifespan) || !Object.values(constants$3.TRANSFER_TOKEN_LIFESPANS).includes(lifespan)) {
        return false;
    }
    return true;
};
/**
 * Assert that a token's lifespan is valid
 */ const assertValidLifespan = (lifespan)=>{
    if (!isValidLifespan(lifespan)) {
        throw new ValidationError$3(`lifespan must be one of the following values:
      ${Object.values(constants$3.TRANSFER_TOKEN_LIFESPANS).join(', ')}`);
    }
};

var token$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  checkSaltIsDefined: checkSaltIsDefined,
  create: create,
  exists: exists,
  getBy: getBy,
  getById: getById,
  getByName: getByName,
  hasAccessKey: hasAccessKey,
  hash: hash,
  list: list,
  regenerate: regenerate,
  revoke: revoke,
  update: update
});

/**
 * A valid transfer token salt must be a non-empty string defined in the Strapi config
 */ const hasValidTokenSalt = ()=>{
    const salt = strapi.config.get('admin.transfer.token.salt', null);
    return typeof salt === 'string' && salt.length > 0;
};
/**
 * Checks whether data transfer features are enabled
 */ const isRemoteTransferEnabled = ()=>{
    const { utils } = getService$1('transfer');
    // TODO v6: Remove this warning
    if (env.bool('STRAPI_DISABLE_REMOTE_DATA_TRANSFER') !== undefined) {
        strapi.log.warn('STRAPI_DISABLE_REMOTE_DATA_TRANSFER is no longer supported. Instead, set transfer.remote.enabled to false in your server configuration');
    }
    return utils.hasValidTokenSalt() && strapi.config.get('server.transfer.remote.enabled');
};

var utils$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hasValidTokenSalt: hasValidTokenSalt,
  isRemoteTransferEnabled: isRemoteTransferEnabled
});

var transfer$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  permission: permission$1,
  token: token$2,
  utils: utils$1
});

const PROJECT_SETTINGS_FILE_INPUTS = [
    'menuLogo',
    'authLogo'
];
const parseFilesData = async (files)=>{
    const formatedFilesData = {};
    await Promise.all(PROJECT_SETTINGS_FILE_INPUTS.map(async (inputName)=>{
        const file = files[inputName];
        // Skip empty file inputs
        if (!file) {
            return;
        }
        const getStream = ()=>fs.createReadStream(file.filepath);
        // Add formated data for the upload provider
        formatedFilesData[inputName] = await strapi.plugin('upload').service('upload').formatFileInfo({
            filename: file.originalFilename,
            type: file.mimetype,
            size: file.size
        });
        // Add image dimensions
        Object.assign(formatedFilesData[inputName], await strapi.plugin('upload').service('image-manipulation').getDimensions({
            getStream
        }));
        // Add file path, and stream
        Object.assign(formatedFilesData[inputName], {
            stream: getStream(),
            tmpPath: file.filepath,
            // TODO
            // @ts-expect-error define the correct return type
            provider: strapi.config.get('plugin::upload').provider
        });
    }));
    return formatedFilesData;
};
const getProjectSettings = async ()=>{
    const store = strapi.store({
        type: 'core',
        name: 'admin'
    });
    // Returns an object with file inputs names as key and null as value
    const defaultProjectSettings = PROJECT_SETTINGS_FILE_INPUTS.reduce((prev, cur)=>{
        prev[cur] = null;
        return prev;
    }, {});
    const projectSettings = {
        ...defaultProjectSettings,
        // @ts-expect-error spread can be applied to return value
        ...await store.get({
            key: 'project-settings'
        })
    };
    // Filter file input fields
    PROJECT_SETTINGS_FILE_INPUTS.forEach((inputName)=>{
        if (!projectSettings[inputName]) {
            return;
        }
        projectSettings[inputName] = pick$1(projectSettings[inputName], [
            'name',
            'url',
            'width',
            'height',
            'ext',
            'size'
        ]);
    });
    return projectSettings;
};
const uploadFiles = async (files = {})=>{
    // Call the provider upload function for each file
    return Promise.all(Object.values(files).filter((file)=>file?.stream instanceof fs.ReadStream).map((file)=>strapi.plugin('upload').provider.uploadStream(file)));
};
const deleteOldFiles = async ({ previousSettings, newSettings })=>{
    return Promise.all(PROJECT_SETTINGS_FILE_INPUTS.map(async (inputName)=>{
        // Skip if the store doesn't contain project settings
        if (!previousSettings) {
            return;
        }
        // Skip if there was no previous file
        if (!previousSettings[inputName]) {
            return;
        }
        // Skip if the file was not changed
        if (newSettings[inputName] && previousSettings[inputName].hash === newSettings[inputName].hash) {
            return;
        }
        // Skip if the file was not uploaded with the current provider
        // TODO
        // @ts-expect-error define the correct return type
        if (strapi.config.get('plugin::upload').provider !== previousSettings[inputName].provider) {
            return;
        }
        // There was a previous file and an new file was uploaded
        // Remove the previous file
        strapi.plugin('upload').provider.delete(previousSettings[inputName]);
    }));
};
const updateProjectSettings$1 = async (newSettings)=>{
    const store = strapi.store({
        type: 'core',
        name: 'admin'
    });
    const previousSettings = await store.get({
        key: 'project-settings'
    });
    const files = pick$1(newSettings, PROJECT_SETTINGS_FILE_INPUTS);
    await uploadFiles(files);
    PROJECT_SETTINGS_FILE_INPUTS.forEach((inputName)=>{
        // If the user input exists but is not a formdata "file" remove it
        if (newSettings[inputName] !== undefined && !(typeof newSettings[inputName] === 'object')) {
            newSettings[inputName] = null;
            return;
        }
        // If the user input is undefined reuse previous setting (do not update field)
        if (!newSettings[inputName] && previousSettings) {
            newSettings[inputName] = previousSettings[inputName];
            return;
        }
        // Update the file
        newSettings[inputName] = pick$1(newSettings[inputName], [
            'name',
            'hash',
            'url',
            'width',
            'height',
            'ext',
            'size',
            'provider'
        ]);
    });
    // No await to proceed asynchronously
    deleteOldFiles({
        previousSettings,
        newSettings
    });
    await store.set({
        key: 'project-settings',
        value: {
            ...previousSettings,
            ...newSettings
        }
    });
    return getProjectSettings();
};

var projectSettings = /*#__PURE__*/Object.freeze({
  __proto__: null,
  deleteOldFiles: deleteOldFiles,
  getProjectSettings: getProjectSettings,
  parseFilesData: parseFilesData,
  updateProjectSettings: updateProjectSettings$1
});

const createHomepageService = ({ strapi })=>{
    const MAX_DOCUMENTS = 4;
    const metadataService = strapi.plugin('content-manager').service('document-metadata');
    const permissionService = strapi.admin.services.permission;
    const getConfiguration = async (contentTypeUids)=>{
        /**
     * Don't use the strapi.store util because we need to make
     * more precise queries than exact key matches, in order to make as few queries as possible.
     */ const coreStore = strapi.db.query('strapi::core-store');
        const rawConfigurations = await coreStore.findMany({
            where: {
                key: {
                    $in: contentTypeUids.map((contentType)=>`plugin_content_manager_configuration_content_types::${contentType}`)
                }
            }
        });
        return rawConfigurations.map((rawConfiguration)=>{
            return JSON.parse(rawConfiguration.value);
        });
    };
    const getPermittedContentTypes = async ()=>{
        const readPermissions = await permissionService.findMany({
            where: {
                role: {
                    users: {
                        id: strapi.requestContext.get()?.state?.user.id
                    }
                },
                action: 'plugin::content-manager.explorer.read'
            }
        });
        return readPermissions.map((permission)=>permission.subject).filter(Boolean);
    };
    const getContentTypesMeta = (allowedContentTypeUids, configurations)=>{
        return allowedContentTypeUids.map((uid)=>{
            const configuration = configurations.find((config)=>config.uid === uid);
            const contentType = strapi.contentType(uid);
            const fields = [
                'documentId',
                'updatedAt'
            ];
            // Add fields required to get the status if D&P is enabled
            const hasDraftAndPublish = contentTypes$1.hasDraftAndPublish(contentType);
            if (hasDraftAndPublish) {
                fields.push('publishedAt');
            }
            // Only add the main field if it's defined
            if (configuration?.settings.mainField) {
                fields.push(configuration.settings.mainField);
            }
            // Only add locale if it's localized
            const isLocalized = contentType.pluginOptions?.i18n?.localized;
            if (isLocalized) {
                fields.push('locale');
            }
            return {
                fields,
                mainField: configuration.settings.mainField,
                contentType,
                hasDraftAndPublish,
                uid
            };
        });
    };
    const formatDocuments = (documents, meta)=>{
        return documents.map((document)=>{
            return {
                documentId: document.documentId,
                locale: document.locale ?? null,
                updatedAt: new Date(document.updatedAt),
                title: document[meta.mainField ?? 'documentId'],
                publishedAt: meta.hasDraftAndPublish && document.publishedAt ? new Date(document.publishedAt) : null,
                contentTypeUid: meta.uid,
                contentTypeDisplayName: meta.contentType.info.displayName,
                kind: meta.contentType.kind
            };
        });
    };
    const addStatusToDocuments = async (documents)=>{
        return Promise.all(documents.map(async (recentDocument)=>{
            const hasDraftAndPublish = contentTypes$1.hasDraftAndPublish(strapi.contentType(recentDocument.contentTypeUid));
            /**
         * Tries to query the other version of the document if draft and publish is enabled,
         * so that we know when to give the "modified" status.
         */ const { availableStatus } = await metadataService.getMetadata(recentDocument.contentTypeUid, recentDocument, {
                availableStatus: hasDraftAndPublish,
                availableLocales: false
            });
            const status = metadataService.getStatus(recentDocument, availableStatus);
            return {
                ...recentDocument,
                status: hasDraftAndPublish ? status : undefined
            };
        }));
    };
    const permissionCheckerService = strapi.plugin('content-manager').service('permission-checker');
    const getPermissionChecker = (uid)=>permissionCheckerService.create({
            userAbility: strapi.requestContext.get()?.state.userAbility,
            model: uid
        });
    return {
        async getRecentlyPublishedDocuments () {
            const permittedContentTypes = await getPermittedContentTypes();
            const allowedContentTypeUids = permittedContentTypes.filter((uid)=>{
                return contentTypes$1.hasDraftAndPublish(strapi.contentType(uid));
            });
            // Fetch the configuration for each content type in a single query
            const configurations = await getConfiguration(allowedContentTypeUids);
            // Get the necessary metadata for the documents
            const contentTypesMeta = getContentTypesMeta(allowedContentTypeUids, configurations);
            // Now actually fetch and format the documents
            const recentDocuments = await Promise.all(contentTypesMeta.map(async (meta)=>{
                const permissionQuery = await getPermissionChecker(meta.uid).sanitizedQuery.read({
                    limit: MAX_DOCUMENTS,
                    sort: 'publishedAt:desc',
                    fields: meta.fields,
                    status: 'published'
                });
                const docs = await strapi.documents(meta.uid).findMany(permissionQuery);
                return formatDocuments(docs, meta);
            }));
            const overallRecentDocuments = recentDocuments.flat().sort((a, b)=>{
                if (!a.publishedAt || !b.publishedAt) return 0;
                return b.publishedAt.valueOf() - a.publishedAt.valueOf();
            }).slice(0, MAX_DOCUMENTS);
            return addStatusToDocuments(overallRecentDocuments);
        },
        async getRecentlyUpdatedDocuments () {
            const allowedContentTypeUids = await getPermittedContentTypes();
            // Fetch the configuration for each content type in a single query
            const configurations = await getConfiguration(allowedContentTypeUids);
            // Get the necessary metadata for the documents
            const contentTypesMeta = getContentTypesMeta(allowedContentTypeUids, configurations);
            // Now actually fetch and format the documents
            const recentDocuments = await Promise.all(contentTypesMeta.map(async (meta)=>{
                const permissionQuery = await getPermissionChecker(meta.uid).sanitizedQuery.read({
                    limit: MAX_DOCUMENTS,
                    sort: 'updatedAt:desc',
                    fields: meta.fields
                });
                const docs = await strapi.documents(meta.uid).findMany(permissionQuery);
                return formatDocuments(docs, meta);
            }));
            const overallRecentDocuments = recentDocuments.flat().sort((a, b)=>{
                return b.updatedAt.valueOf() - a.updatedAt.valueOf();
            }).slice(0, MAX_DOCUMENTS);
            return addStatusToDocuments(overallRecentDocuments);
        }
    };
};

// NOTE: Make sure to use default export for services overwritten in EE
// TODO: TS - Export services one by one as this export is cjs
var services$1 = {
    auth: auth$1,
    user: user$3,
    role: role$3,
    passport: passport$1,
    token: token$3,
    permission: permission$2,
    metrics: metrics$1,
    'content-type': contentType,
    constants: constants$4,
    condition,
    action,
    'api-token': apiToken$2,
    transfer: transfer$1,
    'project-settings': projectSettings,
    homepage: createHomepageService
};

const MAX_IMAGE_WIDTH = 750;
const MAX_IMAGE_HEIGHT = MAX_IMAGE_WIDTH;
const MAX_IMAGE_FILE_SIZE = 1024 * 1024; // 1Mo
const updateProjectSettings = z.object({
    menuLogo: z.string().nullish(),
    authLogo: z.string().nullish()
}).strict();
const updateProjectSettingsLogo = z.object({
    originalFilename: z.string().nullish(),
    mimetype: z.enum([
        'image/jpeg',
        'image/png',
        'image/svg+xml'
    ]),
    size: z.number().max(MAX_IMAGE_FILE_SIZE).nullish()
});
const updateProjectSettingsFiles = z.object({
    menuLogo: updateProjectSettingsLogo.nullish(),
    authLogo: updateProjectSettingsLogo.nullish()
}).strict();
const logoDimensions = z.object({
    width: z.number().max(MAX_IMAGE_WIDTH).nullish(),
    height: z.number().max(MAX_IMAGE_HEIGHT).nullish()
});
const updateProjectSettingsImagesDimensions = z.object({
    menuLogo: logoDimensions.nullish(),
    authLogo: logoDimensions.nullish()
}).strict();
const validateUpdateProjectSettings = validateZod(updateProjectSettings);
const validateUpdateProjectSettingsFiles = validateZod(updateProjectSettingsFiles);
const validateUpdateProjectSettingsImagesDimensions = validateZod(updateProjectSettingsImagesDimensions);

const { isUsingTypeScript } = tsUtils;
/**
 * A set of functions called "actions" for `Admin`
 */ var admin$3 = {
    // TODO very temporary to check the switch ee/ce
    // When removing this we need to update the /admin/src/index.js file
    // whe,re we set the strapi.window.isEE value
    // NOTE: admin/ee/server overrides this controller, and adds the EE features
    // This returns an empty feature list for CE
    async getProjectType () {
        const flags = strapi.config.get('admin.flags', {});
        return {
            data: {
                isEE: false,
                features: [],
                flags
            }
        };
    },
    async init () {
        let uuid = strapi.config.get('uuid', false);
        const hasAdmin = await getService$1('user').exists();
        const { menuLogo, authLogo } = await getService$1('project-settings').getProjectSettings();
        // set to null if telemetryDisabled flag not avaialble in package.json
        const telemetryDisabled = strapi.config.get('packageJsonStrapi.telemetryDisabled', null);
        if (telemetryDisabled !== null && telemetryDisabled === true) {
            uuid = false;
        }
        return {
            data: {
                uuid,
                hasAdmin,
                menuLogo: menuLogo ? menuLogo.url : null,
                authLogo: authLogo ? authLogo.url : null
            }
        };
    },
    async getProjectSettings () {
        return getService$1('project-settings').getProjectSettings();
    },
    async updateProjectSettings (ctx) {
        const { request: { files, body } } = ctx;
        const projectSettingsService = getService$1('project-settings');
        await validateUpdateProjectSettings(body);
        await validateUpdateProjectSettingsFiles(files);
        const formatedFiles = await projectSettingsService.parseFilesData(files);
        await validateUpdateProjectSettingsImagesDimensions(formatedFiles);
        return projectSettingsService.updateProjectSettings({
            ...body,
            ...formatedFiles
        });
    },
    async telemetryProperties (ctx) {
        // If the telemetry is disabled, ignore the request and return early
        if (strapi.telemetry.isDisabled) {
            ctx.status = 204;
            return;
        }
        const useTypescriptOnServer = await isUsingTypeScript(strapi.dirs.app.root);
        const useTypescriptOnAdmin = await isUsingTypeScript(path.join(strapi.dirs.app.root, 'src', 'admin'));
        const isHostedOnStrapiCloud = env('STRAPI_HOSTING', null) === 'strapi.cloud';
        const numberOfAllContentTypes = ___default.size(strapi.contentTypes);
        const numberOfComponents = ___default.size(strapi.components);
        const getNumberOfDynamicZones = ()=>{
            return pipe(map('attributes'), flatMap(values), // @ts-expect-error lodash types
            sumBy(propEq('type', 'dynamiczone')))(strapi.contentTypes);
        };
        return {
            data: {
                useTypescriptOnServer,
                useTypescriptOnAdmin,
                isHostedOnStrapiCloud,
                numberOfAllContentTypes,
                numberOfComponents,
                numberOfDynamicZones: getNumberOfDynamicZones()
            }
        };
    },
    async information () {
        const currentEnvironment = strapi.config.get('environment');
        const autoReload = strapi.config.get('autoReload', false);
        const strapiVersion = strapi.config.get('info.strapi', null);
        const dependencies = strapi.config.get('info.dependencies', {});
        const projectId = strapi.config.get('uuid', null);
        const nodeVersion = process.version;
        const communityEdition = !strapi.EE;
        const useYarn = await exists$4(path.join(process.cwd(), 'yarn.lock'));
        return {
            data: {
                currentEnvironment,
                autoReload,
                strapiVersion,
                dependencies,
                projectId,
                nodeVersion,
                communityEdition,
                useYarn
            }
        };
    },
    async plugins (ctx) {
        const enabledPlugins = strapi.config.get('enabledPlugins');
        // List of core plugins that are always enabled,
        // and so it's not necessary to display them in the plugins list
        const CORE_PLUGINS = [
            'content-manager',
            'content-type-builder',
            'email',
            'upload',
            'i18n',
            'content-releases',
            'review-workflows'
        ];
        const plugins = Object.entries(enabledPlugins).filter(([key])=>!CORE_PLUGINS.includes(key)).map(([key, plugin])=>({
                name: plugin.info.name || key,
                displayName: plugin.info.displayName || plugin.info.name || key,
                description: plugin.info.description || '',
                packageName: plugin.info.packageName
            }));
        ctx.send({
            plugins
        });
    }
};

const apiTokenCreationSchema = yup$1.object().shape({
    name: yup$1.string().min(1).required(),
    description: yup$1.string().optional(),
    type: yup$1.string().oneOf(Object.values(constants$3.API_TOKEN_TYPE)).required(),
    permissions: yup$1.array().of(yup$1.string()).nullable(),
    lifespan: yup$1.number().min(1).oneOf(Object.values(constants$3.API_TOKEN_LIFESPANS)).nullable()
}).noUnknown().strict();
const apiTokenUpdateSchema = yup$1.object().shape({
    name: yup$1.string().min(1).notNull(),
    description: yup$1.string().nullable(),
    type: yup$1.string().oneOf(Object.values(constants$3.API_TOKEN_TYPE)).notNull(),
    permissions: yup$1.array().of(yup$1.string()).nullable()
}).noUnknown().strict();
const validateApiTokenCreationInput = validateYupSchema(apiTokenCreationSchema);
const validateApiTokenUpdateInput = validateYupSchema(apiTokenUpdateSchema);

const { ApplicationError: ApplicationError$7 } = errors;
var apiToken$1 = {
    async create (ctx) {
        const { body } = ctx.request;
        const apiTokenService = getService$1('api-token');
        /**
     * We trim both field to avoid having issues with either:
     * - having a space at the end or start of the value.
     * - having only spaces as value;
     */ const attributes = {
            name: trim(body.name),
            description: trim(body.description),
            type: body.type,
            permissions: body.permissions,
            lifespan: body.lifespan
        };
        await validateApiTokenCreationInput(attributes);
        const alreadyExists = await apiTokenService.exists({
            name: attributes.name
        });
        if (alreadyExists) {
            throw new ApplicationError$7('Name already taken');
        }
        const apiToken = await apiTokenService.create(attributes);
        ctx.created({
            data: apiToken
        });
    },
    async regenerate (ctx) {
        const { id } = ctx.params;
        const apiTokenService = getService$1('api-token');
        const apiTokenExists = await apiTokenService.getById(id);
        if (!apiTokenExists) {
            ctx.notFound('API Token not found');
            return;
        }
        const accessToken = await apiTokenService.regenerate(id);
        ctx.created({
            data: accessToken
        });
    },
    async list (ctx) {
        const apiTokenService = getService$1('api-token');
        const apiTokens = await apiTokenService.list();
        ctx.send({
            data: apiTokens
        });
    },
    async revoke (ctx) {
        const { id } = ctx.params;
        const apiTokenService = getService$1('api-token');
        const apiToken = await apiTokenService.revoke(id);
        ctx.deleted({
            data: apiToken
        });
    },
    async get (ctx) {
        const { id } = ctx.params;
        const apiTokenService = getService$1('api-token');
        const apiToken = await apiTokenService.getById(id);
        if (!apiToken) {
            ctx.notFound('API Token not found');
            return;
        }
        ctx.send({
            data: apiToken
        });
    },
    async update (ctx) {
        const { body } = ctx.request;
        const { id } = ctx.params;
        const apiTokenService = getService$1('api-token');
        const attributes = body;
        /**
     * We trim both field to avoid having issues with either:
     * - having a space at the end or start of the value.
     * - having only spaces as value;
     */ if (has('name', attributes)) {
            attributes.name = trim(body.name);
        }
        if (has('description', attributes) || attributes.description === null) {
            attributes.description = trim(body.description);
        }
        await validateApiTokenUpdateInput(attributes);
        const apiTokenExists = await apiTokenService.getById(id);
        if (!apiTokenExists) {
            return ctx.notFound('API Token not found');
        }
        if (has('name', attributes)) {
            const nameAlreadyTaken = await apiTokenService.getByName(attributes.name);
            /**
       * We cast the ids as string as the one coming from the ctx isn't cast
       * as a Number in case it is supposed to be an integer. It remains
       * as a string. This way we avoid issues with integers in the db.
       */ if (!!nameAlreadyTaken && !strings.isEqual(nameAlreadyTaken.id, id)) {
                throw new ApplicationError$7('Name already taken');
            }
        }
        const apiToken = await apiTokenService.update(id, attributes);
        ctx.send({
            data: apiToken
        });
    },
    async getLayout (ctx) {
        const apiTokenService = getService$1('api-token');
        // TODO
        // @ts-expect-error remove this controller if not used
        const layout = await apiTokenService.getApiTokenLayout();
        ctx.send({
            data: layout
        });
    }
};

const userCreationSchema = yup$1.object().shape({
    email: validators.email.required(),
    firstname: validators.firstname.required(),
    lastname: validators.lastname,
    roles: validators.roles.min(1),
    preferedLanguage: yup$1.string().nullable()
}).noUnknown();
const profileUpdateSchema = yup$1.object().shape({
    email: validators.email.notNull(),
    firstname: validators.firstname.notNull(),
    lastname: validators.lastname.nullable(),
    username: validators.username.nullable(),
    password: validators.password.notNull(),
    currentPassword: yup$1.string().when('password', (password, schema)=>!isUndefined(password) ? schema.required() : schema).notNull(),
    preferedLanguage: yup$1.string().nullable()
}).noUnknown();
const userUpdateSchema = yup$1.object().shape({
    email: validators.email.notNull(),
    firstname: validators.firstname.notNull(),
    lastname: validators.lastname.nullable(),
    username: validators.username.nullable(),
    password: validators.password.notNull(),
    isActive: yup$1.bool().notNull(),
    roles: validators.roles.min(1).notNull()
}).noUnknown();
const usersDeleteSchema = yup$1.object().shape({
    ids: yup$1.array().of(yup$1.strapiID()).min(1).required()
}).noUnknown();
const validateUserCreationInput$1 = validateYupSchema(userCreationSchema);
const validateProfileUpdateInput = validateYupSchema(profileUpdateSchema);
const validateUserUpdateInput = validateYupSchema(userUpdateSchema);
const validateUsersDeleteInput = validateYupSchema(usersDeleteSchema);
const schemas = {
    userCreationSchema,
    usersDeleteSchema,
    userUpdateSchema
};

var authenticatedUser = {
    async getMe (ctx) {
        const userInfo = getService$1('user').sanitizeUser(ctx.state.user);
        ctx.body = {
            data: userInfo
        };
    },
    async updateMe (ctx) {
        const input = ctx.request.body;
        await validateProfileUpdateInput(input);
        const userService = getService$1('user');
        const authServer = getService$1('auth');
        const { currentPassword, ...userInfo } = input;
        if (currentPassword && userInfo.password) {
            const isValid = await authServer.validatePassword(currentPassword, ctx.state.user.password);
            if (!isValid) {
                return ctx.badRequest('ValidationError', {
                    currentPassword: [
                        'Invalid credentials'
                    ]
                });
            }
        }
        const updatedUser = await userService.updateById(ctx.state.user.id, userInfo);
        ctx.body = {
            data: userService.sanitizeUser(updatedUser)
        };
    },
    async getOwnPermissions (ctx) {
        const { findUserPermissions, sanitizePermission } = getService$1('permission');
        const { user } = ctx.state;
        const userPermissions = await findUserPermissions(user);
        ctx.body = {
            // @ts-expect-error - transform response type to sanitized permission
            data: userPermissions.map(sanitizePermission)
        };
    }
};

const registrationSchema = yup$1.object().shape({
    registrationToken: yup$1.string().required(),
    userInfo: yup$1.object().shape({
        firstname: validators.firstname.required(),
        lastname: validators.lastname.nullable(),
        password: validators.password.required()
    }).required().noUnknown()
}).noUnknown();
const registrationInfoQuerySchema = yup$1.object().shape({
    registrationToken: yup$1.string().required()
}).required().noUnknown();
const adminRegistrationSchema = yup$1.object().shape({
    email: validators.email.required(),
    firstname: validators.firstname.required(),
    lastname: validators.lastname.nullable(),
    password: validators.password.required()
}).required().noUnknown();
const validateRegistrationInput = validateYupSchema(registrationSchema);
const validateRegistrationInfoQuery = validateYupSchema(registrationInfoQuerySchema);
const validateAdminRegistrationInput = validateYupSchema(adminRegistrationSchema);

const forgotPasswordSchema = yup$1.object().shape({
    email: validators.email.required()
}).required().noUnknown();
var validateForgotPasswordInput = validateYupSchema(forgotPasswordSchema);

const resetPasswordSchema = yup$1.object().shape({
    resetPasswordToken: yup$1.string().required(),
    password: validators.password.required()
}).required().noUnknown();
var validateResetPasswordInput = validateYupSchema(resetPasswordSchema);

const renewToken = yup$1.object().shape({
    token: yup$1.string().required()
}).required().noUnknown();
var validateRenewTokenInput = validateYupSchema(renewToken);

const { ApplicationError: ApplicationError$6, ValidationError: ValidationError$2 } = errors;
var authentication$1 = {
    login: compose([
        (ctx, next)=>{
            return passport$2.authenticate('local', {
                session: false
            }, (err, user, info)=>{
                if (err) {
                    strapi.eventHub.emit('admin.auth.error', {
                        error: err,
                        provider: 'local'
                    });
                    // if this is a recognized error, allow it to bubble up to user
                    if (err.details?.code === 'LOGIN_NOT_ALLOWED') {
                        throw err;
                    }
                    // for all other errors throw a generic error to prevent leaking info
                    return ctx.notImplemented();
                }
                if (!user) {
                    strapi.eventHub.emit('admin.auth.error', {
                        error: new Error(info.message),
                        provider: 'local'
                    });
                    throw new ApplicationError$6(info.message);
                }
                const query = ctx.state;
                query.user = user;
                const sanitizedUser = getService$1('user').sanitizeUser(user);
                strapi.eventHub.emit('admin.auth.success', {
                    user: sanitizedUser,
                    provider: 'local'
                });
                return next();
            })(ctx, next);
        },
        (ctx)=>{
            const { user } = ctx.state;
            ctx.body = {
                data: {
                    token: getService$1('token').createJwtToken(user),
                    user: getService$1('user').sanitizeUser(ctx.state.user)
                }
            };
        }
    ]),
    async renewToken (ctx) {
        await validateRenewTokenInput(ctx.request.body);
        const { token } = ctx.request.body;
        const { isValid, payload } = getService$1('token').decodeJwtToken(token);
        if (!isValid) {
            throw new ValidationError$2('Invalid token');
        }
        ctx.body = {
            data: {
                token: getService$1('token').createJwtToken({
                    id: payload.id
                })
            }
        };
    },
    async registrationInfo (ctx) {
        await validateRegistrationInfoQuery(ctx.request.query);
        const { registrationToken } = ctx.request.query;
        const registrationInfo = await getService$1('user').findRegistrationInfo(registrationToken);
        if (!registrationInfo) {
            throw new ValidationError$2('Invalid registrationToken');
        }
        ctx.body = {
            data: registrationInfo
        };
    },
    async register (ctx) {
        const input = ctx.request.body;
        await validateRegistrationInput(input);
        const user = await getService$1('user').register(input);
        ctx.body = {
            data: {
                token: getService$1('token').createJwtToken(user),
                user: getService$1('user').sanitizeUser(user)
            }
        };
    },
    async registerAdmin (ctx) {
        const input = ctx.request.body;
        await validateAdminRegistrationInput(input);
        const hasAdmin = await getService$1('user').exists();
        if (hasAdmin) {
            throw new ApplicationError$6('You cannot register a new super admin');
        }
        const superAdminRole = await getService$1('role').getSuperAdmin();
        if (!superAdminRole) {
            throw new ApplicationError$6("Cannot register the first admin because the super admin role doesn't exist.");
        }
        const user = await getService$1('user').create({
            ...input,
            registrationToken: null,
            isActive: true,
            roles: superAdminRole ? [
                superAdminRole.id
            ] : []
        });
        strapi.telemetry.send('didCreateFirstAdmin');
        ctx.body = {
            data: {
                token: getService$1('token').createJwtToken(user),
                user: getService$1('user').sanitizeUser(user)
            }
        };
    },
    async forgotPassword (ctx) {
        const input = ctx.request.body;
        await validateForgotPasswordInput(input);
        getService$1('auth').forgotPassword(input);
        ctx.status = 204;
    },
    async resetPassword (ctx) {
        const input = ctx.request.body;
        await validateResetPasswordInput(input);
        const user = await getService$1('auth').resetPassword(input);
        ctx.body = {
            data: {
                token: getService$1('token').createJwtToken(user),
                user: getService$1('user').sanitizeUser(user)
            }
        };
    },
    logout (ctx) {
        const sanitizedUser = getService$1('user').sanitizeUser(ctx.state.user);
        strapi.eventHub.emit('admin.logout', {
            user: sanitizedUser
        });
        ctx.body = {
            data: {}
        };
    }
};

// visible fields for the API
const publicFields = [
    'id',
    'displayName',
    'category'
];
const formatConditions = map(pick(publicFields));

var permission = {
    /**
   * Check each permissions from `request.body.permissions` and returns an array of booleans
   * @param {KoaContext} ctx - koa context
   */ async check (ctx) {
        const { body: input } = ctx.request;
        const { userAbility } = ctx.state;
        await validateCheckPermissionsInput(input);
        const { engine } = getService$1('permission');
        const checkPermissionsFn = engine.checkMany(userAbility);
        ctx.body = {
            data: checkPermissionsFn(input.permissions)
        };
    },
    /**
   * Returns every permissions, in nested format
   * @param {KoaContext} ctx - koa context
   */ async getAll (ctx) {
        const { sectionsBuilder, actionProvider, conditionProvider } = getService$1('permission');
        const actions = actionProvider.values();
        const conditions = conditionProvider.values();
        const sections = await sectionsBuilder.build(actions);
        ctx.body = {
            data: {
                // @ts-expect-error - refactor to use a proper type
                conditions: formatConditions(conditions),
                sections
            }
        };
    }
};

const roleCreateSchema$1 = yup$1.object().shape({
    name: yup$1.string().min(1).required(),
    description: yup$1.string().nullable()
}).noUnknown();
const rolesDeleteSchema$1 = yup$1.object().shape({
    ids: yup$1.array().of(yup$1.strapiID()).min(1).required().test('roles-deletion-checks', 'Roles deletion checks have failed', async function(ids) {
        try {
            await strapi.service('admin::role').checkRolesIdForDeletion(ids);
        } catch (e) {
            // @ts-expect-error yup types
            return this.createError({
                path: 'ids',
                message: e.message
            });
        }
        return true;
    })
}).noUnknown();
const roleDeleteSchema$1 = yup$1.strapiID().required().test('no-admin-single-delete', 'Role deletion checks have failed', async function(id) {
    try {
        await strapi.service('admin::role').checkRolesIdForDeletion([
            id
        ]);
    } catch (e) {
        // @ts-expect-error yup types
        return this.createError({
            path: 'id',
            message: e.message
        });
    }
    return true;
});
const roleUpdateSchema = yup$1.object().shape({
    name: yup$1.string().min(1),
    description: yup$1.string().nullable()
}).noUnknown();
const validateRoleCreateInput$1 = validateYupSchema(roleCreateSchema$1);
const validateRoleUpdateInput = validateYupSchema(roleUpdateSchema);
const validateRolesDeleteInput$1 = validateYupSchema(rolesDeleteSchema$1);
const validateRoleDeleteInput$1 = validateYupSchema(roleDeleteSchema$1);

const { ApplicationError: ApplicationError$5 } = errors;
const { SUPER_ADMIN_CODE: SUPER_ADMIN_CODE$2 } = constants$3;
var role$2 = {
    /**
   * Create a new role
   * @param {KoaContext} ctx - koa context
   */ async create (ctx) {
        const { body } = ctx.request;
        await validateRoleCreateInput$1(body);
        const roleService = getService$1('role');
        const role = await roleService.create(body);
        const sanitizedRole = roleService.sanitizeRole(role);
        ctx.created({
            data: sanitizedRole
        });
    },
    /**
   * Returns on role by id
   * @param {KoaContext} ctx - koa context
   */ async findOne (ctx) {
        const { id } = ctx.params;
        const role = await getService$1('role').findOneWithUsersCount({
            id
        });
        if (!role) {
            return ctx.notFound('role.notFound');
        }
        ctx.body = {
            data: role
        };
    },
    /**
   * Returns every roles
   * @param {KoaContext} ctx - koa context
   */ async findAll (ctx) {
        const { query } = ctx.request;
        const permissionsManager = getService$1('permission').createPermissionsManager({
            ability: ctx.state.userAbility,
            model: 'admin::role'
        });
        await permissionsManager.validateQuery(query);
        const sanitizedQuery = await permissionsManager.sanitizeQuery(query);
        const roles = await getService$1('role').findAllWithUsersCount(sanitizedQuery);
        ctx.body = {
            data: roles
        };
    },
    /**
   * Updates a role by id
   * @param {KoaContext} ctx - koa context
   */ async update (ctx) {
        const { id } = ctx.params;
        const { body } = ctx.request;
        const roleService = getService$1('role');
        await validateRoleUpdateInput(body);
        const role = await roleService.findOne({
            id
        });
        if (!role) {
            return ctx.notFound('role.notFound');
        }
        if (role.code === SUPER_ADMIN_CODE$2) {
            throw new ApplicationError$5("Super admin can't be edited.");
        }
        const updatedRole = await roleService.update({
            id
        }, body);
        const sanitizedRole = roleService.sanitizeRole(updatedRole);
        ctx.body = {
            data: sanitizedRole
        };
    },
    /**
   * Returns the permissions assigned to a role
   * @param {KoaContext} ctx - koa context
   */ async getPermissions (ctx) {
        const { id } = ctx.params;
        const roleService = getService$1('role');
        const permissionService = getService$1('permission');
        const role = await roleService.findOne({
            id
        });
        if (!role) {
            return ctx.notFound('role.notFound');
        }
        const permissions = await permissionService.findMany({
            where: {
                role: {
                    id: role.id
                }
            }
        });
        const sanitizedPermissions = permissions.map(permissionService.sanitizePermission);
        ctx.body = {
            // @ts-expect-error - transform response type to sanitized permission
            data: sanitizedPermissions
        };
    },
    /**
   * Updates the permissions assigned to a role
   * @param {KoaContext} ctx - koa context
   */ async updatePermissions (ctx) {
        const { id } = ctx.params;
        const { body: input } = ctx.request;
        const roleService = getService$1('role');
        const permissionService = getService$1('permission');
        const role = await roleService.findOne({
            id
        });
        if (!role) {
            return ctx.notFound('role.notFound');
        }
        if (role.code === SUPER_ADMIN_CODE$2) {
            throw new ApplicationError$5("Super admin permissions can't be edited.");
        }
        await validatedUpdatePermissionsInput(input);
        if (!role) {
            return ctx.notFound('role.notFound');
        }
        const permissions = await roleService.assignPermissions(role.id, input.permissions);
        const sanitizedPermissions = permissions.map(permissionService.sanitizePermission);
        ctx.body = {
            data: sanitizedPermissions
        };
    },
    /**
   * Delete a role
   * @param {KoaContext} ctx - koa context
   */ async deleteOne (ctx) {
        const { id } = ctx.params;
        await validateRoleDeleteInput$1(id);
        const roleService = getService$1('role');
        const roles = await roleService.deleteByIds([
            id
        ]);
        const sanitizedRole = roles.map((role)=>roleService.sanitizeRole(role))[0] || null;
        return ctx.deleted({
            data: sanitizedRole
        });
    },
    /**
   * delete several roles
   * @param {KoaContext} ctx - koa context
   */ async deleteMany (ctx) {
        const { body } = ctx.request;
        await validateRolesDeleteInput$1(body);
        const roleService = getService$1('role');
        const roles = await roleService.deleteByIds(body.ids);
        const sanitizedRoles = roles.map(roleService.sanitizeRole);
        return ctx.deleted({
            data: sanitizedRoles
        });
    }
};

const { remote: { handlers: { createPushController, createPullController } } } = strapi$1;
const { UnauthorizedError: UnauthorizedError$1 } = errors;
/**
 * @param ctx the koa context
 * @param scope the scope to verify
 */ const verify = async (ctx, scope)=>{
    const { auth } = ctx.state;
    if (!auth) {
        throw new UnauthorizedError$1();
    }
    await dataTransferAuthStrategy.verify(auth, {
        scope
    });
};
const push = createPushController({
    verify
});
const pull = createPullController({
    verify
});
var runner = {
    push,
    pull
};

const transferTokenCreationSchema = yup$1.object().shape({
    name: yup$1.string().min(1).required(),
    description: yup$1.string().optional(),
    permissions: yup$1.array().min(1).of(yup$1.string().oneOf(Object.values(constants$3.TRANSFER_TOKEN_TYPE))).required(),
    lifespan: yup$1.number().min(1).oneOf(Object.values(constants$3.TRANSFER_TOKEN_LIFESPANS)).nullable()
}).noUnknown().strict();
const transferTokenUpdateSchema = yup$1.object().shape({
    name: yup$1.string().min(1).notNull(),
    description: yup$1.string().nullable(),
    permissions: yup$1.array().min(1).of(yup$1.string().oneOf(Object.values(constants$3.TRANSFER_TOKEN_TYPE))).nullable()
}).noUnknown().strict();
const validateTransferTokenCreationInput$1 = validateYupSchema(transferTokenCreationSchema);
const validateTransferTokenUpdateInput$1 = validateYupSchema(transferTokenUpdateSchema);
var token$1 = {
    validateTransferTokenCreationInput: validateTransferTokenCreationInput$1,
    validateTransferTokenUpdateInput: validateTransferTokenUpdateInput$1
};

const { ApplicationError: ApplicationError$4 } = errors;
const { validateTransferTokenCreationInput, validateTransferTokenUpdateInput } = token$1;
var token = {
    async list (ctx) {
        const transferService = getService$1('transfer');
        const transferTokens = await transferService.token.list();
        ctx.body = {
            data: transferTokens
        };
    },
    async getById (ctx) {
        const { id } = ctx.params;
        const tokenService = getService$1('transfer').token;
        const transferToken = await tokenService.getById(id);
        if (!transferToken) {
            ctx.notFound('Transfer token not found');
            return;
        }
        ctx.body = {
            data: transferToken
        };
    },
    async create (ctx) {
        const { body } = ctx.request;
        const { token: tokenService } = getService$1('transfer');
        /**
     * We trim fields to avoid having issues with either:
     * - having a space at the end or start of the value
     * - having only spaces as value (so that an empty field can be caught in validation)
     */ const attributes = {
            name: trim(body.name),
            description: trim(body.description),
            permissions: body.permissions,
            lifespan: body.lifespan
        };
        await validateTransferTokenCreationInput(attributes);
        const alreadyExists = await tokenService.exists({
            name: attributes.name
        });
        if (alreadyExists) {
            throw new ApplicationError$4('Name already taken');
        }
        const transferTokens = await tokenService.create(attributes);
        ctx.created({
            data: transferTokens
        });
    },
    async update (ctx) {
        const { body } = ctx.request;
        const { id } = ctx.params;
        const { token: tokenService } = getService$1('transfer');
        const attributes = body;
        /**
     * We trim fields to avoid having issues with either:
     * - having a space at the end or start of the value
     * - having only spaces as value (so that an empty field can be caught in validation)
     */ if (has('name', attributes)) {
            attributes.name = trim(body.name);
        }
        if (has('description', attributes) || attributes.description === null) {
            attributes.description = trim(body.description);
        }
        await validateTransferTokenUpdateInput(attributes);
        const apiTokenExists = await tokenService.getById(id);
        if (!apiTokenExists) {
            return ctx.notFound('Transfer token not found');
        }
        if (has('name', attributes)) {
            const nameAlreadyTaken = await tokenService.getByName(attributes.name);
            /**
       * We cast the ids as string as the one coming from the ctx isn't cast
       * as a Number in case it is supposed to be an integer. It remains
       * as a string. This way we avoid issues with integers in the db.
       */ if (!!nameAlreadyTaken && !strings.isEqual(nameAlreadyTaken.id, id)) {
                throw new ApplicationError$4('Name already taken');
            }
        }
        const apiToken = await tokenService.update(id, attributes);
        ctx.body = {
            data: apiToken
        };
    },
    async revoke (ctx) {
        const { id } = ctx.params;
        const { token: tokenService } = getService$1('transfer');
        const transferToken = await tokenService.revoke(id);
        ctx.deleted({
            data: transferToken
        });
    },
    async regenerate (ctx) {
        const { id } = ctx.params;
        const { token: tokenService } = getService$1('transfer');
        const exists = await tokenService.getById(id);
        if (!exists) {
            ctx.notFound('Transfer token not found');
            return;
        }
        const accessToken = await tokenService.regenerate(id);
        ctx.created({
            data: accessToken
        });
    }
};

const prefixActionsName = (prefix, dict)=>mapKeys((key)=>`${prefix}-${key}`, dict);
var transfer = {
    ...prefixActionsName('runner', runner),
    ...prefixActionsName('token', token)
};

const { ApplicationError: ApplicationError$3 } = errors;
var user$2 = {
    async create (ctx) {
        const { body } = ctx.request;
        const cleanData = {
            ...body,
            email: _.get(body, `email`, ``).toLowerCase()
        };
        await validateUserCreationInput$1(cleanData);
        const attributes = _.pick(cleanData, [
            'firstname',
            'lastname',
            'email',
            'roles',
            'preferedLanguage'
        ]);
        const userAlreadyExists = await getService$1('user').exists({
            email: attributes.email
        });
        if (userAlreadyExists) {
            throw new ApplicationError$3('Email already taken');
        }
        const createdUser = await getService$1('user').create(attributes);
        const userInfo = getService$1('user').sanitizeUser(createdUser);
        // Note: We need to assign manually the registrationToken to the
        // final user payload so that it's not removed in the sanitation process.
        Object.assign(userInfo, {
            registrationToken: createdUser.registrationToken
        });
        // Send 201 created
        ctx.created({
            data: userInfo
        });
    },
    async find (ctx) {
        const userService = getService$1('user');
        const permissionsManager = strapi.service('admin::permission').createPermissionsManager({
            ability: ctx.state.userAbility,
            model: 'admin::user'
        });
        await permissionsManager.validateQuery(ctx.query);
        const sanitizedQuery = await permissionsManager.sanitizeQuery(ctx.query);
        // @ts-expect-error update the service type
        const { results, pagination } = await userService.findPage(sanitizedQuery);
        ctx.body = {
            data: {
                results: results.map((user)=>userService.sanitizeUser(user)),
                pagination
            }
        };
    },
    async findOne (ctx) {
        const { id } = ctx.params;
        const user = await getService$1('user').findOne(id);
        if (!user) {
            return ctx.notFound('User does not exist');
        }
        ctx.body = {
            data: getService$1('user').sanitizeUser(user)
        };
    },
    async update (ctx) {
        const { id } = ctx.params;
        const { body: input } = ctx.request;
        await validateUserUpdateInput(input);
        if (_.has(input, 'email')) {
            const uniqueEmailCheck = await getService$1('user').exists({
                id: {
                    $ne: id
                },
                email: input.email
            });
            if (uniqueEmailCheck) {
                throw new ApplicationError$3('A user with this email address already exists');
            }
        }
        const updatedUser = await getService$1('user').updateById(id, input);
        if (!updatedUser) {
            return ctx.notFound('User does not exist');
        }
        ctx.body = {
            data: getService$1('user').sanitizeUser(updatedUser)
        };
    },
    async deleteOne (ctx) {
        const { id } = ctx.params;
        const deletedUser = await getService$1('user').deleteById(id);
        if (!deletedUser) {
            return ctx.notFound('User not found');
        }
        return ctx.deleted({
            data: getService$1('user').sanitizeUser(deletedUser)
        });
    },
    /**
   * Delete several users
   * @param ctx - koa context
   */ async deleteMany (ctx) {
        const { body } = ctx.request;
        await validateUsersDeleteInput(body);
        const users = await getService$1('user').deleteByIds(body.ids);
        const sanitizedUsers = users.map(getService$1('user').sanitizeUser);
        return ctx.deleted({
            data: sanitizedUsers
        });
    }
};

const urlRegex = /^(?:([a-z0-9+.-]+):\/\/)(?:\S+(?::\S*)?@)?(?:(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9_]-*)*[a-z\u00a1-\uffff0-9_]+)(?:\.(?:[a-z\u00a1-\uffff0-9_]-*)*[a-z\u00a1-\uffff0-9_]+)*\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/;
const webhookValidator = yup$1.object({
    name: yup$1.string().required(),
    url: yup$1.string().matches(urlRegex, 'url must be a valid URL').required().test('is-public-url', "Url is not supported because it isn't reachable over the public internet", async (url)=>{
        if (process.env.NODE_ENV !== 'production') {
            return true;
        }
        try {
            const parsedUrl = new URL(punycode.toASCII(url));
            const isLocalUrl = await isLocalhostIp(parsedUrl.hostname);
            return !isLocalUrl;
        } catch  {
            return false;
        }
    }),
    headers: yup$1.lazy((data)=>{
        if (typeof data !== 'object') {
            return yup$1.object().required();
        }
        return yup$1.object(// @ts-expect-error lodash types
        ___default.mapValues(data, ()=>{
            yup$1.string().min(1).required();
        })).required();
    }),
    events: yup$1.array().of(yup$1.string()).required()
}).noUnknown();
const updateWebhookValidator = webhookValidator.shape({
    isEnabled: yup$1.boolean()
});
var webhooks = {
    async listWebhooks (ctx) {
        const webhooks = await strapi.get('webhookStore').findWebhooks();
        ctx.send({
            data: webhooks
        });
    },
    async getWebhook (ctx) {
        const { id } = ctx.params;
        const webhook = await strapi.get('webhookStore').findWebhook(id);
        if (!webhook) {
            return ctx.notFound('webhook.notFound');
        }
        ctx.send({
            data: webhook
        });
    },
    async createWebhook (ctx) {
        const { body } = ctx.request;
        await validateYupSchema(webhookValidator)(body);
        const webhook = await strapi.get('webhookStore').createWebhook(body);
        strapi.get('webhookRunner').add(webhook);
        ctx.created({
            data: webhook
        });
    },
    async updateWebhook (ctx) {
        const { id } = ctx.params;
        const { body } = ctx.request;
        await validateYupSchema(updateWebhookValidator)(body);
        const webhook = await strapi.get('webhookStore').findWebhook(id);
        if (!webhook) {
            return ctx.notFound('webhook.notFound');
        }
        const updatedWebhook = await strapi.get('webhookStore').updateWebhook(id, {
            ...webhook,
            ...body
        });
        if (!updatedWebhook) {
            return ctx.notFound('webhook.notFound');
        }
        strapi.get('webhookRunner').update(updatedWebhook);
        ctx.send({
            data: updatedWebhook
        });
    },
    async deleteWebhook (ctx) {
        const { id } = ctx.params;
        const webhook = await strapi.get('webhookStore').findWebhook(id);
        if (!webhook) {
            return ctx.notFound('webhook.notFound');
        }
        await strapi.get('webhookStore').deleteWebhook(id);
        strapi.get('webhookRunner').remove(webhook);
        ctx.body = {
            data: webhook
        };
    },
    async deleteWebhooks (ctx) {
        const { ids } = ctx.request.body;
        if (!Array.isArray(ids) || ids.length === 0) {
            return ctx.badRequest('ids must be an array of id');
        }
        for (const id of ids){
            const webhook = await strapi.get('webhookStore').findWebhook(id);
            if (webhook) {
                await strapi.get('webhookStore').deleteWebhook(id);
                strapi.get('webhookRunner').remove(webhook);
            }
        }
        ctx.send({
            data: ids
        });
    },
    async triggerWebhook (ctx) {
        const { id } = ctx.params;
        const webhook = await strapi.get('webhookStore').findWebhook(id);
        const response = await strapi.get('webhookRunner').run(webhook, 'trigger-test', {});
        ctx.body = {
            data: response
        };
    }
};

var contentApi = {
    async getPermissions (ctx) {
        const actionsMap = await strapi.contentAPI.permissions.getActionsMap();
        ctx.send({
            data: actionsMap
        });
    },
    async getRoutes (ctx) {
        const routesMap = await strapi.contentAPI.getRoutesMap();
        ctx.send({
            data: routesMap
        });
    }
};

const createHomepageController = ()=>{
    const homepageService = getService$1('homepage');
    const recentDocumentParamsSchema = yup.object().shape({
        action: yup.mixed().oneOf([
            'update',
            'publish'
        ]).required()
    });
    return {
        async getRecentDocuments (ctx) {
            let action;
            try {
                action = (await recentDocumentParamsSchema.validate(ctx.query)).action;
            } catch (error) {
                if (error instanceof yup.ValidationError) {
                    throw new errors.ValidationError(error.message);
                }
                throw error;
            }
            if (action === 'publish') {
                return {
                    data: await homepageService.getRecentlyPublishedDocuments()
                };
            }
            return {
                data: await homepageService.getRecentlyUpdatedDocuments()
            };
        }
    };
};

var controllers$1 = {
    admin: admin$3,
    'api-token': apiToken$1,
    'authenticated-user': authenticatedUser,
    authentication: authentication$1,
    permission,
    role: role$2,
    transfer,
    user: user$2,
    webhooks,
    'content-api': contentApi,
    homepage: createHomepageController
};

/**
 * Lifecycle callbacks for the `Permission` model.
 */ var Permission = {
    collectionName: 'admin_permissions',
    info: {
        name: 'Permission',
        description: '',
        singularName: 'permission',
        pluralName: 'permissions',
        displayName: 'Permission'
    },
    options: {},
    pluginOptions: {
        'content-manager': {
            visible: false
        },
        'content-type-builder': {
            visible: false
        }
    },
    attributes: {
        action: {
            type: 'string',
            minLength: 1,
            configurable: false,
            required: true
        },
        actionParameters: {
            type: 'json',
            configurable: false,
            required: false,
            default: {}
        },
        subject: {
            type: 'string',
            minLength: 1,
            configurable: false,
            required: false
        },
        properties: {
            type: 'json',
            configurable: false,
            required: false,
            default: {}
        },
        conditions: {
            type: 'json',
            configurable: false,
            required: false,
            default: []
        },
        role: {
            configurable: false,
            type: 'relation',
            relation: 'manyToOne',
            inversedBy: 'permissions',
            target: 'admin::role'
        }
    }
};

var User = {
    collectionName: 'admin_users',
    info: {
        name: 'User',
        description: '',
        singularName: 'user',
        pluralName: 'users',
        displayName: 'User'
    },
    pluginOptions: {
        'content-manager': {
            visible: false
        },
        'content-type-builder': {
            visible: false
        }
    },
    attributes: {
        firstname: {
            type: 'string',
            unique: false,
            minLength: 1,
            configurable: false,
            required: false
        },
        lastname: {
            type: 'string',
            unique: false,
            minLength: 1,
            configurable: false,
            required: false
        },
        username: {
            type: 'string',
            unique: false,
            configurable: false,
            required: false
        },
        email: {
            type: 'email',
            minLength: 6,
            configurable: false,
            required: true,
            unique: true,
            private: true
        },
        password: {
            type: 'password',
            minLength: 6,
            configurable: false,
            required: false,
            private: true,
            searchable: false
        },
        resetPasswordToken: {
            type: 'string',
            configurable: false,
            private: true,
            searchable: false
        },
        registrationToken: {
            type: 'string',
            configurable: false,
            private: true,
            searchable: false
        },
        isActive: {
            type: 'boolean',
            default: false,
            configurable: false,
            private: true
        },
        roles: {
            configurable: false,
            private: true,
            type: 'relation',
            relation: 'manyToMany',
            inversedBy: 'users',
            target: 'admin::role',
            // FIXME: Allow setting this
            collectionName: 'strapi_users_roles'
        },
        blocked: {
            type: 'boolean',
            default: false,
            configurable: false,
            private: true
        },
        preferedLanguage: {
            type: 'string',
            configurable: false,
            required: false,
            searchable: false
        }
    },
    config: {
        attributes: {
            resetPasswordToken: {
                hidden: true
            },
            registrationToken: {
                hidden: true
            }
        }
    }
};

/**
 * Lifecycle callbacks for the `Role` model.
 */ var Role = {
    collectionName: 'admin_roles',
    info: {
        name: 'Role',
        description: '',
        singularName: 'role',
        pluralName: 'roles',
        displayName: 'Role'
    },
    options: {},
    pluginOptions: {
        'content-manager': {
            visible: false
        },
        'content-type-builder': {
            visible: false
        }
    },
    attributes: {
        name: {
            type: 'string',
            minLength: 1,
            unique: true,
            configurable: false,
            required: true
        },
        code: {
            type: 'string',
            minLength: 1,
            unique: true,
            configurable: false,
            required: true
        },
        description: {
            type: 'string',
            configurable: false
        },
        users: {
            configurable: false,
            type: 'relation',
            relation: 'manyToMany',
            mappedBy: 'roles',
            target: 'admin::user'
        },
        permissions: {
            configurable: false,
            type: 'relation',
            relation: 'oneToMany',
            mappedBy: 'role',
            target: 'admin::permission'
        }
    }
};

var apiToken = {
    collectionName: 'strapi_api_tokens',
    info: {
        name: 'Api Token',
        singularName: 'api-token',
        pluralName: 'api-tokens',
        displayName: 'Api Token',
        description: ''
    },
    options: {},
    pluginOptions: {
        'content-manager': {
            visible: false
        },
        'content-type-builder': {
            visible: false
        }
    },
    attributes: {
        name: {
            type: 'string',
            minLength: 1,
            configurable: false,
            required: true,
            unique: true
        },
        description: {
            type: 'string',
            minLength: 1,
            configurable: false,
            required: false,
            default: ''
        },
        type: {
            type: 'enumeration',
            enum: Object.values(constants$3.API_TOKEN_TYPE),
            configurable: false,
            required: true,
            default: constants$3.API_TOKEN_TYPE.READ_ONLY
        },
        accessKey: {
            type: 'string',
            minLength: 1,
            configurable: false,
            required: true,
            searchable: false
        },
        lastUsedAt: {
            type: 'datetime',
            configurable: false,
            required: false
        },
        permissions: {
            type: 'relation',
            target: 'admin::api-token-permission',
            relation: 'oneToMany',
            mappedBy: 'token',
            configurable: false,
            required: false
        },
        expiresAt: {
            type: 'datetime',
            configurable: false,
            required: false
        },
        lifespan: {
            type: 'biginteger',
            configurable: false,
            required: false
        }
    }
};

var apiTokenPermission = {
    collectionName: 'strapi_api_token_permissions',
    info: {
        name: 'API Token Permission',
        description: '',
        singularName: 'api-token-permission',
        pluralName: 'api-token-permissions',
        displayName: 'API Token Permission'
    },
    options: {},
    pluginOptions: {
        'content-manager': {
            visible: false
        },
        'content-type-builder': {
            visible: false
        }
    },
    attributes: {
        action: {
            type: 'string',
            minLength: 1,
            configurable: false,
            required: true
        },
        token: {
            configurable: false,
            type: 'relation',
            relation: 'manyToOne',
            inversedBy: 'permissions',
            target: 'admin::api-token'
        }
    }
};

var transferToken = {
    collectionName: 'strapi_transfer_tokens',
    info: {
        name: 'Transfer Token',
        singularName: 'transfer-token',
        pluralName: 'transfer-tokens',
        displayName: 'Transfer Token',
        description: ''
    },
    options: {},
    pluginOptions: {
        'content-manager': {
            visible: false
        },
        'content-type-builder': {
            visible: false
        }
    },
    attributes: {
        name: {
            type: 'string',
            minLength: 1,
            configurable: false,
            required: true,
            unique: true
        },
        description: {
            type: 'string',
            minLength: 1,
            configurable: false,
            required: false,
            default: ''
        },
        accessKey: {
            type: 'string',
            minLength: 1,
            configurable: false,
            required: true
        },
        lastUsedAt: {
            type: 'datetime',
            configurable: false,
            required: false
        },
        permissions: {
            type: 'relation',
            target: 'admin::transfer-token-permission',
            relation: 'oneToMany',
            mappedBy: 'token',
            configurable: false,
            required: false
        },
        expiresAt: {
            type: 'datetime',
            configurable: false,
            required: false
        },
        lifespan: {
            type: 'biginteger',
            configurable: false,
            required: false
        }
    }
};

var transferTokenPermission = {
    collectionName: 'strapi_transfer_token_permissions',
    info: {
        name: 'Transfer Token Permission',
        description: '',
        singularName: 'transfer-token-permission',
        pluralName: 'transfer-token-permissions',
        displayName: 'Transfer Token Permission'
    },
    options: {},
    pluginOptions: {
        'content-manager': {
            visible: false
        },
        'content-type-builder': {
            visible: false
        }
    },
    attributes: {
        action: {
            type: 'string',
            minLength: 1,
            configurable: false,
            required: true
        },
        token: {
            configurable: false,
            type: 'relation',
            relation: 'manyToOne',
            inversedBy: 'permissions',
            target: 'admin::transfer-token'
        }
    }
};

var contentTypes = {
    permission: {
        schema: Permission
    },
    user: {
        schema: User
    },
    role: {
        schema: Role
    },
    'api-token': {
        schema: apiToken
    },
    'api-token-permission': {
        schema: apiTokenPermission
    },
    'transfer-token': {
        schema: transferToken
    },
    'transfer-token-permission': {
        schema: transferTokenPermission
    }
};

const { RateLimitError } = utils$2.errors;
var rateLimit = ((config, { strapi })=>async (ctx, next)=>{
        let rateLimitConfig = strapi.config.get('admin.rateLimit');
        if (!rateLimitConfig) {
            rateLimitConfig = {
                enabled: true
            };
        }
        if (!has('enabled', rateLimitConfig)) {
            rateLimitConfig.enabled = true;
        }
        if (rateLimitConfig.enabled === true) {
            // TODO: TS - Do the dynamic import
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const rateLimit = require('koa2-ratelimit').RateLimit;
            const requestEmail = get('request.body.email')(ctx);
            const userEmail = isString(requestEmail) ? requestEmail.toLowerCase() : 'unknownEmail';
            const requestPath = isString(ctx.request.path) ? toLower(path.normalize(ctx.request.path)).replace(/\/$/, '') : 'invalidPath';
            const loadConfig = {
                interval: {
                    min: 5
                },
                max: 5,
                prefixKey: `${userEmail}:${requestPath}:${ctx.request.ip}`,
                handler () {
                    throw new RateLimitError();
                },
                ...rateLimitConfig,
                ...config
            };
            return rateLimit.middleware(loadConfig)(ctx, next);
        }
        return next();
    });

var dataTransfer = (()=>async (ctx, next)=>{
        const transferUtils = getService$1('transfer').utils;
        const { hasValidTokenSalt, isRemoteTransferEnabled } = transferUtils;
        // verify that data transfer is enabled
        if (isRemoteTransferEnabled()) {
            return next();
        }
        // if it has been manually disabled, return a not found
        if (strapi.config.get('server.transfer.remote.enabled') === false) {
            return ctx.notFound();
        }
        // if it's enabled but doesn't have a valid salt, throw a not implemented
        if (!hasValidTokenSalt()) {
            return ctx.notImplemented('The server configuration for data transfer is invalid. Please contact your server administrator.', {
                code: 'INVALID_TOKEN_SALT'
            });
        }
        // This should never happen as long as we're handling individual scenarios above
        throw new Error('Unexpected error while trying to access a data transfer route');
    });

var middlewares$1 = {
    rateLimit,
    'data-transfer': dataTransfer
};

var register = (async ({ strapi })=>{
    await register$2({
        strapi
    });
});

const getService = (name, { strapi } = {
    strapi: global.strapi
})=>{
    return strapi.service(`admin::${name}`);
};

var actions = {
    sso: [
        {
            uid: 'provider-login.read',
            displayName: 'Read',
            pluginName: 'admin',
            section: 'settings',
            category: 'single sign on',
            subCategory: 'options'
        },
        {
            uid: 'provider-login.update',
            displayName: 'Update',
            pluginName: 'admin',
            section: 'settings',
            category: 'single sign on',
            subCategory: 'options'
        }
    ],
    auditLogs: [
        {
            uid: 'audit-logs.read',
            displayName: 'Read',
            pluginName: 'admin',
            section: 'settings',
            category: 'audit logs',
            subCategory: 'options'
        }
    ]
};

var bootstrap = (async (args)=>{
    const { actionProvider } = getService('permission');
    const { persistTablesWithPrefix } = getService('persist-tables');
    if (strapi.ee.features.isEnabled('sso')) {
        await actionProvider.registerMany(actions.sso);
    }
    if (strapi.ee.features.isEnabled('audit-logs')) {
        await persistTablesWithPrefix('strapi_audit_logs');
        await actionProvider.registerMany(actions.auditLogs);
    }
    await getService('seat-enforcement').seatEnforcementWorkflow();
    await bootstrap$1(args);
});

var destroy = (async ({ strapi })=>{
    await destroy$1();
});

var adminContentTypes = {};

const isSsoLocked = async (user)=>{
    if (!strapi.ee.features.isEnabled('sso')) {
        return false;
    }
    if (!user) {
        throw new Error('Missing user object');
    }
    // check if any roles are locked
    const adminStore = await strapi.store({
        type: 'core',
        name: 'admin'
    });
    const { providers } = await adminStore.get({
        key: 'auth'
    });
    const lockedRoles = providers.ssoLockedRoles ?? [];
    if (isEmpty(lockedRoles)) {
        return false;
    }
    const roles = // If the roles are pre-loaded for the given user, then use them
    user.roles ?? // Otherwise, try to load the role based on the given user ID
    await strapi.db.query('admin::user').load(user, 'roles', {
        roles: {
            fields: [
                'id'
            ]
        }
    }) ?? // If the query fails somehow, default to an empty array
    [];
    // Check if any of the user's roles are in lockedRoles
    const isLocked = lockedRoles.some((lockedId)=>// lockedRoles will be a string to avoid issues with frontend and bigints
        roles.some((role)=>lockedId === role.id.toString()));
    return isLocked;
};

const { ApplicationError: ApplicationError$2 } = errors;
/**
 * Send an email to the user if it exists and is not locked to SSO
 * If those conditions are not met, nothing happens
 *
 * @param {Object} param params
 * @param {string} param.email user email for which to reset the password
 */ const forgotPassword = async ({ email } = {})=>{
    const user = await strapi.db.query('admin::user').findOne({
        where: {
            email,
            isActive: true
        }
    });
    if (!user || await isSsoLocked(user)) {
        return;
    }
    const resetPasswordToken = getService('token').createToken();
    await getService('user').updateById(user.id, {
        resetPasswordToken
    });
    // Send an email to the admin.
    const url = `${strapi.config.get('admin.absoluteUrl')}/auth/reset-password?code=${resetPasswordToken}`;
    return strapi.plugin('email').service('email').sendTemplatedEmail({
        to: user.email,
        from: strapi.config.get('admin.forgotPassword.from'),
        replyTo: strapi.config.get('admin.forgotPassword.replyTo')
    }, strapi.config.get('admin.forgotPassword.emailTemplate'), {
        url,
        user: ___default.pick(user, [
            'email',
            'firstname',
            'lastname',
            'username'
        ])
    }).catch((err)=>{
        // log error server side but do not disclose it to the user to avoid leaking informations
        strapi.log.error(err);
    });
};
/**
 * Reset a user password
 * @param {Object} param params
 * @param {string} param.resetPasswordToken token generated to request a password reset
 * @param {string} param.password new user password
 */ const resetPassword = async ({ resetPasswordToken, password } = {})=>{
    const matchingUser = await strapi.db.query('admin::user').findOne({
        where: {
            resetPasswordToken,
            isActive: true
        }
    });
    if (!matchingUser || await isSsoLocked(matchingUser)) {
        throw new ApplicationError$2();
    }
    return getService('user').updateById(matchingUser.id, {
        password,
        resetPasswordToken: null
    });
};
var auth = {
    forgotPassword,
    resetPassword
};

var createProviderRegistry = (()=>{
    const registry = new Map();
    Object.assign(registry, {
        register (provider) {
            if (strapi.isLoaded) {
                throw new Error(`You can't register new provider after the bootstrap`);
            }
            // TODO
            // @ts-expect-error check map types
            this.set(provider.uid, provider);
        },
        registerMany (providers) {
            providers.forEach((provider)=>{
                this.register(provider);
            });
        },
        getAll () {
            // TODO
            // @ts-expect-error check map types
            return Array.from(this.values());
        }
    });
    return registry;
});

const providerRegistry = createProviderRegistry();
const errorMessage = 'SSO is disabled. Its functionnalities cannot be accessed.';
const getStrategyCallbackURL = (providerName)=>{
    if (!strapi.ee.features.isEnabled('sso')) {
        throw new Error(errorMessage);
    }
    return `/admin/connect/${providerName}`;
};
const syncProviderRegistryWithConfig = ()=>{
    if (!strapi.ee.features.isEnabled('sso')) {
        throw new Error(errorMessage);
    }
    const { providers = [] } = strapi.config.get('admin.auth', {});
    // TODO
    // @ts-expect-error check map types
    providerRegistry.registerMany(providers);
};
const SSOAuthEventsMapper = {
    onSSOAutoRegistration: 'admin.auth.autoRegistration'
};
var sso$1 = {
    providerRegistry,
    getStrategyCallbackURL,
    syncProviderRegistryWithConfig,
    authEventsMapper: {
        ...passport$1.authEventsMapper,
        ...SSOAuthEventsMapper
    }
};

const { UnauthorizedError } = errors;
const localStrategyMiddleware = async ([error, user, message], done)=>{
    // if we got a user, we need to check that it's not sso locked
    if (user && !error && await isSsoLocked(user)) {
        return done(new UnauthorizedError('Login not allowed, please contact your administrator', {
            code: 'LOGIN_NOT_ALLOWED'
        }), user, message);
    }
    return done(error, user, message);
};
const getPassportStrategies = ()=>{
    if (!strapi.ee.features.isEnabled('sso')) {
        return [
            createLocalStrategy(strapi)
        ];
    }
    const localStrategy = createLocalStrategy(strapi, localStrategyMiddleware);
    if (!strapi.isLoaded) {
        sso$1.syncProviderRegistryWithConfig();
    }
    // TODO
    // @ts-expect-error check map types
    const providers = sso$1.providerRegistry.getAll();
    const strategies = providers.map((provider)=>provider.createStrategy(strapi));
    return [
        localStrategy,
        ...strategies
    ];
};
var passport = {
    getPassportStrategies,
    ...sso$1
};

const { ApplicationError: ApplicationError$1 } = errors;
const ssoCheckRolesIdForDeletion = async (ids)=>{
    const adminStore = await strapi.store({
        type: 'core',
        name: 'admin'
    });
    const { providers: { defaultRole } } = await adminStore.get({
        key: 'auth'
    });
    for (const roleId of ids){
        if (defaultRole && toString(defaultRole) === toString(roleId)) {
            throw new ApplicationError$1('This role is used as the default SSO role. Make sure to change this configuration before deleting the role');
        }
    }
};
var role$1 = {
    ssoCheckRolesIdForDeletion
};

const { ValidationError: ValidationError$1 } = errors;
const { SUPER_ADMIN_CODE: SUPER_ADMIN_CODE$1 } = constants$3;
/** Checks if ee disabled users list needs to be updated
 * @param {string} id
 * @param {object} input
 */ const updateEEDisabledUsersList = async (id, input)=>{
    const disabledUsers = await getService('seat-enforcement').getDisabledUserList();
    if (!disabledUsers) {
        return;
    }
    const user = disabledUsers.find((user)=>user.id === Number(id));
    if (!user) {
        return;
    }
    if (user.isActive !== input.isActive) {
        const newDisabledUsersList = disabledUsers.filter((user)=>user.id !== Number(id));
        await strapi.store.set({
            type: 'ee',
            key: 'disabled_users',
            value: newDisabledUsersList
        });
    }
};
const castNumberArray = pipe(castArray, map(toNumber));
const removeFromEEDisabledUsersList = async (ids)=>{
    let idsToCheck;
    if (typeof ids === 'object') {
        idsToCheck = castNumberArray(ids);
    } else {
        idsToCheck = [
            Number(ids)
        ];
    }
    const disabledUsers = await getService('seat-enforcement').getDisabledUserList();
    if (!disabledUsers) {
        return;
    }
    const newDisabledUsersList = disabledUsers.filter((user)=>!idsToCheck.includes(user.id));
    await strapi.store.set({
        type: 'ee',
        key: 'disabled_users',
        value: newDisabledUsersList
    });
};
/**
 * Update a user in database
 * @param id query params to find the user to update
 * @param attributes A partial user object
 * @returns {Promise<user>}
 */ const updateById = async (id, attributes)=>{
    // Check at least one super admin remains
    if (___default.has(attributes, 'roles')) {
        const lastAdminUser = await isLastSuperAdminUser(id);
        const superAdminRole = await getService('role').getSuperAdminWithUsersCount();
        const willRemoveSuperAdminRole = !arrays.includesString(attributes.roles, superAdminRole.id);
        if (lastAdminUser && willRemoveSuperAdminRole) {
            throw new ValidationError$1('You must have at least one user with super admin role.');
        }
    }
    // cannot disable last super admin
    if (attributes.isActive === false) {
        const lastAdminUser = await isLastSuperAdminUser(id);
        if (lastAdminUser) {
            throw new ValidationError$1('You must have at least one user with super admin role.');
        }
    }
    // hash password if a new one is sent
    if (___default.has(attributes, 'password')) {
        const hashedPassword = await getService('auth').hashPassword(attributes.password);
        const updatedUser = await strapi.db.query('admin::user').update({
            where: {
                id
            },
            data: {
                ...attributes,
                password: hashedPassword
            },
            populate: [
                'roles'
            ]
        });
        strapi.eventHub.emit('user.update', {
            user: sanitizeUser(updatedUser)
        });
        return updatedUser;
    }
    const updatedUser = await strapi.db.query('admin::user').update({
        where: {
            id
        },
        data: attributes,
        populate: [
            'roles'
        ]
    });
    await updateEEDisabledUsersList(id, attributes);
    if (updatedUser) {
        strapi.eventHub.emit('user.update', {
            user: sanitizeUser(updatedUser)
        });
    }
    return updatedUser;
};
/** Delete a user
 * @param id id of the user to delete
 * @returns {Promise<user>}
 */ const deleteById = async (id)=>{
    // Check at least one super admin remains
    const userToDelete = await strapi.db.query('admin::user').findOne({
        where: {
            id
        },
        populate: [
            'roles'
        ]
    });
    if (!userToDelete) {
        return null;
    }
    if (userToDelete) {
        if (userToDelete.roles.some((r)=>r.code === SUPER_ADMIN_CODE$1)) {
            const superAdminRole = await getService('role').getSuperAdminWithUsersCount();
            if (superAdminRole.usersCount === 1) {
                throw new ValidationError$1('You must have at least one user with super admin role.');
            }
        }
    }
    const deletedUser = await strapi.db.query('admin::user').delete({
        where: {
            id
        },
        populate: [
            'roles'
        ]
    });
    await removeFromEEDisabledUsersList(id);
    strapi.eventHub.emit('user.delete', {
        user: sanitizeUser(deletedUser)
    });
    return deletedUser;
};
/** Delete a user
 * @param ids ids of the users to delete
 * @returns {Promise<user>}
 */ const deleteByIds = async (ids)=>{
    // Check at least one super admin remains
    const superAdminRole = await getService('role').getSuperAdminWithUsersCount();
    const nbOfSuperAdminToDelete = await strapi.db.query('admin::user').count({
        where: {
            id: ids,
            roles: {
                id: superAdminRole.id
            }
        }
    });
    if (superAdminRole.usersCount === nbOfSuperAdminToDelete) {
        throw new ValidationError$1('You must have at least one user with super admin role.');
    }
    const deletedUsers = [];
    for (const id of ids){
        const deletedUser = await strapi.db.query('admin::user').delete({
            where: {
                id
            },
            populate: [
                'roles'
            ]
        });
        deletedUsers.push(deletedUser);
    }
    await removeFromEEDisabledUsersList(ids);
    strapi.eventHub.emit('user.delete', {
        users: deletedUsers.map((deletedUser)=>sanitizeUser(deletedUser))
    });
    return deletedUsers;
};
const sanitizeUserRoles = (role)=>___default.pick(role, [
        'id',
        'name',
        'description',
        'code'
    ]);
/**
 * Check if a user is the last super admin
 * @param {int|string} userId user's id to look for
 */ const isLastSuperAdminUser = async (userId)=>{
    const user = await findOne(userId);
    const superAdminRole = await getService('role').getSuperAdminWithUsersCount();
    return superAdminRole.usersCount === 1 && hasSuperAdminRole$1(user);
};
/**
 * Remove private user fields
 * @param {Object} user - user to sanitize
 */ const sanitizeUser = (user)=>{
    return {
        ...___default.omit(user, [
            'password',
            'resetPasswordToken',
            'registrationToken',
            'roles'
        ]),
        roles: user.roles && user.roles.map(sanitizeUserRoles)
    };
};
/**
 * Find one user
 */ const findOne = async (id, populate = [
    'roles'
])=>{
    return strapi.db.query('admin::user').findOne({
        where: {
            id
        },
        populate
    });
};
const getCurrentActiveUserCount = async ()=>{
    return strapi.db.query('admin::user').count({
        where: {
            isActive: true
        }
    });
};
var user$1 = {
    updateEEDisabledUsersList,
    removeFromEEDisabledUsersList,
    getCurrentActiveUserCount,
    deleteByIds,
    deleteById,
    updateById
};

const getSSOProvidersList = async ()=>{
    const { providerRegistry } = strapi.service('admin::passport');
    return providerRegistry.getAll().map(({ uid })=>uid);
};
const sendUpdateProjectInformation = async (strapi1)=>{
    let groupProperties = {};
    const numberOfActiveAdminUsers = await getService('user').count({
        isActive: true
    });
    const numberOfAdminUsers = await getService('user').count();
    if (strapi1.ee.features.isEnabled('sso')) {
        const SSOProviders = await getSSOProvidersList();
        groupProperties = assign(groupProperties, {
            SSOProviders,
            isSSOConfigured: SSOProviders.length !== 0
        });
    }
    if (strapi1.ee.features.isEnabled('cms-content-releases')) {
        const numberOfContentReleases = await strapi1.db.query('plugin::content-releases.release').count();
        const numberOfPublishedContentReleases = await strapi1.db.query('plugin::content-releases.release').count({
            filters: {
                releasedAt: {
                    $notNull: true
                }
            }
        });
        groupProperties = assign(groupProperties, {
            numberOfContentReleases,
            numberOfPublishedContentReleases
        });
    }
    groupProperties = assign(groupProperties, {
        numberOfActiveAdminUsers,
        numberOfAdminUsers
    });
    strapi1.telemetry.send('didUpdateProjectInformation', {
        groupProperties
    });
};
const startCron = (strapi1)=>{
    strapi1.cron.add({
        sendProjectInformation: {
            task: ()=>sendUpdateProjectInformation(strapi1),
            options: '0 0 0 * * *'
        }
    });
};
var metrics = {
    startCron,
    getSSOProvidersList,
    sendUpdateProjectInformation
};

const { SUPER_ADMIN_CODE } = constants$3;
/**
 * Keeps the list of users disabled by the seat enforcement service
 */ const getDisabledUserList = async ()=>{
    return strapi.store.get({
        type: 'ee',
        key: 'disabled_users'
    });
};
const enableMaximumUserCount = async (numberOfUsersToEnable)=>{
    const disabledUsers = await getDisabledUserList();
    const orderedDisabledUsers = reverse(disabledUsers);
    const usersToEnable = take(numberOfUsersToEnable, orderedDisabledUsers);
    await strapi.db.query('admin::user').updateMany({
        where: {
            id: map(prop('id'), usersToEnable)
        },
        data: {
            isActive: true
        }
    });
    const remainingDisabledUsers = drop(numberOfUsersToEnable, orderedDisabledUsers);
    await strapi.store.set({
        type: 'ee',
        key: 'disabled_users',
        value: remainingDisabledUsers
    });
};
const disableUsersAboveLicenseLimit = async (numberOfUsersToDisable)=>{
    const currentlyDisabledUsers = await getDisabledUserList() ?? [];
    const usersToDisable = [];
    const nonSuperAdminUsersToDisable = await strapi.db.query('admin::user').findMany({
        where: {
            isActive: true,
            roles: {
                code: {
                    $ne: SUPER_ADMIN_CODE
                }
            }
        },
        orderBy: {
            createdAt: 'DESC'
        },
        limit: numberOfUsersToDisable
    });
    usersToDisable.push(...nonSuperAdminUsersToDisable);
    if (nonSuperAdminUsersToDisable.length < numberOfUsersToDisable) {
        const superAdminUsersToDisable = await strapi.db.query('admin::user').findMany({
            where: {
                isActive: true,
                roles: {
                    code: SUPER_ADMIN_CODE
                }
            },
            orderBy: {
                createdAt: 'DESC'
            },
            limit: numberOfUsersToDisable - nonSuperAdminUsersToDisable.length
        });
        usersToDisable.push(...superAdminUsersToDisable);
    }
    await strapi.db.query('admin::user').updateMany({
        where: {
            id: map(prop('id'), usersToDisable)
        },
        data: {
            isActive: false
        }
    });
    await strapi.store.set({
        type: 'ee',
        key: 'disabled_users',
        value: currentlyDisabledUsers.concat(map(pick([
            'id',
            'isActive'
        ]), usersToDisable))
    });
};
const syncDisabledUserRecords = async ()=>{
    const disabledUsers = await strapi.store.get({
        type: 'ee',
        key: 'disabled_users'
    });
    if (!disabledUsers) {
        return;
    }
    await strapi.db.query('admin::user').updateMany({
        where: {
            id: map(prop('id'), disabledUsers)
        },
        data: {
            isActive: false
        }
    });
};
const seatEnforcementWorkflow = async ()=>{
    const adminSeats = strapi.ee.seats;
    if (isNil(adminSeats)) {
        return;
    }
    // TODO: we need to make sure an admin can decide to disable specific user and reactivate others
    await syncDisabledUserRecords();
    const currentActiveUserCount = await getService('user').getCurrentActiveUserCount();
    const adminSeatsLeft = adminSeats - currentActiveUserCount;
    if (adminSeatsLeft > 0) {
        await enableMaximumUserCount(adminSeatsLeft);
    } else if (adminSeatsLeft < 0) {
        await disableUsersAboveLicenseLimit(-adminSeatsLeft);
    }
};
var seatEnforcement = {
    seatEnforcementWorkflow,
    getDisabledUserList
};

/**
 * Transform table name to the object format
 */ const transformTableName = (table)=>{
    if (typeof table === 'string') {
        return {
            name: table
        };
    }
    return table;
};
/**
 * Finds all tables in the database matching the regular expression
 * @param {Object} ctx
 * @param {Strapi} ctx.strapi
 * @param {RegExp} regex
 * @returns {Promise<string[]>}
 */ async function findTables({ strapi: strapi1 }, regex) {
    const tables = await strapi1.db.dialect.schemaInspector.getTables();
    return tables.filter((tableName)=>regex.test(tableName));
}
/**
 * Add tables name to the reserved tables in core store
 */ async function addPersistTables({ strapi: strapi1 }, tableNames) {
    const persistedTables = await getPersistedTables({
        strapi: strapi1
    });
    const tables = tableNames.map(transformTableName);
    // Get new tables to be persisted, remove tables if they already were persisted
    const notPersistedTableNames = differenceWith(isEqual, tables, persistedTables);
    // Remove tables that are going to be changed
    const tablesToPersist = differenceWith((t1, t2)=>t1.name === t2.name, persistedTables, notPersistedTableNames);
    if (!notPersistedTableNames.length) {
        return;
    }
    // @ts-expect-error lodash types
    tablesToPersist.push(...notPersistedTableNames);
    await strapi1.store.set({
        type: 'core',
        key: 'persisted_tables',
        value: tablesToPersist
    });
}
/**
 * Get all reserved table names from the core store
 * @param {Object} ctx
 * @param {Strapi} ctx.strapi
 * @param {RegExp} regex
 * @returns {Promise<string[]>}
 */ async function getPersistedTables({ strapi: strapi1 }) {
    const persistedTables = await strapi1.store.get({
        type: 'core',
        key: 'persisted_tables'
    });
    return (persistedTables || []).map(transformTableName);
}
/**
 * Set all reserved table names in the core store
 * @param {Object} ctx
 * @param {Strapi} ctx.strapi
 * @param {Array<string|{ table: string; dependsOn?: Array<{ table: string;}> }>} tableNames
 * @returns {Promise<void>}
 */ async function setPersistedTables({ strapi: strapi1 }, tableNames) {
    await strapi1.store.set({
        type: 'core',
        key: 'persisted_tables',
        value: tableNames
    });
}
/**
 * Add all table names that start with a prefix to the reserved tables in
 * core store
 * @param {string} tableNamePrefix
 * @return {Promise<void>}
 */ const persistTablesWithPrefix = async (tableNamePrefix)=>{
    const tableNameRegex = new RegExp(`^${tableNamePrefix}.*`);
    const tableNames = await findTables({
        strapi
    }, tableNameRegex);
    await addPersistTables({
        strapi
    }, tableNames);
};
/**
 * Remove all table names that end with a suffix from the reserved tables in core store
 * @param {string} tableNameSuffix
 * @return {Promise<void>}
 */ const removePersistedTablesWithSuffix = async (tableNameSuffix)=>{
    const tableNameRegex = new RegExp(`.*${tableNameSuffix}$`);
    const persistedTables = await getPersistedTables({
        strapi
    });
    const filteredPersistedTables = persistedTables.filter((table)=>{
        return !tableNameRegex.test(table.name);
    });
    if (filteredPersistedTables.length === persistedTables.length) {
        return;
    }
    await setPersistedTables({
        strapi
    }, filteredPersistedTables);
};
/**
 * Add tables to the reserved tables in core store
 */ const persistTables = async (tables)=>{
    await addPersistTables({
        strapi
    }, tables);
};
var persistTables$1 = {
    persistTablesWithPrefix,
    removePersistedTablesWithSuffix,
    persistTables,
    findTables
};

var services = {
    auth,
    passport,
    role: role$1,
    user: user$1,
    metrics,
    'seat-enforcement': seatEnforcement,
    'persist-tables': persistTables$1
};

const providerOptionsUpdateSchema = yup$1.object().shape({
    autoRegister: yup$1.boolean().required(),
    defaultRole: yup$1.strapiID().when('autoRegister', (value, initSchema)=>{
        return value ? initSchema.required() : initSchema.nullable();
    }).test('is-valid-role', 'You must submit a valid default role', (roleId)=>{
        if (roleId === null) {
            return true;
        }
        return strapi.service('admin::role').exists({
            id: roleId
        });
    }),
    ssoLockedRoles: yup$1.array().nullable().of(yup$1.strapiID().test('is-valid-role', 'You must submit a valid role for the SSO Locked roles', (roleId)=>{
        return strapi.service('admin::role').exists({
            id: roleId
        });
    }))
});
const validateProviderOptionsUpdate = validateYupSchema(providerOptionsUpdateSchema);

const PROVIDER_REDIRECT_BASE = '/auth/login';
const PROVIDER_REDIRECT_SUCCESS = `${PROVIDER_REDIRECT_BASE}/success`;
const PROVIDER_REDIRECT_ERROR = `${PROVIDER_REDIRECT_BASE}/error`;

const PROVIDER_URLS_MAP = {
    success: PROVIDER_REDIRECT_SUCCESS,
    error: PROVIDER_REDIRECT_ERROR
};
const getAdminStore = async ()=>strapi.store({
        type: 'core',
        name: 'admin'
    });
const getPrefixedRedirectUrls = ()=>{
    const { url: adminUrl } = strapi.config.get('admin');
    const prefixUrl = (url)=>`${adminUrl || '/admin'}${url}`;
    return mapValues(prefixUrl, PROVIDER_URLS_MAP);
};
var utils = {
    getAdminStore,
    getPrefixedRedirectUrls
};

const defaultConnectionError = ()=>new Error('Invalid connection payload');
const authenticate = async (ctx, next)=>{
    const { params: { provider } } = ctx;
    const redirectUrls = utils.getPrefixedRedirectUrls();
    // @ts-expect-error - can not use null to authenticate
    return passport$2.authenticate(provider, null, async (error, profile)=>{
        if (error || !profile || !profile.email) {
            if (error) {
                strapi.log.error(error);
            }
            strapi.eventHub.emit('admin.auth.error', {
                error: error || defaultConnectionError(),
                provider
            });
            return ctx.redirect(redirectUrls.error);
        }
        const user = await getService('user').findOneByEmail(profile.email);
        const scenario = user ? existingUserScenario : nonExistingUserScenario;
        return scenario(ctx, next)(user || profile, provider);
    })(ctx, next);
};
const existingUserScenario = (ctx, next)=>async (user, provider)=>{
        const redirectUrls = utils.getPrefixedRedirectUrls();
        if (!user.isActive) {
            strapi.eventHub.emit('admin.auth.error', {
                error: new Error(`Deactivated user tried to login (${user.id})`),
                provider
            });
            return ctx.redirect(redirectUrls.error);
        }
        ctx.state.user = user;
        return next();
    };
const nonExistingUserScenario = (ctx, next)=>async (profile, provider)=>{
        const { email, firstname, lastname, username } = profile;
        const redirectUrls = utils.getPrefixedRedirectUrls();
        const adminStore = await utils.getAdminStore();
        const { providers } = await adminStore.get({
            key: 'auth'
        });
        // We need at least the username or the firstname/lastname combination to register a new user
        const isMissingRegisterFields = !username && (!firstname || !lastname);
        if (!providers.autoRegister || !providers.defaultRole || isMissingRegisterFields) {
            strapi.eventHub.emit('admin.auth.error', {
                error: defaultConnectionError(),
                provider
            });
            return ctx.redirect(redirectUrls.error);
        }
        const defaultRole = await getService('role').findOne({
            id: providers.defaultRole
        });
        // If the default role has been misconfigured, redirect with an error
        if (!defaultRole) {
            strapi.eventHub.emit('admin.auth.error', {
                error: defaultConnectionError(),
                provider
            });
            return ctx.redirect(redirectUrls.error);
        }
        // Register a new user with the information given by the provider and login with it
        ctx.state.user = await getService('user').create({
            email,
            username,
            firstname,
            lastname,
            roles: [
                defaultRole.id
            ],
            isActive: true,
            registrationToken: null
        });
        strapi.eventHub.emit('admin.auth.autoRegistration', {
            user: ctx.state.user,
            provider
        });
        return next();
    };
const redirectWithAuth = (ctx)=>{
    const { params: { provider } } = ctx;
    const redirectUrls = utils.getPrefixedRedirectUrls();
    const domain = strapi.config.get('admin.auth.domain');
    const { user } = ctx.state;
    const jwt = getService('token').createJwtToken(user);
    const isProduction = strapi.config.get('environment') === 'production';
    const cookiesOptions = {
        httpOnly: false,
        secure: isProduction,
        overwrite: true,
        domain
    };
    const sanitizedUser = getService('user').sanitizeUser(user);
    strapi.eventHub.emit('admin.auth.success', {
        user: sanitizedUser,
        provider
    });
    ctx.cookies.set('jwtToken', jwt, cookiesOptions);
    ctx.redirect(redirectUrls.success);
};
var middlewares = {
    authenticate,
    redirectWithAuth
};

const toProviderDTO = pick([
    'uid',
    'displayName',
    'icon'
]);
const toProviderLoginOptionsDTO = pick([
    'autoRegister',
    'defaultRole',
    'ssoLockedRoles'
]);
const { ValidationError } = errors;
const providerAuthenticationFlow = compose([
    middlewares.authenticate,
    middlewares.redirectWithAuth
]);
var authentication = {
    async getProviders (ctx) {
        const { providerRegistry } = strapi.service('admin::passport');
        ctx.body = providerRegistry.getAll().map(toProviderDTO);
    },
    async getProviderLoginOptions (ctx) {
        const adminStore = await utils.getAdminStore();
        const { providers: providersOptions } = await adminStore.get({
            key: 'auth'
        });
        ctx.body = {
            data: toProviderLoginOptionsDTO(providersOptions)
        };
    },
    async updateProviderLoginOptions (ctx) {
        const { request: { body } } = ctx;
        await validateProviderOptionsUpdate(body);
        const adminStore = await utils.getAdminStore();
        const currentAuthOptions = await adminStore.get({
            key: 'auth'
        });
        const newAuthOptions = {
            ...currentAuthOptions,
            providers: body
        };
        await adminStore.set({
            key: 'auth',
            value: newAuthOptions
        });
        strapi.telemetry.send('didUpdateSSOSettings');
        ctx.body = {
            data: toProviderLoginOptionsDTO(newAuthOptions.providers)
        };
    },
    providerLogin (ctx, next) {
        const { params: { provider: providerName } } = ctx;
        const { providerRegistry } = strapi.service('admin::passport');
        if (!providerRegistry.has(providerName)) {
            throw new ValidationError(`Invalid provider supplied: ${providerName}`);
        }
        return providerAuthenticationFlow(ctx, next);
    }
};

const roleCreateSchema = yup$1.object().shape({
    name: yup$1.string().min(1).required(),
    description: yup$1.string().nullable()
}).noUnknown();
const rolesDeleteSchema = yup$1.object().shape({
    ids: yup$1.array().of(yup$1.strapiID()).min(1).required().test('roles-deletion-checks', 'Roles deletion checks have failed', async function rolesDeletionChecks(ids) {
        try {
            await strapi.service('admin::role').checkRolesIdForDeletion(ids);
            if (strapi.ee.features.isEnabled('sso')) {
                await strapi.service('admin::role').ssoCheckRolesIdForDeletion(ids);
            }
        } catch (e) {
            return this.createError({
                path: 'ids',
                message: e.message
            });
        }
        return true;
    })
}).noUnknown();
const roleDeleteSchema = yup$1.strapiID().required().test('no-admin-single-delete', 'Role deletion checks have failed', async function noAdminSingleDelete(id) {
    try {
        await strapi.service('admin::role').checkRolesIdForDeletion([
            id
        ]);
        if (strapi.ee.features.isEnabled('sso')) {
            await strapi.service('admin::role').ssoCheckRolesIdForDeletion([
                id
            ]);
        }
    } catch (e) {
        return this.createError({
            path: 'id',
            message: e.message
        });
    }
    return true;
});
const validateRoleCreateInput = validateYupSchema(roleCreateSchema);
const validateRolesDeleteInput = validateYupSchema(rolesDeleteSchema);
const validateRoleDeleteInput = validateYupSchema(roleDeleteSchema);

var role = {
    /**
   * Create a new role
   * @param {KoaContext} ctx - koa context
   */ async create (ctx) {
        await validateRoleCreateInput(ctx.request.body);
        const roleService = getService('role');
        const role = await roleService.create(ctx.request.body);
        const sanitizedRole = roleService.sanitizeRole(role);
        ctx.created({
            data: sanitizedRole
        });
    },
    /**
   * Delete a role
   * @param {KoaContext} ctx - koa context
   */ async deleteOne (ctx) {
        const { id } = ctx.params;
        await validateRoleDeleteInput(id);
        const roleService = getService('role');
        const roles = await roleService.deleteByIds([
            id
        ]);
        const sanitizedRole = roles.map((role)=>roleService.sanitizeRole(role))[0] || null;
        return ctx.deleted({
            data: sanitizedRole
        });
    },
    /**
   * delete several roles
   * @param {KoaContext} ctx - koa context
   */ async deleteMany (ctx) {
        const { body } = ctx.request;
        await validateRolesDeleteInput(body);
        const roleService = getService('role');
        const roles = await roleService.deleteByIds(body.ids);
        const sanitizedRoles = roles.map(roleService.sanitizeRole);
        return ctx.deleted({
            data: sanitizedRoles
        });
    }
};

const ssoUserCreationInputExtension = yup$1.object().shape({
    useSSORegistration: yup$1.boolean()
}).noUnknown();
const validateUserCreationInput = (data)=>{
    let schema = schemas.userCreationSchema;
    if (strapi.ee.features.isEnabled('sso')) {
        schema = schema.concat(ssoUserCreationInputExtension);
    }
    return validateYupSchema(schema)(data);
};

const { ApplicationError, ForbiddenError } = errors;
const pickUserCreationAttributes = pick([
    'firstname',
    'lastname',
    'email',
    'roles'
]);
const hasAdminSeatsAvaialble = async ()=>{
    if (!strapi.EE) {
        return true;
    }
    const permittedSeats = strapi.ee.seats;
    if (isNil(permittedSeats)) {
        return true;
    }
    const userCount = await strapi.service('admin::user').getCurrentActiveUserCount();
    if (userCount < permittedSeats) {
        return true;
    }
};
var user = {
    async create (ctx) {
        if (!await hasAdminSeatsAvaialble()) {
            throw new ForbiddenError('License seat limit reached. You cannot create a new user');
        }
        const { body } = ctx.request;
        const cleanData = {
            ...body,
            email: ___default.get(body, `email`, ``).toLowerCase()
        };
        await validateUserCreationInput(cleanData);
        const attributes = pickUserCreationAttributes(cleanData);
        const { useSSORegistration } = cleanData;
        const userAlreadyExists = await getService('user').exists({
            email: attributes.email
        });
        if (userAlreadyExists) {
            throw new ApplicationError('Email already taken');
        }
        if (useSSORegistration) {
            Object.assign(attributes, {
                registrationToken: null,
                isActive: true
            });
        }
        const createdUser = await getService('user').create(attributes);
        const userInfo = getService('user').sanitizeUser(createdUser);
        // Note: We need to assign manually the registrationToken to the
        // final user payload so that it's not removed in the sanitation process.
        Object.assign(userInfo, {
            registrationToken: createdUser.registrationToken
        });
        ctx.created({
            data: userInfo
        });
    },
    async update (ctx) {
        const { id } = ctx.params;
        const { body: input } = ctx.request;
        await validateUserUpdateInput(input);
        if (___default.has(input, 'email')) {
            const uniqueEmailCheck = await getService('user').exists({
                id: {
                    $ne: id
                },
                email: input.email
            });
            if (uniqueEmailCheck) {
                throw new ApplicationError('A user with this email address already exists');
            }
        }
        const user = await getService('user').findOne(id, null);
        if (!await hasAdminSeatsAvaialble() && !user.isActive && input.isActive) {
            throw new ForbiddenError('License seat limit reached. You cannot active this user');
        }
        const updatedUser = await getService('user').updateById(id, input);
        if (!updatedUser) {
            return ctx.notFound('User does not exist');
        }
        ctx.body = {
            data: getService('user').sanitizeUser(updatedUser)
        };
    },
    async isSSOLocked (ctx) {
        const { user } = ctx.state;
        const isSSOLocked = await isSsoLocked(user);
        ctx.body = {
            data: {
                isSSOLocked
            }
        };
    }
};

var admin$2 = {
    // NOTE: Overrides CE admin controller
    async getProjectType () {
        const flags = strapi.config.get('admin.flags', {});
        try {
            return {
                data: {
                    isEE: strapi.EE,
                    features: strapi.ee.features.list(),
                    flags
                }
            };
        } catch (err) {
            return {
                data: {
                    isEE: false,
                    features: [],
                    flags
                }
            };
        }
    },
    async licenseLimitInformation () {
        const permittedSeats = strapi.ee.seats;
        let shouldNotify = false;
        let licenseLimitStatus = null;
        let enforcementUserCount;
        const currentActiveUserCount = await getService('user').getCurrentActiveUserCount();
        const eeDisabledUsers = await getService('seat-enforcement').getDisabledUserList();
        if (eeDisabledUsers) {
            enforcementUserCount = currentActiveUserCount + eeDisabledUsers.length;
        } else {
            enforcementUserCount = currentActiveUserCount;
        }
        if (!isNil(permittedSeats) && enforcementUserCount > permittedSeats) {
            shouldNotify = true;
            licenseLimitStatus = 'OVER_LIMIT';
        }
        if (!isNil(permittedSeats) && enforcementUserCount === permittedSeats) {
            shouldNotify = true;
            licenseLimitStatus = 'AT_LIMIT';
        }
        const data = {
            enforcementUserCount,
            currentActiveUserCount,
            permittedSeats,
            shouldNotify,
            shouldStopCreate: isNil(permittedSeats) ? false : currentActiveUserCount >= permittedSeats,
            licenseLimitStatus,
            isHostedOnStrapiCloud: env('STRAPI_HOSTING', null) === 'strapi.cloud',
            features: strapi.ee.features.list() ?? []
        };
        return {
            data
        };
    }
};

var controllers = {
    authentication,
    role,
    user,
    admin: admin$2
};

const enableFeatureMiddleware = (featureName)=>(ctx, next)=>{
        if (strapi.ee.features.isEnabled(featureName)) {
            return next();
        }
        ctx.status = 404;
    };

var sso = {
    type: 'admin',
    routes: [
        {
            method: 'GET',
            path: '/providers',
            handler: 'authentication.getProviders',
            config: {
                middlewares: [
                    enableFeatureMiddleware('sso')
                ],
                auth: false
            }
        },
        {
            method: 'GET',
            path: '/connect/:provider',
            handler: 'authentication.providerLogin',
            config: {
                middlewares: [
                    enableFeatureMiddleware('sso')
                ],
                auth: false
            }
        },
        {
            method: 'POST',
            path: '/connect/:provider',
            handler: 'authentication.providerLogin',
            config: {
                middlewares: [
                    enableFeatureMiddleware('sso')
                ],
                auth: false
            }
        },
        {
            method: 'GET',
            path: '/providers/options',
            handler: 'authentication.getProviderLoginOptions',
            config: {
                middlewares: [
                    enableFeatureMiddleware('sso')
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'admin::provider-login.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'PUT',
            path: '/providers/options',
            handler: 'authentication.updateProviderLoginOptions',
            config: {
                middlewares: [
                    enableFeatureMiddleware('sso')
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'admin::provider-login.update'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/providers/isSSOLocked',
            handler: 'user.isSSOLocked',
            config: {
                middlewares: [
                    enableFeatureMiddleware('sso')
                ],
                policies: [
                    'admin::isAuthenticatedAdmin'
                ]
            }
        }
    ]
};

var licenseLimit = {
    type: 'admin',
    routes: [
        // License limit infos
        {
            method: 'GET',
            path: '/license-limit-information',
            handler: 'admin.licenseLimitInformation',
            config: {
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'admin::users.create',
                                'admin::users.read',
                                'admin::users.update',
                                'admin::users.delete'
                            ]
                        }
                    }
                ]
            }
        }
    ]
};

var routes = {
    sso,
    'license-limit': licenseLimit
};

var auditLogsRoutes = {
    type: 'admin',
    routes: [
        {
            method: 'GET',
            path: '/audit-logs',
            handler: 'audit-logs.findMany',
            config: {
                middlewares: [
                    enableFeatureMiddleware('audit-logs')
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'admin::audit-logs.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/audit-logs/:id',
            handler: 'audit-logs.findOne',
            config: {
                middlewares: [
                    enableFeatureMiddleware('audit-logs')
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'admin::audit-logs.read'
                            ]
                        }
                    }
                ]
            }
        }
    ]
};

const ALLOWED_SORT_STRINGS = [
    'action:ASC',
    'action:DESC',
    'date:ASC',
    'date:DESC'
];
const validateFindManySchema = yup$1.object().shape({
    page: yup$1.number().integer().min(1),
    pageSize: yup$1.number().integer().min(1).max(100),
    sort: yup$1.mixed().oneOf(ALLOWED_SORT_STRINGS)
}).required();
const validateFindMany = validateYupSchema(validateFindManySchema, {
    strict: false
});

var auditLogsController = {
    async findMany (ctx) {
        const { query } = ctx.request;
        await validateFindMany(query);
        const auditLogs = strapi.get('audit-logs');
        const body = await auditLogs.findMany(query);
        ctx.body = body;
    },
    async findOne (ctx) {
        const { id } = ctx.params;
        const auditLogs = strapi.get('audit-logs');
        const body = await auditLogs.findOne(id);
        ctx.body = body;
        strapi.telemetry.send('didWatchAnAuditLog');
    }
};

const getSanitizedUser = (user)=>{
    let displayName = user.email;
    if (user.username) {
        displayName = user.username;
    } else if (user.firstname && user.lastname) {
        displayName = `${user.firstname} ${user.lastname}`;
    }
    return {
        id: user.id,
        email: user.email,
        displayName
    };
};
/**
 * @description
 * Manages audit logs interaction with the database. Accessible via strapi.get('audit-logs')
 */ const createAuditLogsService = (strapi)=>{
    return {
        async saveEvent (event) {
            const { userId, ...rest } = event;
            const auditLog = {
                ...rest,
                user: userId
            };
            // Save to database
            await strapi.db?.query('admin::audit-log').create({
                data: auditLog
            });
            return this;
        },
        async findMany (query) {
            const { results, pagination } = await strapi.db?.query('admin::audit-log').findPage({
                populate: [
                    'user'
                ],
                select: [
                    'action',
                    'date',
                    'payload'
                ],
                ...strapi.get('query-params').transform('admin::audit-log', query)
            });
            const sanitizedResults = results.map((result)=>{
                const { user, ...rest } = result;
                return {
                    ...rest,
                    user: user ? getSanitizedUser(user) : null
                };
            });
            return {
                results: sanitizedResults,
                pagination
            };
        },
        async findOne (id) {
            const result = await strapi.db?.query('admin::audit-log').findOne({
                where: {
                    id
                },
                populate: [
                    'user'
                ],
                select: [
                    'action',
                    'date',
                    'payload'
                ]
            });
            if (!result) {
                return null;
            }
            const { user, ...rest } = result;
            return {
                ...rest,
                user: user ? getSanitizedUser(user) : null
            };
        },
        deleteExpiredEvents (expirationDate) {
            return strapi.db?.query('admin::audit-log').deleteMany({
                where: {
                    date: {
                        $lt: expirationDate.toISOString()
                    }
                }
            });
        }
    };
};

const DEFAULT_RETENTION_DAYS = 90;
const defaultEvents = [
    'entry.create',
    'entry.update',
    'entry.delete',
    'entry.publish',
    'entry.unpublish',
    'media.create',
    'media.update',
    'media.delete',
    'media-folder.create',
    'media-folder.update',
    'media-folder.delete',
    'user.create',
    'user.update',
    'user.delete',
    'admin.auth.success',
    'admin.logout',
    'content-type.create',
    'content-type.update',
    'content-type.delete',
    'component.create',
    'component.update',
    'component.delete',
    'role.create',
    'role.update',
    'role.delete',
    'permission.create',
    'permission.update',
    'permission.delete'
];
const getEventMap = (defaultEvents)=>{
    const getDefaultPayload = (...args)=>args[0];
    // Use the default payload for all default events
    return defaultEvents.reduce((acc, event)=>{
        acc[event] = getDefaultPayload;
        return acc;
    }, {});
};
const getRetentionDays = (strapi)=>{
    const featureConfig = strapi.ee.features.get('audit-logs');
    const licenseRetentionDays = typeof featureConfig === 'object' && featureConfig?.options.retentionDays;
    const userRetentionDays = strapi.config.get('admin.auditLogs.retentionDays');
    // For enterprise plans, use 90 days by default, but allow users to override it
    if (licenseRetentionDays == null) {
        return userRetentionDays ?? DEFAULT_RETENTION_DAYS;
    }
    // Allow users to override the license retention days, but not to increase it
    if (userRetentionDays && userRetentionDays < licenseRetentionDays) {
        return userRetentionDays;
    }
    // User didn't provide a retention days value, use the license one
    return licenseRetentionDays;
};
/**
 * @description
 * Manages the the lifecycle of audit logs. Accessible via strapi.get('audit-logs-lifecycles')
 */ const createAuditLogsLifecycleService = (strapi)=>{
    // Manage internal service state privately
    const state = {};
    const auditLogsService = strapi.get('audit-logs');
    // NOTE: providers should be able to replace getEventMap to add or remove events
    const eventMap = getEventMap(defaultEvents);
    const processEvent = (name, ...args)=>{
        const requestState = strapi.requestContext.get()?.state;
        // Ignore events with auth strategies different from admin
        const isUsingAdminAuth = requestState?.route.info.type === 'admin';
        const user = requestState?.user;
        if (!isUsingAdminAuth || !user) {
            return null;
        }
        const getPayload = eventMap[name];
        // Ignore the event if it's not in the map
        if (!getPayload) {
            return null;
        }
        // Ignore some events based on payload
        // TODO: What does this ignore in upload? Why would we want to ignore anything?
        const ignoredUids = [
            'plugin::upload.file',
            'plugin::upload.folder'
        ];
        if (ignoredUids.includes(args[0]?.uid)) {
            return null;
        }
        return {
            action: name,
            date: new Date().toISOString(),
            payload: getPayload(...args) || {},
            userId: user.id
        };
    };
    const handleEvent = async (name, ...args)=>{
        const processedEvent = processEvent(name, ...args);
        if (processedEvent) {
            await auditLogsService.saveEvent(processedEvent);
        }
    };
    return {
        async register () {
            // Handle license being enabled
            if (!state.eeEnableUnsubscribe) {
                // @ts-expect-error- update event hub to receive callback argument
                state.eeEnableUnsubscribe = strapi.eventHub.on('ee.enable', ()=>{
                    // Recreate the service to use the new license info
                    this.destroy();
                    this.register();
                });
            }
            // Handle license being updated
            if (!state.eeUpdateUnsubscribe) {
                // @ts-expect-error- update event hub to receive callback argument
                state.eeUpdateUnsubscribe = strapi.eventHub.on('ee.update', ()=>{
                    // Recreate the service to use the new license info
                    this.destroy();
                    this.register();
                });
            }
            // Handle license being disabled
            // @ts-expect-error- update event hub to receive callback argument
            state.eeDisableUnsubscribe = strapi.eventHub.on('ee.disable', ()=>{
                // Turn off service when the license gets disabled
                // Only ee.enable and ee.update listeners remain active to recreate the service
                this.destroy();
            });
            // Check current state of license
            if (!strapi.ee.features.isEnabled('audit-logs')) {
                return this;
            }
            // Start saving events
            state.eventHubUnsubscribe = strapi.eventHub.subscribe(handleEvent);
            // Manage audit logs auto deletion
            const retentionDays = getRetentionDays(strapi);
            state.deleteExpiredJob = scheduleJob('0 0 * * *', ()=>{
                const expirationDate = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000);
                auditLogsService.deleteExpiredEvents(expirationDate);
            });
            return this;
        },
        unsubscribe () {
            if (state.eeDisableUnsubscribe) {
                state.eeDisableUnsubscribe();
            }
            if (state.eventHubUnsubscribe) {
                state.eventHubUnsubscribe();
            }
            if (state.deleteExpiredJob) {
                state.deleteExpiredJob.cancel();
            }
            return this;
        },
        destroy () {
            return this.unsubscribe();
        }
    };
};

const auditLog = {
    schema: {
        kind: 'collectionType',
        collectionName: 'strapi_audit_logs',
        info: {
            singularName: 'audit-log',
            pluralName: 'audit-logs',
            displayName: 'Audit Log'
        },
        options: {
            timestamps: false
        },
        pluginOptions: {
            'content-manager': {
                visible: false
            },
            'content-type-builder': {
                visible: false
            }
        },
        attributes: {
            action: {
                type: 'string',
                required: true
            },
            date: {
                type: 'datetime',
                required: true
            },
            user: {
                type: 'relation',
                relation: 'oneToOne',
                target: 'admin::user'
            },
            payload: {
                type: 'json'
            }
        }
    }
};

const getAdminEE = ()=>{
    const eeAdmin = {
        register,
        bootstrap,
        destroy,
        contentTypes: {
            // Always register the audit-log content type to prevent data loss
            'audit-log': auditLog,
            ...adminContentTypes
        },
        services,
        controllers,
        routes
    };
    // Only add the other audit-logs APIs if the feature is enabled by the user and the license
    if (strapi.config.get('admin.auditLogs.enabled', true) && strapi.ee.features.isEnabled('audit-logs')) {
        return {
            ...eeAdmin,
            controllers: {
                ...eeAdmin.controllers,
                'audit-logs': auditLogsController
            },
            routes: {
                ...eeAdmin.routes,
                'audit-logs': auditLogsRoutes
            },
            async register ({ strapi: strapi1 }) {
                // Run the the default registration
                await eeAdmin.register({
                    strapi: strapi1
                });
                // Register an internal audit logs service
                strapi1.add('audit-logs', createAuditLogsService(strapi1));
                // Register an internal audit logs lifecycle service
                const auditLogsLifecycle = createAuditLogsLifecycleService(strapi1);
                strapi1.add('audit-logs-lifecycle', auditLogsLifecycle);
                await auditLogsLifecycle.register();
            },
            async destroy ({ strapi: strapi1 }) {
                strapi1.get('audit-logs-lifecycle').destroy();
                await eeAdmin.destroy({
                    strapi: strapi1
                });
            }
        };
    }
    return eeAdmin;
};

// eslint-disable-next-line import/no-mutable-exports
let admin = {
    bootstrap: bootstrap$1,
    register: register$2,
    destroy: destroy$1,
    config,
    policies,
    routes: routes$1,
    services: services$1,
    controllers: controllers$1,
    contentTypes,
    middlewares: middlewares$1
};
const mergeRoutes = (a, b, key)=>{
    return ___default.isArray(a) && ___default.isArray(b) && key === 'routes' ? a.concat(b) : undefined;
};
if (strapi.EE) {
    admin = ___default.mergeWith({}, admin, getAdminEE(), mergeRoutes);
}
var admin$1 = admin;

export { admin$1 as default };
//# sourceMappingURL=index.mjs.map
