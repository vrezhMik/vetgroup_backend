'use strict';

var fp = require('lodash/fp');
var semver = require('semver');
var utils = require('@strapi/utils');
require('@strapi/types');
var dateFns = require('date-fns');

const getAdminService = (name, { strapi } = {
    strapi: global.strapi
})=>{
    return strapi.service(`admin::${name}`);
};
const getService = (name, { strapi } = {
    strapi: global.strapi
})=>{
    return strapi.plugin('review-workflows').service(name);
};

const WORKFLOW_MODEL_UID = 'plugin::review-workflows.workflow';
const STAGE_MODEL_UID = 'plugin::review-workflows.workflow-stage';
/**
 * TODO: For V4 compatibility, the old UID was kept, when review workflows was in the admin package
 *
 * NOTE!: if you change this string you need to change it here too: strapi/packages/core/review-workflows/admin/src/routes/settings/components/Stages.tsx
 */ const STAGE_TRANSITION_UID = 'admin::review-workflows.stage.transition';
const STAGE_DEFAULT_COLOR = '#4945FF';
const ENTITY_STAGE_ATTRIBUTE = 'strapi_stage';
const ENTITY_ASSIGNEE_ATTRIBUTE = 'strapi_assignee';
const MAX_WORKFLOWS = 200;
const MAX_STAGES_PER_WORKFLOW = 200;
const ERRORS = {
    WORKFLOW_WITHOUT_STAGES: 'A workflow must have at least one stage.',
    WORKFLOWS_LIMIT: 'You’ve reached the limit of workflows in your plan. Delete a workflow or contact Sales to enable more workflows.',
    STAGES_LIMIT: 'You’ve reached the limit of stages for this workflow in your plan. Try deleting some stages or contact Sales to enable more stages.',
    DUPLICATED_STAGE_NAME: 'Stage names must be unique.'
};
const WORKFLOW_POPULATE = {
    stages: {
        populate: {
            permissions: {
                fields: [
                    'action',
                    'actionParameters'
                ],
                populate: {
                    role: {
                        fields: [
                            'id',
                            'name'
                        ]
                    }
                }
            }
        }
    },
    stageRequiredToPublish: true
};

function checkVersionThreshold(startVersion, currentVersion, thresholdVersion) {
    return semver.gte(currentVersion, thresholdVersion) && semver.lt(startVersion, thresholdVersion);
}
/**
 * Shorten strapi stage name
 */ async function migrateStageAttribute({ oldContentTypes, contentTypes }) {
    const getRWVersion = fp.getOr('0.0.0', `${STAGE_MODEL_UID}.options.version`);
    const oldRWVersion = getRWVersion(oldContentTypes);
    const currentRWVersion = getRWVersion(contentTypes);
    checkVersionThreshold(oldRWVersion, currentRWVersion, '1.1.0');
// TODO: Find tables with something else than `findTables` function
// if (migrationNeeded) {
//   const oldAttributeTableName = 'strapi_review_workflows_stage';
//   const newAttributeTableName = 'strapi_stage';
//   // const tables = await findTables({ strapi }, new RegExp(oldAttributeTableName));
//   await async.map(tables, async (tableName: string) => {
//     const newTableName = tableName.replace(oldAttributeTableName, newAttributeTableName);
//     const alreadyHasNextTable = await strapi.db.connection.schema.hasTable(newTableName);
//     // The table can be already created but empty. In order to rename the old one, we need to drop the previously created empty one.
//     if (alreadyHasNextTable) {
//       const dataInTable = await strapi.db.connection(newTableName).select().limit(1);
//       if (!dataInTable.length) {
//         await strapi.db.connection.schema.dropTable(newTableName);
//       }
//     }
//     try {
//       await strapi.db.connection.schema.renameTable(tableName, newTableName);
//     } catch (e: any) {
//       strapi.log.warn(
//         `An error occurred during the migration of ${tableName} table to ${newTableName}.\nIf ${newTableName} already exists, migration can't be done automatically.`
//       );
//       strapi.log.warn(e.message);
//     }
//   });
// }
}

/**
 * Set the default color for stages if the color attribute was added
 */ async function migrateReviewWorkflowStagesColor({ oldContentTypes, contentTypes }) {
    // Look for CT's color attribute
    const hadColor = !!oldContentTypes?.[STAGE_MODEL_UID]?.attributes?.color;
    const hasColor = !!contentTypes?.[STAGE_MODEL_UID]?.attributes?.color;
    // Add the default stage color if color attribute was added
    if (!hadColor && hasColor) {
        await strapi.db.query(STAGE_MODEL_UID).updateMany({
            data: {
                color: STAGE_DEFAULT_COLOR
            }
        });
    }
}

/**
 * Migrate review workflow stages to have RBAC permissions for all roles.
 */ async function migrateReviewWorkflowStagesRoles({ oldContentTypes, contentTypes }) {
    const hadRolePermissions = !!oldContentTypes?.[STAGE_MODEL_UID]?.attributes?.permissions;
    const hasRolePermissions = !!contentTypes?.[STAGE_MODEL_UID]?.attributes?.permissions;
    // If the stage content type did not have permissions in the previous version
    // then we set the permissions of every stage to be every current role in the app.
    // This ensures consistent behaviour when upgrading to a strapi version with review workflows RBAC.
    if (!hadRolePermissions && hasRolePermissions) {
        const roleUID = 'admin::role';
        strapi.log.info(`Migrating all existing review workflow stages to have RBAC permissions for all ${roleUID}.`);
        const stagePermissionsService = getService('stage-permissions');
        const stages = await strapi.db.query(STAGE_MODEL_UID).findMany();
        const roles = await strapi.db.query(roleUID).findMany();
        // Collect the permissions to add and group them by stage id.
        const groupedPermissions = {};
        roles.map((role)=>role.id).forEach((roleId)=>{
            stages.map((stage)=>stage.id).forEach((stageId)=>{
                if (!groupedPermissions[stageId]) {
                    groupedPermissions[stageId] = [];
                }
                groupedPermissions[stageId].push({
                    roleId,
                    fromStage: stageId,
                    action: STAGE_TRANSITION_UID
                });
            });
        });
        for (const [stageId, permissions] of Object.entries(groupedPermissions)){
            const numericalStageId = Number(stageId);
            if (Number.isNaN(numericalStageId)) {
                strapi.log.warn(`Unable to apply ${roleUID} migration for ${STAGE_MODEL_UID} with id ${stageId}. The stage does not have a numerical id.`);
                continue;
            }
            // Register the permissions for this stage
            const stagePermissions = await stagePermissionsService.registerMany(permissions);
            // Update the stage with its new permissions
            await strapi.db.query(STAGE_MODEL_UID).update({
                where: {
                    id: numericalStageId
                },
                data: {
                    permissions: stagePermissions.flat().map((permission)=>permission.id)
                }
            });
        }
    }
}

var name = "Default";
var defaultWorkflow = {
    name: name
};

/**
 * Multiple workflows introduced the ability to name a workflow.
 * This migration adds the default workflow name if the name attribute was added.
 */ async function migrateReviewWorkflowName({ oldContentTypes, contentTypes }) {
    // Look for RW name attribute
    const hadName = !!oldContentTypes?.[WORKFLOW_MODEL_UID]?.attributes?.name;
    const hasName = !!contentTypes?.[WORKFLOW_MODEL_UID]?.attributes?.name;
    // Add the default workflow name if name attribute was added
    if (!hadName && hasName) {
        await strapi.db.query(WORKFLOW_MODEL_UID).updateMany({
            where: {
                name: {
                    $null: true
                }
            },
            data: {
                name: defaultWorkflow.name
            }
        });
    }
}

async function migrateWorkflowsContentTypes({ oldContentTypes, contentTypes }) {
    // Look for RW contentTypes attribute
    const hadContentTypes = !!oldContentTypes?.[WORKFLOW_MODEL_UID]?.attributes?.contentTypes;
    const hasContentTypes = !!contentTypes?.[WORKFLOW_MODEL_UID]?.attributes?.contentTypes;
    if (!hadContentTypes && hasContentTypes) {
        // Initialize contentTypes with an empty array and assign only to one
        // workflow the Content Types which were using Review Workflow before.
        await strapi.db.query(WORKFLOW_MODEL_UID).updateMany({
            data: {
                contentTypes: []
            }
        });
        // Find Content Types which were using Review Workflow before
        const contentTypes = fp.pipe([
            fp.pickBy(fp.get('options.reviewWorkflows')),
            fp.keys
        ])(oldContentTypes);
        if (contentTypes.length) {
            // Update only one workflow with the contentTypes
            // Before this release there was only one workflow, so this operation is safe.
            await strapi.db.query(WORKFLOW_MODEL_UID).update({
                where: {
                    id: {
                        $notNull: true
                    }
                },
                data: {
                    contentTypes
                }
            });
        }
    }
}

const getVisibleContentTypesUID = fp.pipe([
    // Pick only content-types visible in the content-manager and option is not false
    fp.pickBy((value)=>fp.getOr(true, 'pluginOptions.content-manager.visible', value) && !fp.getOr(false, 'options.noStageAttribute', value)),
    // Get UIDs
    fp.keys
]);
const hasStageAttribute = fp.has([
    'attributes',
    ENTITY_STAGE_ATTRIBUTE
]);
const getWorkflowContentTypeFilter = ({ strapi }, contentType)=>{
    if (strapi.db.dialect.supportsOperator('$jsonSupersetOf')) {
        return {
            $jsonSupersetOf: JSON.stringify([
                contentType
            ])
        };
    }
    return {
        $contains: `"${contentType}"`
    };
};
const clampMaxWorkflows = fp.clamp(1, MAX_WORKFLOWS);
const clampMaxStagesPerWorkflow = fp.clamp(1, MAX_STAGES_PER_WORKFLOW);

/**
 * Remove CT references from workflows if the CT is deleted
 */ async function migrateDeletedCTInWorkflows({ oldContentTypes, contentTypes }) {
    const deletedContentTypes = fp.difference(fp.keys(oldContentTypes), fp.keys(contentTypes)) ?? [];
    if (deletedContentTypes.length) {
        await utils.async.map(deletedContentTypes, async (deletedContentTypeUID)=>{
            const workflow = await strapi.db.query(WORKFLOW_MODEL_UID).findOne({
                select: [
                    'id',
                    'contentTypes'
                ],
                where: {
                    contentTypes: getWorkflowContentTypeFilter({
                        strapi
                    }, deletedContentTypeUID)
                }
            });
            if (workflow) {
                await strapi.db.query(WORKFLOW_MODEL_UID).update({
                    where: {
                        id: workflow.id
                    },
                    data: {
                        contentTypes: workflow.contentTypes.filter((contentTypeUID)=>contentTypeUID !== deletedContentTypeUID)
                    }
                });
            }
        });
    }
}

/**
 * A Strapi middleware function that adds support for review workflows.
 *
 * Why is it needed ?
 * For now, the admin panel cannot have anything but top-level attributes in the content-type for options.
 * But we need the CE part to be agnostics from Review Workflow (which is an EE feature).
 * CE handle the `options` object, that's why we move the reviewWorkflows boolean to the options object.
 *
 * @param {object} strapi - The Strapi instance.
 */ function contentTypeMiddleware(strapi) {
    /**
   * A middleware function that moves the `reviewWorkflows` attribute from the top level of
   * the request body to the `options` object within the request body.
   *
   * @param {object} ctx - The Koa context object.
   */ const moveReviewWorkflowOption = (ctx)=>{
        // Move reviewWorkflows to options.reviewWorkflows
        const { reviewWorkflows, ...contentType } = ctx.request.body.contentType;
        if (typeof reviewWorkflows === 'boolean') {
            ctx.request.body.contentType = fp.set('options.reviewWorkflows', reviewWorkflows, contentType);
        }
    };
    strapi.server.router.use('/content-type-builder/content-types/:uid?', (ctx, next)=>{
        if (ctx.method === 'PUT' || ctx.method === 'POST') {
            moveReviewWorkflowOption(ctx);
        }
        return next();
    });
}
var reviewWorkflowsMiddlewares = {
    contentTypeMiddleware
};

const setRelation = (attributeName, target, contentType)=>{
    Object.assign(contentType.attributes, {
        [attributeName]: {
            writable: true,
            private: false,
            configurable: false,
            visible: false,
            useJoinTable: true,
            type: 'relation',
            relation: 'oneToOne',
            target
        }
    });
    return contentType;
};
/**
 * Add the stage and assignee attributes to content types
 */ function extendReviewWorkflowContentTypes({ strapi }) {
    const contentTypeToExtend = getVisibleContentTypesUID(strapi.contentTypes);
    for (const contentTypeUID of contentTypeToExtend){
        strapi.get('content-types').extend(contentTypeUID, (contentType)=>{
            // Set Stage attribute
            setRelation(ENTITY_STAGE_ATTRIBUTE, STAGE_MODEL_UID, contentType);
            // Set Assignee attribute
            setRelation(ENTITY_ASSIGNEE_ATTRIBUTE, 'admin::user', contentType);
        });
    }
}
/**
 * Persist the stage & assignee attributes so they are not removed when downgrading to CE.
 *
 * TODO: V6 - Instead of persisting the join tables, always create the stage & assignee attributes, even in CE mode
 *            It was decided in V4 & V5 to not expose them in CE (as they pollute the CTs) but it's not worth given the complexity this needs
 */ function persistRWOnDowngrade({ strapi }) {
    const { removePersistedTablesWithSuffix, persistTables } = getAdminService('persist-tables');
    return async ({ contentTypes })=>{
        const getStageTableToPersist = (contentTypeUID)=>{
            // Persist the stage join table
            const { attributes, tableName } = strapi.db.metadata.get(contentTypeUID);
            const joinTableName = attributes[ENTITY_STAGE_ATTRIBUTE].joinTable.name;
            return {
                name: joinTableName,
                dependsOn: [
                    {
                        name: tableName
                    }
                ]
            };
        };
        const getAssigneeTableToPersist = (contentTypeUID)=>{
            // Persist the assignee join table
            const { attributes, tableName } = strapi.db.metadata.get(contentTypeUID);
            const joinTableName = attributes[ENTITY_ASSIGNEE_ATTRIBUTE].joinTable.name;
            return {
                name: joinTableName,
                dependsOn: [
                    {
                        name: tableName
                    }
                ]
            };
        };
        const enabledRWContentTypes = fp.pipe([
            getVisibleContentTypesUID,
            fp.filter((uid)=>hasStageAttribute(contentTypes[uid]))
        ])(contentTypes);
        // Remove previously created join tables and persist the new ones
        const stageJoinTablesToPersist = enabledRWContentTypes.map(getStageTableToPersist);
        await removePersistedTablesWithSuffix('_strapi_stage_lnk');
        await persistTables(stageJoinTablesToPersist);
        // Remove previously created join tables and persist the new ones
        const assigneeJoinTablesToPersist = enabledRWContentTypes.map(getAssigneeTableToPersist);
        await removePersistedTablesWithSuffix('_strapi_assignee_lnk');
        await persistTables(assigneeJoinTablesToPersist);
    };
}
var register = (async ({ strapi })=>{
    // Data Migrations
    strapi.hook('strapi::content-types.beforeSync').register(migrateStageAttribute);
    strapi.hook('strapi::content-types.afterSync').register(persistRWOnDowngrade({
        strapi
    }));
    strapi.hook('strapi::content-types.afterSync').register(migrateReviewWorkflowStagesColor).register(migrateReviewWorkflowStagesRoles).register(migrateReviewWorkflowName).register(migrateWorkflowsContentTypes).register(migrateDeletedCTInWorkflows);
    // Middlewares
    reviewWorkflowsMiddlewares.contentTypeMiddleware(strapi);
    // Schema customization
    extendReviewWorkflowContentTypes({
        strapi
    });
    // License limits
    const reviewWorkflowsOptions = fp.defaultsDeep({
        numberOfWorkflows: MAX_WORKFLOWS,
        stagesPerWorkflow: MAX_STAGES_PER_WORKFLOW
    }, strapi.ee.features.get('review-workflows'));
    const workflowsValidationService = getService('validation', {
        strapi
    });
    workflowsValidationService.register(reviewWorkflowsOptions);
});

var workflow = {
    schema: {
        collectionName: 'strapi_workflows',
        info: {
            name: 'Workflow',
            description: '',
            singularName: 'workflow',
            pluralName: 'workflows',
            displayName: 'Workflow'
        },
        options: {},
        pluginOptions: {
            'content-manager': {
                visible: false
            },
            'content-type-builder': {
                visible: false
            }
        },
        attributes: {
            name: {
                type: 'string',
                required: true,
                unique: true
            },
            stages: {
                type: 'relation',
                target: 'plugin::review-workflows.workflow-stage',
                relation: 'oneToMany',
                mappedBy: 'workflow'
            },
            stageRequiredToPublish: {
                type: 'relation',
                target: 'plugin::review-workflows.workflow-stage',
                relation: 'oneToOne',
                required: false
            },
            contentTypes: {
                type: 'json',
                required: true,
                default: '[]'
            }
        }
    }
};

var workflowStage = {
    schema: {
        collectionName: 'strapi_workflows_stages',
        info: {
            name: 'Workflow Stage',
            description: '',
            singularName: 'workflow-stage',
            pluralName: 'workflow-stages',
            displayName: 'Stages'
        },
        options: {
            version: '1.1.0'
        },
        pluginOptions: {
            'content-manager': {
                visible: false
            },
            'content-type-builder': {
                visible: false
            }
        },
        attributes: {
            name: {
                type: 'string',
                configurable: false
            },
            color: {
                type: 'string',
                configurable: false,
                default: STAGE_DEFAULT_COLOR
            },
            workflow: {
                type: 'relation',
                target: 'plugin::review-workflows.workflow',
                relation: 'manyToOne',
                inversedBy: 'stages',
                configurable: false
            },
            permissions: {
                type: 'relation',
                target: 'admin::permission',
                relation: 'manyToMany',
                configurable: false
            }
        }
    }
};

var contentTypes = {
    workflow,
    'workflow-stage': workflowStage
};

var actions = {
    reviewWorkflows: [
        {
            uid: 'review-workflows.create',
            displayName: 'Create',
            pluginName: 'admin',
            section: 'settings',
            category: 'review workflows',
            subCategory: 'options'
        },
        {
            uid: 'review-workflows.read',
            displayName: 'Read',
            pluginName: 'admin',
            section: 'settings',
            category: 'review workflows',
            subCategory: 'options'
        },
        {
            uid: 'review-workflows.update',
            displayName: 'Update',
            pluginName: 'admin',
            section: 'settings',
            category: 'review workflows',
            subCategory: 'options'
        },
        {
            uid: 'review-workflows.delete',
            displayName: 'Delete',
            pluginName: 'admin',
            section: 'settings',
            category: 'review workflows',
            subCategory: 'options'
        },
        {
            uid: 'review-workflows.stage.transition',
            displayName: 'Change stage',
            pluginName: 'admin',
            section: 'internal'
        }
    ]
};

var defaultStages = [
    {
        name: "To do",
        color: "#4945FF"
    },
    {
        name: "Ready to review",
        color: "#9736E8"
    },
    {
        name: "In progress",
        color: "#EE5E52"
    },
    {
        name: "Reviewed",
        color: "#328048"
    }
];

const WORKFLOW_UPDATE_STAGE = 'review-workflows.updateEntryStage';
var webhookEvents = {
    WORKFLOW_UPDATE_STAGE
};

/**
 * Initialize the default workflow if there is no workflow in the database
 */ async function initDefaultWorkflow() {
    const workflowsService = getService('workflows', {
        strapi
    });
    const stagesService = getService('stages', {
        strapi
    });
    const wfCount = await workflowsService.count();
    const stagesCount = await stagesService.count();
    // Check if there is nothing about review-workflow in DB
    // If any, the feature has already been initialized with a workflow and stages
    if (wfCount === 0 && stagesCount === 0) {
        const workflow = {
            ...defaultWorkflow,
            contentTypes: [],
            stages: defaultStages
        };
        await workflowsService.create({
            data: workflow
        });
    }
}
/**
 * Webhook store limits the events that can be triggered,
 * this function extends it with the events review workflows can trigger
 */ const registerWebhookEvents = async ()=>Object.entries(webhookEvents).forEach(([eventKey, event])=>strapi.get('webhookStore').addAllowedEvent(eventKey, event));
var bootstrap = (async (args)=>{
    // Permissions
    const { actionProvider } = getAdminService('permission');
    await actionProvider.registerMany(actions.reviewWorkflows);
    // Webhooks and events
    await registerWebhookEvents();
    await getService('workflow-weekly-metrics').registerCron();
    // Data initialization
    await initDefaultWorkflow();
    // Document service middleware
    const docsMiddlewares = getService('document-service-middlewares');
    strapi.documents.use(docsMiddlewares.assignStageOnCreate);
    strapi.documents.use(docsMiddlewares.handleStageOnUpdate);
    strapi.documents.use(docsMiddlewares.checkStageBeforePublish);
});

var destroy = (async ({ strapi })=>{});

const enableFeatureMiddleware = (featureName)=>(ctx, next)=>{
        if (strapi.ee.features.isEnabled(featureName)) {
            return next();
        }
        ctx.status = 404;
    };

var reviewWorkflows = {
    type: 'admin',
    routes: [
        // Review workflow
        {
            method: 'POST',
            path: '/workflows',
            handler: 'workflows.create',
            config: {
                middlewares: [
                    enableFeatureMiddleware('review-workflows')
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'admin::review-workflows.create'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'PUT',
            path: '/workflows/:id',
            handler: 'workflows.update',
            config: {
                middlewares: [
                    enableFeatureMiddleware('review-workflows')
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'admin::review-workflows.update'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'DELETE',
            path: '/workflows/:id',
            handler: 'workflows.delete',
            config: {
                middlewares: [
                    enableFeatureMiddleware('review-workflows')
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'admin::review-workflows.delete'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/workflows',
            handler: 'workflows.find',
            config: {
                middlewares: [
                    enableFeatureMiddleware('review-workflows')
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'admin::review-workflows.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/workflows/:workflow_id/stages',
            handler: 'stages.find',
            config: {
                middlewares: [
                    enableFeatureMiddleware('review-workflows')
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'admin::review-workflows.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'GET',
            path: '/workflows/:workflow_id/stages/:id',
            handler: 'stages.findById',
            config: {
                middlewares: [
                    enableFeatureMiddleware('review-workflows')
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'admin::review-workflows.read'
                            ]
                        }
                    }
                ]
            }
        },
        {
            method: 'PUT',
            path: '/content-manager/(collection|single)-types/:model_uid/:id/stage',
            handler: 'stages.updateEntity',
            config: {
                middlewares: [
                    enableFeatureMiddleware('review-workflows')
                ],
                policies: [
                    'admin::isAuthenticatedAdmin'
                ]
            }
        },
        {
            method: 'GET',
            path: '/content-manager/(collection|single)-types/:model_uid/:id/stages',
            handler: 'stages.listAvailableStages',
            config: {
                middlewares: [
                    enableFeatureMiddleware('review-workflows')
                ],
                policies: [
                    'admin::isAuthenticatedAdmin'
                ]
            }
        },
        {
            method: 'PUT',
            path: '/content-manager/(collection|single)-types/:model_uid/:id/assignee',
            handler: 'assignees.updateEntity',
            config: {
                middlewares: [
                    enableFeatureMiddleware('review-workflows')
                ],
                policies: [
                    'admin::isAuthenticatedAdmin',
                    {
                        name: 'admin::hasPermissions',
                        config: {
                            actions: [
                                'admin::users.read'
                            ]
                        }
                    }
                ]
            }
        }
    ]
};

var routes = {
    'review-workflows': reviewWorkflows
};

var workflowsContentTypesFactory = (({ strapi })=>{
    const contentManagerContentTypeService = strapi.plugin('content-manager').service('content-types');
    const stagesService = getService('stages', {
        strapi
    });
    const updateContentTypeConfig = async (uid, reviewWorkflowOption)=>{
        // Merge options in the configuration as the configuration service use a destructuration merge which doesn't include nested objects
        const modelConfig = await contentManagerContentTypeService.findConfiguration(uid);
        await contentManagerContentTypeService.updateConfiguration({
            uid
        }, {
            options: fp.merge(modelConfig.options, {
                reviewWorkflows: reviewWorkflowOption
            })
        });
    };
    return {
        /**
     * Migrates entities stages. Used when a content type is assigned to a workflow.
     * @param {*} options
     * @param {Array<string>} options.srcContentTypes - The content types assigned to the previous workflow
     * @param {Array<string>} options.destContentTypes - The content types assigned to the new workflow
     * @param {Workflow.Stage} options.stageId - The new stage to assign the entities to
     */ async migrate ({ srcContentTypes = [], destContentTypes, stageId }) {
            const workflowsService = getService('workflows', {
                strapi
            });
            const { created, deleted } = diffContentTypes(srcContentTypes, destContentTypes);
            await utils.async.map(created, async (uid)=>{
                // Content Types should only be assigned to one workflow
                // However, edge cases can happen, and this handles them
                const srcWorkflows = await workflowsService._getAssignedWorkflows(uid, {});
                if (srcWorkflows.length) {
                    // Updates all existing entities stages links to the new stage
                    await stagesService.updateEntitiesStage(uid, {
                        toStageId: stageId
                    });
                    // Transfer content types from the previous workflow(s)
                    await utils.async.map(srcWorkflows, (srcWorkflow)=>this.transferContentTypes(srcWorkflow, uid));
                }
                await updateContentTypeConfig(uid, true);
                // Create new stages links to the new stage
                return stagesService.updateEntitiesStage(uid, {
                    fromStageId: null,
                    toStageId: stageId
                });
            }, // transferContentTypes can cause race conditions if called in parallel when updating the same workflow
            {
                concurrency: 1
            });
            await utils.async.map(deleted, async (uid)=>{
                await updateContentTypeConfig(uid, false);
                await stagesService.deleteAllEntitiesStage(uid, {});
            });
        },
        /**
     * Filters the content types assigned to a workflow
     * @param {Workflow} srcWorkflow - The workflow to transfer from
     * @param {string} uid - The content type uid
     */ async transferContentTypes (srcWorkflow, uid) {
            // Update assignedContentTypes of the previous workflow
            await strapi.db.query(WORKFLOW_MODEL_UID).update({
                where: {
                    id: srcWorkflow.id
                },
                data: {
                    contentTypes: srcWorkflow.contentTypes.filter((contentType)=>contentType !== uid)
                }
            });
        }
    };
});
const diffContentTypes = (srcContentTypes, destContentTypes)=>{
    const created = fp.difference(destContentTypes, srcContentTypes);
    const deleted = fp.difference(srcContentTypes, destContentTypes);
    return {
        created,
        deleted
    };
};

const processFilters = ({ strapi }, filters = {})=>{
    const processedFilters = {
        ...filters
    };
    if (fp.isString(filters.contentTypes)) {
        processedFilters.contentTypes = getWorkflowContentTypeFilter({
            strapi
        }, filters.contentTypes);
    }
    return processedFilters;
};
// TODO: How can we improve this? Maybe using traversePopulate?
const processPopulate = (populate)=>{
    // If it does not exist or it's not an object (like an array) return the default populate
    if (!populate) {
        return WORKFLOW_POPULATE;
    }
    return populate;
};
var workflows$1 = (({ strapi })=>{
    const workflowsContentTypes = workflowsContentTypesFactory({
        strapi
    });
    const workflowValidator = getService('validation', {
        strapi
    });
    const metrics = getService('workflow-metrics', {
        strapi
    });
    return {
        /**
     * Returns all the workflows matching the user-defined filters.
     * @param {object} opts - Options for the query.
     * @param {object} opts.filters - Filters object.
     * @returns {Promise<object[]>} - List of workflows that match the user's filters.
     */ async find (opts = {}) {
            const filters = processFilters({
                strapi
            }, opts.filters);
            const populate = processPopulate(opts.populate);
            const query = strapi.get('query-params').transform(WORKFLOW_MODEL_UID, {
                ...opts,
                filters,
                populate
            });
            return strapi.db.query(WORKFLOW_MODEL_UID).findMany(query);
        },
        /**
     * Returns the workflow with the specified ID.
     * @param {string} id - ID of the requested workflow.
     * @param {object} opts - Options for the query.
     * @returns {Promise<object>} - Workflow object matching the requested ID.
     */ findById (id, opts = {}) {
            const populate = processPopulate(opts.populate);
            const query = strapi.get('query-params').transform(WORKFLOW_MODEL_UID, {
                populate
            });
            return strapi.db.query(WORKFLOW_MODEL_UID).findOne({
                ...query,
                where: {
                    id
                }
            });
        },
        /**
     * Creates a new workflow.
     * @param {object} opts - Options for creating the new workflow.
     * @returns {Promise<object>} - Workflow object that was just created.
     * @throws {ValidationError} - If the workflow has no stages.
     */ async create (opts) {
            let createOpts = {
                ...opts,
                populate: WORKFLOW_POPULATE
            };
            workflowValidator.validateWorkflowStages(opts.data.stages);
            await workflowValidator.validateWorkflowCount(1);
            return strapi.db.transaction(async ()=>{
                // Create stages
                const stages = await getService('stages', {
                    strapi
                }).createMany(opts.data.stages);
                const mapIds = fp.map(fp.get('id'));
                createOpts = fp.set('data.stages', mapIds(stages), createOpts);
                if (opts.data.stageRequiredToPublishName) {
                    const stageRequiredToPublish = stages.find((stage)=>stage.name === opts.data.stageRequiredToPublishName);
                    if (!stageRequiredToPublish) {
                        throw new utils.errors.ApplicationError('Stage required to publish does not exist');
                    }
                    createOpts = fp.set('data.stageRequiredToPublish', stageRequiredToPublish.id, createOpts);
                }
                // Update (un)assigned Content Types
                if (opts.data.contentTypes) {
                    await workflowsContentTypes.migrate({
                        destContentTypes: opts.data.contentTypes,
                        stageId: stages[0].id
                    });
                }
                // Create Workflow
                const createdWorkflow = await strapi.db.query(WORKFLOW_MODEL_UID).create(strapi.get('query-params').transform(WORKFLOW_MODEL_UID, createOpts));
                metrics.sendDidCreateWorkflow(createdWorkflow.id, !!opts.data.stageRequiredToPublishName);
                if (opts.data.stageRequiredToPublishName) {
                    await strapi.plugin('content-releases').service('release-action').validateActionsByContentTypes(opts.data.contentTypes);
                }
                return createdWorkflow;
            });
        },
        /**
     * Updates an existing workflow.
     * @param {object} workflow - The existing workflow to update.
     * @param {object} opts - Options for updating the workflow.
     * @returns {Promise<object>} - Workflow object that was just updated.
     * @throws {ApplicationError} - If the supplied stage ID does not belong to the workflow.
     */ async update (workflow, opts) {
            const stageService = getService('stages', {
                strapi
            });
            let updateOpts = {
                ...opts,
                populate: {
                    ...WORKFLOW_POPULATE
                }
            };
            let updatedStages = [];
            let updatedStageIds;
            await workflowValidator.validateWorkflowCount();
            return strapi.db.transaction(async ()=>{
                // Update stages
                if (opts.data.stages) {
                    workflowValidator.validateWorkflowStages(opts.data.stages);
                    opts.data.stages.forEach((stage)=>this.assertStageBelongsToWorkflow(stage.id, workflow));
                    updatedStages = await stageService.replaceStages(workflow.stages, opts.data.stages, workflow.contentTypes);
                    updatedStageIds = updatedStages.map((stage)=>stage.id);
                    updateOpts = fp.set('data.stages', updatedStageIds, updateOpts);
                }
                if (opts.data.stageRequiredToPublishName !== undefined) {
                    const stages = updatedStages ?? workflow.stages;
                    if (opts.data.stageRequiredToPublishName === null) {
                        updateOpts = fp.set('data.stageRequiredToPublish', null, updateOpts);
                    } else {
                        const stageRequiredToPublish = stages.find((stage)=>stage.name === opts.data.stageRequiredToPublishName);
                        if (!stageRequiredToPublish) {
                            throw new utils.errors.ApplicationError('Stage required to publish does not exist');
                        }
                        updateOpts = fp.set('data.stageRequiredToPublish', stageRequiredToPublish.id, updateOpts);
                    }
                }
                // Update (un)assigned Content Types
                if (opts.data.contentTypes) {
                    await workflowsContentTypes.migrate({
                        srcContentTypes: workflow.contentTypes,
                        destContentTypes: opts.data.contentTypes,
                        stageId: updatedStageIds ? updatedStageIds[0] : workflow.stages[0].id
                    });
                }
                metrics.sendDidEditWorkflow(workflow.id, !!opts.data.stageRequiredToPublishName);
                const query = strapi.get('query-params').transform(WORKFLOW_MODEL_UID, updateOpts);
                // Update Workflow
                const updatedWorkflow = await strapi.db.query(WORKFLOW_MODEL_UID).update({
                    ...query,
                    where: {
                        id: workflow.id
                    }
                });
                await strapi.plugin('content-releases').service('release-action').validateActionsByContentTypes([
                    ...workflow.contentTypes,
                    ...opts.data.contentTypes || []
                ]);
                return updatedWorkflow;
            });
        },
        /**
     * Deletes an existing workflow.
     * Also deletes all the workflow stages and migrate all assigned the content types.
     * @param {*} workflow
     * @param {*} opts
     * @returns
     */ async delete (workflow, opts) {
            const stageService = getService('stages', {
                strapi
            });
            const workflowCount = await this.count();
            if (workflowCount <= 1) {
                throw new utils.errors.ApplicationError('Can not delete the last workflow');
            }
            return strapi.db.transaction(async ()=>{
                // Delete stages
                await stageService.deleteMany(workflow.stages);
                // Unassign all content types, this will migrate the content types to null
                await workflowsContentTypes.migrate({
                    srcContentTypes: workflow.contentTypes,
                    destContentTypes: []
                });
                const query = strapi.get('query-params').transform(WORKFLOW_MODEL_UID, opts);
                // Delete Workflow
                const deletedWorkflow = await strapi.db.query(WORKFLOW_MODEL_UID).delete({
                    ...query,
                    where: {
                        id: workflow.id
                    }
                });
                await strapi.plugin('content-releases').service('release-action').validateActionsByContentTypes(workflow.contentTypes);
                return deletedWorkflow;
            });
        },
        /**
     * Returns the total count of workflows.
     * @returns {Promise<number>} - Total count of workflows.
     */ count () {
            return strapi.db.query(WORKFLOW_MODEL_UID).count();
        },
        /**
     * Finds the assigned workflow for a given content type ID.
     * @param {string} uid - Content type ID to find the assigned workflow for.
     * @param {object} opts - Options for the query.
     * @returns {Promise<object|null>} - Assigned workflow object if found, or null.
     */ async getAssignedWorkflow (uid, opts = {}) {
            const workflows = await this._getAssignedWorkflows(uid, opts);
            return workflows.length > 0 ? workflows[0] : null;
        },
        /**
     * Finds all the assigned workflows for a given content type ID.
     * Normally, there should only be one workflow assigned to a content type.
     * However, edge cases can occur where a content type is assigned to multiple workflows.
     * @param {string} uid - Content type ID to find the assigned workflows for.
     * @param {object} opts - Options for the query.
     * @returns {Promise<object[]>} - List of assigned workflow objects.
     */ async _getAssignedWorkflows (uid, opts = {}) {
            return this.find({
                ...opts,
                filters: {
                    contentTypes: getWorkflowContentTypeFilter({
                        strapi
                    }, uid)
                }
            });
        },
        /**
     * Asserts that a content type has an assigned workflow.
     * @param {string} uid - Content type ID to verify the assignment of.
     * @returns {Promise<object>} - Workflow object associated with the content type ID.
     * @throws {ApplicationError} - If no assigned workflow is found for the content type ID.
     */ async assertContentTypeBelongsToWorkflow (uid) {
            const workflow = await this.getAssignedWorkflow(uid, {
                populate: 'stages'
            });
            if (!workflow) {
                throw new utils.errors.ApplicationError(`Review workflows is not activated on Content Type ${uid}.`);
            }
            return workflow;
        },
        /**
     * Asserts that a stage belongs to a given workflow.
     * @param {string} stageId - ID of stage to check.
     * @param {object} workflow - Workflow object to check against.
     * @returns
     * @throws {ApplicationError} - If the stage does not belong to the specified workflow.
     */ assertStageBelongsToWorkflow (stageId, workflow) {
            if (!stageId) {
                return;
            }
            const belongs = workflow.stages.some((stage)=>stage.id === stageId);
            if (!belongs) {
                throw new utils.errors.ApplicationError(`Stage does not belong to workflow "${workflow.name}"`);
            }
        }
    };
});

const { ApplicationError: ApplicationError$2, ValidationError: ValidationError$1 } = utils.errors;
const sanitizedStageFields = [
    'id',
    'name',
    'workflow',
    'color'
];
const sanitizeStageFields = fp.pick(sanitizedStageFields);
var stages$1 = (({ strapi })=>{
    const metrics = getService('workflow-metrics', {
        strapi
    });
    const stagePermissionsService = getService('stage-permissions', {
        strapi
    });
    const workflowValidator = getService('validation', {
        strapi
    });
    return {
        find ({ workflowId, populate }) {
            return strapi.db.query(STAGE_MODEL_UID).findMany({
                where: {
                    workflow: workflowId
                },
                populate
            });
        },
        findById (id, { populate } = {}) {
            return strapi.db.query(STAGE_MODEL_UID).findOne({
                where: {
                    id
                },
                populate
            });
        },
        async createMany (stagesList, { fields } = {}) {
            const params = {
                select: fields ?? '*'
            };
            const stages = await Promise.all(stagesList.map((stage)=>strapi.db.query(STAGE_MODEL_UID).create({
                    data: sanitizeStageFields(stage),
                    ...params
                })));
            // Create stage permissions
            await utils.async.reduce(stagesList)(async (_, stage, idx)=>{
                // Ignore stages without permissions
                if (!stage.permissions || stage.permissions.length === 0) {
                    return;
                }
                const stagePermissions = stage.permissions;
                const stageId = stages[idx].id;
                const permissions = await utils.async.map(stagePermissions, // Register each stage permission
                (permission)=>stagePermissionsService.register({
                        roleId: permission.role,
                        action: permission.action,
                        fromStage: stageId
                    }));
                // Update stage with the new permissions
                await strapi.db.query(STAGE_MODEL_UID).update({
                    where: {
                        id: stageId
                    },
                    data: {
                        permissions: permissions.flat().map((p)=>p.id)
                    }
                });
            }, []);
            metrics.sendDidCreateStage();
            return stages;
        },
        async update (srcStage, destStage) {
            let stagePermissions = srcStage?.permissions ?? [];
            const stageId = destStage.id;
            if (destStage.permissions) {
                await this.deleteStagePermissions([
                    srcStage
                ]);
                const permissions = await utils.async.map(destStage.permissions, (permission)=>stagePermissionsService.register({
                        roleId: permission.role,
                        action: permission.action,
                        fromStage: stageId
                    }));
                stagePermissions = permissions.flat().map((p)=>p.id);
            }
            const stage = await strapi.db.query(STAGE_MODEL_UID).update({
                where: {
                    id: stageId
                },
                data: {
                    ...destStage,
                    permissions: stagePermissions
                }
            });
            metrics.sendDidEditStage();
            return stage;
        },
        async delete (stage) {
            // Unregister all permissions related to this stage id
            await this.deleteStagePermissions([
                stage
            ]);
            const deletedStage = await strapi.db.query(STAGE_MODEL_UID).delete({
                where: {
                    id: stage.id
                }
            });
            metrics.sendDidDeleteStage();
            return deletedStage;
        },
        async deleteMany (stages) {
            await this.deleteStagePermissions(stages);
            return strapi.db.query(STAGE_MODEL_UID).deleteMany({
                where: {
                    id: {
                        $in: stages.map((s)=>s.id)
                    }
                }
            });
        },
        async deleteStagePermissions (stages) {
            // TODO: Find another way to do this for when we use the "to" parameter.
            const permissions = stages.map((s)=>s.permissions || []).flat();
            await stagePermissionsService.unregister(permissions || []);
        },
        count ({ workflowId } = {}) {
            const opts = {};
            if (workflowId) {
                opts.where = {
                    workflow: workflowId
                };
            }
            return strapi.db.query(STAGE_MODEL_UID).count(opts);
        },
        async replaceStages (srcStages, destStages, contentTypesToMigrate = []) {
            const { created, updated, deleted } = getDiffBetweenStages(srcStages, destStages);
            assertAtLeastOneStageRemain(srcStages || [], {
                created,
                deleted
            });
            // Update stages and assign entity stages
            return strapi.db.transaction(async ({ trx })=>{
                // Create the new stages
                const createdStages = await this.createMany(created, {
                    fields: [
                        'id'
                    ]
                });
                // Put all the newly created stages ids
                const createdStagesIds = fp.map('id', createdStages);
                // Update the workflow stages
                await utils.async.map(updated, (destStage)=>{
                    const srcStage = srcStages.find((s)=>s.id === destStage.id);
                    return this.update(srcStage, destStage);
                });
                // Delete the stages that are not in the new stages list
                await utils.async.map(deleted, async (stage)=>{
                    // Find the nearest stage in the workflow and newly created stages
                    // that is not deleted, prioritizing the previous stages
                    const nearestStage = findNearestMatchingStage([
                        ...srcStages,
                        ...createdStages
                    ], srcStages.findIndex((s)=>s.id === stage.id), (targetStage)=>{
                        return !deleted.find((s)=>s.id === targetStage.id);
                    });
                    // Assign the new stage to entities that had the deleted stage
                    await utils.async.map(contentTypesToMigrate, (contentTypeUID)=>{
                        this.updateEntitiesStage(contentTypeUID, {
                            fromStageId: stage.id,
                            toStageId: nearestStage.id,
                            trx
                        });
                    });
                    return this.delete(stage);
                });
                return destStages.map((stage)=>({
                        ...stage,
                        id: stage.id ?? createdStagesIds.shift()
                    }));
            });
        },
        /**
     * Update the stage of an entity
     */ async updateEntity (entityToUpdate, model, stageId) {
            const stage = await this.findById(stageId);
            const { documentId, locale } = entityToUpdate;
            await workflowValidator.validateWorkflowCount();
            if (!stage) {
                throw new ApplicationError$2(`Selected stage does not exist`);
            }
            const entity = await strapi.documents(model).update({
                documentId,
                locale,
                // Stage doesn't have DP or i18n enabled, connecting it through the `id`
                // will be safer than relying on the `documentId` + `locale` + `status` transformation
                data: {
                    [ENTITY_STAGE_ATTRIBUTE]: fp.pick([
                        'id'
                    ], stage)
                },
                populate: [
                    ENTITY_STAGE_ATTRIBUTE
                ]
            });
            // Update the `updated_at` field of the entity, so that the `status` is not considered `Modified`
            // NOTE: `updatedAt` is a protected attribute that can not be modified directly from the query layer
            //        hence the knex query builder is used here.
            const { tableName } = strapi.db.metadata.get(model);
            await strapi.db.connection(tableName).where({
                id: entityToUpdate.id
            }).update({
                updated_at: new Date(entityToUpdate.updatedAt)
            });
            metrics.sendDidChangeEntryStage();
            return entity;
        },
        /**
     * Updates entity stages of a content type:
     *  - If fromStageId is undefined, all entities with an existing stage will be assigned the new stage
     *  - If fromStageId is null, all entities without a stage will be assigned the new stage
     *  - If fromStageId is a number, all entities with that stage will be assigned the new stage
     *
     * For performance reasons we use knex queries directly.
     *
     * @param {string} contentTypeUID
     * @param {number | undefined | null} fromStageId
     * @param {number} toStageId
     * @param {import('knex').Knex.Transaction} trx
     * @returns
     */ async updateEntitiesStage (contentTypeUID, { fromStageId, toStageId }) {
            const { attributes, tableName } = strapi.db.metadata.get(contentTypeUID);
            const joinTable = attributes[ENTITY_STAGE_ATTRIBUTE].joinTable;
            const joinColumn = joinTable.joinColumn.name;
            const invJoinColumn = joinTable.inverseJoinColumn.name;
            await workflowValidator.validateWorkflowCount();
            return strapi.db.transaction(async ({ trx })=>{
                // Update all already existing links to the new stage
                if (fromStageId === undefined) {
                    return strapi.db.getConnection().from(joinTable.name).update({
                        [invJoinColumn]: toStageId
                    }).transacting(trx);
                }
                // Update all links from the specified stage to the new stage
                const selectStatement = strapi.db.getConnection().select({
                    [joinColumn]: 't1.id',
                    [invJoinColumn]: toStageId
                }).from(`${tableName} as t1`).leftJoin(`${joinTable.name} as t2`, `t1.id`, `t2.${joinColumn}`).where(`t2.${invJoinColumn}`, fromStageId).toSQL();
                // Insert rows for all entries of the content type that have the specified stage
                return strapi.db.getConnection(joinTable.name).insert(strapi.db.connection.raw(`(${joinColumn}, ${invJoinColumn})  ${selectStatement.sql}`, selectStatement.bindings)).transacting(trx);
            });
        },
        /**
     * Deletes all entity stages of a content type
     * @param {string} contentTypeUID
     * @returns
     */ async deleteAllEntitiesStage (contentTypeUID) {
            const { attributes } = strapi.db.metadata.get(contentTypeUID);
            const joinTable = attributes[ENTITY_STAGE_ATTRIBUTE].joinTable;
            // Delete all stage links for the content type
            return strapi.db.transaction(async ({ trx })=>strapi.db.getConnection().from(joinTable.name).delete().transacting(trx));
        }
    };
});
/**
 * Compares two arrays of stages and returns an object indicating the differences.
 *
 * The function compares the `id` properties of each stage in `sourceStages` and `comparisonStages` to determine if the stage is present in both arrays.
 * If a stage with the same `id` is found in both arrays but the `name` property is different, the stage is considered updated.
 * If a stage with a particular `id` is only found in `comparisonStages`, it is considered created.
 * If a stage with a particular `id` is only found in `sourceStages`, it is considered deleted.
 *
 * @typedef {{id: Number, name: String, workflow: Number}} Stage
 * @typedef {{created: Stage[], updated: Stage[], deleted: Stage[]}} DiffStages
 *
 * The DiffStages object has three properties: `created`, `updated`, and `deleted`.
 * `created` is an array of stages that are in `comparisonStages` but not in `sourceStages`.
 * `updated` is an array of stages that have different names in `comparisonStages` and `sourceStages`.
 * `deleted` is an array of stages that are in `sourceStages` but not in `comparisonStages`.
 *
 * @param {Stage[]} sourceStages
 * @param {Stage[]} comparisonStages
 * @returns { DiffStages }
 */ function getDiffBetweenStages(sourceStages, comparisonStages) {
    const result = comparisonStages.reduce(// ...
    (acc, stageToCompare)=>{
        const srcStage = sourceStages.find((stage)=>stage.id === stageToCompare.id);
        if (!srcStage) {
            acc.created.push(stageToCompare);
        } else if (!fp.isEqual(fp.pick([
            'name',
            'color',
            'permissions'
        ], srcStage), fp.pick([
            'name',
            'color',
            'permissions'
        ], stageToCompare))) {
            acc.updated.push(stageToCompare);
        }
        return acc;
    }, {
        created: [],
        updated: []
    });
    result.deleted = sourceStages.filter((srcStage)=>!comparisonStages.some((cmpStage)=>cmpStage.id === srcStage.id));
    return result;
}
/**
 * Asserts that at least one stage remains in the workflow after applying deletions and additions.
 *
 * @param {Array} workflowStages - An array of stages in the current workflow.
 * @param {Object} diffStages - An object containing the stages to be deleted and created.
 * @param {Array} diffStages.deleted - An array of stages that are planned to be deleted from the workflow.
 * @param {Array} diffStages.created - An array of stages that are planned to be created in the workflow.
 *
 * @throws {ValidationError} If the number of remaining stages in the workflow after applying deletions and additions is less than 1.
 */ function assertAtLeastOneStageRemain(workflowStages, diffStages) {
    const remainingStagesCount = workflowStages.length - diffStages.deleted.length + diffStages.created.length;
    if (remainingStagesCount < 1) {
        throw new ValidationError$1(ERRORS.WORKFLOW_WITHOUT_STAGES);
    }
}
/**
 * Find the id of the nearest object in an array that matches a condition.
 * Used for searching for the nearest stage that is not deleted.
 * Starts by searching the elements before the index, then the remaining elements in the array.
 *
 * @param {Array} stages
 * @param {Number} startIndex the index to start searching from
 * @param {Function} condition must evaluate to true for the object to be considered a match
 * @returns {Object} stage
 */ function findNearestMatchingStage(stages, startIndex, condition) {
    // Start by searching the elements before the startIndex
    for(let i = startIndex; i >= 0; i -= 1){
        if (condition(stages[i])) {
            return stages[i];
        }
    }
    // If no matching element is found before the startIndex,
    // search the remaining elements in the array
    const remainingArray = stages.slice(startIndex + 1);
    const nearestObject = remainingArray.filter(condition)[0];
    return nearestObject;
}

const { ApplicationError: ApplicationError$1 } = utils.errors;
const validActions = [
    STAGE_TRANSITION_UID
];
var stagePermissions = (({ strapi })=>{
    const roleService = getAdminService('role');
    const permissionService = getAdminService('permission');
    return {
        async register ({ roleId, action, fromStage }) {
            if (!validActions.includes(action)) {
                throw new ApplicationError$1(`Invalid action ${action}`);
            }
            const permissions = await roleService.addPermissions(roleId, [
                {
                    action,
                    actionParameters: {
                        from: fromStage
                    }
                }
            ]);
            // TODO: Filter response
            return permissions;
        },
        async registerMany (permissions) {
            return utils.async.map(permissions, this.register);
        },
        async unregister (permissions) {
            const permissionIds = permissions.map(fp.prop('id'));
            await permissionService.deleteByIds(permissionIds);
        },
        can (action, fromStage) {
            const requestState = strapi.requestContext.get()?.state;
            if (!requestState) {
                return false;
            }
            // Override permissions for super admin
            const userRoles = requestState.user?.roles;
            if (userRoles?.some((role)=>role.code === 'strapi-super-admin')) {
                return true;
            }
            return requestState.userAbility.can({
                name: action,
                params: {
                    from: fromStage
                }
            });
        }
    };
});

const { ApplicationError } = utils.errors;
var assignees$1 = (({ strapi })=>{
    const metrics = getService('workflow-metrics', {
        strapi
    });
    return {
        async findEntityAssigneeId (id, model) {
            const entity = await strapi.db.query(model).findOne({
                where: {
                    id
                },
                populate: [
                    ENTITY_ASSIGNEE_ATTRIBUTE
                ],
                select: []
            });
            return entity?.[ENTITY_ASSIGNEE_ATTRIBUTE]?.id ?? null;
        },
        /**
     * Update the assignee of an entity
     */ async updateEntityAssignee (entityToUpdate, model, assigneeId) {
            const { documentId, locale } = entityToUpdate;
            if (!fp.isNil(assigneeId)) {
                const userExists = await getAdminService('user', {
                    strapi
                }).exists({
                    id: assigneeId
                });
                if (!userExists) {
                    throw new ApplicationError(`Selected user does not exist`);
                }
            }
            const oldAssigneeId = await this.findEntityAssigneeId(entityToUpdate.id, model);
            metrics.sendDidEditAssignee(oldAssigneeId, assigneeId || null);
            const entity = await strapi.documents(model).update({
                documentId,
                locale,
                data: {
                    [ENTITY_ASSIGNEE_ATTRIBUTE]: assigneeId || null
                },
                populate: [
                    ENTITY_ASSIGNEE_ATTRIBUTE
                ],
                fields: []
            });
            // Update the `updated_at` field of the entity, so that the `status` is not considered `Modified`
            // NOTE: `updatedAt` is a protected attribute that can not be modified directly from the query layer
            //        hence the knex query builder is used here.
            const { tableName } = strapi.db.metadata.get(model);
            await strapi.db.connection(tableName).where({
                id: entityToUpdate.id
            }).update({
                updated_at: new Date(entityToUpdate.updatedAt)
            });
            return entity;
        }
    };
});

const { ValidationError } = utils.errors;
var reviewWorkflowsValidation = (({ strapi })=>{
    return {
        limits: {
            numberOfWorkflows: MAX_WORKFLOWS,
            stagesPerWorkflow: MAX_STAGES_PER_WORKFLOW
        },
        register ({ numberOfWorkflows, stagesPerWorkflow }) {
            if (!Object.isFrozen(this.limits)) {
                this.limits.numberOfWorkflows = clampMaxWorkflows(numberOfWorkflows || this.limits.numberOfWorkflows);
                this.limits.stagesPerWorkflow = clampMaxStagesPerWorkflow(stagesPerWorkflow || this.limits.stagesPerWorkflow);
                Object.freeze(this.limits);
            }
        },
        /**
     * Validates the stages of a workflow.
     * @param {Array} stages - Array of stages to be validated.
     * @throws {ValidationError} - If the workflow has no stages or exceeds the limit.
     */ validateWorkflowStages (stages) {
            if (!stages || stages.length === 0) {
                throw new ValidationError(ERRORS.WORKFLOW_WITHOUT_STAGES);
            }
            if (stages.length > this.limits.stagesPerWorkflow) {
                throw new ValidationError(ERRORS.STAGES_LIMIT);
            }
            // Validate stage names are not duplicated
            const stageNames = stages.map((stage)=>stage.name);
            if (fp.uniq(stageNames).length !== stageNames.length) {
                throw new ValidationError(ERRORS.DUPLICATED_STAGE_NAME);
            }
        },
        async validateWorkflowCountStages (workflowId, countAddedStages = 0) {
            const stagesService = getService('stages', {
                strapi
            });
            const countWorkflowStages = await stagesService.count({
                workflowId
            });
            if (countWorkflowStages + countAddedStages > this.limits.stagesPerWorkflow) {
                throw new ValidationError(ERRORS.STAGES_LIMIT);
            }
        },
        /**
     * Validates the count of existing and added workflows.
     * @param {number} [countAddedWorkflows=0] - The count of workflows to be added.
     * @throws {ValidationError} - If the total count of workflows exceeds the limit.
     * @returns {Promise<void>} - A Promise that resolves when the validation is completed.
     */ async validateWorkflowCount (countAddedWorkflows = 0) {
            const workflowsService = getService('workflows', {
                strapi
            });
            const countWorkflows = await workflowsService.count();
            if (countWorkflows + countAddedWorkflows > this.limits.numberOfWorkflows) {
                throw new ValidationError(ERRORS.WORKFLOWS_LIMIT);
            }
        }
    };
});

const sendDidCreateStage = async ()=>{
    strapi.telemetry.send('didCreateStage', {});
};
const sendDidEditStage = async ()=>{
    strapi.telemetry.send('didEditStage', {});
};
const sendDidDeleteStage = async ()=>{
    strapi.telemetry.send('didDeleteStage', {});
};
const sendDidChangeEntryStage = async ()=>{
    strapi.telemetry.send('didChangeEntryStage', {});
};
const sendDidCreateWorkflow = async (workflowId, hasRequiredStageToPublish)=>{
    strapi.telemetry.send('didCreateWorkflow', {
        workflowId,
        hasRequiredStageToPublish
    });
};
const sendDidEditWorkflow = async (workflowId, hasRequiredStageToPublish)=>{
    strapi.telemetry.send('didEditWorkflow', {
        workflowId,
        hasRequiredStageToPublish
    });
};
const sendDidEditAssignee = async (fromId, toId)=>{
    strapi.telemetry.send('didEditAssignee', {
        from: fromId,
        to: toId
    });
};
const sendDidSendReviewWorkflowPropertiesOnceAWeek = async (numberOfActiveWorkflows, avgStagesCount, maxStagesCount, activatedContentTypes)=>{
    strapi.telemetry.send('didSendReviewWorkflowPropertiesOnceAWeek', {
        groupProperties: {
            numberOfActiveWorkflows,
            avgStagesCount,
            maxStagesCount,
            activatedContentTypes
        }
    });
};
var reviewWorkflowsMetrics = {
    sendDidCreateStage,
    sendDidEditStage,
    sendDidDeleteStage,
    sendDidChangeEntryStage,
    sendDidCreateWorkflow,
    sendDidEditWorkflow,
    sendDidSendReviewWorkflowPropertiesOnceAWeek,
    sendDidEditAssignee
};

const ONE_WEEK = 7 * 24 * 60 * 60 * 1000;
const getWeeklyCronScheduleAt = (date)=>`${date.getSeconds()} ${date.getMinutes()} ${date.getHours()} * * ${date.getDay()}`;
var reviewWorkflowsWeeklyMetrics = (({ strapi })=>{
    const metrics = getService('workflow-metrics', {
        strapi
    });
    const workflowsService = getService('workflows', {
        strapi
    });
    const getMetricsStoreValue = async ()=>{
        const value = await strapi.store.get({
            type: 'plugin',
            name: 'ee',
            key: 'metrics'
        });
        return fp.defaultTo({}, value);
    };
    const setMetricsStoreValue = (value)=>strapi.store.set({
            type: 'plugin',
            name: 'ee',
            key: 'metrics',
            value
        });
    return {
        async computeMetrics () {
            // There will never be more than 200 workflow, so we can safely fetch them all
            const workflows = await workflowsService.find({
                populate: 'stages'
            });
            const stagesCount = fp.flow(fp.map('stages'), fp.map(fp.size))(workflows);
            const contentTypesCount = fp.flow(fp.map('contentTypes'), fp.map(fp.size))(workflows);
            return {
                numberOfActiveWorkflows: fp.size(workflows),
                avgStagesCount: fp.mean(stagesCount),
                maxStagesCount: fp.max(stagesCount),
                activatedContentTypes: fp.sum(contentTypesCount)
            };
        },
        async sendMetrics () {
            const computedMetrics = await this.computeMetrics();
            metrics.sendDidSendReviewWorkflowPropertiesOnceAWeek(computedMetrics);
            const metricsInfoStored = await getMetricsStoreValue();
            // @ts-expect-error metricsInfoStored can use spread
            await setMetricsStoreValue({
                ...metricsInfoStored,
                lastWeeklyUpdate: new Date().getTime()
            });
        },
        async ensureWeeklyStoredCronSchedule () {
            const metricsInfoStored = await getMetricsStoreValue();
            const { weeklySchedule: currentSchedule, lastWeeklyUpdate } = metricsInfoStored;
            const now = new Date();
            let weeklySchedule = currentSchedule;
            if (!currentSchedule || !lastWeeklyUpdate || lastWeeklyUpdate + ONE_WEEK < now.getTime()) {
                weeklySchedule = getWeeklyCronScheduleAt(dateFns.add(now, {
                    seconds: 10
                }));
                await setMetricsStoreValue({
                    ...metricsInfoStored,
                    weeklySchedule
                });
            }
            return weeklySchedule;
        },
        async registerCron () {
            const weeklySchedule = await this.ensureWeeklyStoredCronSchedule();
            strapi.cron.add({
                reviewWorkflowsWeekly: {
                    task: this.sendMetrics.bind(this),
                    options: weeklySchedule
                }
            });
        }
    };
});

/**
 * Get the stage information of an entity
 * @param {String} uid
 * @param {Number} id
 * @returns {Object}
 */ const getEntityStage = async (uid, id, params)=>{
    const entity = await strapi.documents(uid).findOne({
        ...params,
        documentId: id,
        status: 'draft',
        populate: {
            [ENTITY_STAGE_ATTRIBUTE]: {
                populate: {
                    workflow: true
                }
            }
        }
    });
    return entity?.[ENTITY_STAGE_ATTRIBUTE] ?? {};
};
/**
 * Ensures the entity is assigned to the default workflow stage
 */ const assignStageOnCreate = async (ctx, next)=>{
    if (ctx.action !== 'create' && ctx.action !== 'clone') {
        return next();
    }
    /**
   * Content types can have assigned workflows,
   * if the CT has one, assign a default value to the stage attribute if it's not present
   */ const workflow = await getService('workflows').getAssignedWorkflow(ctx.contentType.uid, {
        populate: 'stages'
    });
    if (!workflow) {
        return next();
    }
    const data = ctx.params.data;
    // Assign the default stage if the entity doesn't have one
    if (ctx.params?.data && fp.isNil(data[ENTITY_STAGE_ATTRIBUTE])) {
        data[ENTITY_STAGE_ATTRIBUTE] = {
            id: workflow.stages[0].id
        };
    }
    return next();
};
const handleStageOnUpdate = async (ctx, next)=>{
    if (ctx.action !== 'update') {
        return next();
    }
    const { documentId } = ctx.params;
    const data = ctx.params.data;
    if (fp.isNil(data?.[ENTITY_STAGE_ATTRIBUTE])) {
        delete data?.[ENTITY_STAGE_ATTRIBUTE];
        return next();
    }
    /**
   * Get last stage of the entity
   */ const previousStage = await getEntityStage(ctx.contentType.uid, documentId, ctx.params);
    const result = await next();
    if (!result) {
        return result;
    }
    // @ts-expect-error
    const updatedStage = result?.[ENTITY_STAGE_ATTRIBUTE];
    // Stage might be null if field is not populated
    if (updatedStage && previousStage?.id && previousStage.id !== updatedStage.id) {
        const model = strapi.getModel(ctx.contentType.uid);
        strapi.eventHub.emit(WORKFLOW_UPDATE_STAGE, {
            model: model.modelName,
            uid: model.uid,
            // TODO v6: Rename to "entry", which is what is used for regular CRUD updates
            entity: {
                // @ts-expect-error
                id: result?.id,
                documentId,
                // @ts-expect-error
                locale: result?.locale,
                status: 'draft'
            },
            workflow: {
                id: previousStage.workflow.id,
                stages: {
                    from: {
                        id: previousStage.id,
                        name: previousStage.name
                    },
                    to: {
                        id: updatedStage.id,
                        name: updatedStage.name
                    }
                }
            }
        });
    }
    return next();
};
/**
 * Check if the entity is at the required stage before publish
 */ const checkStageBeforePublish = async (ctx, next)=>{
    if (ctx.action !== 'publish') {
        return next();
    }
    const workflow = await getService('workflows').getAssignedWorkflow(ctx.contentType.uid, {
        populate: 'stageRequiredToPublish'
    });
    if (!workflow || !workflow.stageRequiredToPublish) {
        return next();
    }
    const { documentId } = ctx.params;
    const entryStage = await getEntityStage(ctx.contentType.uid, documentId, ctx.params);
    if (entryStage.id !== workflow.stageRequiredToPublish.id) {
        throw new utils.errors.ValidationError('Entry is not at the required stage to publish');
    }
    return next();
};
var documentServiceMiddleware = (()=>({
        assignStageOnCreate,
        handleStageOnUpdate,
        checkStageBeforePublish
    }));

var services = {
    workflows: workflows$1,
    stages: stages$1,
    'stage-permissions': stagePermissions,
    assignees: assignees$1,
    validation: reviewWorkflowsValidation,
    'document-service-middlewares': documentServiceMiddleware,
    'workflow-metrics': reviewWorkflowsMetrics,
    'workflow-weekly-metrics': reviewWorkflowsWeeklyMetrics
};

const stageObject = utils.yup.object().shape({
    id: utils.yup.number().integer().min(1),
    name: utils.yup.string().max(255).required(),
    color: utils.yup.string().matches(/^#(?:[0-9a-fA-F]{3}){1,2}$/i),
    permissions: utils.yup.array().of(utils.yup.object().shape({
        role: utils.yup.number().integer().min(1).required(),
        action: utils.yup.string().oneOf([
            STAGE_TRANSITION_UID
        ]).required(),
        actionParameters: utils.yup.object().shape({
            from: utils.yup.number().integer().min(1).required(),
            to: utils.yup.number().integer().min(1)
        })
    }))
});
const validateUpdateStageOnEntitySchema = utils.yup.object().shape({
    id: utils.yup.number().integer().min(1).required()
}).required();
const validateContentTypes = utils.yup.array().of(utils.yup.string().test({
    name: 'content-type-exists',
    message: (value)=>`Content type ${value.originalValue} does not exist`,
    test (uid) {
        // Warning; we use the strapi global - to avoid that, it would need to refactor how
        // we generate validation function by using a factory with the strapi instance as parameter.
        return !!strapi.getModel(uid);
    }
}).test({
    name: 'content-type-review-workflow-enabled',
    message: (value)=>`Content type ${value.originalValue} does not have review workflow enabled`,
    test (uid) {
        const model = strapi.getModel(uid);
        // It's not a valid content type if it doesn't have the stage attribute
        return hasStageAttribute(model);
    }
}));
const validateWorkflowCreateSchema = utils.yup.object().shape({
    name: utils.yup.string().max(255).min(1, 'Workflow name can not be empty').required(),
    stages: utils.yup.array().of(stageObject)// @ts-expect-error - add unique property into the yup namespace typing
    .uniqueProperty('name', 'Stage name must be unique').min(1, 'Can not create a workflow without stages').max(200, 'Can not have more than 200 stages').required('Can not create a workflow without stages'),
    contentTypes: validateContentTypes,
    stageRequiredToPublishName: utils.yup.string().min(1).nullable()
});
const validateWorkflowUpdateSchema = utils.yup.object().shape({
    name: utils.yup.string().max(255).min(1, 'Workflow name can not be empty'),
    stages: utils.yup.array().of(stageObject)// @ts-expect-error - add unique property into the yup namespace typing
    .uniqueProperty('name', 'Stage name must be unique').min(1, 'Can not update a workflow without stages').max(200, 'Can not have more than 200 stages'),
    contentTypes: validateContentTypes,
    stageRequiredToPublishName: utils.yup.string().min(1).nullable()
});
const validateUpdateAssigneeOnEntitySchema = utils.yup.object().shape({
    id: utils.yup.number().integer().min(1).nullable()
}).required();
const validateLocaleSchema = utils.yup.string().nullable();
const validateWorkflowCreate = utils.validateYupSchema(validateWorkflowCreateSchema);
const validateUpdateStageOnEntity = utils.validateYupSchema(validateUpdateStageOnEntitySchema);
const validateUpdateAssigneeOnEntity = utils.validateYupSchema(validateUpdateAssigneeOnEntitySchema);
const validateWorkflowUpdate = utils.validateYupSchema(validateWorkflowUpdateSchema);
const validateLocale = utils.validateYupSchema(validateLocaleSchema);

/**
 *
 * @param { Core.Strapi } strapi - Strapi instance
 * @param userAbility
 * @return { PermissionChecker }
 */ function getWorkflowsPermissionChecker({ strapi: strapi1 }, userAbility) {
    return strapi1.plugin('content-manager').service('permission-checker').create({
        userAbility,
        model: WORKFLOW_MODEL_UID
    });
}
/**
 * Transforms workflow to an admin UI format.
 * Some attributes (like permissions) are presented in a different format in the admin UI.
 * @param {Workflow} workflow
 */ function formatWorkflowToAdmin(workflow) {
    if (!workflow) return;
    if (!workflow.stages) return workflow;
    // Transform permissions roles to be the id string instead of an object
    const transformPermissions = fp.map(fp.update('role', fp.property('id')));
    const transformStages = fp.map(fp.update('permissions', transformPermissions));
    return fp.update('stages', transformStages, workflow);
}
var workflows = {
    /**
   * Create a new workflow
   * @param {import('koa').BaseContext} ctx - koa context
   */ async create (ctx) {
        const { body, query } = ctx.request;
        const { sanitizeCreateInput, sanitizeOutput, sanitizedQuery } = getWorkflowsPermissionChecker({
            strapi
        }, ctx.state.userAbility);
        const { populate } = await sanitizedQuery.create(query);
        const workflowBody = await validateWorkflowCreate(body.data);
        const workflowService = getService('workflows');
        const createdWorkflow = await workflowService.create({
            data: await sanitizeCreateInput(workflowBody),
            populate
        }).then(formatWorkflowToAdmin);
        ctx.created({
            data: await sanitizeOutput(createdWorkflow)
        });
    },
    /**
   * Update a workflow
   * @param {import('koa').BaseContext} ctx - koa context
   */ async update (ctx) {
        const { id } = ctx.params;
        const { body, query } = ctx.request;
        const workflowService = getService('workflows');
        const { sanitizeUpdateInput, sanitizeOutput, sanitizedQuery } = getWorkflowsPermissionChecker({
            strapi
        }, ctx.state.userAbility);
        const { populate } = await sanitizedQuery.update(query);
        const workflowBody = await validateWorkflowUpdate(body.data);
        // Find if workflow exists
        const workflow = await workflowService.findById(id, {
            populate: WORKFLOW_POPULATE
        });
        if (!workflow) {
            return ctx.notFound();
        }
        // Sanitize input data
        const getPermittedFieldToUpdate = sanitizeUpdateInput(workflow);
        const dataToUpdate = await getPermittedFieldToUpdate(workflowBody);
        // Update workflow
        const updatedWorkflow = await workflowService.update(workflow, {
            data: dataToUpdate,
            populate
        }).then(formatWorkflowToAdmin);
        // Send sanitized response
        ctx.body = {
            data: await sanitizeOutput(updatedWorkflow)
        };
    },
    /**
   * Delete a workflow
   * @param {import('koa').BaseContext} ctx - koa context
   */ async delete (ctx) {
        const { id } = ctx.params;
        const { query } = ctx.request;
        const workflowService = getService('workflows');
        const { sanitizeOutput, sanitizedQuery } = getWorkflowsPermissionChecker({
            strapi
        }, ctx.state.userAbility);
        const { populate } = await sanitizedQuery.delete(query);
        const workflow = await workflowService.findById(id, {
            populate: WORKFLOW_POPULATE
        });
        if (!workflow) {
            return ctx.notFound("Workflow doesn't exist");
        }
        const deletedWorkflow = await workflowService.delete(workflow, {
            populate
        }).then(formatWorkflowToAdmin);
        ctx.body = {
            data: await sanitizeOutput(deletedWorkflow)
        };
    },
    /**
   * List all workflows
   * @param {import('koa').BaseContext} ctx - koa context
   */ async find (ctx) {
        const { query } = ctx.request;
        const workflowService = getService('workflows');
        const { sanitizeOutput, sanitizedQuery } = getWorkflowsPermissionChecker({
            strapi
        }, ctx.state.userAbility);
        const { populate, filters, sort } = await sanitizedQuery.read(query);
        const [workflows, workflowCount] = await Promise.all([
            workflowService.find({
                populate,
                filters,
                sort
            }).then(fp.map(formatWorkflowToAdmin)),
            workflowService.count()
        ]);
        ctx.body = {
            data: await utils.async.map(workflows, sanitizeOutput),
            meta: {
                workflowCount
            }
        };
    }
};

/**
 *
 * @param { Core.Strapi } strapi - Strapi instance
 * @param userAbility
 * @return { (Stage) => SanitizedStage }
 */ function sanitizeStage({ strapi: strapi1 }, userAbility) {
    const permissionChecker = strapi1.plugin('content-manager').service('permission-checker').create({
        userAbility,
        model: STAGE_MODEL_UID
    });
    return (entity)=>permissionChecker.sanitizeOutput(entity);
}
var stages = {
    /**
   * List all stages
   * @param {import('koa').BaseContext} ctx - koa context
   */ async find (ctx) {
        const { workflow_id: workflowId } = ctx.params;
        const { populate } = ctx.query;
        const stagesService = getService('stages');
        const sanitizer = sanitizeStage({
            strapi
        }, ctx.state.userAbility);
        const stages = await stagesService.find({
            workflowId,
            populate
        });
        ctx.body = {
            data: await utils.async.map(stages, sanitizer)
        };
    },
    /**
   * Get one stage
   * @param {import('koa').BaseContext} ctx - koa context
   */ async findById (ctx) {
        const { id, workflow_id: workflowId } = ctx.params;
        const { populate } = ctx.query;
        const stagesService = getService('stages');
        const sanitizer = sanitizeStage({
            strapi
        }, ctx.state.userAbility);
        const stage = await stagesService.findById(id, {
            workflowId,
            populate
        });
        ctx.body = {
            data: await sanitizer(stage)
        };
    },
    /**
   * Updates an entity's stage.
   * @async
   * @param {Object} ctx - The Koa context object.
   * @param {Object} ctx.params - An object containing the parameters from the request URL.
   * @param {string} ctx.params.model_uid - The model UID of the entity.
   * @param {string} ctx.params.id - The ID of the entity to update.
   * @param {Object} ctx.request.body.data - Optional data object containing the new stage ID for the entity.
   * @param {string} ctx.request.body.data.id - The ID of the new stage for the entity.
   * @throws {ApplicationError} If review workflows is not activated on the specified model UID.
   * @throws {ValidationError} If the `data` object in the request body fails to pass validation.
   * @returns {Promise<void>} A promise that resolves when the entity's stage has been updated.
   */ async updateEntity (ctx) {
        const stagesService = getService('stages');
        const stagePermissions = getService('stage-permissions');
        const workflowService = getService('workflows');
        const { model_uid: modelUID, id: documentId } = ctx.params;
        const { body, query = {} } = ctx.request;
        const { sanitizeOutput } = strapi.plugin('content-manager').service('permission-checker').create({
            userAbility: ctx.state.userAbility,
            model: modelUID
        });
        // Load entity
        const locale = await validateLocale(query?.locale);
        const entity = await strapi.documents(modelUID).findOne({
            documentId,
            // @ts-expect-error - locale should be also null in the doc service types
            locale,
            populate: [
                ENTITY_STAGE_ATTRIBUTE
            ]
        });
        if (!entity) {
            ctx.throw(404, 'Entity not found');
        }
        // Validate if entity stage can be updated
        const canTransition = stagePermissions.can(STAGE_TRANSITION_UID, entity[ENTITY_STAGE_ATTRIBUTE]?.id);
        if (!canTransition) {
            ctx.throw(403, 'Forbidden stage transition');
        }
        const { id: stageId } = await validateUpdateStageOnEntity({
            id: Number(body?.data?.id)
        }, 'You should pass an id to the body of the put request.');
        const workflow = await workflowService.assertContentTypeBelongsToWorkflow(modelUID);
        workflowService.assertStageBelongsToWorkflow(stageId, workflow);
        const updatedEntity = await stagesService.updateEntity(entity, modelUID, stageId);
        ctx.body = {
            data: await sanitizeOutput(updatedEntity)
        };
    },
    /**
   * List all the stages that are available for a user to transition an entity to.
   * If the user has permission to change the current stage of the entity every other stage in the workflow is returned
   * @async
   * @param {*} ctx
   * @param {string} ctx.params.model_uid - The model UID of the entity.
   * @param {string} ctx.params.id - The ID of the entity.
   * @throws {ApplicationError} If review workflows is not activated on the specified model UID.
   */ async listAvailableStages (ctx) {
        const stagePermissions = getService('stage-permissions');
        const workflowService = getService('workflows');
        const { model_uid: modelUID, id: documentId } = ctx.params;
        const { query = {} } = ctx.request;
        if (strapi.plugin('content-manager').service('permission-checker').create({
            userAbility: ctx.state.userAbility,
            model: modelUID
        }).cannot.read()) {
            return ctx.forbidden();
        }
        // Load entity
        const locale = await validateLocale(query?.locale) ?? undefined;
        const entity = await strapi.documents(modelUID).findOne({
            documentId,
            locale,
            populate: [
                ENTITY_STAGE_ATTRIBUTE
            ]
        });
        if (!entity) {
            ctx.throw(404, 'Entity not found');
        }
        const entityStageId = entity[ENTITY_STAGE_ATTRIBUTE]?.id;
        const canTransition = stagePermissions.can(STAGE_TRANSITION_UID, entityStageId);
        const [workflowCount, workflowResult] = await Promise.all([
            workflowService.count(),
            workflowService.getAssignedWorkflow(modelUID, {
                populate: 'stages'
            })
        ]);
        const workflowStages = workflowResult ? workflowResult.stages : [];
        const meta = {
            stageCount: workflowStages.length,
            workflowCount
        };
        if (!canTransition) {
            ctx.body = {
                data: [],
                meta
            };
            return;
        }
        const data = workflowStages.filter((stage)=>stage.id !== entityStageId);
        ctx.body = {
            data,
            meta
        };
    }
};

var assignees = {
    /**
   * Updates an entity's assignee.
   * @async
   * @param {Object} ctx - The Koa context object.
   * @param {Object} ctx.params - An object containing the parameters from the request URL.
   * @param {string} ctx.params.model_uid - The model UID of the entity.
   * @param {string} ctx.params.id - The ID of the entity to update.
   * @param {Object} ctx.request.body.data - Optional data object containing the new assignee ID for the entity.
   * @param {string} ctx.request.body.data.id - The ID of the new assignee for the entity.
   * @throws {ApplicationError} If review workflows is not activated on the specified model UID.
   * @throws {ValidationError} If the `data` object in the request body fails to pass validation.
   * @returns {Promise<void>} A promise that resolves when the entity's assignee has been updated.
   */ async updateEntity (ctx) {
        const assigneeService = getService('assignees');
        const workflowService = getService('workflows');
        const stagePermissions = getService('stage-permissions');
        const { model_uid: model, id: documentId } = ctx.params;
        const locale = await validateLocale(ctx.request.query?.locale) ?? undefined;
        const { sanitizeOutput } = strapi.plugin('content-manager').service('permission-checker').create({
            userAbility: ctx.state.userAbility,
            model
        });
        // Retrieve the entity so we can get its current stage
        const entity = await strapi.documents(model).findOne({
            documentId,
            locale,
            populate: [
                ENTITY_STAGE_ATTRIBUTE
            ]
        });
        if (!entity) {
            ctx.throw(404, 'Entity not found');
        }
        // Only allow users who can update the current stage to change the assignee
        const canTransitionStage = stagePermissions.can(STAGE_TRANSITION_UID, entity[ENTITY_STAGE_ATTRIBUTE]?.id);
        if (!canTransitionStage) {
            ctx.throw(403, 'Stage transition permission is required');
        }
        // TODO: check if user has update permission on the entity
        const { id: assigneeId } = await validateUpdateAssigneeOnEntity(ctx.request?.body?.data, 'You should pass a valid id to the body of the put request.');
        await workflowService.assertContentTypeBelongsToWorkflow(model);
        const updatedEntity = await assigneeService.updateEntityAssignee(entity, model, assigneeId);
        ctx.body = {
            data: await sanitizeOutput(updatedEntity)
        };
    }
};

var controllers = {
    workflows,
    stages,
    assignees
};

const getPlugin = ()=>{
    if (strapi.ee.features.isEnabled('review-workflows')) {
        return {
            register,
            bootstrap,
            destroy,
            contentTypes,
            services,
            controllers,
            routes
        };
    }
    return {
        // Always return contentTypes to avoid losing data when the feature is disabled
        // or downgrading the license
        contentTypes
    };
};
var index = getPlugin();

module.exports = index;
//# sourceMappingURL=index.js.map
